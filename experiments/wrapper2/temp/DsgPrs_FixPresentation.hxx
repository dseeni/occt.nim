# 1 "/usr/include/opencascade/DsgPrs_FixPresentation.hxx"
# 1 "<interno>"
# 1 "<línea-de-órdenes>"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 1 "<línea-de-órdenes>" 2
# 1 "/usr/include/opencascade/DsgPrs_FixPresentation.hxx"
# 20 "/usr/include/opencascade/DsgPrs_FixPresentation.hxx"
# 1 "/usr/include/opencascade/Standard.hxx" 1
# 20 "/usr/include/opencascade/Standard.hxx"
# 1 "/usr/include/opencascade/Standard_DefineAlloc.hxx" 1
# 21 "/usr/include/opencascade/Standard.hxx" 2
# 1 "/usr/include/opencascade/Standard_Address.hxx" 1
# 18 "/usr/include/opencascade/Standard_Address.hxx"
# 1 "/usr/include/opencascade/Standard_Integer.hxx" 1
# 18 "/usr/include/opencascade/Standard_Integer.hxx"
# 1 "/usr/include/opencascade/Standard_Std.hxx" 1
# 20 "/usr/include/opencascade/Standard_Std.hxx"
# 1 "/usr/include/c++/10.2.0/type_traits" 1 3
# 32 "/usr/include/c++/10.2.0/type_traits" 3
       
# 33 "/usr/include/c++/10.2.0/type_traits" 3





# 1 "/usr/include/c++/10.2.0/x86_64-pc-linux-gnu/bits/c++config.h" 1 3
# 258 "/usr/include/c++/10.2.0/x86_64-pc-linux-gnu/bits/c++config.h" 3

# 258 "/usr/include/c++/10.2.0/x86_64-pc-linux-gnu/bits/c++config.h" 3
namespace std
{
  typedef long unsigned int size_t;
  typedef long int ptrdiff_t;


  typedef decltype(nullptr) nullptr_t;

}
# 280 "/usr/include/c++/10.2.0/x86_64-pc-linux-gnu/bits/c++config.h" 3
namespace std
{
  inline namespace __cxx11 __attribute__((__abi_tag__ ("cxx11"))) { }
}
namespace __gnu_cxx
{
  inline namespace __cxx11 __attribute__((__abi_tag__ ("cxx11"))) { }
}
# 518 "/usr/include/c++/10.2.0/x86_64-pc-linux-gnu/bits/c++config.h" 3
# 1 "/usr/include/c++/10.2.0/x86_64-pc-linux-gnu/bits/os_defines.h" 1 3
# 39 "/usr/include/c++/10.2.0/x86_64-pc-linux-gnu/bits/os_defines.h" 3
# 1 "/usr/include/features.h" 1 3 4
# 473 "/usr/include/features.h" 3 4
# 1 "/usr/include/sys/cdefs.h" 1 3 4
# 462 "/usr/include/sys/cdefs.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 463 "/usr/include/sys/cdefs.h" 2 3 4
# 1 "/usr/include/bits/long-double.h" 1 3 4
# 464 "/usr/include/sys/cdefs.h" 2 3 4
# 474 "/usr/include/features.h" 2 3 4
# 497 "/usr/include/features.h" 3 4
# 1 "/usr/include/gnu/stubs.h" 1 3 4
# 10 "/usr/include/gnu/stubs.h" 3 4
# 1 "/usr/include/gnu/stubs-64.h" 1 3 4
# 11 "/usr/include/gnu/stubs.h" 2 3 4
# 498 "/usr/include/features.h" 2 3 4
# 40 "/usr/include/c++/10.2.0/x86_64-pc-linux-gnu/bits/os_defines.h" 2 3
# 519 "/usr/include/c++/10.2.0/x86_64-pc-linux-gnu/bits/c++config.h" 2 3


# 1 "/usr/include/c++/10.2.0/x86_64-pc-linux-gnu/bits/cpu_defines.h" 1 3
# 522 "/usr/include/c++/10.2.0/x86_64-pc-linux-gnu/bits/c++config.h" 2 3
# 39 "/usr/include/c++/10.2.0/type_traits" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 56 "/usr/include/c++/10.2.0/type_traits" 3
  template<typename _Tp, _Tp __v>
    struct integral_constant
    {
      static constexpr _Tp value = __v;
      typedef _Tp value_type;
      typedef integral_constant<_Tp, __v> type;
      constexpr operator value_type() const noexcept { return value; }




      constexpr value_type operator()() const noexcept { return value; }

    };

  template<typename _Tp, _Tp __v>
    constexpr _Tp integral_constant<_Tp, __v>::value;


  typedef integral_constant<bool, true> true_type;


  typedef integral_constant<bool, false> false_type;

  template<bool __v>
    using __bool_constant = integral_constant<bool, __v>;
# 91 "/usr/include/c++/10.2.0/type_traits" 3
  template<bool, typename, typename>
    struct conditional;

  template <typename _Type>
    struct __type_identity
    { using type = _Type; };

  template<typename _Tp>
    using __type_identity_t = typename __type_identity<_Tp>::type;

  template<typename...>
    struct __or_;

  template<>
    struct __or_<>
    : public false_type
    { };

  template<typename _B1>
    struct __or_<_B1>
    : public _B1
    { };

  template<typename _B1, typename _B2>
    struct __or_<_B1, _B2>
    : public conditional<_B1::value, _B1, _B2>::type
    { };

  template<typename _B1, typename _B2, typename _B3, typename... _Bn>
    struct __or_<_B1, _B2, _B3, _Bn...>
    : public conditional<_B1::value, _B1, __or_<_B2, _B3, _Bn...>>::type
    { };

  template<typename...>
    struct __and_;

  template<>
    struct __and_<>
    : public true_type
    { };

  template<typename _B1>
    struct __and_<_B1>
    : public _B1
    { };

  template<typename _B1, typename _B2>
    struct __and_<_B1, _B2>
    : public conditional<_B1::value, _B2, _B1>::type
    { };

  template<typename _B1, typename _B2, typename _B3, typename... _Bn>
    struct __and_<_B1, _B2, _B3, _Bn...>
    : public conditional<_B1::value, __and_<_B2, _B3, _Bn...>, _B1>::type
    { };

  template<typename _Pp>
    struct __not_
    : public __bool_constant<!bool(_Pp::value)>
    { };
# 188 "/usr/include/c++/10.2.0/type_traits" 3
  template<typename>
    struct is_reference;
  template<typename>
    struct is_function;
  template<typename>
    struct is_void;
  template<typename>
    struct __is_array_unknown_bounds;




  template <typename _Tp, size_t = sizeof(_Tp)>
    constexpr true_type __is_complete_or_unbounded(__type_identity<_Tp>)
    { return {}; }

  template <typename _TypeIdentity,
      typename _NestedType = typename _TypeIdentity::type>
    constexpr typename __or_<
      is_reference<_NestedType>,
      is_function<_NestedType>,
      is_void<_NestedType>,
      __is_array_unknown_bounds<_NestedType>
    >::type __is_complete_or_unbounded(_TypeIdentity)
    { return {}; }






  template<typename _Tp>
    struct __success_type
    { typedef _Tp type; };

  struct __failure_type
  { };

  template<typename>
    struct remove_cv;


  template<typename _Tp>
    using __remove_cv_t = typename remove_cv<_Tp>::type;

  template<typename>
    struct is_const;



  template<typename>
    struct __is_void_helper
    : public false_type { };

  template<>
    struct __is_void_helper<void>
    : public true_type { };


  template<typename _Tp>
    struct is_void
    : public __is_void_helper<__remove_cv_t<_Tp>>::type
    { };

  template<typename>
    struct __is_integral_helper
    : public false_type { };

  template<>
    struct __is_integral_helper<bool>
    : public true_type { };

  template<>
    struct __is_integral_helper<char>
    : public true_type { };

  template<>
    struct __is_integral_helper<signed char>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned char>
    : public true_type { };


  template<>
    struct __is_integral_helper<wchar_t>
    : public true_type { };
# 284 "/usr/include/c++/10.2.0/type_traits" 3
  template<>
    struct __is_integral_helper<char16_t>
    : public true_type { };

  template<>
    struct __is_integral_helper<char32_t>
    : public true_type { };

  template<>
    struct __is_integral_helper<short>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned short>
    : public true_type { };

  template<>
    struct __is_integral_helper<int>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned int>
    : public true_type { };

  template<>
    struct __is_integral_helper<long>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned long>
    : public true_type { };

  template<>
    struct __is_integral_helper<long long>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned long long>
    : public true_type { };




  template<>
    struct __is_integral_helper<__int128>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned __int128>
    : public true_type { };
# 364 "/usr/include/c++/10.2.0/type_traits" 3
  template<typename _Tp>
    struct is_integral
    : public __is_integral_helper<__remove_cv_t<_Tp>>::type
    { };

  template<typename>
    struct __is_floating_point_helper
    : public false_type { };

  template<>
    struct __is_floating_point_helper<float>
    : public true_type { };

  template<>
    struct __is_floating_point_helper<double>
    : public true_type { };

  template<>
    struct __is_floating_point_helper<long double>
    : public true_type { };


  template<>
    struct __is_floating_point_helper<__float128>
    : public true_type { };



  template<typename _Tp>
    struct is_floating_point
    : public __is_floating_point_helper<__remove_cv_t<_Tp>>::type
    { };


  template<typename>
    struct is_array
    : public false_type { };

  template<typename _Tp, std::size_t _Size>
    struct is_array<_Tp[_Size]>
    : public true_type { };

  template<typename _Tp>
    struct is_array<_Tp[]>
    : public true_type { };

  template<typename>
    struct __is_pointer_helper
    : public false_type { };

  template<typename _Tp>
    struct __is_pointer_helper<_Tp*>
    : public true_type { };


  template<typename _Tp>
    struct is_pointer
    : public __is_pointer_helper<__remove_cv_t<_Tp>>::type
    { };


  template<typename>
    struct is_lvalue_reference
    : public false_type { };

  template<typename _Tp>
    struct is_lvalue_reference<_Tp&>
    : public true_type { };


  template<typename>
    struct is_rvalue_reference
    : public false_type { };

  template<typename _Tp>
    struct is_rvalue_reference<_Tp&&>
    : public true_type { };

  template<typename>
    struct __is_member_object_pointer_helper
    : public false_type { };

  template<typename _Tp, typename _Cp>
    struct __is_member_object_pointer_helper<_Tp _Cp::*>
    : public __not_<is_function<_Tp>>::type { };


  template<typename _Tp>
    struct is_member_object_pointer
    : public __is_member_object_pointer_helper<__remove_cv_t<_Tp>>::type
    { };

  template<typename>
    struct __is_member_function_pointer_helper
    : public false_type { };

  template<typename _Tp, typename _Cp>
    struct __is_member_function_pointer_helper<_Tp _Cp::*>
    : public is_function<_Tp>::type { };


  template<typename _Tp>
    struct is_member_function_pointer
    : public __is_member_function_pointer_helper<__remove_cv_t<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_enum
    : public integral_constant<bool, __is_enum(_Tp)>
    { };


  template<typename _Tp>
    struct is_union
    : public integral_constant<bool, __is_union(_Tp)>
    { };


  template<typename _Tp>
    struct is_class
    : public integral_constant<bool, __is_class(_Tp)>
    { };


  template<typename _Tp>
    struct is_function
    : public __bool_constant<!is_const<const _Tp>::value> { };

  template<typename _Tp>
    struct is_function<_Tp&>
    : public false_type { };

  template<typename _Tp>
    struct is_function<_Tp&&>
    : public false_type { };



  template<typename>
    struct __is_null_pointer_helper
    : public false_type { };

  template<>
    struct __is_null_pointer_helper<std::nullptr_t>
    : public true_type { };


  template<typename _Tp>
    struct is_null_pointer
    : public __is_null_pointer_helper<__remove_cv_t<_Tp>>::type
    { };


  template<typename _Tp>
    struct __is_nullptr_t
    : public is_null_pointer<_Tp>
    { } __attribute__ ((__deprecated__));




  template<typename _Tp>
    struct is_reference
    : public __or_<is_lvalue_reference<_Tp>,
                   is_rvalue_reference<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_arithmetic
    : public __or_<is_integral<_Tp>, is_floating_point<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_fundamental
    : public __or_<is_arithmetic<_Tp>, is_void<_Tp>,
     is_null_pointer<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_object
    : public __not_<__or_<is_function<_Tp>, is_reference<_Tp>,
                          is_void<_Tp>>>::type
    { };

  template<typename>
    struct is_member_pointer;


  template<typename _Tp>
    struct is_scalar
    : public __or_<is_arithmetic<_Tp>, is_enum<_Tp>, is_pointer<_Tp>,
                   is_member_pointer<_Tp>, is_null_pointer<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_compound
    : public __not_<is_fundamental<_Tp>>::type { };

  template<typename _Tp>
    struct __is_member_pointer_helper
    : public false_type { };

  template<typename _Tp, typename _Cp>
    struct __is_member_pointer_helper<_Tp _Cp::*>
    : public true_type { };


  template<typename _Tp>
    struct is_member_pointer
    : public __is_member_pointer_helper<__remove_cv_t<_Tp>>::type
    { };

  template<typename, typename>
    struct is_same;

  template<typename _Tp, typename... _Types>
    using __is_one_of = __or_<is_same<_Tp, _Types>...>;


  template<typename _Tp>
    using __is_signed_integer = __is_one_of<__remove_cv_t<_Tp>,
   signed char, signed short, signed int, signed long,
   signed long long

   , signed __int128
# 604 "/usr/include/c++/10.2.0/type_traits" 3
   >;


  template<typename _Tp>
    using __is_unsigned_integer = __is_one_of<__remove_cv_t<_Tp>,
   unsigned char, unsigned short, unsigned int, unsigned long,
   unsigned long long

   , unsigned __int128
# 623 "/usr/include/c++/10.2.0/type_traits" 3
   >;


  template<typename _Tp>
    using __is_standard_integer
      = __or_<__is_signed_integer<_Tp>, __is_unsigned_integer<_Tp>>;


  template<typename...> using __void_t = void;



  template<typename _Tp, typename = void>
    struct __is_referenceable
    : public false_type
    { };

  template<typename _Tp>
    struct __is_referenceable<_Tp, __void_t<_Tp&>>
    : public true_type
    { };




  template<typename>
    struct is_const
    : public false_type { };

  template<typename _Tp>
    struct is_const<_Tp const>
    : public true_type { };


  template<typename>
    struct is_volatile
    : public false_type { };

  template<typename _Tp>
    struct is_volatile<_Tp volatile>
    : public true_type { };


  template<typename _Tp>
    struct is_trivial
    : public integral_constant<bool, __is_trivial(_Tp)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_trivially_copyable
    : public integral_constant<bool, __is_trivially_copyable(_Tp)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_standard_layout
    : public integral_constant<bool, __is_standard_layout(_Tp)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };



  template<typename _Tp>
    struct
   
    is_pod
    : public integral_constant<bool, __is_pod(_Tp)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_literal_type
    : public integral_constant<bool, __is_literal_type(_Tp)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_empty
    : public integral_constant<bool, __is_empty(_Tp)>
    { };


  template<typename _Tp>
    struct is_polymorphic
    : public integral_constant<bool, __is_polymorphic(_Tp)>
    { };




  template<typename _Tp>
    struct is_final
    : public integral_constant<bool, __is_final(_Tp)>
    { };



  template<typename _Tp>
    struct is_abstract
    : public integral_constant<bool, __is_abstract(_Tp)>
    { };

  template<typename _Tp,
    bool = is_arithmetic<_Tp>::value>
    struct __is_signed_helper
    : public false_type { };

  template<typename _Tp>
    struct __is_signed_helper<_Tp, true>
    : public integral_constant<bool, _Tp(-1) < _Tp(0)>
    { };


  template<typename _Tp>
    struct is_signed
    : public __is_signed_helper<_Tp>::type
    { };


  template<typename _Tp>
    struct is_unsigned
    : public __and_<is_arithmetic<_Tp>, __not_<is_signed<_Tp>>>
    { };
# 770 "/usr/include/c++/10.2.0/type_traits" 3
  template<typename _Tp, typename _Up = _Tp&&>
    _Up
    __declval(int);

  template<typename _Tp>
    _Tp
    __declval(long);

  template<typename _Tp>
    auto declval() noexcept -> decltype(__declval<_Tp>(0));

  template<typename, unsigned = 0>
    struct extent;

  template<typename>
    struct remove_all_extents;

  template<typename _Tp>
    struct __is_array_known_bounds
    : public integral_constant<bool, (extent<_Tp>::value > 0)>
    { };

  template<typename _Tp>
    struct __is_array_unknown_bounds
    : public __and_<is_array<_Tp>, __not_<extent<_Tp>>>
    { };






  struct __do_is_destructible_impl
  {
    template<typename _Tp, typename = decltype(declval<_Tp&>().~_Tp())>
      static true_type __test(int);

    template<typename>
      static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_destructible_impl
    : public __do_is_destructible_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp,
           bool = __or_<is_void<_Tp>,
                        __is_array_unknown_bounds<_Tp>,
                        is_function<_Tp>>::value,
           bool = __or_<is_reference<_Tp>, is_scalar<_Tp>>::value>
    struct __is_destructible_safe;

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, false, false>
    : public __is_destructible_impl<typename
               remove_all_extents<_Tp>::type>::type
    { };

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, true, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, false, true>
    : public true_type { };


  template<typename _Tp>
    struct is_destructible
    : public __is_destructible_safe<_Tp>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };





  struct __do_is_nt_destructible_impl
  {
    template<typename _Tp>
      static __bool_constant<noexcept(declval<_Tp&>().~_Tp())>
      __test(int);

    template<typename>
      static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_nt_destructible_impl
    : public __do_is_nt_destructible_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp,
           bool = __or_<is_void<_Tp>,
                        __is_array_unknown_bounds<_Tp>,
                        is_function<_Tp>>::value,
           bool = __or_<is_reference<_Tp>, is_scalar<_Tp>>::value>
    struct __is_nt_destructible_safe;

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, false, false>
    : public __is_nt_destructible_impl<typename
               remove_all_extents<_Tp>::type>::type
    { };

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, true, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, false, true>
    : public true_type { };


  template<typename _Tp>
    struct is_nothrow_destructible
    : public __is_nt_destructible_safe<_Tp>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };

  template<typename _Tp, typename... _Args>
    struct __is_constructible_impl
    : public __bool_constant<__is_constructible(_Tp, _Args...)>
    { };


  template<typename _Tp, typename... _Args>
    struct is_constructible
      : public __is_constructible_impl<_Tp, _Args...>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_default_constructible
    : public __is_constructible_impl<_Tp>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_copy_constructible_impl;

  template<typename _Tp>
    struct __is_copy_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_copy_constructible_impl<_Tp, true>
    : public __is_constructible_impl<_Tp, const _Tp&>
    { };


  template<typename _Tp>
    struct is_copy_constructible
    : public __is_copy_constructible_impl<_Tp>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_move_constructible_impl;

  template<typename _Tp>
    struct __is_move_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_move_constructible_impl<_Tp, true>
    : public __is_constructible_impl<_Tp, _Tp&&>
    { };


  template<typename _Tp>
    struct is_move_constructible
    : public __is_move_constructible_impl<_Tp>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };

  template<bool, typename _Tp, typename... _Args>
    struct __is_nt_constructible_impl
    : public false_type
    { };

  template<typename _Tp, typename... _Args>
    struct __is_nt_constructible_impl<true, _Tp, _Args...>
    : public __bool_constant<noexcept(_Tp(std::declval<_Args>()...))>
    { };

  template<typename _Tp, typename _Arg>
    struct __is_nt_constructible_impl<true, _Tp, _Arg>
    : public __bool_constant<noexcept(static_cast<_Tp>(std::declval<_Arg>()))>
    { };

  template<typename _Tp>
    struct __is_nt_constructible_impl<true, _Tp>
    : public __bool_constant<noexcept(_Tp())>
    { };

  template<typename _Tp, size_t _Num>
    struct __is_nt_constructible_impl<true, _Tp[_Num]>
    : public __bool_constant<noexcept(typename remove_all_extents<_Tp>::type())>
    { };
# 1001 "/usr/include/c++/10.2.0/type_traits" 3
  template<typename _Tp, typename... _Args>
    using __is_nothrow_constructible_impl
      = __is_nt_constructible_impl<__is_constructible(_Tp, _Args...),
       _Tp, _Args...>;


  template<typename _Tp, typename... _Args>
    struct is_nothrow_constructible
    : public __is_nothrow_constructible_impl<_Tp, _Args...>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_nothrow_default_constructible
    : public __is_nothrow_constructible_impl<_Tp>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nothrow_copy_constructible_impl;

  template<typename _Tp>
    struct __is_nothrow_copy_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nothrow_copy_constructible_impl<_Tp, true>
    : public __is_nothrow_constructible_impl<_Tp, const _Tp&>
    { };


  template<typename _Tp>
    struct is_nothrow_copy_constructible
    : public __is_nothrow_copy_constructible_impl<_Tp>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nothrow_move_constructible_impl;

  template<typename _Tp>
    struct __is_nothrow_move_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nothrow_move_constructible_impl<_Tp, true>
    : public __is_nothrow_constructible_impl<_Tp, _Tp&&>
    { };


  template<typename _Tp>
    struct is_nothrow_move_constructible
    : public __is_nothrow_move_constructible_impl<_Tp>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp, typename _Up>
    struct is_assignable
    : public __bool_constant<__is_assignable(_Tp, _Up)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_copy_assignable_impl;

  template<typename _Tp>
    struct __is_copy_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_copy_assignable_impl<_Tp, true>
    : public __bool_constant<__is_assignable(_Tp&, const _Tp&)>
    { };


  template<typename _Tp>
    struct is_copy_assignable
    : public __is_copy_assignable_impl<_Tp>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_move_assignable_impl;

  template<typename _Tp>
    struct __is_move_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_move_assignable_impl<_Tp, true>
    : public __bool_constant<__is_assignable(_Tp&, _Tp&&)>
    { };


  template<typename _Tp>
    struct is_move_assignable
    : public __is_move_assignable_impl<_Tp>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };

  template<typename _Tp, typename _Up>
    struct __is_nt_assignable_impl
    : public integral_constant<bool, noexcept(declval<_Tp>() = declval<_Up>())>
    { };

  template<typename _Tp, typename _Up>
    struct __is_nothrow_assignable_impl
    : public __and_<__bool_constant<__is_assignable(_Tp, _Up)>,
      __is_nt_assignable_impl<_Tp, _Up>>
    { };


  template<typename _Tp, typename _Up>
    struct is_nothrow_assignable
    : public __is_nothrow_assignable_impl<_Tp, _Up>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nt_copy_assignable_impl;

  template<typename _Tp>
    struct __is_nt_copy_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nt_copy_assignable_impl<_Tp, true>
    : public __is_nothrow_assignable_impl<_Tp&, const _Tp&>
    { };


  template<typename _Tp>
    struct is_nothrow_copy_assignable
    : public __is_nt_copy_assignable_impl<_Tp>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nt_move_assignable_impl;

  template<typename _Tp>
    struct __is_nt_move_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nt_move_assignable_impl<_Tp, true>
    : public __is_nothrow_assignable_impl<_Tp&, _Tp&&>
    { };


  template<typename _Tp>
    struct is_nothrow_move_assignable
    : public __is_nt_move_assignable_impl<_Tp>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp, typename... _Args>
    struct is_trivially_constructible
    : public __bool_constant<__is_trivially_constructible(_Tp, _Args...)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_trivially_default_constructible
    : public __bool_constant<__is_trivially_constructible(_Tp)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };

  struct __do_is_implicitly_default_constructible_impl
  {
    template <typename _Tp>
    static void __helper(const _Tp&);

    template <typename _Tp>
    static true_type __test(const _Tp&,
                            decltype(__helper<const _Tp&>({}))* = 0);

    static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_implicitly_default_constructible_impl
    : public __do_is_implicitly_default_constructible_impl
    {
      typedef decltype(__test(declval<_Tp>())) type;
    };

  template<typename _Tp>
    struct __is_implicitly_default_constructible_safe
    : public __is_implicitly_default_constructible_impl<_Tp>::type
    { };

  template <typename _Tp>
    struct __is_implicitly_default_constructible
    : public __and_<__is_constructible_impl<_Tp>,
      __is_implicitly_default_constructible_safe<_Tp>>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_trivially_copy_constructible_impl;

  template<typename _Tp>
    struct __is_trivially_copy_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_trivially_copy_constructible_impl<_Tp, true>
    : public __and_<__is_copy_constructible_impl<_Tp>,
      integral_constant<bool,
   __is_trivially_constructible(_Tp, const _Tp&)>>
    { };


  template<typename _Tp>
    struct is_trivially_copy_constructible
    : public __is_trivially_copy_constructible_impl<_Tp>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_trivially_move_constructible_impl;

  template<typename _Tp>
    struct __is_trivially_move_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_trivially_move_constructible_impl<_Tp, true>
    : public __and_<__is_move_constructible_impl<_Tp>,
      integral_constant<bool,
   __is_trivially_constructible(_Tp, _Tp&&)>>
    { };


  template<typename _Tp>
    struct is_trivially_move_constructible
    : public __is_trivially_move_constructible_impl<_Tp>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp, typename _Up>
    struct is_trivially_assignable
    : public __bool_constant<__is_trivially_assignable(_Tp, _Up)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_trivially_copy_assignable_impl;

  template<typename _Tp>
    struct __is_trivially_copy_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_trivially_copy_assignable_impl<_Tp, true>
    : public __bool_constant<__is_trivially_assignable(_Tp&, const _Tp&)>
    { };


  template<typename _Tp>
    struct is_trivially_copy_assignable
    : public __is_trivially_copy_assignable_impl<_Tp>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_trivially_move_assignable_impl;

  template<typename _Tp>
    struct __is_trivially_move_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_trivially_move_assignable_impl<_Tp, true>
    : public __bool_constant<__is_trivially_assignable(_Tp&, _Tp&&)>
    { };


  template<typename _Tp>
    struct is_trivially_move_assignable
    : public __is_trivially_move_assignable_impl<_Tp>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_trivially_destructible
    : public __and_<__is_destructible_safe<_Tp>,
      __bool_constant<__has_trivial_destructor(_Tp)>>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };



  template<typename _Tp>
    struct has_virtual_destructor
    : public integral_constant<bool, __has_virtual_destructor(_Tp)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };





  template<typename _Tp>
    struct alignment_of
    : public integral_constant<std::size_t, alignof(_Tp)>
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename>
    struct rank
    : public integral_constant<std::size_t, 0> { };

  template<typename _Tp, std::size_t _Size>
    struct rank<_Tp[_Size]>
    : public integral_constant<std::size_t, 1 + rank<_Tp>::value> { };

  template<typename _Tp>
    struct rank<_Tp[]>
    : public integral_constant<std::size_t, 1 + rank<_Tp>::value> { };


  template<typename, unsigned _Uint>
    struct extent
    : public integral_constant<std::size_t, 0> { };

  template<typename _Tp, unsigned _Uint, std::size_t _Size>
    struct extent<_Tp[_Size], _Uint>
    : public integral_constant<std::size_t,
          _Uint == 0 ? _Size : extent<_Tp,
          _Uint - 1>::value>
    { };

  template<typename _Tp, unsigned _Uint>
    struct extent<_Tp[], _Uint>
    : public integral_constant<std::size_t,
          _Uint == 0 ? 0 : extent<_Tp,
             _Uint - 1>::value>
    { };





  template<typename _Tp, typename _Up>
    struct is_same

    : public integral_constant<bool, __is_same_as(_Tp, _Up)>



    { };
# 1410 "/usr/include/c++/10.2.0/type_traits" 3
  template<typename _Base, typename _Derived>
    struct is_base_of
    : public integral_constant<bool, __is_base_of(_Base, _Derived)>
    { };

  template<typename _From, typename _To,
           bool = __or_<is_void<_From>, is_function<_To>,
                        is_array<_To>>::value>
    struct __is_convertible_helper
    {
      typedef typename is_void<_To>::type type;
    };

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wctor-dtor-privacy"
  template<typename _From, typename _To>
    class __is_convertible_helper<_From, _To, false>
    {
      template<typename _To1>
 static void __test_aux(_To1) noexcept;

      template<typename _From1, typename _To1,
        typename = decltype(__test_aux<_To1>(std::declval<_From1>()))>
 static true_type
 __test(int);

      template<typename, typename>
 static false_type
 __test(...);

    public:
      typedef decltype(__test<_From, _To>(0)) type;
    };
#pragma GCC diagnostic pop


  template<typename _From, typename _To>
    struct is_convertible
    : public __is_convertible_helper<_From, _To>::type
    { };


  template<typename _ToElementType, typename _FromElementType>
    using __is_array_convertible
      = is_convertible<_FromElementType(*)[], _ToElementType(*)[]>;

  template<typename _From, typename _To,
           bool = __or_<is_void<_From>, is_function<_To>,
                        is_array<_To>>::value>
    struct __is_nt_convertible_helper
    : is_void<_To>
    { };

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wctor-dtor-privacy"
  template<typename _From, typename _To>
    class __is_nt_convertible_helper<_From, _To, false>
    {
      template<typename _To1>
 static void __test_aux(_To1) noexcept;

      template<typename _From1, typename _To1>
 static
 __bool_constant<noexcept(__test_aux<_To1>(std::declval<_From1>()))>
 __test(int);

      template<typename, typename>
 static false_type
 __test(...);

    public:
      using type = decltype(__test<_From, _To>(0));
    };
#pragma GCC diagnostic pop


  template<typename _From, typename _To>
    struct __is_nothrow_convertible
    : public __is_nt_convertible_helper<_From, _To>::type
    { };
# 1508 "/usr/include/c++/10.2.0/type_traits" 3
  template<typename _Tp>
    struct remove_const
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_const<_Tp const>
    { typedef _Tp type; };


  template<typename _Tp>
    struct remove_volatile
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_volatile<_Tp volatile>
    { typedef _Tp type; };


  template<typename _Tp>
    struct remove_cv
    { using type = _Tp; };

  template<typename _Tp>
    struct remove_cv<const _Tp>
    { using type = _Tp; };

  template<typename _Tp>
    struct remove_cv<volatile _Tp>
    { using type = _Tp; };

  template<typename _Tp>
    struct remove_cv<const volatile _Tp>
    { using type = _Tp; };


  template<typename _Tp>
    struct add_const
    { typedef _Tp const type; };


  template<typename _Tp>
    struct add_volatile
    { typedef _Tp volatile type; };


  template<typename _Tp>
    struct add_cv
    {
      typedef typename
      add_const<typename add_volatile<_Tp>::type>::type type;
    };






  template<typename _Tp>
    using remove_const_t = typename remove_const<_Tp>::type;


  template<typename _Tp>
    using remove_volatile_t = typename remove_volatile<_Tp>::type;


  template<typename _Tp>
    using remove_cv_t = typename remove_cv<_Tp>::type;


  template<typename _Tp>
    using add_const_t = typename add_const<_Tp>::type;


  template<typename _Tp>
    using add_volatile_t = typename add_volatile<_Tp>::type;


  template<typename _Tp>
    using add_cv_t = typename add_cv<_Tp>::type;





  template<typename _Tp>
    struct remove_reference
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_reference<_Tp&>
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_reference<_Tp&&>
    { typedef _Tp type; };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __add_lvalue_reference_helper
    { typedef _Tp type; };

  template<typename _Tp>
    struct __add_lvalue_reference_helper<_Tp, true>
    { typedef _Tp& type; };


  template<typename _Tp>
    struct add_lvalue_reference
    : public __add_lvalue_reference_helper<_Tp>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __add_rvalue_reference_helper
    { typedef _Tp type; };

  template<typename _Tp>
    struct __add_rvalue_reference_helper<_Tp, true>
    { typedef _Tp&& type; };


  template<typename _Tp>
    struct add_rvalue_reference
    : public __add_rvalue_reference_helper<_Tp>
    { };



  template<typename _Tp>
    using remove_reference_t = typename remove_reference<_Tp>::type;


  template<typename _Tp>
    using add_lvalue_reference_t = typename add_lvalue_reference<_Tp>::type;


  template<typename _Tp>
    using add_rvalue_reference_t = typename add_rvalue_reference<_Tp>::type;





  template<typename _Unqualified, bool _IsConst, bool _IsVol>
    struct __cv_selector;

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, false, false>
    { typedef _Unqualified __type; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, false, true>
    { typedef volatile _Unqualified __type; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, true, false>
    { typedef const _Unqualified __type; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, true, true>
    { typedef const volatile _Unqualified __type; };

  template<typename _Qualified, typename _Unqualified,
    bool _IsConst = is_const<_Qualified>::value,
    bool _IsVol = is_volatile<_Qualified>::value>
    class __match_cv_qualifiers
    {
      typedef __cv_selector<_Unqualified, _IsConst, _IsVol> __match;

    public:
      typedef typename __match::__type __type;
    };


  template<typename _Tp>
    struct __make_unsigned
    { typedef _Tp __type; };

  template<>
    struct __make_unsigned<char>
    { typedef unsigned char __type; };

  template<>
    struct __make_unsigned<signed char>
    { typedef unsigned char __type; };

  template<>
    struct __make_unsigned<short>
    { typedef unsigned short __type; };

  template<>
    struct __make_unsigned<int>
    { typedef unsigned int __type; };

  template<>
    struct __make_unsigned<long>
    { typedef unsigned long __type; };

  template<>
    struct __make_unsigned<long long>
    { typedef unsigned long long __type; };


  template<>
    struct __make_unsigned<__int128>
    { typedef unsigned __int128 __type; };
# 1730 "/usr/include/c++/10.2.0/type_traits" 3
  template<typename _Tp,
    bool _IsInt = is_integral<_Tp>::value,
    bool _IsEnum = is_enum<_Tp>::value>
    class __make_unsigned_selector;

  template<typename _Tp>
    class __make_unsigned_selector<_Tp, true, false>
    {
      using __unsigned_type
 = typename __make_unsigned<__remove_cv_t<_Tp>>::__type;

    public:
      using __type
 = typename __match_cv_qualifiers<_Tp, __unsigned_type>::__type;
    };

  class __make_unsigned_selector_base
  {
  protected:
    template<typename...> struct _List { };

    template<typename _Tp, typename... _Up>
      struct _List<_Tp, _Up...> : _List<_Up...>
      { static constexpr size_t __size = sizeof(_Tp); };

    template<size_t _Sz, typename _Tp, bool = (_Sz <= _Tp::__size)>
      struct __select;

    template<size_t _Sz, typename _Uint, typename... _UInts>
      struct __select<_Sz, _List<_Uint, _UInts...>, true>
      { using __type = _Uint; };

    template<size_t _Sz, typename _Uint, typename... _UInts>
      struct __select<_Sz, _List<_Uint, _UInts...>, false>
      : __select<_Sz, _List<_UInts...>>
      { };
  };


  template<typename _Tp>
    class __make_unsigned_selector<_Tp, false, true>
    : __make_unsigned_selector_base
    {

      using _UInts = _List<unsigned char, unsigned short, unsigned int,
      unsigned long, unsigned long long>;

      using __unsigned_type = typename __select<sizeof(_Tp), _UInts>::__type;

    public:
      using __type
 = typename __match_cv_qualifiers<_Tp, __unsigned_type>::__type;
    };






  template<>
    struct __make_unsigned<wchar_t>
    {
      using __type
 = typename __make_unsigned_selector<wchar_t, false, true>::__type;
    };
# 1806 "/usr/include/c++/10.2.0/type_traits" 3
  template<>
    struct __make_unsigned<char16_t>
    {
      using __type
 = typename __make_unsigned_selector<char16_t, false, true>::__type;
    };

  template<>
    struct __make_unsigned<char32_t>
    {
      using __type
 = typename __make_unsigned_selector<char32_t, false, true>::__type;
    };





  template<typename _Tp>
    struct make_unsigned
    { typedef typename __make_unsigned_selector<_Tp>::__type type; };


  template<>
    struct make_unsigned<bool>;



  template<typename _Tp>
    struct __make_signed
    { typedef _Tp __type; };

  template<>
    struct __make_signed<char>
    { typedef signed char __type; };

  template<>
    struct __make_signed<unsigned char>
    { typedef signed char __type; };

  template<>
    struct __make_signed<unsigned short>
    { typedef signed short __type; };

  template<>
    struct __make_signed<unsigned int>
    { typedef signed int __type; };

  template<>
    struct __make_signed<unsigned long>
    { typedef signed long __type; };

  template<>
    struct __make_signed<unsigned long long>
    { typedef signed long long __type; };


  template<>
    struct __make_signed<unsigned __int128>
    { typedef __int128 __type; };
# 1884 "/usr/include/c++/10.2.0/type_traits" 3
  template<typename _Tp,
    bool _IsInt = is_integral<_Tp>::value,
    bool _IsEnum = is_enum<_Tp>::value>
    class __make_signed_selector;

  template<typename _Tp>
    class __make_signed_selector<_Tp, true, false>
    {
      using __signed_type
 = typename __make_signed<__remove_cv_t<_Tp>>::__type;

    public:
      using __type
 = typename __match_cv_qualifiers<_Tp, __signed_type>::__type;
    };


  template<typename _Tp>
    class __make_signed_selector<_Tp, false, true>
    {
      typedef typename __make_unsigned_selector<_Tp>::__type __unsigned_type;

    public:
      typedef typename __make_signed_selector<__unsigned_type>::__type __type;
    };






  template<>
    struct __make_signed<wchar_t>
    {
      using __type
 = typename __make_signed_selector<wchar_t, false, true>::__type;
    };
# 1932 "/usr/include/c++/10.2.0/type_traits" 3
  template<>
    struct __make_signed<char16_t>
    {
      using __type
 = typename __make_signed_selector<char16_t, false, true>::__type;
    };

  template<>
    struct __make_signed<char32_t>
    {
      using __type
 = typename __make_signed_selector<char32_t, false, true>::__type;
    };





  template<typename _Tp>
    struct make_signed
    { typedef typename __make_signed_selector<_Tp>::__type type; };


  template<>
    struct make_signed<bool>;



  template<typename _Tp>
    using make_signed_t = typename make_signed<_Tp>::type;


  template<typename _Tp>
    using make_unsigned_t = typename make_unsigned<_Tp>::type;





  template<typename _Tp>
    struct remove_extent
    { typedef _Tp type; };

  template<typename _Tp, std::size_t _Size>
    struct remove_extent<_Tp[_Size]>
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_extent<_Tp[]>
    { typedef _Tp type; };


  template<typename _Tp>
    struct remove_all_extents
    { typedef _Tp type; };

  template<typename _Tp, std::size_t _Size>
    struct remove_all_extents<_Tp[_Size]>
    { typedef typename remove_all_extents<_Tp>::type type; };

  template<typename _Tp>
    struct remove_all_extents<_Tp[]>
    { typedef typename remove_all_extents<_Tp>::type type; };



  template<typename _Tp>
    using remove_extent_t = typename remove_extent<_Tp>::type;


  template<typename _Tp>
    using remove_all_extents_t = typename remove_all_extents<_Tp>::type;




  template<typename _Tp, typename>
    struct __remove_pointer_helper
    { typedef _Tp type; };

  template<typename _Tp, typename _Up>
    struct __remove_pointer_helper<_Tp, _Up*>
    { typedef _Up type; };


  template<typename _Tp>
    struct remove_pointer
    : public __remove_pointer_helper<_Tp, __remove_cv_t<_Tp>>
    { };


  template<typename _Tp, bool = __or_<__is_referenceable<_Tp>,
          is_void<_Tp>>::value>
    struct __add_pointer_helper
    { typedef _Tp type; };

  template<typename _Tp>
    struct __add_pointer_helper<_Tp, true>
    { typedef typename remove_reference<_Tp>::type* type; };

  template<typename _Tp>
    struct add_pointer
    : public __add_pointer_helper<_Tp>
    { };



  template<typename _Tp>
    using remove_pointer_t = typename remove_pointer<_Tp>::type;


  template<typename _Tp>
    using add_pointer_t = typename add_pointer<_Tp>::type;


  template<std::size_t _Len>
    struct __aligned_storage_msa
    {
      union __type
      {
 unsigned char __data[_Len];
 struct __attribute__((__aligned__)) { } __align;
      };
    };
# 2067 "/usr/include/c++/10.2.0/type_traits" 3
  template<std::size_t _Len, std::size_t _Align =
    __alignof__(typename __aligned_storage_msa<_Len>::__type)>
    struct aligned_storage
    {
      union type
      {
 unsigned char __data[_Len];
 struct __attribute__((__aligned__((_Align)))) { } __align;
      };
    };

  template <typename... _Types>
    struct __strictest_alignment
    {
      static const size_t _S_alignment = 0;
      static const size_t _S_size = 0;
    };

  template <typename _Tp, typename... _Types>
    struct __strictest_alignment<_Tp, _Types...>
    {
      static const size_t _S_alignment =
        alignof(_Tp) > __strictest_alignment<_Types...>::_S_alignment
 ? alignof(_Tp) : __strictest_alignment<_Types...>::_S_alignment;
      static const size_t _S_size =
        sizeof(_Tp) > __strictest_alignment<_Types...>::_S_size
 ? sizeof(_Tp) : __strictest_alignment<_Types...>::_S_size;
    };
# 2106 "/usr/include/c++/10.2.0/type_traits" 3
  template <size_t _Len, typename... _Types>
    struct aligned_union
    {
    private:
      static_assert(sizeof...(_Types) != 0, "At least one type is required");

      using __strictest = __strictest_alignment<_Types...>;
      static const size_t _S_len = _Len > __strictest::_S_size
 ? _Len : __strictest::_S_size;
    public:

      static const size_t alignment_value = __strictest::_S_alignment;

      typedef typename aligned_storage<_S_len, alignment_value>::type type;
    };

  template <size_t _Len, typename... _Types>
    const size_t aligned_union<_Len, _Types...>::alignment_value;



  template<typename _Up,
    bool _IsArray = is_array<_Up>::value,
    bool _IsFunction = is_function<_Up>::value>
    struct __decay_selector;


  template<typename _Up>
    struct __decay_selector<_Up, false, false>
    { typedef __remove_cv_t<_Up> __type; };

  template<typename _Up>
    struct __decay_selector<_Up, true, false>
    { typedef typename remove_extent<_Up>::type* __type; };

  template<typename _Up>
    struct __decay_selector<_Up, false, true>
    { typedef typename add_pointer<_Up>::type __type; };


  template<typename _Tp>
    class decay
    {
      typedef typename remove_reference<_Tp>::type __remove_type;

    public:
      typedef typename __decay_selector<__remove_type>::__type type;
    };


  template<typename _Tp>
    using __decay_t = typename decay<_Tp>::type;

  template<typename _Tp>
    class reference_wrapper;


  template<typename _Tp>
    struct __strip_reference_wrapper
    {
      typedef _Tp __type;
    };

  template<typename _Tp>
    struct __strip_reference_wrapper<reference_wrapper<_Tp> >
    {
      typedef _Tp& __type;
    };

  template<typename _Tp>
    using __decay_and_strip = __strip_reference_wrapper<__decay_t<_Tp>>;




  template<bool, typename _Tp = void>
    struct enable_if
    { };


  template<typename _Tp>
    struct enable_if<true, _Tp>
    { typedef _Tp type; };


  template<bool _Cond, typename _Tp = void>
    using __enable_if_t = typename enable_if<_Cond, _Tp>::type;

  template<typename... _Cond>
    using _Require = __enable_if_t<__and_<_Cond...>::value>;



  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    struct conditional
    { typedef _Iftrue type; };


  template<typename _Iftrue, typename _Iffalse>
    struct conditional<false, _Iftrue, _Iffalse>
    { typedef _Iffalse type; };


  template<typename _Tp>
    using __remove_cvref_t
     = typename remove_cv<typename remove_reference<_Tp>::type>::type;


  template<typename... _Tp>
    struct common_type;



  struct __do_common_type_impl
  {
    template<typename _Tp, typename _Up>
      using __cond_t
 = decltype(true ? std::declval<_Tp>() : std::declval<_Up>());



    template<typename _Tp, typename _Up>
      static __success_type<__decay_t<__cond_t<_Tp, _Up>>>
      _S_test(int);
# 2239 "/usr/include/c++/10.2.0/type_traits" 3
    template<typename, typename>
      static __failure_type
      _S_test_2(...);

    template<typename _Tp, typename _Up>
      static decltype(_S_test_2<_Tp, _Up>(0))
      _S_test(...);
  };


  template<>
    struct common_type<>
    { };


  template<typename _Tp0>
    struct common_type<_Tp0>
    : public common_type<_Tp0, _Tp0>
    { };


  template<typename _Tp1, typename _Tp2,
    typename _Dp1 = __decay_t<_Tp1>, typename _Dp2 = __decay_t<_Tp2>>
    struct __common_type_impl
    {


      using type = common_type<_Dp1, _Dp2>;
    };

  template<typename _Tp1, typename _Tp2>
    struct __common_type_impl<_Tp1, _Tp2, _Tp1, _Tp2>
    : private __do_common_type_impl
    {


      using type = decltype(_S_test<_Tp1, _Tp2>(0));
    };


  template<typename _Tp1, typename _Tp2>
    struct common_type<_Tp1, _Tp2>
    : public __common_type_impl<_Tp1, _Tp2>::type
    { };

  template<typename...>
    struct __common_type_pack
    { };

  template<typename, typename, typename = void>
    struct __common_type_fold;


  template<typename _Tp1, typename _Tp2, typename... _Rp>
    struct common_type<_Tp1, _Tp2, _Rp...>
    : public __common_type_fold<common_type<_Tp1, _Tp2>,
    __common_type_pack<_Rp...>>
    { };




  template<typename _CTp, typename... _Rp>
    struct __common_type_fold<_CTp, __common_type_pack<_Rp...>,
         __void_t<typename _CTp::type>>
    : public common_type<typename _CTp::type, _Rp...>
    { };


  template<typename _CTp, typename _Rp>
    struct __common_type_fold<_CTp, _Rp, void>
    { };

  template<typename _Tp, bool = is_enum<_Tp>::value>
    struct __underlying_type_impl
    {
      using type = __underlying_type(_Tp);
    };

  template<typename _Tp>
    struct __underlying_type_impl<_Tp, false>
    { };


  template<typename _Tp>
    struct underlying_type
    : public __underlying_type_impl<_Tp>
    { };

  template<typename _Tp>
    struct __declval_protector
    {
      static const bool __stop = false;
    };

  template<typename _Tp>
    auto declval() noexcept -> decltype(__declval<_Tp>(0))
    {
      static_assert(__declval_protector<_Tp>::__stop,
      "declval() must not be used!");
      return __declval<_Tp>(0);
    }


  template<typename _Signature>
    class result_of;





  struct __invoke_memfun_ref { };
  struct __invoke_memfun_deref { };
  struct __invoke_memobj_ref { };
  struct __invoke_memobj_deref { };
  struct __invoke_other { };


  template<typename _Tp, typename _Tag>
    struct __result_of_success : __success_type<_Tp>
    { using __invoke_type = _Tag; };


  struct __result_of_memfun_ref_impl
  {
    template<typename _Fp, typename _Tp1, typename... _Args>
      static __result_of_success<decltype(
      (std::declval<_Tp1>().*std::declval<_Fp>())(std::declval<_Args>()...)
      ), __invoke_memfun_ref> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun_ref
    : private __result_of_memfun_ref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg, _Args...>(0)) type;
    };


  struct __result_of_memfun_deref_impl
  {
    template<typename _Fp, typename _Tp1, typename... _Args>
      static __result_of_success<decltype(
      ((*std::declval<_Tp1>()).*std::declval<_Fp>())(std::declval<_Args>()...)
      ), __invoke_memfun_deref> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun_deref
    : private __result_of_memfun_deref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg, _Args...>(0)) type;
    };


  struct __result_of_memobj_ref_impl
  {
    template<typename _Fp, typename _Tp1>
      static __result_of_success<decltype(
      std::declval<_Tp1>().*std::declval<_Fp>()
      ), __invoke_memobj_ref> _S_test(int);

    template<typename, typename>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj_ref
    : private __result_of_memobj_ref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg>(0)) type;
    };


  struct __result_of_memobj_deref_impl
  {
    template<typename _Fp, typename _Tp1>
      static __result_of_success<decltype(
      (*std::declval<_Tp1>()).*std::declval<_Fp>()
      ), __invoke_memobj_deref> _S_test(int);

    template<typename, typename>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj_deref
    : private __result_of_memobj_deref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg>(0)) type;
    };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj;

  template<typename _Res, typename _Class, typename _Arg>
    struct __result_of_memobj<_Res _Class::*, _Arg>
    {
      typedef __remove_cvref_t<_Arg> _Argval;
      typedef _Res _Class::* _MemPtr;
      typedef typename conditional<__or_<is_same<_Argval, _Class>,
        is_base_of<_Class, _Argval>>::value,
        __result_of_memobj_ref<_MemPtr, _Arg>,
        __result_of_memobj_deref<_MemPtr, _Arg>
      >::type::type type;
    };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun;

  template<typename _Res, typename _Class, typename _Arg, typename... _Args>
    struct __result_of_memfun<_Res _Class::*, _Arg, _Args...>
    {
      typedef typename remove_reference<_Arg>::type _Argval;
      typedef _Res _Class::* _MemPtr;
      typedef typename conditional<is_base_of<_Class, _Argval>::value,
        __result_of_memfun_ref<_MemPtr, _Arg, _Args...>,
        __result_of_memfun_deref<_MemPtr, _Arg, _Args...>
      >::type::type type;
    };






  template<typename _Tp, typename _Up = __remove_cvref_t<_Tp>>
    struct __inv_unwrap
    {
      using type = _Tp;
    };

  template<typename _Tp, typename _Up>
    struct __inv_unwrap<_Tp, reference_wrapper<_Up>>
    {
      using type = _Up&;
    };

  template<bool, bool, typename _Functor, typename... _ArgTypes>
    struct __result_of_impl
    {
      typedef __failure_type type;
    };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_impl<true, false, _MemPtr, _Arg>
    : public __result_of_memobj<__decay_t<_MemPtr>,
    typename __inv_unwrap<_Arg>::type>
    { };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_impl<false, true, _MemPtr, _Arg, _Args...>
    : public __result_of_memfun<__decay_t<_MemPtr>,
    typename __inv_unwrap<_Arg>::type, _Args...>
    { };


  struct __result_of_other_impl
  {
    template<typename _Fn, typename... _Args>
      static __result_of_success<decltype(
      std::declval<_Fn>()(std::declval<_Args>()...)
      ), __invoke_other> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _Functor, typename... _ArgTypes>
    struct __result_of_impl<false, false, _Functor, _ArgTypes...>
    : private __result_of_other_impl
    {
      typedef decltype(_S_test<_Functor, _ArgTypes...>(0)) type;
    };


  template<typename _Functor, typename... _ArgTypes>
    struct __invoke_result
    : public __result_of_impl<
        is_member_object_pointer<
          typename remove_reference<_Functor>::type
        >::value,
        is_member_function_pointer<
          typename remove_reference<_Functor>::type
        >::value,
 _Functor, _ArgTypes...
      >::type
    { };

  template<typename _Functor, typename... _ArgTypes>
    struct result_of<_Functor(_ArgTypes...)>
    : public __invoke_result<_Functor, _ArgTypes...>
    { };



  template<size_t _Len, size_t _Align =
     __alignof__(typename __aligned_storage_msa<_Len>::__type)>
    using aligned_storage_t = typename aligned_storage<_Len, _Align>::type;

  template <size_t _Len, typename... _Types>
    using aligned_union_t = typename aligned_union<_Len, _Types...>::type;


  template<typename _Tp>
    using decay_t = typename decay<_Tp>::type;


  template<bool _Cond, typename _Tp = void>
    using enable_if_t = typename enable_if<_Cond, _Tp>::type;


  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    using conditional_t = typename conditional<_Cond, _Iftrue, _Iffalse>::type;


  template<typename... _Tp>
    using common_type_t = typename common_type<_Tp...>::type;


  template<typename _Tp>
    using underlying_type_t = typename underlying_type<_Tp>::type;


  template<typename _Tp>
    using result_of_t = typename result_of<_Tp>::type;





  template<typename...> using void_t = void;



  template<typename _Default, typename _AlwaysVoid,
    template<typename...> class _Op, typename... _Args>
    struct __detector
    {
      using value_t = false_type;
      using type = _Default;
    };


  template<typename _Default, template<typename...> class _Op,
     typename... _Args>
    struct __detector<_Default, __void_t<_Op<_Args...>>, _Op, _Args...>
    {
      using value_t = true_type;
      using type = _Op<_Args...>;
    };


  template<typename _Default, template<typename...> class _Op,
    typename... _Args>
    using __detected_or = __detector<_Default, void, _Op, _Args...>;


  template<typename _Default, template<typename...> class _Op,
    typename... _Args>
    using __detected_or_t
      = typename __detected_or<_Default, _Op, _Args...>::type;
# 2624 "/usr/include/c++/10.2.0/type_traits" 3
  template <typename _Tp>
    struct __is_swappable;

  template <typename _Tp>
    struct __is_nothrow_swappable;

  template<typename... _Elements>
    class tuple;

  template<typename>
    struct __is_tuple_like_impl : false_type
    { };

  template<typename... _Tps>
    struct __is_tuple_like_impl<tuple<_Tps...>> : true_type
    { };


  template<typename _Tp>
    struct __is_tuple_like
    : public __is_tuple_like_impl<__remove_cvref_t<_Tp>>::type
    { };

  template<typename _Tp>
   
    inline
    _Require<__not_<__is_tuple_like<_Tp>>,
      is_move_constructible<_Tp>,
      is_move_assignable<_Tp>>
    swap(_Tp&, _Tp&)
    noexcept(__and_<is_nothrow_move_constructible<_Tp>,
             is_nothrow_move_assignable<_Tp>>::value);

  template<typename _Tp, size_t _Nm>
   
    inline
    __enable_if_t<__is_swappable<_Tp>::value>
    swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])
    noexcept(__is_nothrow_swappable<_Tp>::value);

  namespace __swappable_details {
    using std::swap;

    struct __do_is_swappable_impl
    {
      template<typename _Tp, typename
               = decltype(swap(std::declval<_Tp&>(), std::declval<_Tp&>()))>
        static true_type __test(int);

      template<typename>
        static false_type __test(...);
    };

    struct __do_is_nothrow_swappable_impl
    {
      template<typename _Tp>
        static __bool_constant<
          noexcept(swap(std::declval<_Tp&>(), std::declval<_Tp&>()))
        > __test(int);

      template<typename>
        static false_type __test(...);
    };

  }

  template<typename _Tp>
    struct __is_swappable_impl
    : public __swappable_details::__do_is_swappable_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp>
    struct __is_nothrow_swappable_impl
    : public __swappable_details::__do_is_nothrow_swappable_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp>
    struct __is_swappable
    : public __is_swappable_impl<_Tp>::type
    { };

  template<typename _Tp>
    struct __is_nothrow_swappable
    : public __is_nothrow_swappable_impl<_Tp>::type
    { };






  template<typename _Tp>
    struct is_swappable
    : public __is_swappable_impl<_Tp>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };


  template<typename _Tp>
    struct is_nothrow_swappable
    : public __is_nothrow_swappable_impl<_Tp>::type
    {
      static_assert(std::__is_complete_or_unbounded(__type_identity<_Tp>{}),
 "template argument must be a complete class or an unbounded array");
    };



  template<typename _Tp>
    constexpr bool is_swappable_v =
      is_swappable<_Tp>::value;


  template<typename _Tp>
    constexpr bool is_nothrow_swappable_v =
      is_nothrow_swappable<_Tp>::value;


  namespace __swappable_with_details {
    using std::swap;

    struct __do_is_swappable_with_impl
    {
      template<typename _Tp, typename _Up, typename
               = decltype(swap(std::declval<_Tp>(), std::declval<_Up>())),
               typename
               = decltype(swap(std::declval<_Up>(), std::declval<_Tp>()))>
        static true_type __test(int);

      template<typename, typename>
        static false_type __test(...);
    };

    struct __do_is_nothrow_swappable_with_impl
    {
      template<typename _Tp, typename _Up>
        static __bool_constant<
          noexcept(swap(std::declval<_Tp>(), std::declval<_Up>()))
          &&
          noexcept(swap(std::declval<_Up>(), std::declval<_Tp>()))
        > __test(int);

      template<typename, typename>
        static false_type __test(...);
    };

  }

  template<typename _Tp, typename _Up>
    struct __is_swappable_with_impl
    : public __swappable_with_details::__do_is_swappable_with_impl
    {
      typedef decltype(__test<_Tp, _Up>(0)) type;
    };


  template<typename _Tp>
    struct __is_swappable_with_impl<_Tp&, _Tp&>
    : public __swappable_details::__do_is_swappable_impl
    {
      typedef decltype(__test<_Tp&>(0)) type;
    };

  template<typename _Tp, typename _Up>
    struct __is_nothrow_swappable_with_impl
    : public __swappable_with_details::__do_is_nothrow_swappable_with_impl
    {
      typedef decltype(__test<_Tp, _Up>(0)) type;
    };


  template<typename _Tp>
    struct __is_nothrow_swappable_with_impl<_Tp&, _Tp&>
    : public __swappable_details::__do_is_nothrow_swappable_impl
    {
      typedef decltype(__test<_Tp&>(0)) type;
    };


  template<typename _Tp, typename _Up>
    struct is_swappable_with
    : public __is_swappable_with_impl<_Tp, _Up>::type
    { };


  template<typename _Tp, typename _Up>
    struct is_nothrow_swappable_with
    : public __is_nothrow_swappable_with_impl<_Tp, _Up>::type
    { };



  template<typename _Tp, typename _Up>
    constexpr bool is_swappable_with_v =
      is_swappable_with<_Tp, _Up>::value;


  template<typename _Tp, typename _Up>
    constexpr bool is_nothrow_swappable_with_v =
      is_nothrow_swappable_with<_Tp, _Up>::value;







  template<typename _Result, typename _Ret,
    bool = is_void<_Ret>::value, typename = void>
    struct __is_invocable_impl : false_type { };


  template<typename _Result, typename _Ret>
    struct __is_invocable_impl<_Result, _Ret,
                                true,
          __void_t<typename _Result::type>>
    : true_type
    { };

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wctor-dtor-privacy"

  template<typename _Result, typename _Ret>
    struct __is_invocable_impl<_Result, _Ret,
                                false,
          __void_t<typename _Result::type>>
    {
    private:


      static typename _Result::type _S_get();

      template<typename _Tp>
 static void _S_conv(_Tp);


      template<typename _Tp, typename = decltype(_S_conv<_Tp>(_S_get()))>
 static true_type
 _S_test(int);

      template<typename _Tp>
 static false_type
 _S_test(...);

    public:
      using type = decltype(_S_test<_Ret>(1));
    };
#pragma GCC diagnostic pop

  template<typename _Fn, typename... _ArgTypes>
    struct __is_invocable
    : __is_invocable_impl<__invoke_result<_Fn, _ArgTypes...>, void>::type
    { };

  template<typename _Fn, typename _Tp, typename... _Args>
    constexpr bool __call_is_nt(__invoke_memfun_ref)
    {
      using _Up = typename __inv_unwrap<_Tp>::type;
      return noexcept((std::declval<_Up>().*std::declval<_Fn>())(
     std::declval<_Args>()...));
    }

  template<typename _Fn, typename _Tp, typename... _Args>
    constexpr bool __call_is_nt(__invoke_memfun_deref)
    {
      return noexcept(((*std::declval<_Tp>()).*std::declval<_Fn>())(
     std::declval<_Args>()...));
    }

  template<typename _Fn, typename _Tp>
    constexpr bool __call_is_nt(__invoke_memobj_ref)
    {
      using _Up = typename __inv_unwrap<_Tp>::type;
      return noexcept(std::declval<_Up>().*std::declval<_Fn>());
    }

  template<typename _Fn, typename _Tp>
    constexpr bool __call_is_nt(__invoke_memobj_deref)
    {
      return noexcept((*std::declval<_Tp>()).*std::declval<_Fn>());
    }

  template<typename _Fn, typename... _Args>
    constexpr bool __call_is_nt(__invoke_other)
    {
      return noexcept(std::declval<_Fn>()(std::declval<_Args>()...));
    }

  template<typename _Result, typename _Fn, typename... _Args>
    struct __call_is_nothrow
    : __bool_constant<
 std::__call_is_nt<_Fn, _Args...>(typename _Result::__invoke_type{})
      >
    { };

  template<typename _Fn, typename... _Args>
    using __call_is_nothrow_
      = __call_is_nothrow<__invoke_result<_Fn, _Args...>, _Fn, _Args...>;


  template<typename _Fn, typename... _Args>
    struct __is_nothrow_invocable
    : __and_<__is_invocable<_Fn, _Args...>,
             __call_is_nothrow_<_Fn, _Args...>>::type
    { };

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wctor-dtor-privacy"
  struct __nonesuchbase {};
  struct __nonesuch : private __nonesuchbase {
    ~__nonesuch() = delete;
    __nonesuch(__nonesuch const&) = delete;
    void operator=(__nonesuch const&) = delete;
  };
#pragma GCC diagnostic pop
# 3455 "/usr/include/c++/10.2.0/type_traits" 3

}
# 21 "/usr/include/opencascade/Standard_Std.hxx" 2




# 24 "/usr/include/opencascade/Standard_Std.hxx"
namespace opencascade
{





  namespace std
  {

    using namespace ::std;
# 67 "/usr/include/opencascade/Standard_Std.hxx"
  }


  template <class T1, class T2, class Dummy = void>
  struct is_base_but_not_same : opencascade::std::is_base_of<T1, T2>
  {
  };



  template <class T1, class T2>
  struct is_base_but_not_same<T1,
                              T2,
                              typename opencascade::std::enable_if<opencascade::std::is_same<T1, T2>::value>::type>
  : opencascade::std::false_type
  {
  };



  template <typename TheInteger>
  struct is_integer : std::integral_constant<bool,
                                             opencascade::std::is_integral<TheInteger>::value
                                               && !opencascade::std::is_same<TheInteger, bool>::value>
  {
  };





  template <typename TheType>
  struct disable_deduction
  {
    typedef TheType type;
  };

}
# 19 "/usr/include/opencascade/Standard_Integer.hxx" 2
# 1 "/usr/include/opencascade/Standard_TypeDef.hxx" 1
# 18 "/usr/include/opencascade/Standard_TypeDef.hxx"
# 1 "/usr/include/c++/10.2.0/cstddef" 1 3
# 42 "/usr/include/c++/10.2.0/cstddef" 3
       
# 43 "/usr/include/c++/10.2.0/cstddef" 3







# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/include/stddef.h" 1 3 4
# 143 "/usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/include/stddef.h" 3 4

# 143 "/usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/include/stddef.h" 3 4
typedef long int ptrdiff_t;
# 209 "/usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/include/stddef.h" 3 4
typedef long unsigned int size_t;
# 415 "/usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/include/stddef.h" 3 4
typedef struct {
  long long __max_align_ll __attribute__((__aligned__(__alignof__(long long))));
  long double __max_align_ld __attribute__((__aligned__(__alignof__(long double))));
# 426 "/usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/include/stddef.h" 3 4
} max_align_t;






  typedef decltype(nullptr) nullptr_t;
# 51 "/usr/include/c++/10.2.0/cstddef" 2 3

extern "C++"
{

namespace std
{

  using ::max_align_t;
}
# 179 "/usr/include/c++/10.2.0/cstddef" 3
}
# 19 "/usr/include/opencascade/Standard_TypeDef.hxx" 2
# 1 "/usr/include/c++/10.2.0/ctime" 1 3
# 39 "/usr/include/c++/10.2.0/ctime" 3
       
# 40 "/usr/include/c++/10.2.0/ctime" 3


# 1 "/usr/include/time.h" 1 3 4
# 29 "/usr/include/time.h" 3 4
# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/include/stddef.h" 1 3 4
# 30 "/usr/include/time.h" 2 3 4



# 1 "/usr/include/bits/time.h" 1 3 4
# 26 "/usr/include/bits/time.h" 3 4
# 1 "/usr/include/bits/types.h" 1 3 4
# 27 "/usr/include/bits/types.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 28 "/usr/include/bits/types.h" 2 3 4
# 1 "/usr/include/bits/timesize.h" 1 3 4
# 29 "/usr/include/bits/types.h" 2 3 4


typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;

typedef signed long int __int64_t;
typedef unsigned long int __uint64_t;






typedef __int8_t __int_least8_t;
typedef __uint8_t __uint_least8_t;
typedef __int16_t __int_least16_t;
typedef __uint16_t __uint_least16_t;
typedef __int32_t __int_least32_t;
typedef __uint32_t __uint_least32_t;
typedef __int64_t __int_least64_t;
typedef __uint64_t __uint_least64_t;



typedef long int __quad_t;
typedef unsigned long int __u_quad_t;







typedef long int __intmax_t;
typedef unsigned long int __uintmax_t;
# 141 "/usr/include/bits/types.h" 3 4
# 1 "/usr/include/bits/typesizes.h" 1 3 4
# 142 "/usr/include/bits/types.h" 2 3 4
# 1 "/usr/include/bits/time64.h" 1 3 4
# 143 "/usr/include/bits/types.h" 2 3 4


typedef unsigned long int __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long int __ino_t;
typedef unsigned long int __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long int __nlink_t;
typedef long int __off_t;
typedef long int __off64_t;
typedef int __pid_t;
typedef struct { int __val[2]; } __fsid_t;
typedef long int __clock_t;
typedef unsigned long int __rlim_t;
typedef unsigned long int __rlim64_t;
typedef unsigned int __id_t;
typedef long int __time_t;
typedef unsigned int __useconds_t;
typedef long int __suseconds_t;
typedef long int __suseconds64_t;

typedef int __daddr_t;
typedef int __key_t;


typedef int __clockid_t;


typedef void * __timer_t;


typedef long int __blksize_t;




typedef long int __blkcnt_t;
typedef long int __blkcnt64_t;


typedef unsigned long int __fsblkcnt_t;
typedef unsigned long int __fsblkcnt64_t;


typedef unsigned long int __fsfilcnt_t;
typedef unsigned long int __fsfilcnt64_t;


typedef long int __fsword_t;

typedef long int __ssize_t;


typedef long int __syscall_slong_t;

typedef unsigned long int __syscall_ulong_t;



typedef __off64_t __loff_t;
typedef char *__caddr_t;


typedef long int __intptr_t;


typedef unsigned int __socklen_t;




typedef int __sig_atomic_t;
# 27 "/usr/include/bits/time.h" 2 3 4
# 73 "/usr/include/bits/time.h" 3 4
# 1 "/usr/include/bits/timex.h" 1 3 4
# 22 "/usr/include/bits/timex.h" 3 4
# 1 "/usr/include/bits/types/struct_timeval.h" 1 3 4







struct timeval
{
  __time_t tv_sec;
  __suseconds_t tv_usec;
};
# 23 "/usr/include/bits/timex.h" 2 3 4



struct timex
{
  unsigned int modes;
  __syscall_slong_t offset;
  __syscall_slong_t freq;
  __syscall_slong_t maxerror;
  __syscall_slong_t esterror;
  int status;
  __syscall_slong_t constant;
  __syscall_slong_t precision;
  __syscall_slong_t tolerance;
  struct timeval time;
  __syscall_slong_t tick;
  __syscall_slong_t ppsfreq;
  __syscall_slong_t jitter;
  int shift;
  __syscall_slong_t stabil;
  __syscall_slong_t jitcnt;
  __syscall_slong_t calcnt;
  __syscall_slong_t errcnt;
  __syscall_slong_t stbcnt;

  int tai;


  int :32; int :32; int :32; int :32;
  int :32; int :32; int :32; int :32;
  int :32; int :32; int :32;
};
# 74 "/usr/include/bits/time.h" 2 3 4

extern "C" {


extern int clock_adjtime (__clockid_t __clock_id, struct timex *__utx) noexcept (true);

}
# 34 "/usr/include/time.h" 2 3 4



# 1 "/usr/include/bits/types/clock_t.h" 1 3 4






typedef __clock_t clock_t;
# 38 "/usr/include/time.h" 2 3 4
# 1 "/usr/include/bits/types/time_t.h" 1 3 4






typedef __time_t time_t;
# 39 "/usr/include/time.h" 2 3 4
# 1 "/usr/include/bits/types/struct_tm.h" 1 3 4






struct tm
{
  int tm_sec;
  int tm_min;
  int tm_hour;
  int tm_mday;
  int tm_mon;
  int tm_year;
  int tm_wday;
  int tm_yday;
  int tm_isdst;


  long int tm_gmtoff;
  const char *tm_zone;




};
# 40 "/usr/include/time.h" 2 3 4


# 1 "/usr/include/bits/types/struct_timespec.h" 1 3 4





# 1 "/usr/include/bits/endian.h" 1 3 4
# 35 "/usr/include/bits/endian.h" 3 4
# 1 "/usr/include/bits/endianness.h" 1 3 4
# 36 "/usr/include/bits/endian.h" 2 3 4
# 7 "/usr/include/bits/types/struct_timespec.h" 2 3 4



struct timespec
{
  __time_t tv_sec;



  __syscall_slong_t tv_nsec;
# 26 "/usr/include/bits/types/struct_timespec.h" 3 4
};
# 43 "/usr/include/time.h" 2 3 4



# 1 "/usr/include/bits/types/clockid_t.h" 1 3 4






typedef __clockid_t clockid_t;
# 47 "/usr/include/time.h" 2 3 4
# 1 "/usr/include/bits/types/timer_t.h" 1 3 4






typedef __timer_t timer_t;
# 48 "/usr/include/time.h" 2 3 4
# 1 "/usr/include/bits/types/struct_itimerspec.h" 1 3 4







struct itimerspec
  {
    struct timespec it_interval;
    struct timespec it_value;
  };
# 49 "/usr/include/time.h" 2 3 4
struct sigevent;




typedef __pid_t pid_t;





# 1 "/usr/include/bits/types/locale_t.h" 1 3 4
# 22 "/usr/include/bits/types/locale_t.h" 3 4
# 1 "/usr/include/bits/types/__locale_t.h" 1 3 4
# 28 "/usr/include/bits/types/__locale_t.h" 3 4
struct __locale_struct
{

  struct __locale_data *__locales[13];


  const unsigned short int *__ctype_b;
  const int *__ctype_tolower;
  const int *__ctype_toupper;


  const char *__names[13];
};

typedef struct __locale_struct *__locale_t;
# 23 "/usr/include/bits/types/locale_t.h" 2 3 4

typedef __locale_t locale_t;
# 61 "/usr/include/time.h" 2 3 4







extern "C" {



extern clock_t clock (void) noexcept (true);


extern time_t time (time_t *__timer) noexcept (true);


extern double difftime (time_t __time1, time_t __time0)
     noexcept (true) __attribute__ ((__const__));


extern time_t mktime (struct tm *__tp) noexcept (true);





extern size_t strftime (char *__restrict __s, size_t __maxsize,
   const char *__restrict __format,
   const struct tm *__restrict __tp) noexcept (true);




extern char *strptime (const char *__restrict __s,
         const char *__restrict __fmt, struct tm *__tp)
     noexcept (true);






extern size_t strftime_l (char *__restrict __s, size_t __maxsize,
     const char *__restrict __format,
     const struct tm *__restrict __tp,
     locale_t __loc) noexcept (true);



extern char *strptime_l (const char *__restrict __s,
    const char *__restrict __fmt, struct tm *__tp,
    locale_t __loc) noexcept (true);





extern struct tm *gmtime (const time_t *__timer) noexcept (true);



extern struct tm *localtime (const time_t *__timer) noexcept (true);




extern struct tm *gmtime_r (const time_t *__restrict __timer,
       struct tm *__restrict __tp) noexcept (true);



extern struct tm *localtime_r (const time_t *__restrict __timer,
          struct tm *__restrict __tp) noexcept (true);




extern char *asctime (const struct tm *__tp) noexcept (true);


extern char *ctime (const time_t *__timer) noexcept (true);






extern char *asctime_r (const struct tm *__restrict __tp,
   char *__restrict __buf) noexcept (true);


extern char *ctime_r (const time_t *__restrict __timer,
        char *__restrict __buf) noexcept (true);




extern char *__tzname[2];
extern int __daylight;
extern long int __timezone;




extern char *tzname[2];



extern void tzset (void) noexcept (true);



extern int daylight;
extern long int timezone;
# 190 "/usr/include/time.h" 3 4
extern time_t timegm (struct tm *__tp) noexcept (true);


extern time_t timelocal (struct tm *__tp) noexcept (true);


extern int dysize (int __year) noexcept (true) __attribute__ ((__const__));
# 205 "/usr/include/time.h" 3 4
extern int nanosleep (const struct timespec *__requested_time,
        struct timespec *__remaining);



extern int clock_getres (clockid_t __clock_id, struct timespec *__res) noexcept (true);


extern int clock_gettime (clockid_t __clock_id, struct timespec *__tp) noexcept (true);


extern int clock_settime (clockid_t __clock_id, const struct timespec *__tp)
     noexcept (true);






extern int clock_nanosleep (clockid_t __clock_id, int __flags,
       const struct timespec *__req,
       struct timespec *__rem);


extern int clock_getcpuclockid (pid_t __pid, clockid_t *__clock_id) noexcept (true);




extern int timer_create (clockid_t __clock_id,
    struct sigevent *__restrict __evp,
    timer_t *__restrict __timerid) noexcept (true);


extern int timer_delete (timer_t __timerid) noexcept (true);


extern int timer_settime (timer_t __timerid, int __flags,
     const struct itimerspec *__restrict __value,
     struct itimerspec *__restrict __ovalue) noexcept (true);


extern int timer_gettime (timer_t __timerid, struct itimerspec *__value)
     noexcept (true);


extern int timer_getoverrun (timer_t __timerid) noexcept (true);





extern int timespec_get (struct timespec *__ts, int __base)
     noexcept (true) __attribute__ ((__nonnull__ (1)));
# 274 "/usr/include/time.h" 3 4
extern int getdate_err;
# 283 "/usr/include/time.h" 3 4
extern struct tm *getdate (const char *__string);
# 297 "/usr/include/time.h" 3 4
extern int getdate_r (const char *__restrict __string,
        struct tm *__restrict __resbufp);


}
# 43 "/usr/include/c++/10.2.0/ctime" 2 3
# 58 "/usr/include/c++/10.2.0/ctime" 3
namespace std
{
  using ::clock_t;
  using ::time_t;
  using ::tm;

  using ::clock;
  using ::difftime;
  using ::mktime;
  using ::time;
  using ::asctime;
  using ::ctime;
  using ::gmtime;
  using ::localtime;
  using ::strftime;
}
# 20 "/usr/include/opencascade/Standard_TypeDef.hxx" 2
# 34 "/usr/include/opencascade/Standard_TypeDef.hxx"
# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/include/stdint.h" 1 3 4
# 9 "/usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/include/stdint.h" 3 4
# 1 "/usr/include/stdint.h" 1 3 4
# 26 "/usr/include/stdint.h" 3 4
# 1 "/usr/include/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/stdint.h" 2 3 4

# 1 "/usr/include/bits/wchar.h" 1 3 4
# 29 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 30 "/usr/include/stdint.h" 2 3 4




# 1 "/usr/include/bits/stdint-intn.h" 1 3 4
# 24 "/usr/include/bits/stdint-intn.h" 3 4
typedef __int8_t int8_t;
typedef __int16_t int16_t;
typedef __int32_t int32_t;
typedef __int64_t int64_t;
# 35 "/usr/include/stdint.h" 2 3 4


# 1 "/usr/include/bits/stdint-uintn.h" 1 3 4
# 24 "/usr/include/bits/stdint-uintn.h" 3 4
typedef __uint8_t uint8_t;
typedef __uint16_t uint16_t;
typedef __uint32_t uint32_t;
typedef __uint64_t uint64_t;
# 38 "/usr/include/stdint.h" 2 3 4





typedef __int_least8_t int_least8_t;
typedef __int_least16_t int_least16_t;
typedef __int_least32_t int_least32_t;
typedef __int_least64_t int_least64_t;


typedef __uint_least8_t uint_least8_t;
typedef __uint_least16_t uint_least16_t;
typedef __uint_least32_t uint_least32_t;
typedef __uint_least64_t uint_least64_t;





typedef signed char int_fast8_t;

typedef long int int_fast16_t;
typedef long int int_fast32_t;
typedef long int int_fast64_t;
# 71 "/usr/include/stdint.h" 3 4
typedef unsigned char uint_fast8_t;

typedef unsigned long int uint_fast16_t;
typedef unsigned long int uint_fast32_t;
typedef unsigned long int uint_fast64_t;
# 87 "/usr/include/stdint.h" 3 4
typedef long int intptr_t;


typedef unsigned long int uintptr_t;
# 101 "/usr/include/stdint.h" 3 4
typedef __intmax_t intmax_t;
typedef __uintmax_t uintmax_t;
# 10 "/usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/include/stdint.h" 2 3 4
# 35 "/usr/include/opencascade/Standard_TypeDef.hxx" 2
# 61 "/usr/include/opencascade/Standard_TypeDef.hxx"
# 1 "/usr/include/inttypes.h" 1 3 4
# 266 "/usr/include/inttypes.h" 3 4
extern "C" {




typedef struct
  {
    long int quot;
    long int rem;
  } imaxdiv_t;
# 290 "/usr/include/inttypes.h" 3 4
extern intmax_t imaxabs (intmax_t __n) noexcept (true) __attribute__ ((__const__));


extern imaxdiv_t imaxdiv (intmax_t __numer, intmax_t __denom)
      noexcept (true) __attribute__ ((__const__));


extern intmax_t strtoimax (const char *__restrict __nptr,
      char **__restrict __endptr, int __base) noexcept (true);


extern uintmax_t strtoumax (const char *__restrict __nptr,
       char ** __restrict __endptr, int __base) noexcept (true);


extern intmax_t wcstoimax (const wchar_t *__restrict __nptr,
      wchar_t **__restrict __endptr, int __base)
     noexcept (true);


extern uintmax_t wcstoumax (const wchar_t *__restrict __nptr,
       wchar_t ** __restrict __endptr, int __base)
     noexcept (true);

}
# 62 "/usr/include/opencascade/Standard_TypeDef.hxx" 2





# 1 "/usr/include/opencascade/Standard_Macro.hxx" 1
# 68 "/usr/include/opencascade/Standard_TypeDef.hxx" 2


# 69 "/usr/include/opencascade/Standard_TypeDef.hxx"
typedef int Standard_Integer;
typedef double Standard_Real;
typedef bool Standard_Boolean;
typedef float Standard_ShortReal;
typedef char Standard_Character;
typedef unsigned char Standard_Byte;
typedef void* Standard_Address;
typedef size_t Standard_Size;
typedef std::time_t Standard_Time;


typedef char Standard_Utf8Char;
typedef unsigned char Standard_Utf8UChar;






typedef char16_t Standard_ExtCharacter;
typedef char16_t Standard_Utf16Char;
typedef char32_t Standard_Utf32Char;

typedef wchar_t Standard_WideChar;


typedef const Standard_Character* Standard_CString;
typedef const Standard_ExtCharacter* Standard_ExtString;
# 20 "/usr/include/opencascade/Standard_Integer.hxx" 2
# 1 "/usr/include/opencascade/Standard_values.h" 1
# 23 "/usr/include/opencascade/Standard_values.h"
# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/include-fixed/limits.h" 1 3 4
# 34 "/usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/include-fixed/limits.h" 3 4
# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/include-fixed/syslimits.h" 1 3 4






# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/include-fixed/limits.h" 1 3 4
# 195 "/usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/include-fixed/limits.h" 3 4
# 1 "/usr/include/limits.h" 1 3 4
# 26 "/usr/include/limits.h" 3 4
# 1 "/usr/include/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/limits.h" 2 3 4
# 195 "/usr/include/limits.h" 3 4
# 1 "/usr/include/bits/posix1_lim.h" 1 3 4
# 27 "/usr/include/bits/posix1_lim.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 28 "/usr/include/bits/posix1_lim.h" 2 3 4
# 161 "/usr/include/bits/posix1_lim.h" 3 4
# 1 "/usr/include/bits/local_lim.h" 1 3 4
# 38 "/usr/include/bits/local_lim.h" 3 4
# 1 "/usr/include/linux/limits.h" 1 3 4
# 39 "/usr/include/bits/local_lim.h" 2 3 4
# 162 "/usr/include/bits/posix1_lim.h" 2 3 4
# 196 "/usr/include/limits.h" 2 3 4



# 1 "/usr/include/bits/posix2_lim.h" 1 3 4
# 200 "/usr/include/limits.h" 2 3 4



# 1 "/usr/include/bits/xopen_lim.h" 1 3 4
# 64 "/usr/include/bits/xopen_lim.h" 3 4
# 1 "/usr/include/bits/uio_lim.h" 1 3 4
# 65 "/usr/include/bits/xopen_lim.h" 2 3 4
# 204 "/usr/include/limits.h" 2 3 4
# 196 "/usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/include-fixed/limits.h" 2 3 4
# 8 "/usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/include-fixed/syslimits.h" 2 3 4
# 35 "/usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/include-fixed/limits.h" 2 3 4
# 24 "/usr/include/opencascade/Standard_values.h" 2
# 21 "/usr/include/opencascade/Standard_Integer.hxx" 2
# 29 "/usr/include/opencascade/Standard_Integer.hxx"
inline Standard_Integer Abs (const Standard_Integer Value)
{
  return Value >= 0 ? Value : -Value;
}




inline Standard_Boolean IsEven (const Standard_Integer Value)
{ return Value % 2 == 0; }





inline Standard_Boolean IsOdd (const Standard_Integer Value)
{ return Value % 2 == 1; }




inline Standard_Integer Max (const Standard_Integer Val1,
         const Standard_Integer Val2)
{
  return Val1 >= Val2 ? Val1 : Val2;
}




inline Standard_Integer Min (const Standard_Integer Val1,
         const Standard_Integer Val2)
{
  return Val1 <= Val2 ? Val1 : Val2;
}




inline Standard_Integer Modulus (const Standard_Integer Value,
      const Standard_Integer Divisor)
{ return Value % Divisor; }




inline Standard_Integer Square(const Standard_Integer Value)
{ return Value * Value; }




inline Standard_Integer IntegerFirst()
{ return 
# 82 "/usr/include/opencascade/Standard_Integer.hxx" 3 4
        (-0x7fffffff - 1)
# 82 "/usr/include/opencascade/Standard_Integer.hxx"
               ; }




inline Standard_Integer IntegerLast()
{ return 0x7fffffff; }




inline Standard_Integer IntegerSize()
{ return (8 * sizeof(Standard_Integer)); }
# 103 "/usr/include/opencascade/Standard_Integer.hxx"
template <typename TheInteger>
typename opencascade::std::enable_if<opencascade::is_integer<TheInteger>::value, Standard_Integer>::type
IntegerHashCode (const TheInteger theValue,
                 const typename opencascade::disable_deduction<TheInteger>::type theMask,
                 const Standard_Integer theUpperBound)
{
  return static_cast<Standard_Integer> ((theValue & theMask) % theUpperBound + 1);
}





inline Standard_Integer HashCode (const Standard_Integer theValue,
                                  const Standard_Integer theUpperBound)
{

  return IntegerHashCode(theValue, IntegerLast(), theUpperBound);
}




inline Standard_Boolean IsEqual (const Standard_Integer theOne,
                                 const Standard_Integer theTwo)
{
  return theOne == theTwo;
}





inline Standard_Integer HashCode (const unsigned int theValue, const Standard_Integer theUpperBound)
{
  return ::HashCode (static_cast<Standard_Integer> (theValue), theUpperBound);
}





inline Standard_Integer HashCode (const long long int theValue, const Standard_Integer theUpperBound)
{
  return IntegerHashCode(theValue, 0x7fffffffffffffff, theUpperBound);
}
# 159 "/usr/include/opencascade/Standard_Integer.hxx"
template <typename TheUtf32Char>
typename opencascade::std::enable_if<!opencascade::std::is_same<Standard_Utf32Char, unsigned int>::value
                                       && opencascade::std::is_same<TheUtf32Char, Standard_Utf32Char>::value,
                                     Standard_Integer>::type
HashCode (const TheUtf32Char theValue, const Standard_Integer theUpperBound)
{
  return IntegerHashCode (theValue, IntegerLast(), theUpperBound);
}




inline Standard_Boolean IsEqual (const Standard_Utf32Char theOne,
                                 const Standard_Utf32Char theTwo)
{
  return theOne == theTwo;
}
# 19 "/usr/include/opencascade/Standard_Address.hxx" 2





inline Standard_Integer HashCode (const void* const thePointer, const Standard_Integer theUpperBound)
{
  union
  {
    const void* L;
    Standard_Integer I[2];
  } U;

  U.I[0] = 0;
  U.I[1] = 0;
  U.L = thePointer;

  return HashCode (U.I[0] ^ U.I[1], theUpperBound);
}





inline Standard_Boolean IsEqual(const Standard_Address One
          ,const Standard_Address Two)
{ return One == Two; }
# 22 "/usr/include/opencascade/Standard.hxx" 2
# 1 "/usr/include/opencascade/Standard_Size.hxx" 1
# 30 "/usr/include/opencascade/Standard_Size.hxx"
template <typename TheSize>
typename opencascade::std::enable_if<!opencascade::std::is_same<Standard_Size, unsigned int>::value
                                       && opencascade::std::is_same<TheSize, Standard_Size>::value,
                                     Standard_Integer>::type
HashCode (const TheSize theValue, const Standard_Integer theUpperBound)
{
  Standard_Size aKey = ~theValue + (theValue << 18);
  aKey ^= (aKey >> 31);
  aKey *= 21;
  aKey ^= (aKey >> 11);
  aKey += (aKey << 6);
  aKey ^= (aKey >> 22);
  return IntegerHashCode(aKey, IntegerLast(), theUpperBound);
}




inline Standard_Boolean IsEqual(const Standard_Size One,
                                const Standard_Size Two)
{
  return One == Two;
}
# 23 "/usr/include/opencascade/Standard.hxx" 2


class Standard_ErrorHandler;
class Standard_Persistent;
class Standard_Transient;
class Standard_Failure;




class Standard
{
public:

  void* operator new (size_t theSize) { return Standard::Allocate (theSize); } void operator delete (void* theAddress) { Standard::Free (theAddress); } void* operator new[] (size_t theSize) { return Standard::Allocate (theSize); } void operator delete[] (void* theAddress) { Standard::Free (theAddress); } void* operator new (size_t, void* theAddress) { return theAddress; } void operator delete (void*, void*) { }




  static Standard_Address Allocate (const Standard_Size aSize);



  static void Free (const Standard_Address thePtr);



  template <typename T>
  static inline void Free (T*& thePtr)
  {
    Free ((void*)thePtr);
    thePtr = 0;
  }




  static Standard_Address Reallocate (const Standard_Address aStorage, const Standard_Size aNewSize);






  static Standard_Address AllocateAligned (const Standard_Size theSize, const Standard_Size theAlign);



  static void FreeAligned (const Standard_Address thePtrAligned);



  template <typename T>
  static inline void FreeAligned (T*& thePtrAligned)
  {
    FreeAligned ((void* )thePtrAligned);
    thePtrAligned = 0;
  }




  static Standard_Integer Purge();

};



# 1 "/usr/include/opencascade/Standard_Transient.hxx" 1
# 18 "/usr/include/opencascade/Standard_Transient.hxx"
# 1 "/usr/include/opencascade/Standard.hxx" 1
# 19 "/usr/include/opencascade/Standard_Transient.hxx" 2

# 1 "/usr/include/opencascade/Standard_PrimitiveTypes.hxx" 1
# 18 "/usr/include/opencascade/Standard_PrimitiveTypes.hxx"
# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/include/stddef.h" 1 3 4
# 19 "/usr/include/opencascade/Standard_PrimitiveTypes.hxx" 2
# 1 "/usr/include/c++/10.2.0/stdlib.h" 1 3
# 36 "/usr/include/c++/10.2.0/stdlib.h" 3
# 1 "/usr/include/c++/10.2.0/cstdlib" 1 3
# 39 "/usr/include/c++/10.2.0/cstdlib" 3
       
# 40 "/usr/include/c++/10.2.0/cstdlib" 3
# 75 "/usr/include/c++/10.2.0/cstdlib" 3
# 1 "/usr/include/stdlib.h" 1 3 4
# 25 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/bits/libc-header-start.h" 1 3 4
# 26 "/usr/include/stdlib.h" 2 3 4





# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/include/stddef.h" 1 3 4
# 32 "/usr/include/stdlib.h" 2 3 4


# 33 "/usr/include/stdlib.h" 3 4
extern "C" {





# 1 "/usr/include/bits/waitflags.h" 1 3 4
# 40 "/usr/include/stdlib.h" 2 3 4
# 1 "/usr/include/bits/waitstatus.h" 1 3 4
# 41 "/usr/include/stdlib.h" 2 3 4
# 55 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/bits/floatn.h" 1 3 4
# 74 "/usr/include/bits/floatn.h" 3 4
typedef _Complex float __cfloat128 __attribute__ ((__mode__ (__TC__)));
# 86 "/usr/include/bits/floatn.h" 3 4
typedef __float128 _Float128;
# 119 "/usr/include/bits/floatn.h" 3 4
# 1 "/usr/include/bits/floatn-common.h" 1 3 4
# 24 "/usr/include/bits/floatn-common.h" 3 4
# 1 "/usr/include/bits/long-double.h" 1 3 4
# 25 "/usr/include/bits/floatn-common.h" 2 3 4
# 214 "/usr/include/bits/floatn-common.h" 3 4
typedef float _Float32;
# 251 "/usr/include/bits/floatn-common.h" 3 4
typedef double _Float64;
# 268 "/usr/include/bits/floatn-common.h" 3 4
typedef double _Float32x;
# 285 "/usr/include/bits/floatn-common.h" 3 4
typedef long double _Float64x;
# 120 "/usr/include/bits/floatn.h" 2 3 4
# 56 "/usr/include/stdlib.h" 2 3 4


typedef struct
  {
    int quot;
    int rem;
  } div_t;



typedef struct
  {
    long int quot;
    long int rem;
  } ldiv_t;





__extension__ typedef struct
  {
    long long int quot;
    long long int rem;
  } lldiv_t;
# 97 "/usr/include/stdlib.h" 3 4
extern size_t __ctype_get_mb_cur_max (void) noexcept (true) ;



extern double atof (const char *__nptr)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern int atoi (const char *__nptr)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern long int atol (const char *__nptr)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;



__extension__ extern long long int atoll (const char *__nptr)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;



extern double strtod (const char *__restrict __nptr,
        char **__restrict __endptr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));



extern float strtof (const char *__restrict __nptr,
       char **__restrict __endptr) noexcept (true) __attribute__ ((__nonnull__ (1)));

extern long double strtold (const char *__restrict __nptr,
       char **__restrict __endptr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));
# 140 "/usr/include/stdlib.h" 3 4
extern _Float32 strtof32 (const char *__restrict __nptr,
     char **__restrict __endptr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));



extern _Float64 strtof64 (const char *__restrict __nptr,
     char **__restrict __endptr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));



extern _Float128 strtof128 (const char *__restrict __nptr,
       char **__restrict __endptr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));



extern _Float32x strtof32x (const char *__restrict __nptr,
       char **__restrict __endptr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));



extern _Float64x strtof64x (const char *__restrict __nptr,
       char **__restrict __endptr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));
# 176 "/usr/include/stdlib.h" 3 4
extern long int strtol (const char *__restrict __nptr,
   char **__restrict __endptr, int __base)
     noexcept (true) __attribute__ ((__nonnull__ (1)));

extern unsigned long int strtoul (const char *__restrict __nptr,
      char **__restrict __endptr, int __base)
     noexcept (true) __attribute__ ((__nonnull__ (1)));



__extension__
extern long long int strtoq (const char *__restrict __nptr,
        char **__restrict __endptr, int __base)
     noexcept (true) __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtouq (const char *__restrict __nptr,
           char **__restrict __endptr, int __base)
     noexcept (true) __attribute__ ((__nonnull__ (1)));




__extension__
extern long long int strtoll (const char *__restrict __nptr,
         char **__restrict __endptr, int __base)
     noexcept (true) __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtoull (const char *__restrict __nptr,
     char **__restrict __endptr, int __base)
     noexcept (true) __attribute__ ((__nonnull__ (1)));




extern int strfromd (char *__dest, size_t __size, const char *__format,
       double __f)
     noexcept (true) __attribute__ ((__nonnull__ (3)));

extern int strfromf (char *__dest, size_t __size, const char *__format,
       float __f)
     noexcept (true) __attribute__ ((__nonnull__ (3)));

extern int strfroml (char *__dest, size_t __size, const char *__format,
       long double __f)
     noexcept (true) __attribute__ ((__nonnull__ (3)));
# 232 "/usr/include/stdlib.h" 3 4
extern int strfromf32 (char *__dest, size_t __size, const char * __format,
         _Float32 __f)
     noexcept (true) __attribute__ ((__nonnull__ (3)));



extern int strfromf64 (char *__dest, size_t __size, const char * __format,
         _Float64 __f)
     noexcept (true) __attribute__ ((__nonnull__ (3)));



extern int strfromf128 (char *__dest, size_t __size, const char * __format,
   _Float128 __f)
     noexcept (true) __attribute__ ((__nonnull__ (3)));



extern int strfromf32x (char *__dest, size_t __size, const char * __format,
   _Float32x __f)
     noexcept (true) __attribute__ ((__nonnull__ (3)));



extern int strfromf64x (char *__dest, size_t __size, const char * __format,
   _Float64x __f)
     noexcept (true) __attribute__ ((__nonnull__ (3)));
# 274 "/usr/include/stdlib.h" 3 4
extern long int strtol_l (const char *__restrict __nptr,
     char **__restrict __endptr, int __base,
     locale_t __loc) noexcept (true) __attribute__ ((__nonnull__ (1, 4)));

extern unsigned long int strtoul_l (const char *__restrict __nptr,
        char **__restrict __endptr,
        int __base, locale_t __loc)
     noexcept (true) __attribute__ ((__nonnull__ (1, 4)));

__extension__
extern long long int strtoll_l (const char *__restrict __nptr,
    char **__restrict __endptr, int __base,
    locale_t __loc)
     noexcept (true) __attribute__ ((__nonnull__ (1, 4)));

__extension__
extern unsigned long long int strtoull_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       int __base, locale_t __loc)
     noexcept (true) __attribute__ ((__nonnull__ (1, 4)));

extern double strtod_l (const char *__restrict __nptr,
   char **__restrict __endptr, locale_t __loc)
     noexcept (true) __attribute__ ((__nonnull__ (1, 3)));

extern float strtof_l (const char *__restrict __nptr,
         char **__restrict __endptr, locale_t __loc)
     noexcept (true) __attribute__ ((__nonnull__ (1, 3)));

extern long double strtold_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     noexcept (true) __attribute__ ((__nonnull__ (1, 3)));
# 316 "/usr/include/stdlib.h" 3 4
extern _Float32 strtof32_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       locale_t __loc)
     noexcept (true) __attribute__ ((__nonnull__ (1, 3)));



extern _Float64 strtof64_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       locale_t __loc)
     noexcept (true) __attribute__ ((__nonnull__ (1, 3)));



extern _Float128 strtof128_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     noexcept (true) __attribute__ ((__nonnull__ (1, 3)));



extern _Float32x strtof32x_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     noexcept (true) __attribute__ ((__nonnull__ (1, 3)));



extern _Float64x strtof64x_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     noexcept (true) __attribute__ ((__nonnull__ (1, 3)));
# 385 "/usr/include/stdlib.h" 3 4
extern char *l64a (long int __n) noexcept (true) ;


extern long int a64l (const char *__s)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;




# 1 "/usr/include/sys/types.h" 1 3 4
# 27 "/usr/include/sys/types.h" 3 4
extern "C" {





typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;


typedef __loff_t loff_t;




typedef __ino_t ino_t;






typedef __ino64_t ino64_t;




typedef __dev_t dev_t;




typedef __gid_t gid_t;




typedef __mode_t mode_t;




typedef __nlink_t nlink_t;




typedef __uid_t uid_t;





typedef __off_t off_t;






typedef __off64_t off64_t;
# 103 "/usr/include/sys/types.h" 3 4
typedef __id_t id_t;




typedef __ssize_t ssize_t;





typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;





typedef __key_t key_t;
# 134 "/usr/include/sys/types.h" 3 4
typedef __useconds_t useconds_t;



typedef __suseconds_t suseconds_t;





# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/include/stddef.h" 1 3 4
# 145 "/usr/include/sys/types.h" 2 3 4



typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;







typedef __uint8_t u_int8_t;
typedef __uint16_t u_int16_t;
typedef __uint32_t u_int32_t;
typedef __uint64_t u_int64_t;


typedef int register_t __attribute__ ((__mode__ (__word__)));
# 176 "/usr/include/sys/types.h" 3 4
# 1 "/usr/include/endian.h" 1 3 4
# 35 "/usr/include/endian.h" 3 4
# 1 "/usr/include/bits/byteswap.h" 1 3 4
# 33 "/usr/include/bits/byteswap.h" 3 4
static __inline __uint16_t
__bswap_16 (__uint16_t __bsx)
{

  return __builtin_bswap16 (__bsx);



}






static __inline __uint32_t
__bswap_32 (__uint32_t __bsx)
{

  return __builtin_bswap32 (__bsx);



}
# 69 "/usr/include/bits/byteswap.h" 3 4
__extension__ static __inline __uint64_t
__bswap_64 (__uint64_t __bsx)
{

  return __builtin_bswap64 (__bsx);



}
# 36 "/usr/include/endian.h" 2 3 4
# 1 "/usr/include/bits/uintn-identity.h" 1 3 4
# 32 "/usr/include/bits/uintn-identity.h" 3 4
static __inline __uint16_t
__uint16_identity (__uint16_t __x)
{
  return __x;
}

static __inline __uint32_t
__uint32_identity (__uint32_t __x)
{
  return __x;
}

static __inline __uint64_t
__uint64_identity (__uint64_t __x)
{
  return __x;
}
# 37 "/usr/include/endian.h" 2 3 4
# 177 "/usr/include/sys/types.h" 2 3 4


# 1 "/usr/include/sys/select.h" 1 3 4
# 30 "/usr/include/sys/select.h" 3 4
# 1 "/usr/include/bits/select.h" 1 3 4
# 31 "/usr/include/sys/select.h" 2 3 4


# 1 "/usr/include/bits/types/sigset_t.h" 1 3 4



# 1 "/usr/include/bits/types/__sigset_t.h" 1 3 4




typedef struct
{
  unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
} __sigset_t;
# 5 "/usr/include/bits/types/sigset_t.h" 2 3 4


typedef __sigset_t sigset_t;
# 34 "/usr/include/sys/select.h" 2 3 4
# 49 "/usr/include/sys/select.h" 3 4
typedef long int __fd_mask;
# 59 "/usr/include/sys/select.h" 3 4
typedef struct
  {



    __fd_mask fds_bits[1024 / (8 * (int) sizeof (__fd_mask))];





  } fd_set;






typedef __fd_mask fd_mask;
# 91 "/usr/include/sys/select.h" 3 4
extern "C" {
# 101 "/usr/include/sys/select.h" 3 4
extern int select (int __nfds, fd_set *__restrict __readfds,
     fd_set *__restrict __writefds,
     fd_set *__restrict __exceptfds,
     struct timeval *__restrict __timeout);
# 113 "/usr/include/sys/select.h" 3 4
extern int pselect (int __nfds, fd_set *__restrict __readfds,
      fd_set *__restrict __writefds,
      fd_set *__restrict __exceptfds,
      const struct timespec *__restrict __timeout,
      const __sigset_t *__restrict __sigmask);
# 126 "/usr/include/sys/select.h" 3 4
}
# 180 "/usr/include/sys/types.h" 2 3 4





typedef __blksize_t blksize_t;






typedef __blkcnt_t blkcnt_t;



typedef __fsblkcnt_t fsblkcnt_t;



typedef __fsfilcnt_t fsfilcnt_t;
# 219 "/usr/include/sys/types.h" 3 4
typedef __blkcnt64_t blkcnt64_t;
typedef __fsblkcnt64_t fsblkcnt64_t;
typedef __fsfilcnt64_t fsfilcnt64_t;





# 1 "/usr/include/bits/pthreadtypes.h" 1 3 4
# 23 "/usr/include/bits/pthreadtypes.h" 3 4
# 1 "/usr/include/bits/thread-shared-types.h" 1 3 4
# 44 "/usr/include/bits/thread-shared-types.h" 3 4
# 1 "/usr/include/bits/pthreadtypes-arch.h" 1 3 4
# 21 "/usr/include/bits/pthreadtypes-arch.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 22 "/usr/include/bits/pthreadtypes-arch.h" 2 3 4
# 45 "/usr/include/bits/thread-shared-types.h" 2 3 4




typedef struct __pthread_internal_list
{
  struct __pthread_internal_list *__prev;
  struct __pthread_internal_list *__next;
} __pthread_list_t;

typedef struct __pthread_internal_slist
{
  struct __pthread_internal_slist *__next;
} __pthread_slist_t;
# 74 "/usr/include/bits/thread-shared-types.h" 3 4
# 1 "/usr/include/bits/struct_mutex.h" 1 3 4
# 22 "/usr/include/bits/struct_mutex.h" 3 4
struct __pthread_mutex_s
{
  int __lock;
  unsigned int __count;
  int __owner;

  unsigned int __nusers;



  int __kind;

  short __spins;
  short __elision;
  __pthread_list_t __list;
# 53 "/usr/include/bits/struct_mutex.h" 3 4
};
# 75 "/usr/include/bits/thread-shared-types.h" 2 3 4
# 87 "/usr/include/bits/thread-shared-types.h" 3 4
# 1 "/usr/include/bits/struct_rwlock.h" 1 3 4
# 23 "/usr/include/bits/struct_rwlock.h" 3 4
struct __pthread_rwlock_arch_t
{
  unsigned int __readers;
  unsigned int __writers;
  unsigned int __wrphase_futex;
  unsigned int __writers_futex;
  unsigned int __pad3;
  unsigned int __pad4;

  int __cur_writer;
  int __shared;
  signed char __rwelision;




  unsigned char __pad1[7];


  unsigned long int __pad2;


  unsigned int __flags;
# 55 "/usr/include/bits/struct_rwlock.h" 3 4
};
# 88 "/usr/include/bits/thread-shared-types.h" 2 3 4




struct __pthread_cond_s
{
  __extension__ union
  {
    __extension__ unsigned long long int __wseq;
    struct
    {
      unsigned int __low;
      unsigned int __high;
    } __wseq32;
  };
  __extension__ union
  {
    __extension__ unsigned long long int __g1_start;
    struct
    {
      unsigned int __low;
      unsigned int __high;
    } __g1_start32;
  };
  unsigned int __g_refs[2] ;
  unsigned int __g_size[2];
  unsigned int __g1_orig_size;
  unsigned int __wrefs;
  unsigned int __g_signals[2];
};

typedef unsigned int __tss_t;
typedef unsigned long int __thrd_t;

typedef struct
{
  int __data ;
} __once_flag;
# 24 "/usr/include/bits/pthreadtypes.h" 2 3 4



typedef unsigned long int pthread_t;




typedef union
{
  char __size[4];
  int __align;
} pthread_mutexattr_t;




typedef union
{
  char __size[4];
  int __align;
} pthread_condattr_t;



typedef unsigned int pthread_key_t;



typedef int pthread_once_t;


union pthread_attr_t
{
  char __size[56];
  long int __align;
};

typedef union pthread_attr_t pthread_attr_t;




typedef union
{
  struct __pthread_mutex_s __data;
  char __size[40];
  long int __align;
} pthread_mutex_t;


typedef union
{
  struct __pthread_cond_s __data;
  char __size[48];
  __extension__ long long int __align;
} pthread_cond_t;





typedef union
{
  struct __pthread_rwlock_arch_t __data;
  char __size[56];
  long int __align;
} pthread_rwlock_t;

typedef union
{
  char __size[8];
  long int __align;
} pthread_rwlockattr_t;





typedef volatile int pthread_spinlock_t;




typedef union
{
  char __size[32];
  long int __align;
} pthread_barrier_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_barrierattr_t;
# 228 "/usr/include/sys/types.h" 2 3 4


}
# 395 "/usr/include/stdlib.h" 2 3 4






extern long int random (void) noexcept (true);


extern void srandom (unsigned int __seed) noexcept (true);





extern char *initstate (unsigned int __seed, char *__statebuf,
   size_t __statelen) noexcept (true) __attribute__ ((__nonnull__ (2)));



extern char *setstate (char *__statebuf) noexcept (true) __attribute__ ((__nonnull__ (1)));







struct random_data
  {
    int32_t *fptr;
    int32_t *rptr;
    int32_t *state;
    int rand_type;
    int rand_deg;
    int rand_sep;
    int32_t *end_ptr;
  };

extern int random_r (struct random_data *__restrict __buf,
       int32_t *__restrict __result) noexcept (true) __attribute__ ((__nonnull__ (1, 2)));

extern int srandom_r (unsigned int __seed, struct random_data *__buf)
     noexcept (true) __attribute__ ((__nonnull__ (2)));

extern int initstate_r (unsigned int __seed, char *__restrict __statebuf,
   size_t __statelen,
   struct random_data *__restrict __buf)
     noexcept (true) __attribute__ ((__nonnull__ (2, 4)));

extern int setstate_r (char *__restrict __statebuf,
         struct random_data *__restrict __buf)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));





extern int rand (void) noexcept (true);

extern void srand (unsigned int __seed) noexcept (true);



extern int rand_r (unsigned int *__seed) noexcept (true);







extern double drand48 (void) noexcept (true);
extern double erand48 (unsigned short int __xsubi[3]) noexcept (true) __attribute__ ((__nonnull__ (1)));


extern long int lrand48 (void) noexcept (true);
extern long int nrand48 (unsigned short int __xsubi[3])
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern long int mrand48 (void) noexcept (true);
extern long int jrand48 (unsigned short int __xsubi[3])
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern void srand48 (long int __seedval) noexcept (true);
extern unsigned short int *seed48 (unsigned short int __seed16v[3])
     noexcept (true) __attribute__ ((__nonnull__ (1)));
extern void lcong48 (unsigned short int __param[7]) noexcept (true) __attribute__ ((__nonnull__ (1)));





struct drand48_data
  {
    unsigned short int __x[3];
    unsigned short int __old_x[3];
    unsigned short int __c;
    unsigned short int __init;
    __extension__ unsigned long long int __a;

  };


extern int drand48_r (struct drand48_data *__restrict __buffer,
        double *__restrict __result) noexcept (true) __attribute__ ((__nonnull__ (1, 2)));
extern int erand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        double *__restrict __result) noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern int lrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));
extern int nrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern int mrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));
extern int jrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern int srand48_r (long int __seedval, struct drand48_data *__buffer)
     noexcept (true) __attribute__ ((__nonnull__ (2)));

extern int seed48_r (unsigned short int __seed16v[3],
       struct drand48_data *__buffer) noexcept (true) __attribute__ ((__nonnull__ (1, 2)));

extern int lcong48_r (unsigned short int __param[7],
        struct drand48_data *__buffer)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));




extern void *malloc (size_t __size) noexcept (true) __attribute__ ((__malloc__))
     __attribute__ ((__alloc_size__ (1))) ;

extern void *calloc (size_t __nmemb, size_t __size)
     noexcept (true) __attribute__ ((__malloc__)) __attribute__ ((__alloc_size__ (1, 2))) ;






extern void *realloc (void *__ptr, size_t __size)
     noexcept (true) __attribute__ ((__warn_unused_result__)) __attribute__ ((__alloc_size__ (2)));







extern void *reallocarray (void *__ptr, size_t __nmemb, size_t __size)
     noexcept (true) __attribute__ ((__warn_unused_result__))
     __attribute__ ((__alloc_size__ (2, 3)));



extern void free (void *__ptr) noexcept (true);


# 1 "/usr/include/alloca.h" 1 3 4
# 24 "/usr/include/alloca.h" 3 4
# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/include/stddef.h" 1 3 4
# 25 "/usr/include/alloca.h" 2 3 4

extern "C" {





extern void *alloca (size_t __size) noexcept (true);





}
# 569 "/usr/include/stdlib.h" 2 3 4





extern void *valloc (size_t __size) noexcept (true) __attribute__ ((__malloc__))
     __attribute__ ((__alloc_size__ (1))) ;




extern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)
     noexcept (true) __attribute__ ((__nonnull__ (1))) ;




extern void *aligned_alloc (size_t __alignment, size_t __size)
     noexcept (true) __attribute__ ((__malloc__)) __attribute__ ((__alloc_size__ (2))) ;



extern void abort (void) noexcept (true) __attribute__ ((__noreturn__));



extern int atexit (void (*__func) (void)) noexcept (true) __attribute__ ((__nonnull__ (1)));




extern "C++" int at_quick_exit (void (*__func) (void))
     noexcept (true) __asm ("at_quick_exit") __attribute__ ((__nonnull__ (1)));
# 610 "/usr/include/stdlib.h" 3 4
extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)
     noexcept (true) __attribute__ ((__nonnull__ (1)));





extern void exit (int __status) noexcept (true) __attribute__ ((__noreturn__));





extern void quick_exit (int __status) noexcept (true) __attribute__ ((__noreturn__));





extern void _Exit (int __status) noexcept (true) __attribute__ ((__noreturn__));




extern char *getenv (const char *__name) noexcept (true) __attribute__ ((__nonnull__ (1))) ;




extern char *secure_getenv (const char *__name)
     noexcept (true) __attribute__ ((__nonnull__ (1))) ;






extern int putenv (char *__string) noexcept (true) __attribute__ ((__nonnull__ (1)));





extern int setenv (const char *__name, const char *__value, int __replace)
     noexcept (true) __attribute__ ((__nonnull__ (2)));


extern int unsetenv (const char *__name) noexcept (true) __attribute__ ((__nonnull__ (1)));






extern int clearenv (void) noexcept (true);
# 675 "/usr/include/stdlib.h" 3 4
extern char *mktemp (char *__template) noexcept (true) __attribute__ ((__nonnull__ (1)));
# 688 "/usr/include/stdlib.h" 3 4
extern int mkstemp (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 698 "/usr/include/stdlib.h" 3 4
extern int mkstemp64 (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 710 "/usr/include/stdlib.h" 3 4
extern int mkstemps (char *__template, int __suffixlen) __attribute__ ((__nonnull__ (1))) ;
# 720 "/usr/include/stdlib.h" 3 4
extern int mkstemps64 (char *__template, int __suffixlen)
     __attribute__ ((__nonnull__ (1))) ;
# 731 "/usr/include/stdlib.h" 3 4
extern char *mkdtemp (char *__template) noexcept (true) __attribute__ ((__nonnull__ (1))) ;
# 742 "/usr/include/stdlib.h" 3 4
extern int mkostemp (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
# 752 "/usr/include/stdlib.h" 3 4
extern int mkostemp64 (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
# 762 "/usr/include/stdlib.h" 3 4
extern int mkostemps (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;
# 774 "/usr/include/stdlib.h" 3 4
extern int mkostemps64 (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;
# 784 "/usr/include/stdlib.h" 3 4
extern int system (const char *__command) ;





extern char *canonicalize_file_name (const char *__name)
     noexcept (true) __attribute__ ((__nonnull__ (1))) ;
# 800 "/usr/include/stdlib.h" 3 4
extern char *realpath (const char *__restrict __name,
         char *__restrict __resolved) noexcept (true) ;






typedef int (*__compar_fn_t) (const void *, const void *);


typedef __compar_fn_t comparison_fn_t;



typedef int (*__compar_d_fn_t) (const void *, const void *, void *);




extern void *bsearch (const void *__key, const void *__base,
        size_t __nmemb, size_t __size, __compar_fn_t __compar)
     __attribute__ ((__nonnull__ (1, 2, 5))) ;







extern void qsort (void *__base, size_t __nmemb, size_t __size,
     __compar_fn_t __compar) __attribute__ ((__nonnull__ (1, 4)));

extern void qsort_r (void *__base, size_t __nmemb, size_t __size,
       __compar_d_fn_t __compar, void *__arg)
  __attribute__ ((__nonnull__ (1, 4)));




extern int abs (int __x) noexcept (true) __attribute__ ((__const__)) ;
extern long int labs (long int __x) noexcept (true) __attribute__ ((__const__)) ;


__extension__ extern long long int llabs (long long int __x)
     noexcept (true) __attribute__ ((__const__)) ;






extern div_t div (int __numer, int __denom)
     noexcept (true) __attribute__ ((__const__)) ;
extern ldiv_t ldiv (long int __numer, long int __denom)
     noexcept (true) __attribute__ ((__const__)) ;


__extension__ extern lldiv_t lldiv (long long int __numer,
        long long int __denom)
     noexcept (true) __attribute__ ((__const__)) ;
# 872 "/usr/include/stdlib.h" 3 4
extern char *ecvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) noexcept (true) __attribute__ ((__nonnull__ (3, 4))) ;




extern char *fcvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) noexcept (true) __attribute__ ((__nonnull__ (3, 4))) ;




extern char *gcvt (double __value, int __ndigit, char *__buf)
     noexcept (true) __attribute__ ((__nonnull__ (3))) ;




extern char *qecvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     noexcept (true) __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qfcvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     noexcept (true) __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qgcvt (long double __value, int __ndigit, char *__buf)
     noexcept (true) __attribute__ ((__nonnull__ (3))) ;




extern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) noexcept (true) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) noexcept (true) __attribute__ ((__nonnull__ (3, 4, 5)));

extern int qecvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     noexcept (true) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int qfcvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     noexcept (true) __attribute__ ((__nonnull__ (3, 4, 5)));





extern int mblen (const char *__s, size_t __n) noexcept (true);


extern int mbtowc (wchar_t *__restrict __pwc,
     const char *__restrict __s, size_t __n) noexcept (true);


extern int wctomb (char *__s, wchar_t __wchar) noexcept (true);



extern size_t mbstowcs (wchar_t *__restrict __pwcs,
   const char *__restrict __s, size_t __n) noexcept (true)
    __attribute__ ((__access__ (__read_only__, 2)));

extern size_t wcstombs (char *__restrict __s,
   const wchar_t *__restrict __pwcs, size_t __n)
     noexcept (true)
  __attribute__ ((__access__ (__write_only__, 1, 3))) __attribute__ ((__access__ (__read_only__, 2)));






extern int rpmatch (const char *__response) noexcept (true) __attribute__ ((__nonnull__ (1))) ;
# 958 "/usr/include/stdlib.h" 3 4
extern int getsubopt (char **__restrict __optionp,
        char *const *__restrict __tokens,
        char **__restrict __valuep)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2, 3))) ;







extern int posix_openpt (int __oflag) ;







extern int grantpt (int __fd) noexcept (true);



extern int unlockpt (int __fd) noexcept (true);




extern char *ptsname (int __fd) noexcept (true) ;






extern int ptsname_r (int __fd, char *__buf, size_t __buflen)
     noexcept (true) __attribute__ ((__nonnull__ (2))) __attribute__ ((__access__ (__write_only__, 2, 3)));


extern int getpt (void);






extern int getloadavg (double __loadavg[], int __nelem)
     noexcept (true) __attribute__ ((__nonnull__ (1)));
# 1014 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/bits/stdlib-float.h" 1 3 4
# 1015 "/usr/include/stdlib.h" 2 3 4
# 1026 "/usr/include/stdlib.h" 3 4
}
# 76 "/usr/include/c++/10.2.0/cstdlib" 2 3

# 1 "/usr/include/c++/10.2.0/bits/std_abs.h" 1 3
# 33 "/usr/include/c++/10.2.0/bits/std_abs.h" 3
       
# 34 "/usr/include/c++/10.2.0/bits/std_abs.h" 3
# 46 "/usr/include/c++/10.2.0/bits/std_abs.h" 3
extern "C++"
{
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::abs;


  inline long
  abs(long __i) { return __builtin_labs(__i); }



  inline long long
  abs(long long __x) { return __builtin_llabs (__x); }
# 70 "/usr/include/c++/10.2.0/bits/std_abs.h" 3
  inline constexpr double
  abs(double __x)
  { return __builtin_fabs(__x); }

  inline constexpr float
  abs(float __x)
  { return __builtin_fabsf(__x); }

  inline constexpr long double
  abs(long double __x)
  { return __builtin_fabsl(__x); }



  inline constexpr __int128
  abs(__int128 __x) { return __x >= 0 ? __x : -__x; }
# 101 "/usr/include/c++/10.2.0/bits/std_abs.h" 3
  inline constexpr
  __float128
  abs(__float128 __x)
  { return __x < 0 ? -__x : __x; }



}
}
# 78 "/usr/include/c++/10.2.0/cstdlib" 2 3
# 121 "/usr/include/c++/10.2.0/cstdlib" 3
extern "C++"
{
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::div_t;
  using ::ldiv_t;

  using ::abort;



  using ::atexit;


  using ::at_quick_exit;


  using ::atof;
  using ::atoi;
  using ::atol;
  using ::bsearch;
  using ::calloc;
  using ::div;
  using ::exit;
  using ::free;
  using ::getenv;
  using ::labs;
  using ::ldiv;
  using ::malloc;

  using ::mblen;
  using ::mbstowcs;
  using ::mbtowc;

  using ::qsort;


  using ::quick_exit;


  using ::rand;
  using ::realloc;
  using ::srand;
  using ::strtod;
  using ::strtol;
  using ::strtoul;
  using ::system;

  using ::wcstombs;
  using ::wctomb;



  inline ldiv_t
  div(long __i, long __j) { return ldiv(__i, __j); }




}
# 195 "/usr/include/c++/10.2.0/cstdlib" 3
namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{



  using ::lldiv_t;





  using ::_Exit;



  using ::llabs;

  inline lldiv_t
  div(long long __n, long long __d)
  { lldiv_t __q; __q.quot = __n / __d; __q.rem = __n % __d; return __q; }

  using ::lldiv;
# 227 "/usr/include/c++/10.2.0/cstdlib" 3
  using ::atoll;
  using ::strtoll;
  using ::strtoull;

  using ::strtof;
  using ::strtold;


}

namespace std
{

  using ::__gnu_cxx::lldiv_t;

  using ::__gnu_cxx::_Exit;

  using ::__gnu_cxx::llabs;
  using ::__gnu_cxx::div;
  using ::__gnu_cxx::lldiv;

  using ::__gnu_cxx::atoll;
  using ::__gnu_cxx::strtof;
  using ::__gnu_cxx::strtoll;
  using ::__gnu_cxx::strtoull;
  using ::__gnu_cxx::strtold;
}



}
# 37 "/usr/include/c++/10.2.0/stdlib.h" 2 3

using std::abort;
using std::atexit;
using std::exit;


  using std::at_quick_exit;


  using std::quick_exit;




using std::div_t;
using std::ldiv_t;

using std::abs;
using std::atof;
using std::atoi;
using std::atol;
using std::bsearch;
using std::calloc;
using std::div;
using std::free;
using std::getenv;
using std::labs;
using std::ldiv;
using std::malloc;

using std::mblen;
using std::mbstowcs;
using std::mbtowc;

using std::qsort;
using std::rand;
using std::realloc;
using std::srand;
using std::strtod;
using std::strtol;
using std::strtoul;
using std::system;

using std::wcstombs;
using std::wctomb;
# 20 "/usr/include/opencascade/Standard_PrimitiveTypes.hxx" 2



# 1 "/usr/include/opencascade/Standard_Boolean.hxx" 1
# 24 "/usr/include/opencascade/Standard_PrimitiveTypes.hxx" 2

# 1 "/usr/include/opencascade/Standard_Real.hxx" 1
# 18 "/usr/include/opencascade/Standard_Real.hxx"
# 1 "/usr/include/c++/10.2.0/cmath" 1 3
# 39 "/usr/include/c++/10.2.0/cmath" 3
       
# 40 "/usr/include/c++/10.2.0/cmath" 3


# 1 "/usr/include/c++/10.2.0/bits/cpp_type_traits.h" 1 3
# 35 "/usr/include/c++/10.2.0/bits/cpp_type_traits.h" 3
       
# 36 "/usr/include/c++/10.2.0/bits/cpp_type_traits.h" 3
# 67 "/usr/include/c++/10.2.0/bits/cpp_type_traits.h" 3
extern "C++" {

namespace std __attribute__ ((__visibility__ ("default")))
{


  struct __true_type { };
  struct __false_type { };

  template<bool>
    struct __truth_type
    { typedef __false_type __type; };

  template<>
    struct __truth_type<true>
    { typedef __true_type __type; };



  template<class _Sp, class _Tp>
    struct __traitor
    {
      enum { __value = bool(_Sp::__value) || bool(_Tp::__value) };
      typedef typename __truth_type<__value>::__type __type;
    };


  template<typename, typename>
    struct __are_same
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __are_same<_Tp, _Tp>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename _Tp>
    struct __is_void
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_void<void>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_integer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };





  template<>
    struct __is_integer<bool>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_integer<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
# 184 "/usr/include/c++/10.2.0/bits/cpp_type_traits.h" 3
  template<>
    struct __is_integer<char16_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<char32_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_integer<short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
# 270 "/usr/include/c++/10.2.0/bits/cpp_type_traits.h" 3
template<> struct __is_integer<__int128> { enum { __value = 1 }; typedef __true_type __type; }; template<> struct __is_integer<unsigned __int128> { enum { __value = 1 }; typedef __true_type __type; };
# 287 "/usr/include/c++/10.2.0/bits/cpp_type_traits.h" 3
  template<typename _Tp>
    struct __is_floating
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };


  template<>
    struct __is_floating<float>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<long double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_pointer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __is_pointer<_Tp*>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_arithmetic
    : public __traitor<__is_integer<_Tp>, __is_floating<_Tp> >
    { };




  template<typename _Tp>
    struct __is_scalar
    : public __traitor<__is_arithmetic<_Tp>, __is_pointer<_Tp> >
    { };




  template<typename _Tp>
    struct __is_char
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_char<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_char<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename _Tp>
    struct __is_byte
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_byte<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_byte<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_byte<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
# 423 "/usr/include/c++/10.2.0/bits/cpp_type_traits.h" 3
  template<typename> struct iterator_traits;


  template<typename _Tp>
    struct __is_nonvolatile_trivially_copyable
    {
      enum { __value = __is_trivially_copyable(_Tp) };
    };




  template<typename _Tp>
    struct __is_nonvolatile_trivially_copyable<volatile _Tp>
    {
      enum { __value = 0 };
    };


  template<typename _OutputIter, typename _InputIter>
    struct __memcpyable
    {
      enum { __value = 0 };
    };

  template<typename _Tp>
    struct __memcpyable<_Tp*, _Tp*>
    : __is_nonvolatile_trivially_copyable<_Tp>
    { };

  template<typename _Tp>
    struct __memcpyable<_Tp*, const _Tp*>
    : __is_nonvolatile_trivially_copyable<_Tp>
    { };






  template<typename _Iter1, typename _Iter2>
    struct __memcmpable
    {
      enum { __value = 0 };
    };


  template<typename _Tp>
    struct __memcmpable<_Tp*, _Tp*>
    : __is_nonvolatile_trivially_copyable<_Tp>
    { };

  template<typename _Tp>
    struct __memcmpable<const _Tp*, _Tp*>
    : __is_nonvolatile_trivially_copyable<_Tp>
    { };

  template<typename _Tp>
    struct __memcmpable<_Tp*, const _Tp*>
    : __is_nonvolatile_trivially_copyable<_Tp>
    { };




  template<typename _Tp>
    struct __is_move_iterator
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };



  template<typename _Iterator>
   
    inline _Iterator
    __miter_base(_Iterator __it)
    { return __it; }


}
}
# 43 "/usr/include/c++/10.2.0/cmath" 2 3
# 1 "/usr/include/c++/10.2.0/ext/type_traits.h" 1 3
# 32 "/usr/include/c++/10.2.0/ext/type_traits.h" 3
       
# 33 "/usr/include/c++/10.2.0/ext/type_traits.h" 3




extern "C++" {

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{



  template<bool, typename>
    struct __enable_if
    { };

  template<typename _Tp>
    struct __enable_if<true, _Tp>
    { typedef _Tp __type; };



  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    struct __conditional_type
    { typedef _Iftrue __type; };

  template<typename _Iftrue, typename _Iffalse>
    struct __conditional_type<false, _Iftrue, _Iffalse>
    { typedef _Iffalse __type; };



  template<typename _Tp>
    struct __add_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __add_unsigned<char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<signed char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<short>
    { typedef unsigned short __type; };

  template<>
    struct __add_unsigned<int>
    { typedef unsigned int __type; };

  template<>
    struct __add_unsigned<long>
    { typedef unsigned long __type; };

  template<>
    struct __add_unsigned<long long>
    { typedef unsigned long long __type; };


  template<>
    struct __add_unsigned<bool>;

  template<>
    struct __add_unsigned<wchar_t>;



  template<typename _Tp>
    struct __remove_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __remove_unsigned<char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned short>
    { typedef short __type; };

  template<>
    struct __remove_unsigned<unsigned int>
    { typedef int __type; };

  template<>
    struct __remove_unsigned<unsigned long>
    { typedef long __type; };

  template<>
    struct __remove_unsigned<unsigned long long>
    { typedef long long __type; };


  template<>
    struct __remove_unsigned<bool>;

  template<>
    struct __remove_unsigned<wchar_t>;



  template<typename _Type>
    inline bool
    __is_null_pointer(_Type* __ptr)
    { return __ptr == 0; }

  template<typename _Type>
    inline bool
    __is_null_pointer(_Type)
    { return false; }


  inline bool
  __is_null_pointer(std::nullptr_t)
  { return true; }



  template<typename _Tp, bool = std::__is_integer<_Tp>::__value>
    struct __promote
    { typedef double __type; };




  template<typename _Tp>
    struct __promote<_Tp, false>
    { };

  template<>
    struct __promote<long double>
    { typedef long double __type; };

  template<>
    struct __promote<double>
    { typedef double __type; };

  template<>
    struct __promote<float>
    { typedef float __type; };

  template<typename _Tp, typename _Up,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type>
    struct __promote_2
    {
      typedef __typeof__(_Tp2() + _Up2()) __type;
    };

  template<typename _Tp, typename _Up, typename _Vp,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type,
           typename _Vp2 = typename __promote<_Vp>::__type>
    struct __promote_3
    {
      typedef __typeof__(_Tp2() + _Up2() + _Vp2()) __type;
    };

  template<typename _Tp, typename _Up, typename _Vp, typename _Wp,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type,
           typename _Vp2 = typename __promote<_Vp>::__type,
           typename _Wp2 = typename __promote<_Wp>::__type>
    struct __promote_4
    {
      typedef __typeof__(_Tp2() + _Up2() + _Vp2() + _Wp2()) __type;
    };


}
}
# 44 "/usr/include/c++/10.2.0/cmath" 2 3

# 1 "/usr/include/math.h" 1 3 4
# 27 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/libc-header-start.h" 1 3 4
# 28 "/usr/include/math.h" 2 3 4






extern "C" {





# 1 "/usr/include/bits/math-vector.h" 1 3 4
# 25 "/usr/include/bits/math-vector.h" 3 4
# 1 "/usr/include/bits/libm-simd-decl-stubs.h" 1 3 4
# 26 "/usr/include/bits/math-vector.h" 2 3 4
# 41 "/usr/include/math.h" 2 3 4
# 138 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/flt-eval-method.h" 1 3 4
# 139 "/usr/include/math.h" 2 3 4
# 149 "/usr/include/math.h" 3 4
typedef float float_t;
typedef double double_t;
# 190 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/fp-logb.h" 1 3 4
# 191 "/usr/include/math.h" 2 3 4
# 233 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/fp-fast.h" 1 3 4
# 234 "/usr/include/math.h" 2 3 4



enum
  {
    FP_INT_UPWARD =

      0,
    FP_INT_DOWNWARD =

      1,
    FP_INT_TOWARDZERO =

      2,
    FP_INT_TONEARESTFROMZERO =

      3,
    FP_INT_TONEAREST =

      4,
  };
# 298 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls-helper-functions.h" 1 3 4
# 20 "/usr/include/bits/mathcalls-helper-functions.h" 3 4
extern int __fpclassify (double __value) noexcept (true)
     __attribute__ ((__const__));


extern int __signbit (double __value) noexcept (true)
     __attribute__ ((__const__));



extern int __isinf (double __value) noexcept (true)
  __attribute__ ((__const__));


extern int __finite (double __value) noexcept (true)
  __attribute__ ((__const__));


extern int __isnan (double __value) noexcept (true)
  __attribute__ ((__const__));


extern int __iseqsig (double __x, double __y) noexcept (true);


extern int __issignaling (double __value) noexcept (true)
     __attribute__ ((__const__));
# 299 "/usr/include/math.h" 2 3 4
# 1 "/usr/include/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/bits/mathcalls.h" 3 4
extern double acos (double __x) noexcept (true); extern double __acos (double __x) noexcept (true);

extern double asin (double __x) noexcept (true); extern double __asin (double __x) noexcept (true);

extern double atan (double __x) noexcept (true); extern double __atan (double __x) noexcept (true);

extern double atan2 (double __y, double __x) noexcept (true); extern double __atan2 (double __y, double __x) noexcept (true);


 extern double cos (double __x) noexcept (true); extern double __cos (double __x) noexcept (true);

 extern double sin (double __x) noexcept (true); extern double __sin (double __x) noexcept (true);

extern double tan (double __x) noexcept (true); extern double __tan (double __x) noexcept (true);




extern double cosh (double __x) noexcept (true); extern double __cosh (double __x) noexcept (true);

extern double sinh (double __x) noexcept (true); extern double __sinh (double __x) noexcept (true);

extern double tanh (double __x) noexcept (true); extern double __tanh (double __x) noexcept (true);



 extern void sincos (double __x, double *__sinx, double *__cosx) noexcept (true); extern void __sincos (double __x, double *__sinx, double *__cosx) noexcept (true)
                                                        ;




extern double acosh (double __x) noexcept (true); extern double __acosh (double __x) noexcept (true);

extern double asinh (double __x) noexcept (true); extern double __asinh (double __x) noexcept (true);

extern double atanh (double __x) noexcept (true); extern double __atanh (double __x) noexcept (true);





 extern double exp (double __x) noexcept (true); extern double __exp (double __x) noexcept (true);


extern double frexp (double __x, int *__exponent) noexcept (true); extern double __frexp (double __x, int *__exponent) noexcept (true);


extern double ldexp (double __x, int __exponent) noexcept (true); extern double __ldexp (double __x, int __exponent) noexcept (true);


 extern double log (double __x) noexcept (true); extern double __log (double __x) noexcept (true);


extern double log10 (double __x) noexcept (true); extern double __log10 (double __x) noexcept (true);


extern double modf (double __x, double *__iptr) noexcept (true); extern double __modf (double __x, double *__iptr) noexcept (true) __attribute__ ((__nonnull__ (2)));



extern double exp10 (double __x) noexcept (true); extern double __exp10 (double __x) noexcept (true);




extern double expm1 (double __x) noexcept (true); extern double __expm1 (double __x) noexcept (true);


extern double log1p (double __x) noexcept (true); extern double __log1p (double __x) noexcept (true);


extern double logb (double __x) noexcept (true); extern double __logb (double __x) noexcept (true);




extern double exp2 (double __x) noexcept (true); extern double __exp2 (double __x) noexcept (true);


extern double log2 (double __x) noexcept (true); extern double __log2 (double __x) noexcept (true);






 extern double pow (double __x, double __y) noexcept (true); extern double __pow (double __x, double __y) noexcept (true);


extern double sqrt (double __x) noexcept (true); extern double __sqrt (double __x) noexcept (true);



extern double hypot (double __x, double __y) noexcept (true); extern double __hypot (double __x, double __y) noexcept (true);




extern double cbrt (double __x) noexcept (true); extern double __cbrt (double __x) noexcept (true);






extern double ceil (double __x) noexcept (true) __attribute__ ((__const__)); extern double __ceil (double __x) noexcept (true) __attribute__ ((__const__));


extern double fabs (double __x) noexcept (true) __attribute__ ((__const__)); extern double __fabs (double __x) noexcept (true) __attribute__ ((__const__));


extern double floor (double __x) noexcept (true) __attribute__ ((__const__)); extern double __floor (double __x) noexcept (true) __attribute__ ((__const__));


extern double fmod (double __x, double __y) noexcept (true); extern double __fmod (double __x, double __y) noexcept (true);
# 183 "/usr/include/bits/mathcalls.h" 3 4
extern int finite (double __value) noexcept (true)
  __attribute__ ((__const__));


extern double drem (double __x, double __y) noexcept (true); extern double __drem (double __x, double __y) noexcept (true);



extern double significand (double __x) noexcept (true); extern double __significand (double __x) noexcept (true);






extern double copysign (double __x, double __y) noexcept (true) __attribute__ ((__const__)); extern double __copysign (double __x, double __y) noexcept (true) __attribute__ ((__const__));




extern double nan (const char *__tagb) noexcept (true); extern double __nan (const char *__tagb) noexcept (true);
# 220 "/usr/include/bits/mathcalls.h" 3 4
extern double j0 (double) noexcept (true); extern double __j0 (double) noexcept (true);
extern double j1 (double) noexcept (true); extern double __j1 (double) noexcept (true);
extern double jn (int, double) noexcept (true); extern double __jn (int, double) noexcept (true);
extern double y0 (double) noexcept (true); extern double __y0 (double) noexcept (true);
extern double y1 (double) noexcept (true); extern double __y1 (double) noexcept (true);
extern double yn (int, double) noexcept (true); extern double __yn (int, double) noexcept (true);





extern double erf (double) noexcept (true); extern double __erf (double) noexcept (true);
extern double erfc (double) noexcept (true); extern double __erfc (double) noexcept (true);
extern double lgamma (double) noexcept (true); extern double __lgamma (double) noexcept (true);




extern double tgamma (double) noexcept (true); extern double __tgamma (double) noexcept (true);





extern double gamma (double) noexcept (true); extern double __gamma (double) noexcept (true);







extern double lgamma_r (double, int *__signgamp) noexcept (true); extern double __lgamma_r (double, int *__signgamp) noexcept (true);






extern double rint (double __x) noexcept (true); extern double __rint (double __x) noexcept (true);


extern double nextafter (double __x, double __y) noexcept (true); extern double __nextafter (double __x, double __y) noexcept (true);

extern double nexttoward (double __x, long double __y) noexcept (true); extern double __nexttoward (double __x, long double __y) noexcept (true);




extern double nextdown (double __x) noexcept (true); extern double __nextdown (double __x) noexcept (true);

extern double nextup (double __x) noexcept (true); extern double __nextup (double __x) noexcept (true);



extern double remainder (double __x, double __y) noexcept (true); extern double __remainder (double __x, double __y) noexcept (true);



extern double scalbn (double __x, int __n) noexcept (true); extern double __scalbn (double __x, int __n) noexcept (true);



extern int ilogb (double __x) noexcept (true); extern int __ilogb (double __x) noexcept (true);




extern long int llogb (double __x) noexcept (true); extern long int __llogb (double __x) noexcept (true);




extern double scalbln (double __x, long int __n) noexcept (true); extern double __scalbln (double __x, long int __n) noexcept (true);



extern double nearbyint (double __x) noexcept (true); extern double __nearbyint (double __x) noexcept (true);



extern double round (double __x) noexcept (true) __attribute__ ((__const__)); extern double __round (double __x) noexcept (true) __attribute__ ((__const__));



extern double trunc (double __x) noexcept (true) __attribute__ ((__const__)); extern double __trunc (double __x) noexcept (true) __attribute__ ((__const__));




extern double remquo (double __x, double __y, int *__quo) noexcept (true); extern double __remquo (double __x, double __y, int *__quo) noexcept (true);






extern long int lrint (double __x) noexcept (true); extern long int __lrint (double __x) noexcept (true);
__extension__
extern long long int llrint (double __x) noexcept (true); extern long long int __llrint (double __x) noexcept (true);



extern long int lround (double __x) noexcept (true); extern long int __lround (double __x) noexcept (true);
__extension__
extern long long int llround (double __x) noexcept (true); extern long long int __llround (double __x) noexcept (true);



extern double fdim (double __x, double __y) noexcept (true); extern double __fdim (double __x, double __y) noexcept (true);


extern double fmax (double __x, double __y) noexcept (true) __attribute__ ((__const__)); extern double __fmax (double __x, double __y) noexcept (true) __attribute__ ((__const__));


extern double fmin (double __x, double __y) noexcept (true) __attribute__ ((__const__)); extern double __fmin (double __x, double __y) noexcept (true) __attribute__ ((__const__));


extern double fma (double __x, double __y, double __z) noexcept (true); extern double __fma (double __x, double __y, double __z) noexcept (true);




extern double roundeven (double __x) noexcept (true) __attribute__ ((__const__)); extern double __roundeven (double __x) noexcept (true) __attribute__ ((__const__));



extern __intmax_t fromfp (double __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfp (double __x, int __round, unsigned int __width) noexcept (true)
                            ;



extern __uintmax_t ufromfp (double __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfp (double __x, int __round, unsigned int __width) noexcept (true)
                              ;




extern __intmax_t fromfpx (double __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpx (double __x, int __round, unsigned int __width) noexcept (true)
                             ;




extern __uintmax_t ufromfpx (double __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpx (double __x, int __round, unsigned int __width) noexcept (true)
                               ;


extern double fmaxmag (double __x, double __y) noexcept (true) __attribute__ ((__const__)); extern double __fmaxmag (double __x, double __y) noexcept (true) __attribute__ ((__const__));


extern double fminmag (double __x, double __y) noexcept (true) __attribute__ ((__const__)); extern double __fminmag (double __x, double __y) noexcept (true) __attribute__ ((__const__));


extern int canonicalize (double *__cx, const double *__x) noexcept (true);




extern int totalorder (const double *__x, const double *__y) noexcept (true)

     __attribute__ ((__pure__));


extern int totalordermag (const double *__x, const double *__y) noexcept (true)

     __attribute__ ((__pure__));


extern double getpayload (const double *__x) noexcept (true); extern double __getpayload (const double *__x) noexcept (true);


extern int setpayload (double *__x, double __payload) noexcept (true);


extern int setpayloadsig (double *__x, double __payload) noexcept (true);







extern double scalb (double __x, double __n) noexcept (true); extern double __scalb (double __x, double __n) noexcept (true);
# 300 "/usr/include/math.h" 2 3 4
# 315 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls-helper-functions.h" 1 3 4
# 20 "/usr/include/bits/mathcalls-helper-functions.h" 3 4
extern int __fpclassifyf (float __value) noexcept (true)
     __attribute__ ((__const__));


extern int __signbitf (float __value) noexcept (true)
     __attribute__ ((__const__));



extern int __isinff (float __value) noexcept (true)
  __attribute__ ((__const__));


extern int __finitef (float __value) noexcept (true)
  __attribute__ ((__const__));


extern int __isnanf (float __value) noexcept (true)
  __attribute__ ((__const__));


extern int __iseqsigf (float __x, float __y) noexcept (true);


extern int __issignalingf (float __value) noexcept (true)
     __attribute__ ((__const__));
# 316 "/usr/include/math.h" 2 3 4
# 1 "/usr/include/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/bits/mathcalls.h" 3 4
extern float acosf (float __x) noexcept (true); extern float __acosf (float __x) noexcept (true);

extern float asinf (float __x) noexcept (true); extern float __asinf (float __x) noexcept (true);

extern float atanf (float __x) noexcept (true); extern float __atanf (float __x) noexcept (true);

extern float atan2f (float __y, float __x) noexcept (true); extern float __atan2f (float __y, float __x) noexcept (true);


 extern float cosf (float __x) noexcept (true); extern float __cosf (float __x) noexcept (true);

 extern float sinf (float __x) noexcept (true); extern float __sinf (float __x) noexcept (true);

extern float tanf (float __x) noexcept (true); extern float __tanf (float __x) noexcept (true);




extern float coshf (float __x) noexcept (true); extern float __coshf (float __x) noexcept (true);

extern float sinhf (float __x) noexcept (true); extern float __sinhf (float __x) noexcept (true);

extern float tanhf (float __x) noexcept (true); extern float __tanhf (float __x) noexcept (true);



 extern void sincosf (float __x, float *__sinx, float *__cosx) noexcept (true); extern void __sincosf (float __x, float *__sinx, float *__cosx) noexcept (true)
                                                        ;




extern float acoshf (float __x) noexcept (true); extern float __acoshf (float __x) noexcept (true);

extern float asinhf (float __x) noexcept (true); extern float __asinhf (float __x) noexcept (true);

extern float atanhf (float __x) noexcept (true); extern float __atanhf (float __x) noexcept (true);





 extern float expf (float __x) noexcept (true); extern float __expf (float __x) noexcept (true);


extern float frexpf (float __x, int *__exponent) noexcept (true); extern float __frexpf (float __x, int *__exponent) noexcept (true);


extern float ldexpf (float __x, int __exponent) noexcept (true); extern float __ldexpf (float __x, int __exponent) noexcept (true);


 extern float logf (float __x) noexcept (true); extern float __logf (float __x) noexcept (true);


extern float log10f (float __x) noexcept (true); extern float __log10f (float __x) noexcept (true);


extern float modff (float __x, float *__iptr) noexcept (true); extern float __modff (float __x, float *__iptr) noexcept (true) __attribute__ ((__nonnull__ (2)));



extern float exp10f (float __x) noexcept (true); extern float __exp10f (float __x) noexcept (true);




extern float expm1f (float __x) noexcept (true); extern float __expm1f (float __x) noexcept (true);


extern float log1pf (float __x) noexcept (true); extern float __log1pf (float __x) noexcept (true);


extern float logbf (float __x) noexcept (true); extern float __logbf (float __x) noexcept (true);




extern float exp2f (float __x) noexcept (true); extern float __exp2f (float __x) noexcept (true);


extern float log2f (float __x) noexcept (true); extern float __log2f (float __x) noexcept (true);






 extern float powf (float __x, float __y) noexcept (true); extern float __powf (float __x, float __y) noexcept (true);


extern float sqrtf (float __x) noexcept (true); extern float __sqrtf (float __x) noexcept (true);



extern float hypotf (float __x, float __y) noexcept (true); extern float __hypotf (float __x, float __y) noexcept (true);




extern float cbrtf (float __x) noexcept (true); extern float __cbrtf (float __x) noexcept (true);






extern float ceilf (float __x) noexcept (true) __attribute__ ((__const__)); extern float __ceilf (float __x) noexcept (true) __attribute__ ((__const__));


extern float fabsf (float __x) noexcept (true) __attribute__ ((__const__)); extern float __fabsf (float __x) noexcept (true) __attribute__ ((__const__));


extern float floorf (float __x) noexcept (true) __attribute__ ((__const__)); extern float __floorf (float __x) noexcept (true) __attribute__ ((__const__));


extern float fmodf (float __x, float __y) noexcept (true); extern float __fmodf (float __x, float __y) noexcept (true);
# 177 "/usr/include/bits/mathcalls.h" 3 4
extern int isinff (float __value) noexcept (true)
  __attribute__ ((__const__));




extern int finitef (float __value) noexcept (true)
  __attribute__ ((__const__));


extern float dremf (float __x, float __y) noexcept (true); extern float __dremf (float __x, float __y) noexcept (true);



extern float significandf (float __x) noexcept (true); extern float __significandf (float __x) noexcept (true);






extern float copysignf (float __x, float __y) noexcept (true) __attribute__ ((__const__)); extern float __copysignf (float __x, float __y) noexcept (true) __attribute__ ((__const__));




extern float nanf (const char *__tagb) noexcept (true); extern float __nanf (const char *__tagb) noexcept (true);
# 213 "/usr/include/bits/mathcalls.h" 3 4
extern int isnanf (float __value) noexcept (true)
  __attribute__ ((__const__));





extern float j0f (float) noexcept (true); extern float __j0f (float) noexcept (true);
extern float j1f (float) noexcept (true); extern float __j1f (float) noexcept (true);
extern float jnf (int, float) noexcept (true); extern float __jnf (int, float) noexcept (true);
extern float y0f (float) noexcept (true); extern float __y0f (float) noexcept (true);
extern float y1f (float) noexcept (true); extern float __y1f (float) noexcept (true);
extern float ynf (int, float) noexcept (true); extern float __ynf (int, float) noexcept (true);





extern float erff (float) noexcept (true); extern float __erff (float) noexcept (true);
extern float erfcf (float) noexcept (true); extern float __erfcf (float) noexcept (true);
extern float lgammaf (float) noexcept (true); extern float __lgammaf (float) noexcept (true);




extern float tgammaf (float) noexcept (true); extern float __tgammaf (float) noexcept (true);





extern float gammaf (float) noexcept (true); extern float __gammaf (float) noexcept (true);







extern float lgammaf_r (float, int *__signgamp) noexcept (true); extern float __lgammaf_r (float, int *__signgamp) noexcept (true);






extern float rintf (float __x) noexcept (true); extern float __rintf (float __x) noexcept (true);


extern float nextafterf (float __x, float __y) noexcept (true); extern float __nextafterf (float __x, float __y) noexcept (true);

extern float nexttowardf (float __x, long double __y) noexcept (true); extern float __nexttowardf (float __x, long double __y) noexcept (true);




extern float nextdownf (float __x) noexcept (true); extern float __nextdownf (float __x) noexcept (true);

extern float nextupf (float __x) noexcept (true); extern float __nextupf (float __x) noexcept (true);



extern float remainderf (float __x, float __y) noexcept (true); extern float __remainderf (float __x, float __y) noexcept (true);



extern float scalbnf (float __x, int __n) noexcept (true); extern float __scalbnf (float __x, int __n) noexcept (true);



extern int ilogbf (float __x) noexcept (true); extern int __ilogbf (float __x) noexcept (true);




extern long int llogbf (float __x) noexcept (true); extern long int __llogbf (float __x) noexcept (true);




extern float scalblnf (float __x, long int __n) noexcept (true); extern float __scalblnf (float __x, long int __n) noexcept (true);



extern float nearbyintf (float __x) noexcept (true); extern float __nearbyintf (float __x) noexcept (true);



extern float roundf (float __x) noexcept (true) __attribute__ ((__const__)); extern float __roundf (float __x) noexcept (true) __attribute__ ((__const__));



extern float truncf (float __x) noexcept (true) __attribute__ ((__const__)); extern float __truncf (float __x) noexcept (true) __attribute__ ((__const__));




extern float remquof (float __x, float __y, int *__quo) noexcept (true); extern float __remquof (float __x, float __y, int *__quo) noexcept (true);






extern long int lrintf (float __x) noexcept (true); extern long int __lrintf (float __x) noexcept (true);
__extension__
extern long long int llrintf (float __x) noexcept (true); extern long long int __llrintf (float __x) noexcept (true);



extern long int lroundf (float __x) noexcept (true); extern long int __lroundf (float __x) noexcept (true);
__extension__
extern long long int llroundf (float __x) noexcept (true); extern long long int __llroundf (float __x) noexcept (true);



extern float fdimf (float __x, float __y) noexcept (true); extern float __fdimf (float __x, float __y) noexcept (true);


extern float fmaxf (float __x, float __y) noexcept (true) __attribute__ ((__const__)); extern float __fmaxf (float __x, float __y) noexcept (true) __attribute__ ((__const__));


extern float fminf (float __x, float __y) noexcept (true) __attribute__ ((__const__)); extern float __fminf (float __x, float __y) noexcept (true) __attribute__ ((__const__));


extern float fmaf (float __x, float __y, float __z) noexcept (true); extern float __fmaf (float __x, float __y, float __z) noexcept (true);




extern float roundevenf (float __x) noexcept (true) __attribute__ ((__const__)); extern float __roundevenf (float __x) noexcept (true) __attribute__ ((__const__));



extern __intmax_t fromfpf (float __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpf (float __x, int __round, unsigned int __width) noexcept (true)
                            ;



extern __uintmax_t ufromfpf (float __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpf (float __x, int __round, unsigned int __width) noexcept (true)
                              ;




extern __intmax_t fromfpxf (float __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpxf (float __x, int __round, unsigned int __width) noexcept (true)
                             ;




extern __uintmax_t ufromfpxf (float __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpxf (float __x, int __round, unsigned int __width) noexcept (true)
                               ;


extern float fmaxmagf (float __x, float __y) noexcept (true) __attribute__ ((__const__)); extern float __fmaxmagf (float __x, float __y) noexcept (true) __attribute__ ((__const__));


extern float fminmagf (float __x, float __y) noexcept (true) __attribute__ ((__const__)); extern float __fminmagf (float __x, float __y) noexcept (true) __attribute__ ((__const__));


extern int canonicalizef (float *__cx, const float *__x) noexcept (true);




extern int totalorderf (const float *__x, const float *__y) noexcept (true)

     __attribute__ ((__pure__));


extern int totalordermagf (const float *__x, const float *__y) noexcept (true)

     __attribute__ ((__pure__));


extern float getpayloadf (const float *__x) noexcept (true); extern float __getpayloadf (const float *__x) noexcept (true);


extern int setpayloadf (float *__x, float __payload) noexcept (true);


extern int setpayloadsigf (float *__x, float __payload) noexcept (true);







extern float scalbf (float __x, float __n) noexcept (true); extern float __scalbf (float __x, float __n) noexcept (true);
# 317 "/usr/include/math.h" 2 3 4
# 384 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls-helper-functions.h" 1 3 4
# 20 "/usr/include/bits/mathcalls-helper-functions.h" 3 4
extern int __fpclassifyl (long double __value) noexcept (true)
     __attribute__ ((__const__));


extern int __signbitl (long double __value) noexcept (true)
     __attribute__ ((__const__));



extern int __isinfl (long double __value) noexcept (true)
  __attribute__ ((__const__));


extern int __finitel (long double __value) noexcept (true)
  __attribute__ ((__const__));


extern int __isnanl (long double __value) noexcept (true)
  __attribute__ ((__const__));


extern int __iseqsigl (long double __x, long double __y) noexcept (true);


extern int __issignalingl (long double __value) noexcept (true)
     __attribute__ ((__const__));
# 385 "/usr/include/math.h" 2 3 4
# 1 "/usr/include/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/bits/mathcalls.h" 3 4
extern long double acosl (long double __x) noexcept (true); extern long double __acosl (long double __x) noexcept (true);

extern long double asinl (long double __x) noexcept (true); extern long double __asinl (long double __x) noexcept (true);

extern long double atanl (long double __x) noexcept (true); extern long double __atanl (long double __x) noexcept (true);

extern long double atan2l (long double __y, long double __x) noexcept (true); extern long double __atan2l (long double __y, long double __x) noexcept (true);


 extern long double cosl (long double __x) noexcept (true); extern long double __cosl (long double __x) noexcept (true);

 extern long double sinl (long double __x) noexcept (true); extern long double __sinl (long double __x) noexcept (true);

extern long double tanl (long double __x) noexcept (true); extern long double __tanl (long double __x) noexcept (true);




extern long double coshl (long double __x) noexcept (true); extern long double __coshl (long double __x) noexcept (true);

extern long double sinhl (long double __x) noexcept (true); extern long double __sinhl (long double __x) noexcept (true);

extern long double tanhl (long double __x) noexcept (true); extern long double __tanhl (long double __x) noexcept (true);



 extern void sincosl (long double __x, long double *__sinx, long double *__cosx) noexcept (true); extern void __sincosl (long double __x, long double *__sinx, long double *__cosx) noexcept (true)
                                                        ;




extern long double acoshl (long double __x) noexcept (true); extern long double __acoshl (long double __x) noexcept (true);

extern long double asinhl (long double __x) noexcept (true); extern long double __asinhl (long double __x) noexcept (true);

extern long double atanhl (long double __x) noexcept (true); extern long double __atanhl (long double __x) noexcept (true);





 extern long double expl (long double __x) noexcept (true); extern long double __expl (long double __x) noexcept (true);


extern long double frexpl (long double __x, int *__exponent) noexcept (true); extern long double __frexpl (long double __x, int *__exponent) noexcept (true);


extern long double ldexpl (long double __x, int __exponent) noexcept (true); extern long double __ldexpl (long double __x, int __exponent) noexcept (true);


 extern long double logl (long double __x) noexcept (true); extern long double __logl (long double __x) noexcept (true);


extern long double log10l (long double __x) noexcept (true); extern long double __log10l (long double __x) noexcept (true);


extern long double modfl (long double __x, long double *__iptr) noexcept (true); extern long double __modfl (long double __x, long double *__iptr) noexcept (true) __attribute__ ((__nonnull__ (2)));



extern long double exp10l (long double __x) noexcept (true); extern long double __exp10l (long double __x) noexcept (true);




extern long double expm1l (long double __x) noexcept (true); extern long double __expm1l (long double __x) noexcept (true);


extern long double log1pl (long double __x) noexcept (true); extern long double __log1pl (long double __x) noexcept (true);


extern long double logbl (long double __x) noexcept (true); extern long double __logbl (long double __x) noexcept (true);




extern long double exp2l (long double __x) noexcept (true); extern long double __exp2l (long double __x) noexcept (true);


extern long double log2l (long double __x) noexcept (true); extern long double __log2l (long double __x) noexcept (true);






 extern long double powl (long double __x, long double __y) noexcept (true); extern long double __powl (long double __x, long double __y) noexcept (true);


extern long double sqrtl (long double __x) noexcept (true); extern long double __sqrtl (long double __x) noexcept (true);



extern long double hypotl (long double __x, long double __y) noexcept (true); extern long double __hypotl (long double __x, long double __y) noexcept (true);




extern long double cbrtl (long double __x) noexcept (true); extern long double __cbrtl (long double __x) noexcept (true);






extern long double ceill (long double __x) noexcept (true) __attribute__ ((__const__)); extern long double __ceill (long double __x) noexcept (true) __attribute__ ((__const__));


extern long double fabsl (long double __x) noexcept (true) __attribute__ ((__const__)); extern long double __fabsl (long double __x) noexcept (true) __attribute__ ((__const__));


extern long double floorl (long double __x) noexcept (true) __attribute__ ((__const__)); extern long double __floorl (long double __x) noexcept (true) __attribute__ ((__const__));


extern long double fmodl (long double __x, long double __y) noexcept (true); extern long double __fmodl (long double __x, long double __y) noexcept (true);
# 177 "/usr/include/bits/mathcalls.h" 3 4
extern int isinfl (long double __value) noexcept (true)
  __attribute__ ((__const__));




extern int finitel (long double __value) noexcept (true)
  __attribute__ ((__const__));


extern long double dreml (long double __x, long double __y) noexcept (true); extern long double __dreml (long double __x, long double __y) noexcept (true);



extern long double significandl (long double __x) noexcept (true); extern long double __significandl (long double __x) noexcept (true);






extern long double copysignl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__)); extern long double __copysignl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));




extern long double nanl (const char *__tagb) noexcept (true); extern long double __nanl (const char *__tagb) noexcept (true);
# 213 "/usr/include/bits/mathcalls.h" 3 4
extern int isnanl (long double __value) noexcept (true)
  __attribute__ ((__const__));





extern long double j0l (long double) noexcept (true); extern long double __j0l (long double) noexcept (true);
extern long double j1l (long double) noexcept (true); extern long double __j1l (long double) noexcept (true);
extern long double jnl (int, long double) noexcept (true); extern long double __jnl (int, long double) noexcept (true);
extern long double y0l (long double) noexcept (true); extern long double __y0l (long double) noexcept (true);
extern long double y1l (long double) noexcept (true); extern long double __y1l (long double) noexcept (true);
extern long double ynl (int, long double) noexcept (true); extern long double __ynl (int, long double) noexcept (true);





extern long double erfl (long double) noexcept (true); extern long double __erfl (long double) noexcept (true);
extern long double erfcl (long double) noexcept (true); extern long double __erfcl (long double) noexcept (true);
extern long double lgammal (long double) noexcept (true); extern long double __lgammal (long double) noexcept (true);




extern long double tgammal (long double) noexcept (true); extern long double __tgammal (long double) noexcept (true);





extern long double gammal (long double) noexcept (true); extern long double __gammal (long double) noexcept (true);







extern long double lgammal_r (long double, int *__signgamp) noexcept (true); extern long double __lgammal_r (long double, int *__signgamp) noexcept (true);






extern long double rintl (long double __x) noexcept (true); extern long double __rintl (long double __x) noexcept (true);


extern long double nextafterl (long double __x, long double __y) noexcept (true); extern long double __nextafterl (long double __x, long double __y) noexcept (true);

extern long double nexttowardl (long double __x, long double __y) noexcept (true); extern long double __nexttowardl (long double __x, long double __y) noexcept (true);




extern long double nextdownl (long double __x) noexcept (true); extern long double __nextdownl (long double __x) noexcept (true);

extern long double nextupl (long double __x) noexcept (true); extern long double __nextupl (long double __x) noexcept (true);



extern long double remainderl (long double __x, long double __y) noexcept (true); extern long double __remainderl (long double __x, long double __y) noexcept (true);



extern long double scalbnl (long double __x, int __n) noexcept (true); extern long double __scalbnl (long double __x, int __n) noexcept (true);



extern int ilogbl (long double __x) noexcept (true); extern int __ilogbl (long double __x) noexcept (true);




extern long int llogbl (long double __x) noexcept (true); extern long int __llogbl (long double __x) noexcept (true);




extern long double scalblnl (long double __x, long int __n) noexcept (true); extern long double __scalblnl (long double __x, long int __n) noexcept (true);



extern long double nearbyintl (long double __x) noexcept (true); extern long double __nearbyintl (long double __x) noexcept (true);



extern long double roundl (long double __x) noexcept (true) __attribute__ ((__const__)); extern long double __roundl (long double __x) noexcept (true) __attribute__ ((__const__));



extern long double truncl (long double __x) noexcept (true) __attribute__ ((__const__)); extern long double __truncl (long double __x) noexcept (true) __attribute__ ((__const__));




extern long double remquol (long double __x, long double __y, int *__quo) noexcept (true); extern long double __remquol (long double __x, long double __y, int *__quo) noexcept (true);






extern long int lrintl (long double __x) noexcept (true); extern long int __lrintl (long double __x) noexcept (true);
__extension__
extern long long int llrintl (long double __x) noexcept (true); extern long long int __llrintl (long double __x) noexcept (true);



extern long int lroundl (long double __x) noexcept (true); extern long int __lroundl (long double __x) noexcept (true);
__extension__
extern long long int llroundl (long double __x) noexcept (true); extern long long int __llroundl (long double __x) noexcept (true);



extern long double fdiml (long double __x, long double __y) noexcept (true); extern long double __fdiml (long double __x, long double __y) noexcept (true);


extern long double fmaxl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__)); extern long double __fmaxl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));


extern long double fminl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__)); extern long double __fminl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));


extern long double fmal (long double __x, long double __y, long double __z) noexcept (true); extern long double __fmal (long double __x, long double __y, long double __z) noexcept (true);




extern long double roundevenl (long double __x) noexcept (true) __attribute__ ((__const__)); extern long double __roundevenl (long double __x) noexcept (true) __attribute__ ((__const__));



extern __intmax_t fromfpl (long double __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpl (long double __x, int __round, unsigned int __width) noexcept (true)
                            ;



extern __uintmax_t ufromfpl (long double __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpl (long double __x, int __round, unsigned int __width) noexcept (true)
                              ;




extern __intmax_t fromfpxl (long double __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpxl (long double __x, int __round, unsigned int __width) noexcept (true)
                             ;




extern __uintmax_t ufromfpxl (long double __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpxl (long double __x, int __round, unsigned int __width) noexcept (true)
                               ;


extern long double fmaxmagl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__)); extern long double __fmaxmagl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));


extern long double fminmagl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__)); extern long double __fminmagl (long double __x, long double __y) noexcept (true) __attribute__ ((__const__));


extern int canonicalizel (long double *__cx, const long double *__x) noexcept (true);




extern int totalorderl (const long double *__x, const long double *__y) noexcept (true)

     __attribute__ ((__pure__));


extern int totalordermagl (const long double *__x, const long double *__y) noexcept (true)

     __attribute__ ((__pure__));


extern long double getpayloadl (const long double *__x) noexcept (true); extern long double __getpayloadl (const long double *__x) noexcept (true);


extern int setpayloadl (long double *__x, long double __payload) noexcept (true);


extern int setpayloadsigl (long double *__x, long double __payload) noexcept (true);







extern long double scalbl (long double __x, long double __n) noexcept (true); extern long double __scalbl (long double __x, long double __n) noexcept (true);
# 386 "/usr/include/math.h" 2 3 4
# 436 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/bits/mathcalls.h" 3 4
extern _Float32 acosf32 (_Float32 __x) noexcept (true); extern _Float32 __acosf32 (_Float32 __x) noexcept (true);

extern _Float32 asinf32 (_Float32 __x) noexcept (true); extern _Float32 __asinf32 (_Float32 __x) noexcept (true);

extern _Float32 atanf32 (_Float32 __x) noexcept (true); extern _Float32 __atanf32 (_Float32 __x) noexcept (true);

extern _Float32 atan2f32 (_Float32 __y, _Float32 __x) noexcept (true); extern _Float32 __atan2f32 (_Float32 __y, _Float32 __x) noexcept (true);


 extern _Float32 cosf32 (_Float32 __x) noexcept (true); extern _Float32 __cosf32 (_Float32 __x) noexcept (true);

 extern _Float32 sinf32 (_Float32 __x) noexcept (true); extern _Float32 __sinf32 (_Float32 __x) noexcept (true);

extern _Float32 tanf32 (_Float32 __x) noexcept (true); extern _Float32 __tanf32 (_Float32 __x) noexcept (true);




extern _Float32 coshf32 (_Float32 __x) noexcept (true); extern _Float32 __coshf32 (_Float32 __x) noexcept (true);

extern _Float32 sinhf32 (_Float32 __x) noexcept (true); extern _Float32 __sinhf32 (_Float32 __x) noexcept (true);

extern _Float32 tanhf32 (_Float32 __x) noexcept (true); extern _Float32 __tanhf32 (_Float32 __x) noexcept (true);



 extern void sincosf32 (_Float32 __x, _Float32 *__sinx, _Float32 *__cosx) noexcept (true); extern void __sincosf32 (_Float32 __x, _Float32 *__sinx, _Float32 *__cosx) noexcept (true)
                                                        ;




extern _Float32 acoshf32 (_Float32 __x) noexcept (true); extern _Float32 __acoshf32 (_Float32 __x) noexcept (true);

extern _Float32 asinhf32 (_Float32 __x) noexcept (true); extern _Float32 __asinhf32 (_Float32 __x) noexcept (true);

extern _Float32 atanhf32 (_Float32 __x) noexcept (true); extern _Float32 __atanhf32 (_Float32 __x) noexcept (true);





 extern _Float32 expf32 (_Float32 __x) noexcept (true); extern _Float32 __expf32 (_Float32 __x) noexcept (true);


extern _Float32 frexpf32 (_Float32 __x, int *__exponent) noexcept (true); extern _Float32 __frexpf32 (_Float32 __x, int *__exponent) noexcept (true);


extern _Float32 ldexpf32 (_Float32 __x, int __exponent) noexcept (true); extern _Float32 __ldexpf32 (_Float32 __x, int __exponent) noexcept (true);


 extern _Float32 logf32 (_Float32 __x) noexcept (true); extern _Float32 __logf32 (_Float32 __x) noexcept (true);


extern _Float32 log10f32 (_Float32 __x) noexcept (true); extern _Float32 __log10f32 (_Float32 __x) noexcept (true);


extern _Float32 modff32 (_Float32 __x, _Float32 *__iptr) noexcept (true); extern _Float32 __modff32 (_Float32 __x, _Float32 *__iptr) noexcept (true) __attribute__ ((__nonnull__ (2)));



extern _Float32 exp10f32 (_Float32 __x) noexcept (true); extern _Float32 __exp10f32 (_Float32 __x) noexcept (true);




extern _Float32 expm1f32 (_Float32 __x) noexcept (true); extern _Float32 __expm1f32 (_Float32 __x) noexcept (true);


extern _Float32 log1pf32 (_Float32 __x) noexcept (true); extern _Float32 __log1pf32 (_Float32 __x) noexcept (true);


extern _Float32 logbf32 (_Float32 __x) noexcept (true); extern _Float32 __logbf32 (_Float32 __x) noexcept (true);




extern _Float32 exp2f32 (_Float32 __x) noexcept (true); extern _Float32 __exp2f32 (_Float32 __x) noexcept (true);


extern _Float32 log2f32 (_Float32 __x) noexcept (true); extern _Float32 __log2f32 (_Float32 __x) noexcept (true);






 extern _Float32 powf32 (_Float32 __x, _Float32 __y) noexcept (true); extern _Float32 __powf32 (_Float32 __x, _Float32 __y) noexcept (true);


extern _Float32 sqrtf32 (_Float32 __x) noexcept (true); extern _Float32 __sqrtf32 (_Float32 __x) noexcept (true);



extern _Float32 hypotf32 (_Float32 __x, _Float32 __y) noexcept (true); extern _Float32 __hypotf32 (_Float32 __x, _Float32 __y) noexcept (true);




extern _Float32 cbrtf32 (_Float32 __x) noexcept (true); extern _Float32 __cbrtf32 (_Float32 __x) noexcept (true);






extern _Float32 ceilf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__)); extern _Float32 __ceilf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__));


extern _Float32 fabsf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__)); extern _Float32 __fabsf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__));


extern _Float32 floorf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__)); extern _Float32 __floorf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__));


extern _Float32 fmodf32 (_Float32 __x, _Float32 __y) noexcept (true); extern _Float32 __fmodf32 (_Float32 __x, _Float32 __y) noexcept (true);
# 198 "/usr/include/bits/mathcalls.h" 3 4
extern _Float32 copysignf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__)); extern _Float32 __copysignf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));




extern _Float32 nanf32 (const char *__tagb) noexcept (true); extern _Float32 __nanf32 (const char *__tagb) noexcept (true);
# 220 "/usr/include/bits/mathcalls.h" 3 4
extern _Float32 j0f32 (_Float32) noexcept (true); extern _Float32 __j0f32 (_Float32) noexcept (true);
extern _Float32 j1f32 (_Float32) noexcept (true); extern _Float32 __j1f32 (_Float32) noexcept (true);
extern _Float32 jnf32 (int, _Float32) noexcept (true); extern _Float32 __jnf32 (int, _Float32) noexcept (true);
extern _Float32 y0f32 (_Float32) noexcept (true); extern _Float32 __y0f32 (_Float32) noexcept (true);
extern _Float32 y1f32 (_Float32) noexcept (true); extern _Float32 __y1f32 (_Float32) noexcept (true);
extern _Float32 ynf32 (int, _Float32) noexcept (true); extern _Float32 __ynf32 (int, _Float32) noexcept (true);





extern _Float32 erff32 (_Float32) noexcept (true); extern _Float32 __erff32 (_Float32) noexcept (true);
extern _Float32 erfcf32 (_Float32) noexcept (true); extern _Float32 __erfcf32 (_Float32) noexcept (true);
extern _Float32 lgammaf32 (_Float32) noexcept (true); extern _Float32 __lgammaf32 (_Float32) noexcept (true);




extern _Float32 tgammaf32 (_Float32) noexcept (true); extern _Float32 __tgammaf32 (_Float32) noexcept (true);
# 252 "/usr/include/bits/mathcalls.h" 3 4
extern _Float32 lgammaf32_r (_Float32, int *__signgamp) noexcept (true); extern _Float32 __lgammaf32_r (_Float32, int *__signgamp) noexcept (true);






extern _Float32 rintf32 (_Float32 __x) noexcept (true); extern _Float32 __rintf32 (_Float32 __x) noexcept (true);


extern _Float32 nextafterf32 (_Float32 __x, _Float32 __y) noexcept (true); extern _Float32 __nextafterf32 (_Float32 __x, _Float32 __y) noexcept (true);






extern _Float32 nextdownf32 (_Float32 __x) noexcept (true); extern _Float32 __nextdownf32 (_Float32 __x) noexcept (true);

extern _Float32 nextupf32 (_Float32 __x) noexcept (true); extern _Float32 __nextupf32 (_Float32 __x) noexcept (true);



extern _Float32 remainderf32 (_Float32 __x, _Float32 __y) noexcept (true); extern _Float32 __remainderf32 (_Float32 __x, _Float32 __y) noexcept (true);



extern _Float32 scalbnf32 (_Float32 __x, int __n) noexcept (true); extern _Float32 __scalbnf32 (_Float32 __x, int __n) noexcept (true);



extern int ilogbf32 (_Float32 __x) noexcept (true); extern int __ilogbf32 (_Float32 __x) noexcept (true);




extern long int llogbf32 (_Float32 __x) noexcept (true); extern long int __llogbf32 (_Float32 __x) noexcept (true);




extern _Float32 scalblnf32 (_Float32 __x, long int __n) noexcept (true); extern _Float32 __scalblnf32 (_Float32 __x, long int __n) noexcept (true);



extern _Float32 nearbyintf32 (_Float32 __x) noexcept (true); extern _Float32 __nearbyintf32 (_Float32 __x) noexcept (true);



extern _Float32 roundf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__)); extern _Float32 __roundf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__));



extern _Float32 truncf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__)); extern _Float32 __truncf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__));




extern _Float32 remquof32 (_Float32 __x, _Float32 __y, int *__quo) noexcept (true); extern _Float32 __remquof32 (_Float32 __x, _Float32 __y, int *__quo) noexcept (true);






extern long int lrintf32 (_Float32 __x) noexcept (true); extern long int __lrintf32 (_Float32 __x) noexcept (true);
__extension__
extern long long int llrintf32 (_Float32 __x) noexcept (true); extern long long int __llrintf32 (_Float32 __x) noexcept (true);



extern long int lroundf32 (_Float32 __x) noexcept (true); extern long int __lroundf32 (_Float32 __x) noexcept (true);
__extension__
extern long long int llroundf32 (_Float32 __x) noexcept (true); extern long long int __llroundf32 (_Float32 __x) noexcept (true);



extern _Float32 fdimf32 (_Float32 __x, _Float32 __y) noexcept (true); extern _Float32 __fdimf32 (_Float32 __x, _Float32 __y) noexcept (true);


extern _Float32 fmaxf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__)); extern _Float32 __fmaxf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));


extern _Float32 fminf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__)); extern _Float32 __fminf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));


extern _Float32 fmaf32 (_Float32 __x, _Float32 __y, _Float32 __z) noexcept (true); extern _Float32 __fmaf32 (_Float32 __x, _Float32 __y, _Float32 __z) noexcept (true);




extern _Float32 roundevenf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__)); extern _Float32 __roundevenf32 (_Float32 __x) noexcept (true) __attribute__ ((__const__));



extern __intmax_t fromfpf32 (_Float32 __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpf32 (_Float32 __x, int __round, unsigned int __width) noexcept (true)
                            ;



extern __uintmax_t ufromfpf32 (_Float32 __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpf32 (_Float32 __x, int __round, unsigned int __width) noexcept (true)
                              ;




extern __intmax_t fromfpxf32 (_Float32 __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpxf32 (_Float32 __x, int __round, unsigned int __width) noexcept (true)
                             ;




extern __uintmax_t ufromfpxf32 (_Float32 __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpxf32 (_Float32 __x, int __round, unsigned int __width) noexcept (true)
                               ;


extern _Float32 fmaxmagf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__)); extern _Float32 __fmaxmagf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));


extern _Float32 fminmagf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__)); extern _Float32 __fminmagf32 (_Float32 __x, _Float32 __y) noexcept (true) __attribute__ ((__const__));


extern int canonicalizef32 (_Float32 *__cx, const _Float32 *__x) noexcept (true);




extern int totalorderf32 (const _Float32 *__x, const _Float32 *__y) noexcept (true)

     __attribute__ ((__pure__));


extern int totalordermagf32 (const _Float32 *__x, const _Float32 *__y) noexcept (true)

     __attribute__ ((__pure__));


extern _Float32 getpayloadf32 (const _Float32 *__x) noexcept (true); extern _Float32 __getpayloadf32 (const _Float32 *__x) noexcept (true);


extern int setpayloadf32 (_Float32 *__x, _Float32 __payload) noexcept (true);


extern int setpayloadsigf32 (_Float32 *__x, _Float32 __payload) noexcept (true);
# 437 "/usr/include/math.h" 2 3 4
# 453 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/bits/mathcalls.h" 3 4
extern _Float64 acosf64 (_Float64 __x) noexcept (true); extern _Float64 __acosf64 (_Float64 __x) noexcept (true);

extern _Float64 asinf64 (_Float64 __x) noexcept (true); extern _Float64 __asinf64 (_Float64 __x) noexcept (true);

extern _Float64 atanf64 (_Float64 __x) noexcept (true); extern _Float64 __atanf64 (_Float64 __x) noexcept (true);

extern _Float64 atan2f64 (_Float64 __y, _Float64 __x) noexcept (true); extern _Float64 __atan2f64 (_Float64 __y, _Float64 __x) noexcept (true);


 extern _Float64 cosf64 (_Float64 __x) noexcept (true); extern _Float64 __cosf64 (_Float64 __x) noexcept (true);

 extern _Float64 sinf64 (_Float64 __x) noexcept (true); extern _Float64 __sinf64 (_Float64 __x) noexcept (true);

extern _Float64 tanf64 (_Float64 __x) noexcept (true); extern _Float64 __tanf64 (_Float64 __x) noexcept (true);




extern _Float64 coshf64 (_Float64 __x) noexcept (true); extern _Float64 __coshf64 (_Float64 __x) noexcept (true);

extern _Float64 sinhf64 (_Float64 __x) noexcept (true); extern _Float64 __sinhf64 (_Float64 __x) noexcept (true);

extern _Float64 tanhf64 (_Float64 __x) noexcept (true); extern _Float64 __tanhf64 (_Float64 __x) noexcept (true);



 extern void sincosf64 (_Float64 __x, _Float64 *__sinx, _Float64 *__cosx) noexcept (true); extern void __sincosf64 (_Float64 __x, _Float64 *__sinx, _Float64 *__cosx) noexcept (true)
                                                        ;




extern _Float64 acoshf64 (_Float64 __x) noexcept (true); extern _Float64 __acoshf64 (_Float64 __x) noexcept (true);

extern _Float64 asinhf64 (_Float64 __x) noexcept (true); extern _Float64 __asinhf64 (_Float64 __x) noexcept (true);

extern _Float64 atanhf64 (_Float64 __x) noexcept (true); extern _Float64 __atanhf64 (_Float64 __x) noexcept (true);





 extern _Float64 expf64 (_Float64 __x) noexcept (true); extern _Float64 __expf64 (_Float64 __x) noexcept (true);


extern _Float64 frexpf64 (_Float64 __x, int *__exponent) noexcept (true); extern _Float64 __frexpf64 (_Float64 __x, int *__exponent) noexcept (true);


extern _Float64 ldexpf64 (_Float64 __x, int __exponent) noexcept (true); extern _Float64 __ldexpf64 (_Float64 __x, int __exponent) noexcept (true);


 extern _Float64 logf64 (_Float64 __x) noexcept (true); extern _Float64 __logf64 (_Float64 __x) noexcept (true);


extern _Float64 log10f64 (_Float64 __x) noexcept (true); extern _Float64 __log10f64 (_Float64 __x) noexcept (true);


extern _Float64 modff64 (_Float64 __x, _Float64 *__iptr) noexcept (true); extern _Float64 __modff64 (_Float64 __x, _Float64 *__iptr) noexcept (true) __attribute__ ((__nonnull__ (2)));



extern _Float64 exp10f64 (_Float64 __x) noexcept (true); extern _Float64 __exp10f64 (_Float64 __x) noexcept (true);




extern _Float64 expm1f64 (_Float64 __x) noexcept (true); extern _Float64 __expm1f64 (_Float64 __x) noexcept (true);


extern _Float64 log1pf64 (_Float64 __x) noexcept (true); extern _Float64 __log1pf64 (_Float64 __x) noexcept (true);


extern _Float64 logbf64 (_Float64 __x) noexcept (true); extern _Float64 __logbf64 (_Float64 __x) noexcept (true);




extern _Float64 exp2f64 (_Float64 __x) noexcept (true); extern _Float64 __exp2f64 (_Float64 __x) noexcept (true);


extern _Float64 log2f64 (_Float64 __x) noexcept (true); extern _Float64 __log2f64 (_Float64 __x) noexcept (true);






 extern _Float64 powf64 (_Float64 __x, _Float64 __y) noexcept (true); extern _Float64 __powf64 (_Float64 __x, _Float64 __y) noexcept (true);


extern _Float64 sqrtf64 (_Float64 __x) noexcept (true); extern _Float64 __sqrtf64 (_Float64 __x) noexcept (true);



extern _Float64 hypotf64 (_Float64 __x, _Float64 __y) noexcept (true); extern _Float64 __hypotf64 (_Float64 __x, _Float64 __y) noexcept (true);




extern _Float64 cbrtf64 (_Float64 __x) noexcept (true); extern _Float64 __cbrtf64 (_Float64 __x) noexcept (true);






extern _Float64 ceilf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__)); extern _Float64 __ceilf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__));


extern _Float64 fabsf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__)); extern _Float64 __fabsf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__));


extern _Float64 floorf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__)); extern _Float64 __floorf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__));


extern _Float64 fmodf64 (_Float64 __x, _Float64 __y) noexcept (true); extern _Float64 __fmodf64 (_Float64 __x, _Float64 __y) noexcept (true);
# 198 "/usr/include/bits/mathcalls.h" 3 4
extern _Float64 copysignf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__)); extern _Float64 __copysignf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));




extern _Float64 nanf64 (const char *__tagb) noexcept (true); extern _Float64 __nanf64 (const char *__tagb) noexcept (true);
# 220 "/usr/include/bits/mathcalls.h" 3 4
extern _Float64 j0f64 (_Float64) noexcept (true); extern _Float64 __j0f64 (_Float64) noexcept (true);
extern _Float64 j1f64 (_Float64) noexcept (true); extern _Float64 __j1f64 (_Float64) noexcept (true);
extern _Float64 jnf64 (int, _Float64) noexcept (true); extern _Float64 __jnf64 (int, _Float64) noexcept (true);
extern _Float64 y0f64 (_Float64) noexcept (true); extern _Float64 __y0f64 (_Float64) noexcept (true);
extern _Float64 y1f64 (_Float64) noexcept (true); extern _Float64 __y1f64 (_Float64) noexcept (true);
extern _Float64 ynf64 (int, _Float64) noexcept (true); extern _Float64 __ynf64 (int, _Float64) noexcept (true);





extern _Float64 erff64 (_Float64) noexcept (true); extern _Float64 __erff64 (_Float64) noexcept (true);
extern _Float64 erfcf64 (_Float64) noexcept (true); extern _Float64 __erfcf64 (_Float64) noexcept (true);
extern _Float64 lgammaf64 (_Float64) noexcept (true); extern _Float64 __lgammaf64 (_Float64) noexcept (true);




extern _Float64 tgammaf64 (_Float64) noexcept (true); extern _Float64 __tgammaf64 (_Float64) noexcept (true);
# 252 "/usr/include/bits/mathcalls.h" 3 4
extern _Float64 lgammaf64_r (_Float64, int *__signgamp) noexcept (true); extern _Float64 __lgammaf64_r (_Float64, int *__signgamp) noexcept (true);






extern _Float64 rintf64 (_Float64 __x) noexcept (true); extern _Float64 __rintf64 (_Float64 __x) noexcept (true);


extern _Float64 nextafterf64 (_Float64 __x, _Float64 __y) noexcept (true); extern _Float64 __nextafterf64 (_Float64 __x, _Float64 __y) noexcept (true);






extern _Float64 nextdownf64 (_Float64 __x) noexcept (true); extern _Float64 __nextdownf64 (_Float64 __x) noexcept (true);

extern _Float64 nextupf64 (_Float64 __x) noexcept (true); extern _Float64 __nextupf64 (_Float64 __x) noexcept (true);



extern _Float64 remainderf64 (_Float64 __x, _Float64 __y) noexcept (true); extern _Float64 __remainderf64 (_Float64 __x, _Float64 __y) noexcept (true);



extern _Float64 scalbnf64 (_Float64 __x, int __n) noexcept (true); extern _Float64 __scalbnf64 (_Float64 __x, int __n) noexcept (true);



extern int ilogbf64 (_Float64 __x) noexcept (true); extern int __ilogbf64 (_Float64 __x) noexcept (true);




extern long int llogbf64 (_Float64 __x) noexcept (true); extern long int __llogbf64 (_Float64 __x) noexcept (true);




extern _Float64 scalblnf64 (_Float64 __x, long int __n) noexcept (true); extern _Float64 __scalblnf64 (_Float64 __x, long int __n) noexcept (true);



extern _Float64 nearbyintf64 (_Float64 __x) noexcept (true); extern _Float64 __nearbyintf64 (_Float64 __x) noexcept (true);



extern _Float64 roundf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__)); extern _Float64 __roundf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__));



extern _Float64 truncf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__)); extern _Float64 __truncf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__));




extern _Float64 remquof64 (_Float64 __x, _Float64 __y, int *__quo) noexcept (true); extern _Float64 __remquof64 (_Float64 __x, _Float64 __y, int *__quo) noexcept (true);






extern long int lrintf64 (_Float64 __x) noexcept (true); extern long int __lrintf64 (_Float64 __x) noexcept (true);
__extension__
extern long long int llrintf64 (_Float64 __x) noexcept (true); extern long long int __llrintf64 (_Float64 __x) noexcept (true);



extern long int lroundf64 (_Float64 __x) noexcept (true); extern long int __lroundf64 (_Float64 __x) noexcept (true);
__extension__
extern long long int llroundf64 (_Float64 __x) noexcept (true); extern long long int __llroundf64 (_Float64 __x) noexcept (true);



extern _Float64 fdimf64 (_Float64 __x, _Float64 __y) noexcept (true); extern _Float64 __fdimf64 (_Float64 __x, _Float64 __y) noexcept (true);


extern _Float64 fmaxf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__)); extern _Float64 __fmaxf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));


extern _Float64 fminf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__)); extern _Float64 __fminf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));


extern _Float64 fmaf64 (_Float64 __x, _Float64 __y, _Float64 __z) noexcept (true); extern _Float64 __fmaf64 (_Float64 __x, _Float64 __y, _Float64 __z) noexcept (true);




extern _Float64 roundevenf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__)); extern _Float64 __roundevenf64 (_Float64 __x) noexcept (true) __attribute__ ((__const__));



extern __intmax_t fromfpf64 (_Float64 __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpf64 (_Float64 __x, int __round, unsigned int __width) noexcept (true)
                            ;



extern __uintmax_t ufromfpf64 (_Float64 __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpf64 (_Float64 __x, int __round, unsigned int __width) noexcept (true)
                              ;




extern __intmax_t fromfpxf64 (_Float64 __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpxf64 (_Float64 __x, int __round, unsigned int __width) noexcept (true)
                             ;




extern __uintmax_t ufromfpxf64 (_Float64 __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpxf64 (_Float64 __x, int __round, unsigned int __width) noexcept (true)
                               ;


extern _Float64 fmaxmagf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__)); extern _Float64 __fmaxmagf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));


extern _Float64 fminmagf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__)); extern _Float64 __fminmagf64 (_Float64 __x, _Float64 __y) noexcept (true) __attribute__ ((__const__));


extern int canonicalizef64 (_Float64 *__cx, const _Float64 *__x) noexcept (true);




extern int totalorderf64 (const _Float64 *__x, const _Float64 *__y) noexcept (true)

     __attribute__ ((__pure__));


extern int totalordermagf64 (const _Float64 *__x, const _Float64 *__y) noexcept (true)

     __attribute__ ((__pure__));


extern _Float64 getpayloadf64 (const _Float64 *__x) noexcept (true); extern _Float64 __getpayloadf64 (const _Float64 *__x) noexcept (true);


extern int setpayloadf64 (_Float64 *__x, _Float64 __payload) noexcept (true);


extern int setpayloadsigf64 (_Float64 *__x, _Float64 __payload) noexcept (true);
# 454 "/usr/include/math.h" 2 3 4
# 467 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls-helper-functions.h" 1 3 4
# 20 "/usr/include/bits/mathcalls-helper-functions.h" 3 4
extern int __fpclassifyf128 (_Float128 __value) noexcept (true)
     __attribute__ ((__const__));


extern int __signbitf128 (_Float128 __value) noexcept (true)
     __attribute__ ((__const__));



extern int __isinff128 (_Float128 __value) noexcept (true)
  __attribute__ ((__const__));


extern int __finitef128 (_Float128 __value) noexcept (true)
  __attribute__ ((__const__));


extern int __isnanf128 (_Float128 __value) noexcept (true)
  __attribute__ ((__const__));


extern int __iseqsigf128 (_Float128 __x, _Float128 __y) noexcept (true);


extern int __issignalingf128 (_Float128 __value) noexcept (true)
     __attribute__ ((__const__));
# 468 "/usr/include/math.h" 2 3 4


# 1 "/usr/include/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/bits/mathcalls.h" 3 4
extern _Float128 acosf128 (_Float128 __x) noexcept (true); extern _Float128 __acosf128 (_Float128 __x) noexcept (true);

extern _Float128 asinf128 (_Float128 __x) noexcept (true); extern _Float128 __asinf128 (_Float128 __x) noexcept (true);

extern _Float128 atanf128 (_Float128 __x) noexcept (true); extern _Float128 __atanf128 (_Float128 __x) noexcept (true);

extern _Float128 atan2f128 (_Float128 __y, _Float128 __x) noexcept (true); extern _Float128 __atan2f128 (_Float128 __y, _Float128 __x) noexcept (true);


 extern _Float128 cosf128 (_Float128 __x) noexcept (true); extern _Float128 __cosf128 (_Float128 __x) noexcept (true);

 extern _Float128 sinf128 (_Float128 __x) noexcept (true); extern _Float128 __sinf128 (_Float128 __x) noexcept (true);

extern _Float128 tanf128 (_Float128 __x) noexcept (true); extern _Float128 __tanf128 (_Float128 __x) noexcept (true);




extern _Float128 coshf128 (_Float128 __x) noexcept (true); extern _Float128 __coshf128 (_Float128 __x) noexcept (true);

extern _Float128 sinhf128 (_Float128 __x) noexcept (true); extern _Float128 __sinhf128 (_Float128 __x) noexcept (true);

extern _Float128 tanhf128 (_Float128 __x) noexcept (true); extern _Float128 __tanhf128 (_Float128 __x) noexcept (true);



 extern void sincosf128 (_Float128 __x, _Float128 *__sinx, _Float128 *__cosx) noexcept (true); extern void __sincosf128 (_Float128 __x, _Float128 *__sinx, _Float128 *__cosx) noexcept (true)
                                                        ;




extern _Float128 acoshf128 (_Float128 __x) noexcept (true); extern _Float128 __acoshf128 (_Float128 __x) noexcept (true);

extern _Float128 asinhf128 (_Float128 __x) noexcept (true); extern _Float128 __asinhf128 (_Float128 __x) noexcept (true);

extern _Float128 atanhf128 (_Float128 __x) noexcept (true); extern _Float128 __atanhf128 (_Float128 __x) noexcept (true);





 extern _Float128 expf128 (_Float128 __x) noexcept (true); extern _Float128 __expf128 (_Float128 __x) noexcept (true);


extern _Float128 frexpf128 (_Float128 __x, int *__exponent) noexcept (true); extern _Float128 __frexpf128 (_Float128 __x, int *__exponent) noexcept (true);


extern _Float128 ldexpf128 (_Float128 __x, int __exponent) noexcept (true); extern _Float128 __ldexpf128 (_Float128 __x, int __exponent) noexcept (true);


 extern _Float128 logf128 (_Float128 __x) noexcept (true); extern _Float128 __logf128 (_Float128 __x) noexcept (true);


extern _Float128 log10f128 (_Float128 __x) noexcept (true); extern _Float128 __log10f128 (_Float128 __x) noexcept (true);


extern _Float128 modff128 (_Float128 __x, _Float128 *__iptr) noexcept (true); extern _Float128 __modff128 (_Float128 __x, _Float128 *__iptr) noexcept (true) __attribute__ ((__nonnull__ (2)));



extern _Float128 exp10f128 (_Float128 __x) noexcept (true); extern _Float128 __exp10f128 (_Float128 __x) noexcept (true);




extern _Float128 expm1f128 (_Float128 __x) noexcept (true); extern _Float128 __expm1f128 (_Float128 __x) noexcept (true);


extern _Float128 log1pf128 (_Float128 __x) noexcept (true); extern _Float128 __log1pf128 (_Float128 __x) noexcept (true);


extern _Float128 logbf128 (_Float128 __x) noexcept (true); extern _Float128 __logbf128 (_Float128 __x) noexcept (true);




extern _Float128 exp2f128 (_Float128 __x) noexcept (true); extern _Float128 __exp2f128 (_Float128 __x) noexcept (true);


extern _Float128 log2f128 (_Float128 __x) noexcept (true); extern _Float128 __log2f128 (_Float128 __x) noexcept (true);






 extern _Float128 powf128 (_Float128 __x, _Float128 __y) noexcept (true); extern _Float128 __powf128 (_Float128 __x, _Float128 __y) noexcept (true);


extern _Float128 sqrtf128 (_Float128 __x) noexcept (true); extern _Float128 __sqrtf128 (_Float128 __x) noexcept (true);



extern _Float128 hypotf128 (_Float128 __x, _Float128 __y) noexcept (true); extern _Float128 __hypotf128 (_Float128 __x, _Float128 __y) noexcept (true);




extern _Float128 cbrtf128 (_Float128 __x) noexcept (true); extern _Float128 __cbrtf128 (_Float128 __x) noexcept (true);






extern _Float128 ceilf128 (_Float128 __x) noexcept (true) __attribute__ ((__const__)); extern _Float128 __ceilf128 (_Float128 __x) noexcept (true) __attribute__ ((__const__));


extern _Float128 fabsf128 (_Float128 __x) noexcept (true) __attribute__ ((__const__)); extern _Float128 __fabsf128 (_Float128 __x) noexcept (true) __attribute__ ((__const__));


extern _Float128 floorf128 (_Float128 __x) noexcept (true) __attribute__ ((__const__)); extern _Float128 __floorf128 (_Float128 __x) noexcept (true) __attribute__ ((__const__));


extern _Float128 fmodf128 (_Float128 __x, _Float128 __y) noexcept (true); extern _Float128 __fmodf128 (_Float128 __x, _Float128 __y) noexcept (true);
# 198 "/usr/include/bits/mathcalls.h" 3 4
extern _Float128 copysignf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__)); extern _Float128 __copysignf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__));




extern _Float128 nanf128 (const char *__tagb) noexcept (true); extern _Float128 __nanf128 (const char *__tagb) noexcept (true);
# 220 "/usr/include/bits/mathcalls.h" 3 4
extern _Float128 j0f128 (_Float128) noexcept (true); extern _Float128 __j0f128 (_Float128) noexcept (true);
extern _Float128 j1f128 (_Float128) noexcept (true); extern _Float128 __j1f128 (_Float128) noexcept (true);
extern _Float128 jnf128 (int, _Float128) noexcept (true); extern _Float128 __jnf128 (int, _Float128) noexcept (true);
extern _Float128 y0f128 (_Float128) noexcept (true); extern _Float128 __y0f128 (_Float128) noexcept (true);
extern _Float128 y1f128 (_Float128) noexcept (true); extern _Float128 __y1f128 (_Float128) noexcept (true);
extern _Float128 ynf128 (int, _Float128) noexcept (true); extern _Float128 __ynf128 (int, _Float128) noexcept (true);





extern _Float128 erff128 (_Float128) noexcept (true); extern _Float128 __erff128 (_Float128) noexcept (true);
extern _Float128 erfcf128 (_Float128) noexcept (true); extern _Float128 __erfcf128 (_Float128) noexcept (true);
extern _Float128 lgammaf128 (_Float128) noexcept (true); extern _Float128 __lgammaf128 (_Float128) noexcept (true);




extern _Float128 tgammaf128 (_Float128) noexcept (true); extern _Float128 __tgammaf128 (_Float128) noexcept (true);
# 252 "/usr/include/bits/mathcalls.h" 3 4
extern _Float128 lgammaf128_r (_Float128, int *__signgamp) noexcept (true); extern _Float128 __lgammaf128_r (_Float128, int *__signgamp) noexcept (true);






extern _Float128 rintf128 (_Float128 __x) noexcept (true); extern _Float128 __rintf128 (_Float128 __x) noexcept (true);


extern _Float128 nextafterf128 (_Float128 __x, _Float128 __y) noexcept (true); extern _Float128 __nextafterf128 (_Float128 __x, _Float128 __y) noexcept (true);






extern _Float128 nextdownf128 (_Float128 __x) noexcept (true); extern _Float128 __nextdownf128 (_Float128 __x) noexcept (true);

extern _Float128 nextupf128 (_Float128 __x) noexcept (true); extern _Float128 __nextupf128 (_Float128 __x) noexcept (true);



extern _Float128 remainderf128 (_Float128 __x, _Float128 __y) noexcept (true); extern _Float128 __remainderf128 (_Float128 __x, _Float128 __y) noexcept (true);



extern _Float128 scalbnf128 (_Float128 __x, int __n) noexcept (true); extern _Float128 __scalbnf128 (_Float128 __x, int __n) noexcept (true);



extern int ilogbf128 (_Float128 __x) noexcept (true); extern int __ilogbf128 (_Float128 __x) noexcept (true);




extern long int llogbf128 (_Float128 __x) noexcept (true); extern long int __llogbf128 (_Float128 __x) noexcept (true);




extern _Float128 scalblnf128 (_Float128 __x, long int __n) noexcept (true); extern _Float128 __scalblnf128 (_Float128 __x, long int __n) noexcept (true);



extern _Float128 nearbyintf128 (_Float128 __x) noexcept (true); extern _Float128 __nearbyintf128 (_Float128 __x) noexcept (true);



extern _Float128 roundf128 (_Float128 __x) noexcept (true) __attribute__ ((__const__)); extern _Float128 __roundf128 (_Float128 __x) noexcept (true) __attribute__ ((__const__));



extern _Float128 truncf128 (_Float128 __x) noexcept (true) __attribute__ ((__const__)); extern _Float128 __truncf128 (_Float128 __x) noexcept (true) __attribute__ ((__const__));




extern _Float128 remquof128 (_Float128 __x, _Float128 __y, int *__quo) noexcept (true); extern _Float128 __remquof128 (_Float128 __x, _Float128 __y, int *__quo) noexcept (true);






extern long int lrintf128 (_Float128 __x) noexcept (true); extern long int __lrintf128 (_Float128 __x) noexcept (true);
__extension__
extern long long int llrintf128 (_Float128 __x) noexcept (true); extern long long int __llrintf128 (_Float128 __x) noexcept (true);



extern long int lroundf128 (_Float128 __x) noexcept (true); extern long int __lroundf128 (_Float128 __x) noexcept (true);
__extension__
extern long long int llroundf128 (_Float128 __x) noexcept (true); extern long long int __llroundf128 (_Float128 __x) noexcept (true);



extern _Float128 fdimf128 (_Float128 __x, _Float128 __y) noexcept (true); extern _Float128 __fdimf128 (_Float128 __x, _Float128 __y) noexcept (true);


extern _Float128 fmaxf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__)); extern _Float128 __fmaxf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__));


extern _Float128 fminf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__)); extern _Float128 __fminf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__));


extern _Float128 fmaf128 (_Float128 __x, _Float128 __y, _Float128 __z) noexcept (true); extern _Float128 __fmaf128 (_Float128 __x, _Float128 __y, _Float128 __z) noexcept (true);




extern _Float128 roundevenf128 (_Float128 __x) noexcept (true) __attribute__ ((__const__)); extern _Float128 __roundevenf128 (_Float128 __x) noexcept (true) __attribute__ ((__const__));



extern __intmax_t fromfpf128 (_Float128 __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpf128 (_Float128 __x, int __round, unsigned int __width) noexcept (true)
                            ;



extern __uintmax_t ufromfpf128 (_Float128 __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpf128 (_Float128 __x, int __round, unsigned int __width) noexcept (true)
                              ;




extern __intmax_t fromfpxf128 (_Float128 __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpxf128 (_Float128 __x, int __round, unsigned int __width) noexcept (true)
                             ;




extern __uintmax_t ufromfpxf128 (_Float128 __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpxf128 (_Float128 __x, int __round, unsigned int __width) noexcept (true)
                               ;


extern _Float128 fmaxmagf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__)); extern _Float128 __fmaxmagf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__));


extern _Float128 fminmagf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__)); extern _Float128 __fminmagf128 (_Float128 __x, _Float128 __y) noexcept (true) __attribute__ ((__const__));


extern int canonicalizef128 (_Float128 *__cx, const _Float128 *__x) noexcept (true);




extern int totalorderf128 (const _Float128 *__x, const _Float128 *__y) noexcept (true)

     __attribute__ ((__pure__));


extern int totalordermagf128 (const _Float128 *__x, const _Float128 *__y) noexcept (true)

     __attribute__ ((__pure__));


extern _Float128 getpayloadf128 (const _Float128 *__x) noexcept (true); extern _Float128 __getpayloadf128 (const _Float128 *__x) noexcept (true);


extern int setpayloadf128 (_Float128 *__x, _Float128 __payload) noexcept (true);


extern int setpayloadsigf128 (_Float128 *__x, _Float128 __payload) noexcept (true);
# 471 "/usr/include/math.h" 2 3 4
# 487 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/bits/mathcalls.h" 3 4
extern _Float32x acosf32x (_Float32x __x) noexcept (true); extern _Float32x __acosf32x (_Float32x __x) noexcept (true);

extern _Float32x asinf32x (_Float32x __x) noexcept (true); extern _Float32x __asinf32x (_Float32x __x) noexcept (true);

extern _Float32x atanf32x (_Float32x __x) noexcept (true); extern _Float32x __atanf32x (_Float32x __x) noexcept (true);

extern _Float32x atan2f32x (_Float32x __y, _Float32x __x) noexcept (true); extern _Float32x __atan2f32x (_Float32x __y, _Float32x __x) noexcept (true);


 extern _Float32x cosf32x (_Float32x __x) noexcept (true); extern _Float32x __cosf32x (_Float32x __x) noexcept (true);

 extern _Float32x sinf32x (_Float32x __x) noexcept (true); extern _Float32x __sinf32x (_Float32x __x) noexcept (true);

extern _Float32x tanf32x (_Float32x __x) noexcept (true); extern _Float32x __tanf32x (_Float32x __x) noexcept (true);




extern _Float32x coshf32x (_Float32x __x) noexcept (true); extern _Float32x __coshf32x (_Float32x __x) noexcept (true);

extern _Float32x sinhf32x (_Float32x __x) noexcept (true); extern _Float32x __sinhf32x (_Float32x __x) noexcept (true);

extern _Float32x tanhf32x (_Float32x __x) noexcept (true); extern _Float32x __tanhf32x (_Float32x __x) noexcept (true);



 extern void sincosf32x (_Float32x __x, _Float32x *__sinx, _Float32x *__cosx) noexcept (true); extern void __sincosf32x (_Float32x __x, _Float32x *__sinx, _Float32x *__cosx) noexcept (true)
                                                        ;




extern _Float32x acoshf32x (_Float32x __x) noexcept (true); extern _Float32x __acoshf32x (_Float32x __x) noexcept (true);

extern _Float32x asinhf32x (_Float32x __x) noexcept (true); extern _Float32x __asinhf32x (_Float32x __x) noexcept (true);

extern _Float32x atanhf32x (_Float32x __x) noexcept (true); extern _Float32x __atanhf32x (_Float32x __x) noexcept (true);





 extern _Float32x expf32x (_Float32x __x) noexcept (true); extern _Float32x __expf32x (_Float32x __x) noexcept (true);


extern _Float32x frexpf32x (_Float32x __x, int *__exponent) noexcept (true); extern _Float32x __frexpf32x (_Float32x __x, int *__exponent) noexcept (true);


extern _Float32x ldexpf32x (_Float32x __x, int __exponent) noexcept (true); extern _Float32x __ldexpf32x (_Float32x __x, int __exponent) noexcept (true);


 extern _Float32x logf32x (_Float32x __x) noexcept (true); extern _Float32x __logf32x (_Float32x __x) noexcept (true);


extern _Float32x log10f32x (_Float32x __x) noexcept (true); extern _Float32x __log10f32x (_Float32x __x) noexcept (true);


extern _Float32x modff32x (_Float32x __x, _Float32x *__iptr) noexcept (true); extern _Float32x __modff32x (_Float32x __x, _Float32x *__iptr) noexcept (true) __attribute__ ((__nonnull__ (2)));



extern _Float32x exp10f32x (_Float32x __x) noexcept (true); extern _Float32x __exp10f32x (_Float32x __x) noexcept (true);




extern _Float32x expm1f32x (_Float32x __x) noexcept (true); extern _Float32x __expm1f32x (_Float32x __x) noexcept (true);


extern _Float32x log1pf32x (_Float32x __x) noexcept (true); extern _Float32x __log1pf32x (_Float32x __x) noexcept (true);


extern _Float32x logbf32x (_Float32x __x) noexcept (true); extern _Float32x __logbf32x (_Float32x __x) noexcept (true);




extern _Float32x exp2f32x (_Float32x __x) noexcept (true); extern _Float32x __exp2f32x (_Float32x __x) noexcept (true);


extern _Float32x log2f32x (_Float32x __x) noexcept (true); extern _Float32x __log2f32x (_Float32x __x) noexcept (true);






 extern _Float32x powf32x (_Float32x __x, _Float32x __y) noexcept (true); extern _Float32x __powf32x (_Float32x __x, _Float32x __y) noexcept (true);


extern _Float32x sqrtf32x (_Float32x __x) noexcept (true); extern _Float32x __sqrtf32x (_Float32x __x) noexcept (true);



extern _Float32x hypotf32x (_Float32x __x, _Float32x __y) noexcept (true); extern _Float32x __hypotf32x (_Float32x __x, _Float32x __y) noexcept (true);




extern _Float32x cbrtf32x (_Float32x __x) noexcept (true); extern _Float32x __cbrtf32x (_Float32x __x) noexcept (true);






extern _Float32x ceilf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__)); extern _Float32x __ceilf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__));


extern _Float32x fabsf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__)); extern _Float32x __fabsf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__));


extern _Float32x floorf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__)); extern _Float32x __floorf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__));


extern _Float32x fmodf32x (_Float32x __x, _Float32x __y) noexcept (true); extern _Float32x __fmodf32x (_Float32x __x, _Float32x __y) noexcept (true);
# 198 "/usr/include/bits/mathcalls.h" 3 4
extern _Float32x copysignf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__)); extern _Float32x __copysignf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));




extern _Float32x nanf32x (const char *__tagb) noexcept (true); extern _Float32x __nanf32x (const char *__tagb) noexcept (true);
# 220 "/usr/include/bits/mathcalls.h" 3 4
extern _Float32x j0f32x (_Float32x) noexcept (true); extern _Float32x __j0f32x (_Float32x) noexcept (true);
extern _Float32x j1f32x (_Float32x) noexcept (true); extern _Float32x __j1f32x (_Float32x) noexcept (true);
extern _Float32x jnf32x (int, _Float32x) noexcept (true); extern _Float32x __jnf32x (int, _Float32x) noexcept (true);
extern _Float32x y0f32x (_Float32x) noexcept (true); extern _Float32x __y0f32x (_Float32x) noexcept (true);
extern _Float32x y1f32x (_Float32x) noexcept (true); extern _Float32x __y1f32x (_Float32x) noexcept (true);
extern _Float32x ynf32x (int, _Float32x) noexcept (true); extern _Float32x __ynf32x (int, _Float32x) noexcept (true);





extern _Float32x erff32x (_Float32x) noexcept (true); extern _Float32x __erff32x (_Float32x) noexcept (true);
extern _Float32x erfcf32x (_Float32x) noexcept (true); extern _Float32x __erfcf32x (_Float32x) noexcept (true);
extern _Float32x lgammaf32x (_Float32x) noexcept (true); extern _Float32x __lgammaf32x (_Float32x) noexcept (true);




extern _Float32x tgammaf32x (_Float32x) noexcept (true); extern _Float32x __tgammaf32x (_Float32x) noexcept (true);
# 252 "/usr/include/bits/mathcalls.h" 3 4
extern _Float32x lgammaf32x_r (_Float32x, int *__signgamp) noexcept (true); extern _Float32x __lgammaf32x_r (_Float32x, int *__signgamp) noexcept (true);






extern _Float32x rintf32x (_Float32x __x) noexcept (true); extern _Float32x __rintf32x (_Float32x __x) noexcept (true);


extern _Float32x nextafterf32x (_Float32x __x, _Float32x __y) noexcept (true); extern _Float32x __nextafterf32x (_Float32x __x, _Float32x __y) noexcept (true);






extern _Float32x nextdownf32x (_Float32x __x) noexcept (true); extern _Float32x __nextdownf32x (_Float32x __x) noexcept (true);

extern _Float32x nextupf32x (_Float32x __x) noexcept (true); extern _Float32x __nextupf32x (_Float32x __x) noexcept (true);



extern _Float32x remainderf32x (_Float32x __x, _Float32x __y) noexcept (true); extern _Float32x __remainderf32x (_Float32x __x, _Float32x __y) noexcept (true);



extern _Float32x scalbnf32x (_Float32x __x, int __n) noexcept (true); extern _Float32x __scalbnf32x (_Float32x __x, int __n) noexcept (true);



extern int ilogbf32x (_Float32x __x) noexcept (true); extern int __ilogbf32x (_Float32x __x) noexcept (true);




extern long int llogbf32x (_Float32x __x) noexcept (true); extern long int __llogbf32x (_Float32x __x) noexcept (true);




extern _Float32x scalblnf32x (_Float32x __x, long int __n) noexcept (true); extern _Float32x __scalblnf32x (_Float32x __x, long int __n) noexcept (true);



extern _Float32x nearbyintf32x (_Float32x __x) noexcept (true); extern _Float32x __nearbyintf32x (_Float32x __x) noexcept (true);



extern _Float32x roundf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__)); extern _Float32x __roundf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__));



extern _Float32x truncf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__)); extern _Float32x __truncf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__));




extern _Float32x remquof32x (_Float32x __x, _Float32x __y, int *__quo) noexcept (true); extern _Float32x __remquof32x (_Float32x __x, _Float32x __y, int *__quo) noexcept (true);






extern long int lrintf32x (_Float32x __x) noexcept (true); extern long int __lrintf32x (_Float32x __x) noexcept (true);
__extension__
extern long long int llrintf32x (_Float32x __x) noexcept (true); extern long long int __llrintf32x (_Float32x __x) noexcept (true);



extern long int lroundf32x (_Float32x __x) noexcept (true); extern long int __lroundf32x (_Float32x __x) noexcept (true);
__extension__
extern long long int llroundf32x (_Float32x __x) noexcept (true); extern long long int __llroundf32x (_Float32x __x) noexcept (true);



extern _Float32x fdimf32x (_Float32x __x, _Float32x __y) noexcept (true); extern _Float32x __fdimf32x (_Float32x __x, _Float32x __y) noexcept (true);


extern _Float32x fmaxf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__)); extern _Float32x __fmaxf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));


extern _Float32x fminf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__)); extern _Float32x __fminf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));


extern _Float32x fmaf32x (_Float32x __x, _Float32x __y, _Float32x __z) noexcept (true); extern _Float32x __fmaf32x (_Float32x __x, _Float32x __y, _Float32x __z) noexcept (true);




extern _Float32x roundevenf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__)); extern _Float32x __roundevenf32x (_Float32x __x) noexcept (true) __attribute__ ((__const__));



extern __intmax_t fromfpf32x (_Float32x __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpf32x (_Float32x __x, int __round, unsigned int __width) noexcept (true)
                            ;



extern __uintmax_t ufromfpf32x (_Float32x __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpf32x (_Float32x __x, int __round, unsigned int __width) noexcept (true)
                              ;




extern __intmax_t fromfpxf32x (_Float32x __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpxf32x (_Float32x __x, int __round, unsigned int __width) noexcept (true)
                             ;




extern __uintmax_t ufromfpxf32x (_Float32x __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpxf32x (_Float32x __x, int __round, unsigned int __width) noexcept (true)
                               ;


extern _Float32x fmaxmagf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__)); extern _Float32x __fmaxmagf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));


extern _Float32x fminmagf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__)); extern _Float32x __fminmagf32x (_Float32x __x, _Float32x __y) noexcept (true) __attribute__ ((__const__));


extern int canonicalizef32x (_Float32x *__cx, const _Float32x *__x) noexcept (true);




extern int totalorderf32x (const _Float32x *__x, const _Float32x *__y) noexcept (true)

     __attribute__ ((__pure__));


extern int totalordermagf32x (const _Float32x *__x, const _Float32x *__y) noexcept (true)

     __attribute__ ((__pure__));


extern _Float32x getpayloadf32x (const _Float32x *__x) noexcept (true); extern _Float32x __getpayloadf32x (const _Float32x *__x) noexcept (true);


extern int setpayloadf32x (_Float32x *__x, _Float32x __payload) noexcept (true);


extern int setpayloadsigf32x (_Float32x *__x, _Float32x __payload) noexcept (true);
# 488 "/usr/include/math.h" 2 3 4
# 504 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/bits/mathcalls.h" 3 4
extern _Float64x acosf64x (_Float64x __x) noexcept (true); extern _Float64x __acosf64x (_Float64x __x) noexcept (true);

extern _Float64x asinf64x (_Float64x __x) noexcept (true); extern _Float64x __asinf64x (_Float64x __x) noexcept (true);

extern _Float64x atanf64x (_Float64x __x) noexcept (true); extern _Float64x __atanf64x (_Float64x __x) noexcept (true);

extern _Float64x atan2f64x (_Float64x __y, _Float64x __x) noexcept (true); extern _Float64x __atan2f64x (_Float64x __y, _Float64x __x) noexcept (true);


 extern _Float64x cosf64x (_Float64x __x) noexcept (true); extern _Float64x __cosf64x (_Float64x __x) noexcept (true);

 extern _Float64x sinf64x (_Float64x __x) noexcept (true); extern _Float64x __sinf64x (_Float64x __x) noexcept (true);

extern _Float64x tanf64x (_Float64x __x) noexcept (true); extern _Float64x __tanf64x (_Float64x __x) noexcept (true);




extern _Float64x coshf64x (_Float64x __x) noexcept (true); extern _Float64x __coshf64x (_Float64x __x) noexcept (true);

extern _Float64x sinhf64x (_Float64x __x) noexcept (true); extern _Float64x __sinhf64x (_Float64x __x) noexcept (true);

extern _Float64x tanhf64x (_Float64x __x) noexcept (true); extern _Float64x __tanhf64x (_Float64x __x) noexcept (true);



 extern void sincosf64x (_Float64x __x, _Float64x *__sinx, _Float64x *__cosx) noexcept (true); extern void __sincosf64x (_Float64x __x, _Float64x *__sinx, _Float64x *__cosx) noexcept (true)
                                                        ;




extern _Float64x acoshf64x (_Float64x __x) noexcept (true); extern _Float64x __acoshf64x (_Float64x __x) noexcept (true);

extern _Float64x asinhf64x (_Float64x __x) noexcept (true); extern _Float64x __asinhf64x (_Float64x __x) noexcept (true);

extern _Float64x atanhf64x (_Float64x __x) noexcept (true); extern _Float64x __atanhf64x (_Float64x __x) noexcept (true);





 extern _Float64x expf64x (_Float64x __x) noexcept (true); extern _Float64x __expf64x (_Float64x __x) noexcept (true);


extern _Float64x frexpf64x (_Float64x __x, int *__exponent) noexcept (true); extern _Float64x __frexpf64x (_Float64x __x, int *__exponent) noexcept (true);


extern _Float64x ldexpf64x (_Float64x __x, int __exponent) noexcept (true); extern _Float64x __ldexpf64x (_Float64x __x, int __exponent) noexcept (true);


 extern _Float64x logf64x (_Float64x __x) noexcept (true); extern _Float64x __logf64x (_Float64x __x) noexcept (true);


extern _Float64x log10f64x (_Float64x __x) noexcept (true); extern _Float64x __log10f64x (_Float64x __x) noexcept (true);


extern _Float64x modff64x (_Float64x __x, _Float64x *__iptr) noexcept (true); extern _Float64x __modff64x (_Float64x __x, _Float64x *__iptr) noexcept (true) __attribute__ ((__nonnull__ (2)));



extern _Float64x exp10f64x (_Float64x __x) noexcept (true); extern _Float64x __exp10f64x (_Float64x __x) noexcept (true);




extern _Float64x expm1f64x (_Float64x __x) noexcept (true); extern _Float64x __expm1f64x (_Float64x __x) noexcept (true);


extern _Float64x log1pf64x (_Float64x __x) noexcept (true); extern _Float64x __log1pf64x (_Float64x __x) noexcept (true);


extern _Float64x logbf64x (_Float64x __x) noexcept (true); extern _Float64x __logbf64x (_Float64x __x) noexcept (true);




extern _Float64x exp2f64x (_Float64x __x) noexcept (true); extern _Float64x __exp2f64x (_Float64x __x) noexcept (true);


extern _Float64x log2f64x (_Float64x __x) noexcept (true); extern _Float64x __log2f64x (_Float64x __x) noexcept (true);






 extern _Float64x powf64x (_Float64x __x, _Float64x __y) noexcept (true); extern _Float64x __powf64x (_Float64x __x, _Float64x __y) noexcept (true);


extern _Float64x sqrtf64x (_Float64x __x) noexcept (true); extern _Float64x __sqrtf64x (_Float64x __x) noexcept (true);



extern _Float64x hypotf64x (_Float64x __x, _Float64x __y) noexcept (true); extern _Float64x __hypotf64x (_Float64x __x, _Float64x __y) noexcept (true);




extern _Float64x cbrtf64x (_Float64x __x) noexcept (true); extern _Float64x __cbrtf64x (_Float64x __x) noexcept (true);






extern _Float64x ceilf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__)); extern _Float64x __ceilf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__));


extern _Float64x fabsf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__)); extern _Float64x __fabsf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__));


extern _Float64x floorf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__)); extern _Float64x __floorf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__));


extern _Float64x fmodf64x (_Float64x __x, _Float64x __y) noexcept (true); extern _Float64x __fmodf64x (_Float64x __x, _Float64x __y) noexcept (true);
# 198 "/usr/include/bits/mathcalls.h" 3 4
extern _Float64x copysignf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__)); extern _Float64x __copysignf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));




extern _Float64x nanf64x (const char *__tagb) noexcept (true); extern _Float64x __nanf64x (const char *__tagb) noexcept (true);
# 220 "/usr/include/bits/mathcalls.h" 3 4
extern _Float64x j0f64x (_Float64x) noexcept (true); extern _Float64x __j0f64x (_Float64x) noexcept (true);
extern _Float64x j1f64x (_Float64x) noexcept (true); extern _Float64x __j1f64x (_Float64x) noexcept (true);
extern _Float64x jnf64x (int, _Float64x) noexcept (true); extern _Float64x __jnf64x (int, _Float64x) noexcept (true);
extern _Float64x y0f64x (_Float64x) noexcept (true); extern _Float64x __y0f64x (_Float64x) noexcept (true);
extern _Float64x y1f64x (_Float64x) noexcept (true); extern _Float64x __y1f64x (_Float64x) noexcept (true);
extern _Float64x ynf64x (int, _Float64x) noexcept (true); extern _Float64x __ynf64x (int, _Float64x) noexcept (true);





extern _Float64x erff64x (_Float64x) noexcept (true); extern _Float64x __erff64x (_Float64x) noexcept (true);
extern _Float64x erfcf64x (_Float64x) noexcept (true); extern _Float64x __erfcf64x (_Float64x) noexcept (true);
extern _Float64x lgammaf64x (_Float64x) noexcept (true); extern _Float64x __lgammaf64x (_Float64x) noexcept (true);




extern _Float64x tgammaf64x (_Float64x) noexcept (true); extern _Float64x __tgammaf64x (_Float64x) noexcept (true);
# 252 "/usr/include/bits/mathcalls.h" 3 4
extern _Float64x lgammaf64x_r (_Float64x, int *__signgamp) noexcept (true); extern _Float64x __lgammaf64x_r (_Float64x, int *__signgamp) noexcept (true);






extern _Float64x rintf64x (_Float64x __x) noexcept (true); extern _Float64x __rintf64x (_Float64x __x) noexcept (true);


extern _Float64x nextafterf64x (_Float64x __x, _Float64x __y) noexcept (true); extern _Float64x __nextafterf64x (_Float64x __x, _Float64x __y) noexcept (true);






extern _Float64x nextdownf64x (_Float64x __x) noexcept (true); extern _Float64x __nextdownf64x (_Float64x __x) noexcept (true);

extern _Float64x nextupf64x (_Float64x __x) noexcept (true); extern _Float64x __nextupf64x (_Float64x __x) noexcept (true);



extern _Float64x remainderf64x (_Float64x __x, _Float64x __y) noexcept (true); extern _Float64x __remainderf64x (_Float64x __x, _Float64x __y) noexcept (true);



extern _Float64x scalbnf64x (_Float64x __x, int __n) noexcept (true); extern _Float64x __scalbnf64x (_Float64x __x, int __n) noexcept (true);



extern int ilogbf64x (_Float64x __x) noexcept (true); extern int __ilogbf64x (_Float64x __x) noexcept (true);




extern long int llogbf64x (_Float64x __x) noexcept (true); extern long int __llogbf64x (_Float64x __x) noexcept (true);




extern _Float64x scalblnf64x (_Float64x __x, long int __n) noexcept (true); extern _Float64x __scalblnf64x (_Float64x __x, long int __n) noexcept (true);



extern _Float64x nearbyintf64x (_Float64x __x) noexcept (true); extern _Float64x __nearbyintf64x (_Float64x __x) noexcept (true);



extern _Float64x roundf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__)); extern _Float64x __roundf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__));



extern _Float64x truncf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__)); extern _Float64x __truncf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__));




extern _Float64x remquof64x (_Float64x __x, _Float64x __y, int *__quo) noexcept (true); extern _Float64x __remquof64x (_Float64x __x, _Float64x __y, int *__quo) noexcept (true);






extern long int lrintf64x (_Float64x __x) noexcept (true); extern long int __lrintf64x (_Float64x __x) noexcept (true);
__extension__
extern long long int llrintf64x (_Float64x __x) noexcept (true); extern long long int __llrintf64x (_Float64x __x) noexcept (true);



extern long int lroundf64x (_Float64x __x) noexcept (true); extern long int __lroundf64x (_Float64x __x) noexcept (true);
__extension__
extern long long int llroundf64x (_Float64x __x) noexcept (true); extern long long int __llroundf64x (_Float64x __x) noexcept (true);



extern _Float64x fdimf64x (_Float64x __x, _Float64x __y) noexcept (true); extern _Float64x __fdimf64x (_Float64x __x, _Float64x __y) noexcept (true);


extern _Float64x fmaxf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__)); extern _Float64x __fmaxf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));


extern _Float64x fminf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__)); extern _Float64x __fminf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));


extern _Float64x fmaf64x (_Float64x __x, _Float64x __y, _Float64x __z) noexcept (true); extern _Float64x __fmaf64x (_Float64x __x, _Float64x __y, _Float64x __z) noexcept (true);




extern _Float64x roundevenf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__)); extern _Float64x __roundevenf64x (_Float64x __x) noexcept (true) __attribute__ ((__const__));



extern __intmax_t fromfpf64x (_Float64x __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpf64x (_Float64x __x, int __round, unsigned int __width) noexcept (true)
                            ;



extern __uintmax_t ufromfpf64x (_Float64x __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpf64x (_Float64x __x, int __round, unsigned int __width) noexcept (true)
                              ;




extern __intmax_t fromfpxf64x (_Float64x __x, int __round, unsigned int __width) noexcept (true); extern __intmax_t __fromfpxf64x (_Float64x __x, int __round, unsigned int __width) noexcept (true)
                             ;




extern __uintmax_t ufromfpxf64x (_Float64x __x, int __round, unsigned int __width) noexcept (true); extern __uintmax_t __ufromfpxf64x (_Float64x __x, int __round, unsigned int __width) noexcept (true)
                               ;


extern _Float64x fmaxmagf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__)); extern _Float64x __fmaxmagf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));


extern _Float64x fminmagf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__)); extern _Float64x __fminmagf64x (_Float64x __x, _Float64x __y) noexcept (true) __attribute__ ((__const__));


extern int canonicalizef64x (_Float64x *__cx, const _Float64x *__x) noexcept (true);




extern int totalorderf64x (const _Float64x *__x, const _Float64x *__y) noexcept (true)

     __attribute__ ((__pure__));


extern int totalordermagf64x (const _Float64x *__x, const _Float64x *__y) noexcept (true)

     __attribute__ ((__pure__));


extern _Float64x getpayloadf64x (const _Float64x *__x) noexcept (true); extern _Float64x __getpayloadf64x (const _Float64x *__x) noexcept (true);


extern int setpayloadf64x (_Float64x *__x, _Float64x __payload) noexcept (true);


extern int setpayloadsigf64x (_Float64x *__x, _Float64x __payload) noexcept (true);
# 505 "/usr/include/math.h" 2 3 4
# 552 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/bits/mathcalls-narrow.h" 3 4
extern float fadd (double __x, double __y) noexcept (true);


extern float fdiv (double __x, double __y) noexcept (true);


extern float fmul (double __x, double __y) noexcept (true);


extern float fsub (double __x, double __y) noexcept (true);
# 553 "/usr/include/math.h" 2 3 4
# 571 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/bits/mathcalls-narrow.h" 3 4
extern float faddl (long double __x, long double __y) noexcept (true);


extern float fdivl (long double __x, long double __y) noexcept (true);


extern float fmull (long double __x, long double __y) noexcept (true);


extern float fsubl (long double __x, long double __y) noexcept (true);
# 572 "/usr/include/math.h" 2 3 4
# 597 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/bits/mathcalls-narrow.h" 3 4
extern double daddl (long double __x, long double __y) noexcept (true);


extern double ddivl (long double __x, long double __y) noexcept (true);


extern double dmull (long double __x, long double __y) noexcept (true);


extern double dsubl (long double __x, long double __y) noexcept (true);
# 598 "/usr/include/math.h" 2 3 4
# 677 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/bits/mathcalls-narrow.h" 3 4
extern _Float32 f32addf32x (_Float32x __x, _Float32x __y) noexcept (true);


extern _Float32 f32divf32x (_Float32x __x, _Float32x __y) noexcept (true);


extern _Float32 f32mulf32x (_Float32x __x, _Float32x __y) noexcept (true);


extern _Float32 f32subf32x (_Float32x __x, _Float32x __y) noexcept (true);
# 678 "/usr/include/math.h" 2 3 4
# 687 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/bits/mathcalls-narrow.h" 3 4
extern _Float32 f32addf64 (_Float64 __x, _Float64 __y) noexcept (true);


extern _Float32 f32divf64 (_Float64 __x, _Float64 __y) noexcept (true);


extern _Float32 f32mulf64 (_Float64 __x, _Float64 __y) noexcept (true);


extern _Float32 f32subf64 (_Float64 __x, _Float64 __y) noexcept (true);
# 688 "/usr/include/math.h" 2 3 4
# 697 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/bits/mathcalls-narrow.h" 3 4
extern _Float32 f32addf64x (_Float64x __x, _Float64x __y) noexcept (true);


extern _Float32 f32divf64x (_Float64x __x, _Float64x __y) noexcept (true);


extern _Float32 f32mulf64x (_Float64x __x, _Float64x __y) noexcept (true);


extern _Float32 f32subf64x (_Float64x __x, _Float64x __y) noexcept (true);
# 698 "/usr/include/math.h" 2 3 4
# 707 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/bits/mathcalls-narrow.h" 3 4
extern _Float32 f32addf128 (_Float128 __x, _Float128 __y) noexcept (true);


extern _Float32 f32divf128 (_Float128 __x, _Float128 __y) noexcept (true);


extern _Float32 f32mulf128 (_Float128 __x, _Float128 __y) noexcept (true);


extern _Float32 f32subf128 (_Float128 __x, _Float128 __y) noexcept (true);
# 708 "/usr/include/math.h" 2 3 4
# 727 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/bits/mathcalls-narrow.h" 3 4
extern _Float32x f32xaddf64 (_Float64 __x, _Float64 __y) noexcept (true);


extern _Float32x f32xdivf64 (_Float64 __x, _Float64 __y) noexcept (true);


extern _Float32x f32xmulf64 (_Float64 __x, _Float64 __y) noexcept (true);


extern _Float32x f32xsubf64 (_Float64 __x, _Float64 __y) noexcept (true);
# 728 "/usr/include/math.h" 2 3 4
# 737 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/bits/mathcalls-narrow.h" 3 4
extern _Float32x f32xaddf64x (_Float64x __x, _Float64x __y) noexcept (true);


extern _Float32x f32xdivf64x (_Float64x __x, _Float64x __y) noexcept (true);


extern _Float32x f32xmulf64x (_Float64x __x, _Float64x __y) noexcept (true);


extern _Float32x f32xsubf64x (_Float64x __x, _Float64x __y) noexcept (true);
# 738 "/usr/include/math.h" 2 3 4
# 747 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/bits/mathcalls-narrow.h" 3 4
extern _Float32x f32xaddf128 (_Float128 __x, _Float128 __y) noexcept (true);


extern _Float32x f32xdivf128 (_Float128 __x, _Float128 __y) noexcept (true);


extern _Float32x f32xmulf128 (_Float128 __x, _Float128 __y) noexcept (true);


extern _Float32x f32xsubf128 (_Float128 __x, _Float128 __y) noexcept (true);
# 748 "/usr/include/math.h" 2 3 4
# 767 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/bits/mathcalls-narrow.h" 3 4
extern _Float64 f64addf64x (_Float64x __x, _Float64x __y) noexcept (true);


extern _Float64 f64divf64x (_Float64x __x, _Float64x __y) noexcept (true);


extern _Float64 f64mulf64x (_Float64x __x, _Float64x __y) noexcept (true);


extern _Float64 f64subf64x (_Float64x __x, _Float64x __y) noexcept (true);
# 768 "/usr/include/math.h" 2 3 4
# 777 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/bits/mathcalls-narrow.h" 3 4
extern _Float64 f64addf128 (_Float128 __x, _Float128 __y) noexcept (true);


extern _Float64 f64divf128 (_Float128 __x, _Float128 __y) noexcept (true);


extern _Float64 f64mulf128 (_Float128 __x, _Float128 __y) noexcept (true);


extern _Float64 f64subf128 (_Float128 __x, _Float128 __y) noexcept (true);
# 778 "/usr/include/math.h" 2 3 4
# 797 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/bits/mathcalls-narrow.h" 3 4
extern _Float64x f64xaddf128 (_Float128 __x, _Float128 __y) noexcept (true);


extern _Float64x f64xdivf128 (_Float128 __x, _Float128 __y) noexcept (true);


extern _Float64x f64xmulf128 (_Float128 __x, _Float128 __y) noexcept (true);


extern _Float64x f64xsubf128 (_Float128 __x, _Float128 __y) noexcept (true);
# 798 "/usr/include/math.h" 2 3 4
# 834 "/usr/include/math.h" 3 4
extern int signgam;
# 914 "/usr/include/math.h" 3 4
enum
  {
    FP_NAN =

      0,
    FP_INFINITE =

      1,
    FP_ZERO =

      2,
    FP_SUBNORMAL =

      3,
    FP_NORMAL =

      4
  };
# 1034 "/usr/include/math.h" 3 4
# 1 "/usr/include/bits/iscanonical.h" 1 3 4
# 23 "/usr/include/bits/iscanonical.h" 3 4
extern int __iscanonicall (long double __x)
     noexcept (true) __attribute__ ((__const__));
# 46 "/usr/include/bits/iscanonical.h" 3 4
extern "C++" {
inline int iscanonical (float __val) { return ((void) (__typeof (__val)) (__val), 1); }
inline int iscanonical (double __val) { return ((void) (__typeof (__val)) (__val), 1); }
inline int iscanonical (long double __val) { return __iscanonicall (__val); }

inline int iscanonical (_Float128 __val) { return ((void) (__typeof (__val)) (__val), 1); }

}
# 1035 "/usr/include/math.h" 2 3 4
# 1046 "/usr/include/math.h" 3 4
extern "C++" {
inline int issignaling (float __val) { return __issignalingf (__val); }
inline int issignaling (double __val) { return __issignaling (__val); }
inline int
issignaling (long double __val)
{



  return __issignalingl (__val);

}



inline int issignaling (_Float128 __val) { return __issignalingf128 (__val); }

}
# 1077 "/usr/include/math.h" 3 4
extern "C++" {
# 1108 "/usr/include/math.h" 3 4
template <class __T> inline bool
iszero (__T __val)
{
  return __val == 0;
}

}
# 1326 "/usr/include/math.h" 3 4
extern "C++" {
template<typename> struct __iseqsig_type;

template<> struct __iseqsig_type<float>
{
  static int __call (float __x, float __y) throw ()
  {
    return __iseqsigf (__x, __y);
  }
};

template<> struct __iseqsig_type<double>
{
  static int __call (double __x, double __y) throw ()
  {
    return __iseqsig (__x, __y);
  }
};

template<> struct __iseqsig_type<long double>
{
  static int __call (long double __x, long double __y) throw ()
  {

    return __iseqsigl (__x, __y);



  }
};




template<> struct __iseqsig_type<_Float128>
{
  static int __call (_Float128 __x, _Float128 __y) throw ()
  {
    return __iseqsigf128 (__x, __y);
  }
};


template<typename _T1, typename _T2>
inline int
iseqsig (_T1 __x, _T2 __y) throw ()
{

  typedef decltype (((__x) + (__y) + 0.0f)) _T3;



  return __iseqsig_type<_T3>::__call (__x, __y);
}

}




}
# 46 "/usr/include/c++/10.2.0/cmath" 2 3
# 77 "/usr/include/c++/10.2.0/cmath" 3
extern "C++"
{
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::acos;


  inline constexpr float
  acos(float __x)
  { return __builtin_acosf(__x); }

  inline constexpr long double
  acos(long double __x)
  { return __builtin_acosl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    acos(_Tp __x)
    { return __builtin_acos(__x); }

  using ::asin;


  inline constexpr float
  asin(float __x)
  { return __builtin_asinf(__x); }

  inline constexpr long double
  asin(long double __x)
  { return __builtin_asinl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    asin(_Tp __x)
    { return __builtin_asin(__x); }

  using ::atan;


  inline constexpr float
  atan(float __x)
  { return __builtin_atanf(__x); }

  inline constexpr long double
  atan(long double __x)
  { return __builtin_atanl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    atan(_Tp __x)
    { return __builtin_atan(__x); }

  using ::atan2;


  inline constexpr float
  atan2(float __y, float __x)
  { return __builtin_atan2f(__y, __x); }

  inline constexpr long double
  atan2(long double __y, long double __x)
  { return __builtin_atan2l(__y, __x); }


  template<typename _Tp, typename _Up>
    inline constexpr
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    atan2(_Tp __y, _Up __x)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return atan2(__type(__y), __type(__x));
    }

  using ::ceil;


  inline constexpr float
  ceil(float __x)
  { return __builtin_ceilf(__x); }

  inline constexpr long double
  ceil(long double __x)
  { return __builtin_ceill(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    ceil(_Tp __x)
    { return __builtin_ceil(__x); }

  using ::cos;


  inline constexpr float
  cos(float __x)
  { return __builtin_cosf(__x); }

  inline constexpr long double
  cos(long double __x)
  { return __builtin_cosl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    cos(_Tp __x)
    { return __builtin_cos(__x); }

  using ::cosh;


  inline constexpr float
  cosh(float __x)
  { return __builtin_coshf(__x); }

  inline constexpr long double
  cosh(long double __x)
  { return __builtin_coshl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    cosh(_Tp __x)
    { return __builtin_cosh(__x); }

  using ::exp;


  inline constexpr float
  exp(float __x)
  { return __builtin_expf(__x); }

  inline constexpr long double
  exp(long double __x)
  { return __builtin_expl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    exp(_Tp __x)
    { return __builtin_exp(__x); }

  using ::fabs;


  inline constexpr float
  fabs(float __x)
  { return __builtin_fabsf(__x); }

  inline constexpr long double
  fabs(long double __x)
  { return __builtin_fabsl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    fabs(_Tp __x)
    { return __builtin_fabs(__x); }

  using ::floor;


  inline constexpr float
  floor(float __x)
  { return __builtin_floorf(__x); }

  inline constexpr long double
  floor(long double __x)
  { return __builtin_floorl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    floor(_Tp __x)
    { return __builtin_floor(__x); }

  using ::fmod;


  inline constexpr float
  fmod(float __x, float __y)
  { return __builtin_fmodf(__x, __y); }

  inline constexpr long double
  fmod(long double __x, long double __y)
  { return __builtin_fmodl(__x, __y); }


  template<typename _Tp, typename _Up>
    inline constexpr
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fmod(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fmod(__type(__x), __type(__y));
    }

  using ::frexp;


  inline float
  frexp(float __x, int* __exp)
  { return __builtin_frexpf(__x, __exp); }

  inline long double
  frexp(long double __x, int* __exp)
  { return __builtin_frexpl(__x, __exp); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    frexp(_Tp __x, int* __exp)
    { return __builtin_frexp(__x, __exp); }

  using ::ldexp;


  inline constexpr float
  ldexp(float __x, int __exp)
  { return __builtin_ldexpf(__x, __exp); }

  inline constexpr long double
  ldexp(long double __x, int __exp)
  { return __builtin_ldexpl(__x, __exp); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    ldexp(_Tp __x, int __exp)
    { return __builtin_ldexp(__x, __exp); }

  using ::log;


  inline constexpr float
  log(float __x)
  { return __builtin_logf(__x); }

  inline constexpr long double
  log(long double __x)
  { return __builtin_logl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    log(_Tp __x)
    { return __builtin_log(__x); }

  using ::log10;


  inline constexpr float
  log10(float __x)
  { return __builtin_log10f(__x); }

  inline constexpr long double
  log10(long double __x)
  { return __builtin_log10l(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    log10(_Tp __x)
    { return __builtin_log10(__x); }

  using ::modf;


  inline float
  modf(float __x, float* __iptr)
  { return __builtin_modff(__x, __iptr); }

  inline long double
  modf(long double __x, long double* __iptr)
  { return __builtin_modfl(__x, __iptr); }


  using ::pow;


  inline constexpr float
  pow(float __x, float __y)
  { return __builtin_powf(__x, __y); }

  inline constexpr long double
  pow(long double __x, long double __y)
  { return __builtin_powl(__x, __y); }
# 412 "/usr/include/c++/10.2.0/cmath" 3
  template<typename _Tp, typename _Up>
    inline constexpr
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    pow(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return pow(__type(__x), __type(__y));
    }

  using ::sin;


  inline constexpr float
  sin(float __x)
  { return __builtin_sinf(__x); }

  inline constexpr long double
  sin(long double __x)
  { return __builtin_sinl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    sin(_Tp __x)
    { return __builtin_sin(__x); }

  using ::sinh;


  inline constexpr float
  sinh(float __x)
  { return __builtin_sinhf(__x); }

  inline constexpr long double
  sinh(long double __x)
  { return __builtin_sinhl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    sinh(_Tp __x)
    { return __builtin_sinh(__x); }

  using ::sqrt;


  inline constexpr float
  sqrt(float __x)
  { return __builtin_sqrtf(__x); }

  inline constexpr long double
  sqrt(long double __x)
  { return __builtin_sqrtl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    sqrt(_Tp __x)
    { return __builtin_sqrt(__x); }

  using ::tan;


  inline constexpr float
  tan(float __x)
  { return __builtin_tanf(__x); }

  inline constexpr long double
  tan(long double __x)
  { return __builtin_tanl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    tan(_Tp __x)
    { return __builtin_tan(__x); }

  using ::tanh;


  inline constexpr float
  tanh(float __x)
  { return __builtin_tanhf(__x); }

  inline constexpr long double
  tanh(long double __x)
  { return __builtin_tanhl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    tanh(_Tp __x)
    { return __builtin_tanh(__x); }
# 536 "/usr/include/c++/10.2.0/cmath" 3
  constexpr int
  fpclassify(float __x)
  { return __builtin_fpclassify(0, 1, 4,
    3, 2, __x); }

  constexpr int
  fpclassify(double __x)
  { return __builtin_fpclassify(0, 1, 4,
    3, 2, __x); }

  constexpr int
  fpclassify(long double __x)
  { return __builtin_fpclassify(0, 1, 4,
    3, 2, __x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              int>::__type
    fpclassify(_Tp __x)
    { return __x != 0 ? 4 : 2; }



  constexpr bool
  isfinite(float __x)
  { return __builtin_isfinite(__x); }

  constexpr bool
  isfinite(double __x)
  { return __builtin_isfinite(__x); }

  constexpr bool
  isfinite(long double __x)
  { return __builtin_isfinite(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isfinite(_Tp __x)
    { return true; }



  constexpr bool
  isinf(float __x)
  { return __builtin_isinf(__x); }





  constexpr bool
  isinf(double __x)
  { return __builtin_isinf(__x); }


  constexpr bool
  isinf(long double __x)
  { return __builtin_isinf(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isinf(_Tp __x)
    { return false; }



  constexpr bool
  isnan(float __x)
  { return __builtin_isnan(__x); }





  constexpr bool
  isnan(double __x)
  { return __builtin_isnan(__x); }


  constexpr bool
  isnan(long double __x)
  { return __builtin_isnan(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isnan(_Tp __x)
    { return false; }



  constexpr bool
  isnormal(float __x)
  { return __builtin_isnormal(__x); }

  constexpr bool
  isnormal(double __x)
  { return __builtin_isnormal(__x); }

  constexpr bool
  isnormal(long double __x)
  { return __builtin_isnormal(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isnormal(_Tp __x)
    { return __x != 0 ? true : false; }




  constexpr bool
  signbit(float __x)
  { return __builtin_signbit(__x); }

  constexpr bool
  signbit(double __x)
  { return __builtin_signbit(__x); }

  constexpr bool
  signbit(long double __x)
  { return __builtin_signbit(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    signbit(_Tp __x)
    { return __x < 0 ? true : false; }



  constexpr bool
  isgreater(float __x, float __y)
  { return __builtin_isgreater(__x, __y); }

  constexpr bool
  isgreater(double __x, double __y)
  { return __builtin_isgreater(__x, __y); }

  constexpr bool
  isgreater(long double __x, long double __y)
  { return __builtin_isgreater(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isgreater(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isgreater(__type(__x), __type(__y));
    }



  constexpr bool
  isgreaterequal(float __x, float __y)
  { return __builtin_isgreaterequal(__x, __y); }

  constexpr bool
  isgreaterequal(double __x, double __y)
  { return __builtin_isgreaterequal(__x, __y); }

  constexpr bool
  isgreaterequal(long double __x, long double __y)
  { return __builtin_isgreaterequal(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isgreaterequal(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isgreaterequal(__type(__x), __type(__y));
    }



  constexpr bool
  isless(float __x, float __y)
  { return __builtin_isless(__x, __y); }

  constexpr bool
  isless(double __x, double __y)
  { return __builtin_isless(__x, __y); }

  constexpr bool
  isless(long double __x, long double __y)
  { return __builtin_isless(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isless(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isless(__type(__x), __type(__y));
    }



  constexpr bool
  islessequal(float __x, float __y)
  { return __builtin_islessequal(__x, __y); }

  constexpr bool
  islessequal(double __x, double __y)
  { return __builtin_islessequal(__x, __y); }

  constexpr bool
  islessequal(long double __x, long double __y)
  { return __builtin_islessequal(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    islessequal(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_islessequal(__type(__x), __type(__y));
    }



  constexpr bool
  islessgreater(float __x, float __y)
  { return __builtin_islessgreater(__x, __y); }

  constexpr bool
  islessgreater(double __x, double __y)
  { return __builtin_islessgreater(__x, __y); }

  constexpr bool
  islessgreater(long double __x, long double __y)
  { return __builtin_islessgreater(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    islessgreater(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_islessgreater(__type(__x), __type(__y));
    }



  constexpr bool
  isunordered(float __x, float __y)
  { return __builtin_isunordered(__x, __y); }

  constexpr bool
  isunordered(double __x, double __y)
  { return __builtin_isunordered(__x, __y); }

  constexpr bool
  isunordered(long double __x, long double __y)
  { return __builtin_isunordered(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isunordered(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isunordered(__type(__x), __type(__y));
    }
# 1065 "/usr/include/c++/10.2.0/cmath" 3
  using ::double_t;
  using ::float_t;


  using ::acosh;
  using ::acoshf;
  using ::acoshl;

  using ::asinh;
  using ::asinhf;
  using ::asinhl;

  using ::atanh;
  using ::atanhf;
  using ::atanhl;

  using ::cbrt;
  using ::cbrtf;
  using ::cbrtl;

  using ::copysign;
  using ::copysignf;
  using ::copysignl;

  using ::erf;
  using ::erff;
  using ::erfl;

  using ::erfc;
  using ::erfcf;
  using ::erfcl;

  using ::exp2;
  using ::exp2f;
  using ::exp2l;

  using ::expm1;
  using ::expm1f;
  using ::expm1l;

  using ::fdim;
  using ::fdimf;
  using ::fdiml;

  using ::fma;
  using ::fmaf;
  using ::fmal;

  using ::fmax;
  using ::fmaxf;
  using ::fmaxl;

  using ::fmin;
  using ::fminf;
  using ::fminl;

  using ::hypot;
  using ::hypotf;
  using ::hypotl;

  using ::ilogb;
  using ::ilogbf;
  using ::ilogbl;

  using ::lgamma;
  using ::lgammaf;
  using ::lgammal;


  using ::llrint;
  using ::llrintf;
  using ::llrintl;

  using ::llround;
  using ::llroundf;
  using ::llroundl;


  using ::log1p;
  using ::log1pf;
  using ::log1pl;

  using ::log2;
  using ::log2f;
  using ::log2l;

  using ::logb;
  using ::logbf;
  using ::logbl;

  using ::lrint;
  using ::lrintf;
  using ::lrintl;

  using ::lround;
  using ::lroundf;
  using ::lroundl;

  using ::nan;
  using ::nanf;
  using ::nanl;

  using ::nearbyint;
  using ::nearbyintf;
  using ::nearbyintl;

  using ::nextafter;
  using ::nextafterf;
  using ::nextafterl;

  using ::nexttoward;
  using ::nexttowardf;
  using ::nexttowardl;

  using ::remainder;
  using ::remainderf;
  using ::remainderl;

  using ::remquo;
  using ::remquof;
  using ::remquol;

  using ::rint;
  using ::rintf;
  using ::rintl;

  using ::round;
  using ::roundf;
  using ::roundl;

  using ::scalbln;
  using ::scalblnf;
  using ::scalblnl;

  using ::scalbn;
  using ::scalbnf;
  using ::scalbnl;

  using ::tgamma;
  using ::tgammaf;
  using ::tgammal;

  using ::trunc;
  using ::truncf;
  using ::truncl;



  constexpr float
  acosh(float __x)
  { return __builtin_acoshf(__x); }

  constexpr long double
  acosh(long double __x)
  { return __builtin_acoshl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    acosh(_Tp __x)
    { return __builtin_acosh(__x); }



  constexpr float
  asinh(float __x)
  { return __builtin_asinhf(__x); }

  constexpr long double
  asinh(long double __x)
  { return __builtin_asinhl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    asinh(_Tp __x)
    { return __builtin_asinh(__x); }



  constexpr float
  atanh(float __x)
  { return __builtin_atanhf(__x); }

  constexpr long double
  atanh(long double __x)
  { return __builtin_atanhl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    atanh(_Tp __x)
    { return __builtin_atanh(__x); }



  constexpr float
  cbrt(float __x)
  { return __builtin_cbrtf(__x); }

  constexpr long double
  cbrt(long double __x)
  { return __builtin_cbrtl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    cbrt(_Tp __x)
    { return __builtin_cbrt(__x); }



  constexpr float
  copysign(float __x, float __y)
  { return __builtin_copysignf(__x, __y); }

  constexpr long double
  copysign(long double __x, long double __y)
  { return __builtin_copysignl(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    copysign(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return copysign(__type(__x), __type(__y));
    }



  constexpr float
  erf(float __x)
  { return __builtin_erff(__x); }

  constexpr long double
  erf(long double __x)
  { return __builtin_erfl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    erf(_Tp __x)
    { return __builtin_erf(__x); }



  constexpr float
  erfc(float __x)
  { return __builtin_erfcf(__x); }

  constexpr long double
  erfc(long double __x)
  { return __builtin_erfcl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    erfc(_Tp __x)
    { return __builtin_erfc(__x); }



  constexpr float
  exp2(float __x)
  { return __builtin_exp2f(__x); }

  constexpr long double
  exp2(long double __x)
  { return __builtin_exp2l(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    exp2(_Tp __x)
    { return __builtin_exp2(__x); }



  constexpr float
  expm1(float __x)
  { return __builtin_expm1f(__x); }

  constexpr long double
  expm1(long double __x)
  { return __builtin_expm1l(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    expm1(_Tp __x)
    { return __builtin_expm1(__x); }



  constexpr float
  fdim(float __x, float __y)
  { return __builtin_fdimf(__x, __y); }

  constexpr long double
  fdim(long double __x, long double __y)
  { return __builtin_fdiml(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fdim(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fdim(__type(__x), __type(__y));
    }



  constexpr float
  fma(float __x, float __y, float __z)
  { return __builtin_fmaf(__x, __y, __z); }

  constexpr long double
  fma(long double __x, long double __y, long double __z)
  { return __builtin_fmal(__x, __y, __z); }



  template<typename _Tp, typename _Up, typename _Vp>
    constexpr typename __gnu_cxx::__promote_3<_Tp, _Up, _Vp>::__type
    fma(_Tp __x, _Up __y, _Vp __z)
    {
      typedef typename __gnu_cxx::__promote_3<_Tp, _Up, _Vp>::__type __type;
      return fma(__type(__x), __type(__y), __type(__z));
    }



  constexpr float
  fmax(float __x, float __y)
  { return __builtin_fmaxf(__x, __y); }

  constexpr long double
  fmax(long double __x, long double __y)
  { return __builtin_fmaxl(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fmax(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fmax(__type(__x), __type(__y));
    }



  constexpr float
  fmin(float __x, float __y)
  { return __builtin_fminf(__x, __y); }

  constexpr long double
  fmin(long double __x, long double __y)
  { return __builtin_fminl(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fmin(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fmin(__type(__x), __type(__y));
    }



  constexpr float
  hypot(float __x, float __y)
  { return __builtin_hypotf(__x, __y); }

  constexpr long double
  hypot(long double __x, long double __y)
  { return __builtin_hypotl(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    hypot(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return hypot(__type(__x), __type(__y));
    }



  constexpr int
  ilogb(float __x)
  { return __builtin_ilogbf(__x); }

  constexpr int
  ilogb(long double __x)
  { return __builtin_ilogbl(__x); }



  template<typename _Tp>
    constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    int>::__type
    ilogb(_Tp __x)
    { return __builtin_ilogb(__x); }



  constexpr float
  lgamma(float __x)
  { return __builtin_lgammaf(__x); }

  constexpr long double
  lgamma(long double __x)
  { return __builtin_lgammal(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    lgamma(_Tp __x)
    { return __builtin_lgamma(__x); }



  constexpr long long
  llrint(float __x)
  { return __builtin_llrintf(__x); }

  constexpr long long
  llrint(long double __x)
  { return __builtin_llrintl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long long>::__type
    llrint(_Tp __x)
    { return __builtin_llrint(__x); }



  constexpr long long
  llround(float __x)
  { return __builtin_llroundf(__x); }

  constexpr long long
  llround(long double __x)
  { return __builtin_llroundl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long long>::__type
    llround(_Tp __x)
    { return __builtin_llround(__x); }



  constexpr float
  log1p(float __x)
  { return __builtin_log1pf(__x); }

  constexpr long double
  log1p(long double __x)
  { return __builtin_log1pl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    log1p(_Tp __x)
    { return __builtin_log1p(__x); }




  constexpr float
  log2(float __x)
  { return __builtin_log2f(__x); }

  constexpr long double
  log2(long double __x)
  { return __builtin_log2l(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    log2(_Tp __x)
    { return __builtin_log2(__x); }



  constexpr float
  logb(float __x)
  { return __builtin_logbf(__x); }

  constexpr long double
  logb(long double __x)
  { return __builtin_logbl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    logb(_Tp __x)
    { return __builtin_logb(__x); }



  constexpr long
  lrint(float __x)
  { return __builtin_lrintf(__x); }

  constexpr long
  lrint(long double __x)
  { return __builtin_lrintl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long>::__type
    lrint(_Tp __x)
    { return __builtin_lrint(__x); }



  constexpr long
  lround(float __x)
  { return __builtin_lroundf(__x); }

  constexpr long
  lround(long double __x)
  { return __builtin_lroundl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long>::__type
    lround(_Tp __x)
    { return __builtin_lround(__x); }



  constexpr float
  nearbyint(float __x)
  { return __builtin_nearbyintf(__x); }

  constexpr long double
  nearbyint(long double __x)
  { return __builtin_nearbyintl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    nearbyint(_Tp __x)
    { return __builtin_nearbyint(__x); }



  constexpr float
  nextafter(float __x, float __y)
  { return __builtin_nextafterf(__x, __y); }

  constexpr long double
  nextafter(long double __x, long double __y)
  { return __builtin_nextafterl(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    nextafter(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return nextafter(__type(__x), __type(__y));
    }



  constexpr float
  nexttoward(float __x, long double __y)
  { return __builtin_nexttowardf(__x, __y); }

  constexpr long double
  nexttoward(long double __x, long double __y)
  { return __builtin_nexttowardl(__x, __y); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    nexttoward(_Tp __x, long double __y)
    { return __builtin_nexttoward(__x, __y); }



  constexpr float
  remainder(float __x, float __y)
  { return __builtin_remainderf(__x, __y); }

  constexpr long double
  remainder(long double __x, long double __y)
  { return __builtin_remainderl(__x, __y); }



  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    remainder(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return remainder(__type(__x), __type(__y));
    }



  inline float
  remquo(float __x, float __y, int* __pquo)
  { return __builtin_remquof(__x, __y, __pquo); }

  inline long double
  remquo(long double __x, long double __y, int* __pquo)
  { return __builtin_remquol(__x, __y, __pquo); }



  template<typename _Tp, typename _Up>
    inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    remquo(_Tp __x, _Up __y, int* __pquo)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return remquo(__type(__x), __type(__y), __pquo);
    }



  constexpr float
  rint(float __x)
  { return __builtin_rintf(__x); }

  constexpr long double
  rint(long double __x)
  { return __builtin_rintl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    rint(_Tp __x)
    { return __builtin_rint(__x); }



  constexpr float
  round(float __x)
  { return __builtin_roundf(__x); }

  constexpr long double
  round(long double __x)
  { return __builtin_roundl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    round(_Tp __x)
    { return __builtin_round(__x); }



  constexpr float
  scalbln(float __x, long __ex)
  { return __builtin_scalblnf(__x, __ex); }

  constexpr long double
  scalbln(long double __x, long __ex)
  { return __builtin_scalblnl(__x, __ex); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    scalbln(_Tp __x, long __ex)
    { return __builtin_scalbln(__x, __ex); }



  constexpr float
  scalbn(float __x, int __ex)
  { return __builtin_scalbnf(__x, __ex); }

  constexpr long double
  scalbn(long double __x, int __ex)
  { return __builtin_scalbnl(__x, __ex); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    scalbn(_Tp __x, int __ex)
    { return __builtin_scalbn(__x, __ex); }



  constexpr float
  tgamma(float __x)
  { return __builtin_tgammaf(__x); }

  constexpr long double
  tgamma(long double __x)
  { return __builtin_tgammal(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    tgamma(_Tp __x)
    { return __builtin_tgamma(__x); }



  constexpr float
  trunc(float __x)
  { return __builtin_truncf(__x); }

  constexpr long double
  trunc(long double __x)
  { return __builtin_truncl(__x); }



  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    trunc(_Tp __x)
    { return __builtin_trunc(__x); }
# 1923 "/usr/include/c++/10.2.0/cmath" 3

}





}
# 19 "/usr/include/opencascade/Standard_Real.hxx" 2
# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/include/float.h" 1 3 4
# 20 "/usr/include/opencascade/Standard_Real.hxx" 2

# 1 "/usr/include/opencascade/Standard_math.hxx" 1
# 22 "/usr/include/opencascade/Standard_Real.hxx" 2
# 38 "/usr/include/opencascade/Standard_Real.hxx"
 
# 38 "/usr/include/opencascade/Standard_Real.hxx"
               Standard_Integer HashCode (Standard_Real theReal, Standard_Integer theUpperBound);

 Standard_Real ACos (const Standard_Real );
 Standard_Real ACosApprox (const Standard_Real );
 Standard_Real ASin (const Standard_Real );
 Standard_Real ATan2 (const Standard_Real , const Standard_Real );
 Standard_Real NextAfter (const Standard_Real , const Standard_Real );


 Standard_Real Sign(const Standard_Real a, const Standard_Real b);

 Standard_Real ATanh (const Standard_Real );
 Standard_Real ACosh (const Standard_Real );
 Standard_Real Sinh (const Standard_Real );
 Standard_Real Cosh (const Standard_Real );
 Standard_Real Log (const Standard_Real );
 Standard_Real Sqrt (const Standard_Real );




inline Standard_Real RealSmall()
{ return double(2.22507385850720138309023271733240406e-308L); }




inline Standard_Real Abs(const Standard_Real Value)
{ return fabs(Value); }





inline Standard_Boolean IsEqual (const Standard_Real Value1,
      const Standard_Real Value2)
{ return Abs((Value1 - Value2)) < RealSmall(); }
# 87 "/usr/include/opencascade/Standard_Real.hxx"
inline Standard_Integer RealDigits()
{ return 15; }





inline Standard_Real RealEpsilon()
{ return double(2.22044604925031308084726333618164062e-16L); }




inline Standard_Real RealFirst()
{ return -double(1.79769313486231570814527423731704357e+308L); }





inline Standard_Integer RealFirst10Exp()
{ return (-307); }




inline Standard_Real RealLast()
{ return double(1.79769313486231570814527423731704357e+308L); }





inline Standard_Integer RealLast10Exp()
{ return 308; }





inline Standard_Integer RealMantissa()
{ return 53; }




inline Standard_Integer RealRadix()
{ return 2; }




inline Standard_Integer RealSize()
{ return (8 * sizeof(Standard_Real)); }
# 152 "/usr/include/opencascade/Standard_Real.hxx"
inline Standard_Real IntToReal(const Standard_Integer Value)
{ return Value; }




inline Standard_Real ATan(const Standard_Real Value)
{ return atan(Value); }





inline Standard_Real Ceiling (const Standard_Real Value)
{ return ceil(Value); }




inline Standard_Real Cos (const Standard_Real Value)
{ return cos(Value); }
# 184 "/usr/include/opencascade/Standard_Real.hxx"
inline Standard_Real Epsilon (const Standard_Real Value)
{
  Standard_Real aEpsilon;

  if (Value>=0.0){
    aEpsilon = NextAfter(Value, RealLast()) - Value;
  } else {
    aEpsilon = Value - NextAfter(Value, RealFirst());
  }
  return aEpsilon;
}




inline Standard_Real Exp (const Standard_Real Value)
{ return exp(Value); }




inline Standard_Real Floor (const Standard_Real Value)
{ return floor(Value); }




inline Standard_Real IntegerPart (const Standard_Real Value)
{ return ( (Value>0) ? floor(Value) : ceil(Value) ); }





inline Standard_Real Log10 (const Standard_Real Value)
{ return log10(Value); }




inline Standard_Real Max (const Standard_Real Val1,
                              const Standard_Real Val2)
{
  return Val1 >= Val2 ? Val1 : Val2;
}




inline Standard_Real Min (const Standard_Real Val1,
                              const Standard_Real Val2)
{
  return Val1 <= Val2 ? Val1 : Val2;
}




inline Standard_Real Pow (const Standard_Real Value, const Standard_Real P)
{ return pow(Value,P); }




inline Standard_Real RealPart (const Standard_Real Value)
{ return fabs(IntegerPart(Value) - Value); }






inline Standard_Integer RealToInt (const Standard_Real Value)
{



  return Value < 
# 261 "/usr/include/opencascade/Standard_Real.hxx" 3 4
                (-0x7fffffff - 1) 
# 261 "/usr/include/opencascade/Standard_Real.hxx"
                        ? 
# 261 "/usr/include/opencascade/Standard_Real.hxx" 3 4
                          (-0x7fffffff - 1)
    
# 262 "/usr/include/opencascade/Standard_Real.hxx"
   : Value > 0x7fffffff ? 0x7fffffff
    : (Standard_Integer)Value;
}
# 273 "/usr/include/opencascade/Standard_Real.hxx"
inline Standard_ShortReal RealToShortReal (const Standard_Real theVal)
{
  return theVal < -3.40282346638528859811704183484516925e+38F ? -3.40282346638528859811704183484516925e+38F
    : theVal > 3.40282346638528859811704183484516925e+38F ? 3.40282346638528859811704183484516925e+38F
    : (Standard_ShortReal)theVal;
}




inline Standard_Real Round (const Standard_Real Value)
{ return IntegerPart(Value + (Value > 0 ? 0.5 : -0.5)); }




inline Standard_Real Sin (const Standard_Real Value)
{ return sin(Value); }





inline Standard_Real ASinh(const Standard_Real Value)



{ return asinh(Value); }





inline Standard_Real Square(const Standard_Real Value)
{ return Value * Value; }




inline Standard_Real Tan (const Standard_Real Value)
{ return tan(Value); }




inline Standard_Real Tanh (const Standard_Real Value)
{ return tanh(Value); }
# 26 "/usr/include/opencascade/Standard_PrimitiveTypes.hxx" 2
# 1 "/usr/include/opencascade/Standard_Character.hxx" 1
# 29 "/usr/include/opencascade/Standard_Character.hxx"
# 1 "/usr/include/string.h" 1 3 4
# 26 "/usr/include/string.h" 3 4
# 1 "/usr/include/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/string.h" 2 3 4


# 28 "/usr/include/string.h" 3 4
extern "C" {




# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/include/stddef.h" 1 3 4
# 34 "/usr/include/string.h" 2 3 4
# 43 "/usr/include/string.h" 3 4
extern void *memcpy (void *__restrict __dest, const void *__restrict __src,
       size_t __n) noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern void *memmove (void *__dest, const void *__src, size_t __n)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));





extern void *memccpy (void *__restrict __dest, const void *__restrict __src,
        int __c, size_t __n)
    noexcept (true) __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__access__ (__write_only__, 1, 4)));




extern void *memset (void *__s, int __c, size_t __n) noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int memcmp (const void *__s1, const void *__s2, size_t __n)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));



extern "C++"
{
extern void *memchr (void *__s, int __c, size_t __n)
      noexcept (true) __asm ("memchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const void *memchr (const void *__s, int __c, size_t __n)
      noexcept (true) __asm ("memchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 89 "/usr/include/string.h" 3 4
}
# 99 "/usr/include/string.h" 3 4
extern "C++" void *rawmemchr (void *__s, int __c)
     noexcept (true) __asm ("rawmemchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern "C++" const void *rawmemchr (const void *__s, int __c)
     noexcept (true) __asm ("rawmemchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));







extern "C++" void *memrchr (void *__s, int __c, size_t __n)
      noexcept (true) __asm ("memrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)))
      __attribute__ ((__access__ (__read_only__, 1, 3)));
extern "C++" const void *memrchr (const void *__s, int __c, size_t __n)
      noexcept (true) __asm ("memrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)))
      __attribute__ ((__access__ (__read_only__, 1, 3)));
# 125 "/usr/include/string.h" 3 4
extern char *strcpy (char *__restrict __dest, const char *__restrict __src)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern char *strcat (char *__restrict __dest, const char *__restrict __src)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncat (char *__restrict __dest, const char *__restrict __src,
        size_t __n) noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern int strcmp (const char *__s1, const char *__s2)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int strncmp (const char *__s1, const char *__s2, size_t __n)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcoll (const char *__s1, const char *__s2)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern size_t strxfrm (char *__restrict __dest,
         const char *__restrict __src, size_t __n)
    noexcept (true) __attribute__ ((__nonnull__ (2))) __attribute__ ((__access__ (__write_only__, 1, 3)));






extern int strcoll_l (const char *__s1, const char *__s2, locale_t __l)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));


extern size_t strxfrm_l (char *__dest, const char *__src, size_t __n,
    locale_t __l) noexcept (true) __attribute__ ((__nonnull__ (2, 4)))
     __attribute__ ((__access__ (__write_only__, 1, 3)));





extern char *strdup (const char *__s)
     noexcept (true) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));






extern char *strndup (const char *__string, size_t __n)
     noexcept (true) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));
# 208 "/usr/include/string.h" 3 4
extern "C++"
{
extern char *strchr (char *__s, int __c)
     noexcept (true) __asm ("strchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const char *strchr (const char *__s, int __c)
     noexcept (true) __asm ("strchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 228 "/usr/include/string.h" 3 4
}






extern "C++"
{
extern char *strrchr (char *__s, int __c)
     noexcept (true) __asm ("strrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const char *strrchr (const char *__s, int __c)
     noexcept (true) __asm ("strrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 255 "/usr/include/string.h" 3 4
}
# 265 "/usr/include/string.h" 3 4
extern "C++" char *strchrnul (char *__s, int __c)
     noexcept (true) __asm ("strchrnul") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern "C++" const char *strchrnul (const char *__s, int __c)
     noexcept (true) __asm ("strchrnul") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 277 "/usr/include/string.h" 3 4
extern size_t strcspn (const char *__s, const char *__reject)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern size_t strspn (const char *__s, const char *__accept)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern "C++"
{
extern char *strpbrk (char *__s, const char *__accept)
     noexcept (true) __asm ("strpbrk") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern const char *strpbrk (const char *__s, const char *__accept)
     noexcept (true) __asm ("strpbrk") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 305 "/usr/include/string.h" 3 4
}






extern "C++"
{
extern char *strstr (char *__haystack, const char *__needle)
     noexcept (true) __asm ("strstr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern const char *strstr (const char *__haystack, const char *__needle)
     noexcept (true) __asm ("strstr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 332 "/usr/include/string.h" 3 4
}







extern char *strtok (char *__restrict __s, const char *__restrict __delim)
     noexcept (true) __attribute__ ((__nonnull__ (2)));



extern char *__strtok_r (char *__restrict __s,
    const char *__restrict __delim,
    char **__restrict __save_ptr)
     noexcept (true) __attribute__ ((__nonnull__ (2, 3)));

extern char *strtok_r (char *__restrict __s, const char *__restrict __delim,
         char **__restrict __save_ptr)
     noexcept (true) __attribute__ ((__nonnull__ (2, 3)));





extern "C++" char *strcasestr (char *__haystack, const char *__needle)
     noexcept (true) __asm ("strcasestr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern "C++" const char *strcasestr (const char *__haystack,
         const char *__needle)
     noexcept (true) __asm ("strcasestr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 373 "/usr/include/string.h" 3 4
extern void *memmem (const void *__haystack, size_t __haystacklen,
       const void *__needle, size_t __needlelen)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 3)))
    __attribute__ ((__access__ (__read_only__, 1, 2)))
    __attribute__ ((__access__ (__read_only__, 3, 4)));



extern void *__mempcpy (void *__restrict __dest,
   const void *__restrict __src, size_t __n)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));
extern void *mempcpy (void *__restrict __dest,
        const void *__restrict __src, size_t __n)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));




extern size_t strlen (const char *__s)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




extern size_t strnlen (const char *__string, size_t __maxlen)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




extern char *strerror (int __errnum) noexcept (true);
# 428 "/usr/include/string.h" 3 4
extern char *strerror_r (int __errnum, char *__buf, size_t __buflen)
     noexcept (true) __attribute__ ((__nonnull__ (2))) __attribute__ ((__access__ (__write_only__, 2, 3)));




extern const char *strerrordesc_np (int __err) noexcept (true);

extern const char *strerrorname_np (int __err) noexcept (true);





extern char *strerror_l (int __errnum, locale_t __l) noexcept (true);



# 1 "/usr/include/strings.h" 1 3 4
# 23 "/usr/include/strings.h" 3 4
# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/include/stddef.h" 1 3 4
# 24 "/usr/include/strings.h" 2 3 4






extern "C" {



extern int bcmp (const void *__s1, const void *__s2, size_t __n)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern void bcopy (const void *__src, void *__dest, size_t __n)
  noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern void bzero (void *__s, size_t __n) noexcept (true) __attribute__ ((__nonnull__ (1)));



extern "C++"
{
extern char *index (char *__s, int __c)
     noexcept (true) __asm ("index") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const char *index (const char *__s, int __c)
     noexcept (true) __asm ("index") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 66 "/usr/include/strings.h" 3 4
}







extern "C++"
{
extern char *rindex (char *__s, int __c)
     noexcept (true) __asm ("rindex") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const char *rindex (const char *__s, int __c)
     noexcept (true) __asm ("rindex") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 94 "/usr/include/strings.h" 3 4
}
# 104 "/usr/include/strings.h" 3 4
extern int ffs (int __i) noexcept (true) __attribute__ ((__const__));





extern int ffsl (long int __l) noexcept (true) __attribute__ ((__const__));
__extension__ extern int ffsll (long long int __ll)
     noexcept (true) __attribute__ ((__const__));



extern int strcasecmp (const char *__s1, const char *__s2)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strncasecmp (const char *__s1, const char *__s2, size_t __n)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));






extern int strcasecmp_l (const char *__s1, const char *__s2, locale_t __loc)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));



extern int strncasecmp_l (const char *__s1, const char *__s2,
     size_t __n, locale_t __loc)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 4)));


}
# 447 "/usr/include/string.h" 2 3 4



extern void explicit_bzero (void *__s, size_t __n) noexcept (true) __attribute__ ((__nonnull__ (1)))
    __attribute__ ((__access__ (__write_only__, 1, 2)));



extern char *strsep (char **__restrict __stringp,
       const char *__restrict __delim)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));




extern char *strsignal (int __sig) noexcept (true);



extern const char *sigabbrev_np (int __sig) noexcept (true);


extern const char *sigdescr_np (int __sig) noexcept (true);



extern char *__stpcpy (char *__restrict __dest, const char *__restrict __src)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));
extern char *stpcpy (char *__restrict __dest, const char *__restrict __src)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));



extern char *__stpncpy (char *__restrict __dest,
   const char *__restrict __src, size_t __n)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));
extern char *stpncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));




extern int strverscmp (const char *__s1, const char *__s2)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strfry (char *__string) noexcept (true) __attribute__ ((__nonnull__ (1)));


extern void *memfrob (void *__s, size_t __n) noexcept (true) __attribute__ ((__nonnull__ (1)))
    __attribute__ ((__access__ (__write_only__, 1, 2)));







extern "C++" char *basename (char *__filename)
     noexcept (true) __asm ("basename") __attribute__ ((__nonnull__ (1)));
extern "C++" const char *basename (const char *__filename)
     noexcept (true) __asm ("basename") __attribute__ ((__nonnull__ (1)));
# 523 "/usr/include/string.h" 3 4
}
# 30 "/usr/include/opencascade/Standard_Character.hxx" 2
# 1 "/usr/include/c++/10.2.0/cctype" 1 3
# 39 "/usr/include/c++/10.2.0/cctype" 3
       
# 40 "/usr/include/c++/10.2.0/cctype" 3


# 1 "/usr/include/ctype.h" 1 3 4
# 28 "/usr/include/ctype.h" 3 4
extern "C" {
# 46 "/usr/include/ctype.h" 3 4
enum
{
  _ISupper = ((0) < 8 ? ((1 << (0)) << 8) : ((1 << (0)) >> 8)),
  _ISlower = ((1) < 8 ? ((1 << (1)) << 8) : ((1 << (1)) >> 8)),
  _ISalpha = ((2) < 8 ? ((1 << (2)) << 8) : ((1 << (2)) >> 8)),
  _ISdigit = ((3) < 8 ? ((1 << (3)) << 8) : ((1 << (3)) >> 8)),
  _ISxdigit = ((4) < 8 ? ((1 << (4)) << 8) : ((1 << (4)) >> 8)),
  _ISspace = ((5) < 8 ? ((1 << (5)) << 8) : ((1 << (5)) >> 8)),
  _ISprint = ((6) < 8 ? ((1 << (6)) << 8) : ((1 << (6)) >> 8)),
  _ISgraph = ((7) < 8 ? ((1 << (7)) << 8) : ((1 << (7)) >> 8)),
  _ISblank = ((8) < 8 ? ((1 << (8)) << 8) : ((1 << (8)) >> 8)),
  _IScntrl = ((9) < 8 ? ((1 << (9)) << 8) : ((1 << (9)) >> 8)),
  _ISpunct = ((10) < 8 ? ((1 << (10)) << 8) : ((1 << (10)) >> 8)),
  _ISalnum = ((11) < 8 ? ((1 << (11)) << 8) : ((1 << (11)) >> 8))
};
# 79 "/usr/include/ctype.h" 3 4
extern const unsigned short int **__ctype_b_loc (void)
     noexcept (true) __attribute__ ((__const__));
extern const __int32_t **__ctype_tolower_loc (void)
     noexcept (true) __attribute__ ((__const__));
extern const __int32_t **__ctype_toupper_loc (void)
     noexcept (true) __attribute__ ((__const__));
# 108 "/usr/include/ctype.h" 3 4
extern int isalnum (int) noexcept (true);
extern int isalpha (int) noexcept (true);
extern int iscntrl (int) noexcept (true);
extern int isdigit (int) noexcept (true);
extern int islower (int) noexcept (true);
extern int isgraph (int) noexcept (true);
extern int isprint (int) noexcept (true);
extern int ispunct (int) noexcept (true);
extern int isspace (int) noexcept (true);
extern int isupper (int) noexcept (true);
extern int isxdigit (int) noexcept (true);



extern int tolower (int __c) noexcept (true);


extern int toupper (int __c) noexcept (true);




extern int isblank (int) noexcept (true);




extern int isctype (int __c, int __mask) noexcept (true);






extern int isascii (int __c) noexcept (true);



extern int toascii (int __c) noexcept (true);



extern int _toupper (int) noexcept (true);
extern int _tolower (int) noexcept (true);
# 251 "/usr/include/ctype.h" 3 4
extern int isalnum_l (int, locale_t) noexcept (true);
extern int isalpha_l (int, locale_t) noexcept (true);
extern int iscntrl_l (int, locale_t) noexcept (true);
extern int isdigit_l (int, locale_t) noexcept (true);
extern int islower_l (int, locale_t) noexcept (true);
extern int isgraph_l (int, locale_t) noexcept (true);
extern int isprint_l (int, locale_t) noexcept (true);
extern int ispunct_l (int, locale_t) noexcept (true);
extern int isspace_l (int, locale_t) noexcept (true);
extern int isupper_l (int, locale_t) noexcept (true);
extern int isxdigit_l (int, locale_t) noexcept (true);

extern int isblank_l (int, locale_t) noexcept (true);



extern int __tolower_l (int __c, locale_t __l) noexcept (true);
extern int tolower_l (int __c, locale_t __l) noexcept (true);


extern int __toupper_l (int __c, locale_t __l) noexcept (true);
extern int toupper_l (int __c, locale_t __l) noexcept (true);
# 327 "/usr/include/ctype.h" 3 4
}
# 43 "/usr/include/c++/10.2.0/cctype" 2 3
# 62 "/usr/include/c++/10.2.0/cctype" 3
namespace std
{
  using ::isalnum;
  using ::isalpha;
  using ::iscntrl;
  using ::isdigit;
  using ::isgraph;
  using ::islower;
  using ::isprint;
  using ::ispunct;
  using ::isspace;
  using ::isupper;
  using ::isxdigit;
  using ::tolower;
  using ::toupper;
}







namespace std
{
  using ::isblank;
}
# 31 "/usr/include/opencascade/Standard_Character.hxx" 2





# 35 "/usr/include/opencascade/Standard_Character.hxx"
inline Standard_Boolean IsEqual(const Standard_Character One,
    const Standard_Character Two)
{ return One == Two; }
# 57 "/usr/include/opencascade/Standard_Character.hxx"
inline Standard_Boolean IsAlphabetic(const Standard_Character me)
{ return std::isalpha ((unsigned char)me) != 0; }




inline Standard_Boolean IsDigit(const Standard_Character me)
{ return std::isdigit ((unsigned char)me) != 0; }




inline Standard_Boolean IsXDigit(const Standard_Character me)
{ return std::isxdigit((unsigned char)me) != 0; }




inline Standard_Boolean IsAlphanumeric(const Standard_Character me)
{ return (IsAlphabetic(me) || IsDigit(me)) ; }




inline Standard_Boolean IsControl(const Standard_Character me)
{ return std::iscntrl((unsigned char)me) != 0; }





inline Standard_Boolean IsGraphic(const Standard_Character me)
{ return std::isgraph((unsigned char)me) != 0; }




inline Standard_Boolean IsLowerCase(const Standard_Character me)
{ return std::islower((unsigned char)me) != 0; }




inline Standard_Boolean IsPrintable(const Standard_Character me)
{ return std::isprint((unsigned char)me) != 0; }





inline Standard_Boolean IsPunctuation(const Standard_Character me)
{ return ( IsGraphic(me) && !IsAlphanumeric(me)); }




inline Standard_Boolean IsSpace(const Standard_Character me)
{ return std::isspace((unsigned char)me) != 0; }




inline Standard_Boolean IsUpperCase(const Standard_Character me)
{ return std::isupper((unsigned char)me) != 0; }




inline Standard_Character LowerCase(const Standard_Character me)
{ return (Standard_Character)(unsigned char)std::tolower((unsigned char)me); }




inline Standard_Character UpperCase(const Standard_Character me)
{ return (Standard_Character)(unsigned char)std::toupper((unsigned char)me); }
# 27 "/usr/include/opencascade/Standard_PrimitiveTypes.hxx" 2
# 1 "/usr/include/opencascade/Standard_ExtCharacter.hxx" 1
# 28 "/usr/include/opencascade/Standard_ExtCharacter.hxx"
# 1 "/usr/include/opencascade/Standard_OStream.hxx" 1
# 19 "/usr/include/opencascade/Standard_OStream.hxx"
# 1 "/usr/include/opencascade/Standard_Stream.hxx" 1
# 20 "/usr/include/opencascade/Standard_Stream.hxx"
# 1 "/usr/include/c++/10.2.0/iostream" 1 3
# 36 "/usr/include/c++/10.2.0/iostream" 3
       
# 37 "/usr/include/c++/10.2.0/iostream" 3


# 1 "/usr/include/c++/10.2.0/ostream" 1 3
# 36 "/usr/include/c++/10.2.0/ostream" 3
       
# 37 "/usr/include/c++/10.2.0/ostream" 3

# 1 "/usr/include/c++/10.2.0/ios" 1 3
# 36 "/usr/include/c++/10.2.0/ios" 3
       
# 37 "/usr/include/c++/10.2.0/ios" 3

# 1 "/usr/include/c++/10.2.0/iosfwd" 1 3
# 36 "/usr/include/c++/10.2.0/iosfwd" 3
       
# 37 "/usr/include/c++/10.2.0/iosfwd" 3


# 1 "/usr/include/c++/10.2.0/bits/stringfwd.h" 1 3
# 37 "/usr/include/c++/10.2.0/bits/stringfwd.h" 3
       
# 38 "/usr/include/c++/10.2.0/bits/stringfwd.h" 3


# 1 "/usr/include/c++/10.2.0/bits/memoryfwd.h" 1 3
# 46 "/usr/include/c++/10.2.0/bits/memoryfwd.h" 3
       
# 47 "/usr/include/c++/10.2.0/bits/memoryfwd.h" 3




# 50 "/usr/include/c++/10.2.0/bits/memoryfwd.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 63 "/usr/include/c++/10.2.0/bits/memoryfwd.h" 3
  template<typename>
    class allocator;


  template<>
    class allocator<void>;




  template<typename, typename>
    struct uses_allocator;





}
# 41 "/usr/include/c++/10.2.0/bits/stringfwd.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{








  template<class _CharT>
    struct char_traits;

  template<> struct char_traits<char>;


  template<> struct char_traits<wchar_t>;







  template<> struct char_traits<char16_t>;
  template<> struct char_traits<char32_t>;


namespace __cxx11 {

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
           typename _Alloc = allocator<_CharT> >
    class basic_string;

}


  typedef basic_string<char> string;



  typedef basic_string<wchar_t> wstring;
# 93 "/usr/include/c++/10.2.0/bits/stringfwd.h" 3
  typedef basic_string<char16_t> u16string;


  typedef basic_string<char32_t> u32string;





}
# 40 "/usr/include/c++/10.2.0/iosfwd" 2 3
# 1 "/usr/include/c++/10.2.0/bits/postypes.h" 1 3
# 38 "/usr/include/c++/10.2.0/bits/postypes.h" 3
       
# 39 "/usr/include/c++/10.2.0/bits/postypes.h" 3

# 1 "/usr/include/c++/10.2.0/cwchar" 1 3
# 39 "/usr/include/c++/10.2.0/cwchar" 3
       
# 40 "/usr/include/c++/10.2.0/cwchar" 3




# 1 "/usr/include/wchar.h" 1 3 4
# 27 "/usr/include/wchar.h" 3 4
# 1 "/usr/include/bits/libc-header-start.h" 1 3 4
# 28 "/usr/include/wchar.h" 2 3 4







# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/include/stddef.h" 1 3 4
# 36 "/usr/include/wchar.h" 2 3 4


# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/include/stdarg.h" 1 3 4
# 40 "/usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 39 "/usr/include/wchar.h" 2 3 4


# 1 "/usr/include/bits/types/wint_t.h" 1 3 4
# 20 "/usr/include/bits/types/wint_t.h" 3 4
typedef unsigned int wint_t;
# 42 "/usr/include/wchar.h" 2 3 4
# 1 "/usr/include/bits/types/mbstate_t.h" 1 3 4



# 1 "/usr/include/bits/types/__mbstate_t.h" 1 3 4
# 13 "/usr/include/bits/types/__mbstate_t.h" 3 4
typedef struct
{
  int __count;
  union
  {
    unsigned int __wch;
    char __wchb[4];
  } __value;
} __mbstate_t;
# 5 "/usr/include/bits/types/mbstate_t.h" 2 3 4

typedef __mbstate_t mbstate_t;
# 43 "/usr/include/wchar.h" 2 3 4
# 1 "/usr/include/bits/types/__FILE.h" 1 3 4



struct _IO_FILE;
typedef struct _IO_FILE __FILE;
# 44 "/usr/include/wchar.h" 2 3 4


# 1 "/usr/include/bits/types/FILE.h" 1 3 4



struct _IO_FILE;


typedef struct _IO_FILE FILE;
# 47 "/usr/include/wchar.h" 2 3 4
# 79 "/usr/include/wchar.h" 3 4
extern "C" {



struct tm;



extern wchar_t *wcscpy (wchar_t *__restrict __dest,
   const wchar_t *__restrict __src)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern wchar_t *wcsncpy (wchar_t *__restrict __dest,
    const wchar_t *__restrict __src, size_t __n)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern wchar_t *wcscat (wchar_t *__restrict __dest,
   const wchar_t *__restrict __src)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));

extern wchar_t *wcsncat (wchar_t *__restrict __dest,
    const wchar_t *__restrict __src, size_t __n)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern int wcscmp (const wchar_t *__s1, const wchar_t *__s2)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int wcsncmp (const wchar_t *__s1, const wchar_t *__s2, size_t __n)
     noexcept (true) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));



extern int wcscasecmp (const wchar_t *__s1, const wchar_t *__s2) noexcept (true);


extern int wcsncasecmp (const wchar_t *__s1, const wchar_t *__s2,
   size_t __n) noexcept (true);



extern int wcscasecmp_l (const wchar_t *__s1, const wchar_t *__s2,
    locale_t __loc) noexcept (true);

extern int wcsncasecmp_l (const wchar_t *__s1, const wchar_t *__s2,
     size_t __n, locale_t __loc) noexcept (true);




extern int wcscoll (const wchar_t *__s1, const wchar_t *__s2) noexcept (true);



extern size_t wcsxfrm (wchar_t *__restrict __s1,
         const wchar_t *__restrict __s2, size_t __n) noexcept (true);







extern int wcscoll_l (const wchar_t *__s1, const wchar_t *__s2,
        locale_t __loc) noexcept (true);




extern size_t wcsxfrm_l (wchar_t *__s1, const wchar_t *__s2,
    size_t __n, locale_t __loc) noexcept (true);


extern wchar_t *wcsdup (const wchar_t *__s) noexcept (true) __attribute__ ((__malloc__));




extern "C++" wchar_t *wcschr (wchar_t *__wcs, wchar_t __wc)
     noexcept (true) __asm ("wcschr") __attribute__ ((__pure__));
extern "C++" const wchar_t *wcschr (const wchar_t *__wcs, wchar_t __wc)
     noexcept (true) __asm ("wcschr") __attribute__ ((__pure__));






extern "C++" wchar_t *wcsrchr (wchar_t *__wcs, wchar_t __wc)
     noexcept (true) __asm ("wcsrchr") __attribute__ ((__pure__));
extern "C++" const wchar_t *wcsrchr (const wchar_t *__wcs, wchar_t __wc)
     noexcept (true) __asm ("wcsrchr") __attribute__ ((__pure__));
# 181 "/usr/include/wchar.h" 3 4
extern wchar_t *wcschrnul (const wchar_t *__s, wchar_t __wc)
     noexcept (true) __attribute__ ((__pure__));




extern size_t wcscspn (const wchar_t *__wcs, const wchar_t *__reject)
     noexcept (true) __attribute__ ((__pure__));


extern size_t wcsspn (const wchar_t *__wcs, const wchar_t *__accept)
     noexcept (true) __attribute__ ((__pure__));


extern "C++" wchar_t *wcspbrk (wchar_t *__wcs, const wchar_t *__accept)
     noexcept (true) __asm ("wcspbrk") __attribute__ ((__pure__));
extern "C++" const wchar_t *wcspbrk (const wchar_t *__wcs,
         const wchar_t *__accept)
     noexcept (true) __asm ("wcspbrk") __attribute__ ((__pure__));






extern "C++" wchar_t *wcsstr (wchar_t *__haystack, const wchar_t *__needle)
     noexcept (true) __asm ("wcsstr") __attribute__ ((__pure__));
extern "C++" const wchar_t *wcsstr (const wchar_t *__haystack,
        const wchar_t *__needle)
     noexcept (true) __asm ("wcsstr") __attribute__ ((__pure__));






extern wchar_t *wcstok (wchar_t *__restrict __s,
   const wchar_t *__restrict __delim,
   wchar_t **__restrict __ptr) noexcept (true);


extern size_t wcslen (const wchar_t *__s) noexcept (true) __attribute__ ((__pure__));




extern "C++" wchar_t *wcswcs (wchar_t *__haystack, const wchar_t *__needle)
     noexcept (true) __asm ("wcswcs") __attribute__ ((__pure__));
extern "C++" const wchar_t *wcswcs (const wchar_t *__haystack,
        const wchar_t *__needle)
     noexcept (true) __asm ("wcswcs") __attribute__ ((__pure__));
# 240 "/usr/include/wchar.h" 3 4
extern size_t wcsnlen (const wchar_t *__s, size_t __maxlen)
     noexcept (true) __attribute__ ((__pure__));





extern "C++" wchar_t *wmemchr (wchar_t *__s, wchar_t __c, size_t __n)
     noexcept (true) __asm ("wmemchr") __attribute__ ((__pure__));
extern "C++" const wchar_t *wmemchr (const wchar_t *__s, wchar_t __c,
         size_t __n)
     noexcept (true) __asm ("wmemchr") __attribute__ ((__pure__));






extern int wmemcmp (const wchar_t *__s1, const wchar_t *__s2, size_t __n)
     noexcept (true) __attribute__ ((__pure__));


extern wchar_t *wmemcpy (wchar_t *__restrict __s1,
    const wchar_t *__restrict __s2, size_t __n) noexcept (true);



extern wchar_t *wmemmove (wchar_t *__s1, const wchar_t *__s2, size_t __n)
     noexcept (true);


extern wchar_t *wmemset (wchar_t *__s, wchar_t __c, size_t __n) noexcept (true);




extern wchar_t *wmempcpy (wchar_t *__restrict __s1,
     const wchar_t *__restrict __s2, size_t __n)
     noexcept (true);





extern wint_t btowc (int __c) noexcept (true);



extern int wctob (wint_t __c) noexcept (true);



extern int mbsinit (const mbstate_t *__ps) noexcept (true) __attribute__ ((__pure__));



extern size_t mbrtowc (wchar_t *__restrict __pwc,
         const char *__restrict __s, size_t __n,
         mbstate_t *__restrict __p) noexcept (true);


extern size_t wcrtomb (char *__restrict __s, wchar_t __wc,
         mbstate_t *__restrict __ps) noexcept (true);


extern size_t __mbrlen (const char *__restrict __s, size_t __n,
   mbstate_t *__restrict __ps) noexcept (true);
extern size_t mbrlen (const char *__restrict __s, size_t __n,
        mbstate_t *__restrict __ps) noexcept (true);
# 337 "/usr/include/wchar.h" 3 4
extern size_t mbsrtowcs (wchar_t *__restrict __dst,
    const char **__restrict __src, size_t __len,
    mbstate_t *__restrict __ps) noexcept (true);



extern size_t wcsrtombs (char *__restrict __dst,
    const wchar_t **__restrict __src, size_t __len,
    mbstate_t *__restrict __ps) noexcept (true);





extern size_t mbsnrtowcs (wchar_t *__restrict __dst,
     const char **__restrict __src, size_t __nmc,
     size_t __len, mbstate_t *__restrict __ps) noexcept (true);



extern size_t wcsnrtombs (char *__restrict __dst,
     const wchar_t **__restrict __src,
     size_t __nwc, size_t __len,
     mbstate_t *__restrict __ps) noexcept (true);






extern int wcwidth (wchar_t __c) noexcept (true);



extern int wcswidth (const wchar_t *__s, size_t __n) noexcept (true);





extern double wcstod (const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr) noexcept (true);



extern float wcstof (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) noexcept (true);
extern long double wcstold (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) noexcept (true);
# 396 "/usr/include/wchar.h" 3 4
extern _Float32 wcstof32 (const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr) noexcept (true);



extern _Float64 wcstof64 (const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr) noexcept (true);



extern _Float128 wcstof128 (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) noexcept (true);



extern _Float32x wcstof32x (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) noexcept (true);



extern _Float64x wcstof64x (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) noexcept (true);
# 428 "/usr/include/wchar.h" 3 4
extern long int wcstol (const wchar_t *__restrict __nptr,
   wchar_t **__restrict __endptr, int __base) noexcept (true);



extern unsigned long int wcstoul (const wchar_t *__restrict __nptr,
      wchar_t **__restrict __endptr, int __base)
     noexcept (true);




__extension__
extern long long int wcstoll (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr, int __base)
     noexcept (true);



__extension__
extern unsigned long long int wcstoull (const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr,
     int __base) noexcept (true);





__extension__
extern long long int wcstoq (const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr, int __base)
     noexcept (true);



__extension__
extern unsigned long long int wcstouq (const wchar_t *__restrict __nptr,
           wchar_t **__restrict __endptr,
           int __base) noexcept (true);






extern long int wcstol_l (const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr, int __base,
     locale_t __loc) noexcept (true);

extern unsigned long int wcstoul_l (const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr,
        int __base, locale_t __loc) noexcept (true);

__extension__
extern long long int wcstoll_l (const wchar_t *__restrict __nptr,
    wchar_t **__restrict __endptr,
    int __base, locale_t __loc) noexcept (true);

__extension__
extern unsigned long long int wcstoull_l (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr,
       int __base, locale_t __loc)
     noexcept (true);

extern double wcstod_l (const wchar_t *__restrict __nptr,
   wchar_t **__restrict __endptr, locale_t __loc)
     noexcept (true);

extern float wcstof_l (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr, locale_t __loc)
     noexcept (true);

extern long double wcstold_l (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr,
         locale_t __loc) noexcept (true);
# 511 "/usr/include/wchar.h" 3 4
extern _Float32 wcstof32_l (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr,
       locale_t __loc) noexcept (true);



extern _Float64 wcstof64_l (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr,
       locale_t __loc) noexcept (true);



extern _Float128 wcstof128_l (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr,
         locale_t __loc) noexcept (true);



extern _Float32x wcstof32x_l (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr,
         locale_t __loc) noexcept (true);



extern _Float64x wcstof64x_l (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr,
         locale_t __loc) noexcept (true);
# 551 "/usr/include/wchar.h" 3 4
extern wchar_t *wcpcpy (wchar_t *__restrict __dest,
   const wchar_t *__restrict __src) noexcept (true);



extern wchar_t *wcpncpy (wchar_t *__restrict __dest,
    const wchar_t *__restrict __src, size_t __n)
     noexcept (true);
# 567 "/usr/include/wchar.h" 3 4
extern __FILE *open_wmemstream (wchar_t **__bufloc, size_t *__sizeloc) noexcept (true);





extern int fwide (__FILE *__fp, int __mode) noexcept (true);






extern int fwprintf (__FILE *__restrict __stream,
       const wchar_t *__restrict __format, ...)
                                                           ;




extern int wprintf (const wchar_t *__restrict __format, ...)
                                                           ;

extern int swprintf (wchar_t *__restrict __s, size_t __n,
       const wchar_t *__restrict __format, ...)
     noexcept (true) ;





extern int vfwprintf (__FILE *__restrict __s,
        const wchar_t *__restrict __format,
        __gnuc_va_list __arg)
                                                           ;




extern int vwprintf (const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
                                                           ;


extern int vswprintf (wchar_t *__restrict __s, size_t __n,
        const wchar_t *__restrict __format,
        __gnuc_va_list __arg)
     noexcept (true) ;






extern int fwscanf (__FILE *__restrict __stream,
      const wchar_t *__restrict __format, ...)
                                                          ;




extern int wscanf (const wchar_t *__restrict __format, ...)
                                                          ;

extern int swscanf (const wchar_t *__restrict __s,
      const wchar_t *__restrict __format, ...)
     noexcept (true) ;
# 642 "/usr/include/wchar.h" 3 4
extern int fwscanf (__FILE *__restrict __stream, const wchar_t *__restrict __format, ...) __asm__ ("" "__isoc99_fwscanf")


                                                          ;
extern int wscanf (const wchar_t *__restrict __format, ...) __asm__ ("" "__isoc99_wscanf")

                                                          ;
extern int swscanf (const wchar_t *__restrict __s, const wchar_t *__restrict __format, ...) noexcept (true) __asm__ ("" "__isoc99_swscanf")


                                                          ;
# 673 "/usr/include/wchar.h" 3 4
extern int vfwscanf (__FILE *__restrict __s,
       const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
                                                          ;




extern int vwscanf (const wchar_t *__restrict __format,
      __gnuc_va_list __arg)
                                                          ;

extern int vswscanf (const wchar_t *__restrict __s,
       const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
     noexcept (true) ;







extern int vfwscanf (__FILE *__restrict __s, const wchar_t *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vfwscanf")


                                                          ;
extern int vwscanf (const wchar_t *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vwscanf")

                                                          ;
extern int vswscanf (const wchar_t *__restrict __s, const wchar_t *__restrict __format, __gnuc_va_list __arg) noexcept (true) __asm__ ("" "__isoc99_vswscanf")


                                                          ;
# 729 "/usr/include/wchar.h" 3 4
extern wint_t fgetwc (__FILE *__stream);
extern wint_t getwc (__FILE *__stream);





extern wint_t getwchar (void);






extern wint_t fputwc (wchar_t __wc, __FILE *__stream);
extern wint_t putwc (wchar_t __wc, __FILE *__stream);





extern wint_t putwchar (wchar_t __wc);







extern wchar_t *fgetws (wchar_t *__restrict __ws, int __n,
   __FILE *__restrict __stream);





extern int fputws (const wchar_t *__restrict __ws,
     __FILE *__restrict __stream);






extern wint_t ungetwc (wint_t __wc, __FILE *__stream);
# 784 "/usr/include/wchar.h" 3 4
extern wint_t getwc_unlocked (__FILE *__stream);
extern wint_t getwchar_unlocked (void);







extern wint_t fgetwc_unlocked (__FILE *__stream);







extern wint_t fputwc_unlocked (wchar_t __wc, __FILE *__stream);
# 810 "/usr/include/wchar.h" 3 4
extern wint_t putwc_unlocked (wchar_t __wc, __FILE *__stream);
extern wint_t putwchar_unlocked (wchar_t __wc);
# 820 "/usr/include/wchar.h" 3 4
extern wchar_t *fgetws_unlocked (wchar_t *__restrict __ws, int __n,
     __FILE *__restrict __stream);







extern int fputws_unlocked (const wchar_t *__restrict __ws,
       __FILE *__restrict __stream);






extern size_t wcsftime (wchar_t *__restrict __s, size_t __maxsize,
   const wchar_t *__restrict __format,
   const struct tm *__restrict __tp) noexcept (true);




extern size_t wcsftime_l (wchar_t *__restrict __s, size_t __maxsize,
     const wchar_t *__restrict __format,
     const struct tm *__restrict __tp,
     locale_t __loc) noexcept (true);
# 860 "/usr/include/wchar.h" 3 4
}
# 45 "/usr/include/c++/10.2.0/cwchar" 2 3
# 62 "/usr/include/c++/10.2.0/cwchar" 3
namespace std
{
  using ::mbstate_t;
}
# 135 "/usr/include/c++/10.2.0/cwchar" 3
extern "C++"
{
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::wint_t;

  using ::btowc;
  using ::fgetwc;
  using ::fgetws;
  using ::fputwc;
  using ::fputws;
  using ::fwide;
  using ::fwprintf;
  using ::fwscanf;
  using ::getwc;
  using ::getwchar;
  using ::mbrlen;
  using ::mbrtowc;
  using ::mbsinit;
  using ::mbsrtowcs;
  using ::putwc;
  using ::putwchar;

  using ::swprintf;

  using ::swscanf;
  using ::ungetwc;
  using ::vfwprintf;

  using ::vfwscanf;


  using ::vswprintf;


  using ::vswscanf;

  using ::vwprintf;

  using ::vwscanf;

  using ::wcrtomb;
  using ::wcscat;
  using ::wcscmp;
  using ::wcscoll;
  using ::wcscpy;
  using ::wcscspn;
  using ::wcsftime;
  using ::wcslen;
  using ::wcsncat;
  using ::wcsncmp;
  using ::wcsncpy;
  using ::wcsrtombs;
  using ::wcsspn;
  using ::wcstod;

  using ::wcstof;

  using ::wcstok;
  using ::wcstol;
  using ::wcstoul;
  using ::wcsxfrm;
  using ::wctob;
  using ::wmemcmp;
  using ::wmemcpy;
  using ::wmemmove;
  using ::wmemset;
  using ::wprintf;
  using ::wscanf;
  using ::wcschr;
  using ::wcspbrk;
  using ::wcsrchr;
  using ::wcsstr;
  using ::wmemchr;
# 234 "/usr/include/c++/10.2.0/cwchar" 3

}
}







namespace __gnu_cxx
{





  using ::wcstold;
# 260 "/usr/include/c++/10.2.0/cwchar" 3
  using ::wcstoll;
  using ::wcstoull;

}

namespace std
{
  using ::__gnu_cxx::wcstold;
  using ::__gnu_cxx::wcstoll;
  using ::__gnu_cxx::wcstoull;
}
# 280 "/usr/include/c++/10.2.0/cwchar" 3
namespace std
{

  using std::wcstof;


  using std::vfwscanf;


  using std::vswscanf;


  using std::vwscanf;



  using std::wcstold;
  using std::wcstoll;
  using std::wcstoull;

}
# 41 "/usr/include/c++/10.2.0/bits/postypes.h" 2 3
# 68 "/usr/include/c++/10.2.0/bits/postypes.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 88 "/usr/include/c++/10.2.0/bits/postypes.h" 3
  typedef long streamoff;
# 98 "/usr/include/c++/10.2.0/bits/postypes.h" 3
  typedef ptrdiff_t streamsize;
# 111 "/usr/include/c++/10.2.0/bits/postypes.h" 3
  template<typename _StateT>
    class fpos
    {
    private:
      streamoff _M_off;
      _StateT _M_state;

    public:




      fpos()
      : _M_off(0), _M_state() { }
# 133 "/usr/include/c++/10.2.0/bits/postypes.h" 3
      fpos(streamoff __off)
      : _M_off(__off), _M_state() { }


      fpos(const fpos&) = default;
      fpos& operator=(const fpos&) = default;
      ~fpos() = default;



      operator streamoff() const { return _M_off; }


      void
      state(_StateT __st)
      { _M_state = __st; }


      _StateT
      state() const
      { return _M_state; }





      fpos&
      operator+=(streamoff __off)
      {
 _M_off += __off;
 return *this;
      }





      fpos&
      operator-=(streamoff __off)
      {
 _M_off -= __off;
 return *this;
      }







      fpos
      operator+(streamoff __off) const
      {
 fpos __pos(*this);
 __pos += __off;
 return __pos;
      }







      fpos
      operator-(streamoff __off) const
      {
 fpos __pos(*this);
 __pos -= __off;
 return __pos;
      }






      streamoff
      operator-(const fpos& __other) const
      { return _M_off - __other._M_off; }
    };






  template<typename _StateT>
    inline bool
    operator==(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
    { return streamoff(__lhs) == streamoff(__rhs); }

  template<typename _StateT>
    inline bool
    operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
    { return streamoff(__lhs) != streamoff(__rhs); }





  typedef fpos<mbstate_t> streampos;

  typedef fpos<mbstate_t> wstreampos;
# 245 "/usr/include/c++/10.2.0/bits/postypes.h" 3
  typedef fpos<mbstate_t> u16streampos;

  typedef fpos<mbstate_t> u32streampos;



}
# 41 "/usr/include/c++/10.2.0/iosfwd" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 74 "/usr/include/c++/10.2.0/iosfwd" 3
  class ios_base;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ios;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_streambuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_istream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ostream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_iostream;


namespace __cxx11 {

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
     typename _Alloc = allocator<_CharT> >
    class basic_stringbuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_istringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_ostringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_stringstream;

}

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_filebuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ifstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ofstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_fstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class istreambuf_iterator;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class ostreambuf_iterator;



  typedef basic_ios<char> ios;


  typedef basic_streambuf<char> streambuf;


  typedef basic_istream<char> istream;


  typedef basic_ostream<char> ostream;


  typedef basic_iostream<char> iostream;


  typedef basic_stringbuf<char> stringbuf;


  typedef basic_istringstream<char> istringstream;


  typedef basic_ostringstream<char> ostringstream;


  typedef basic_stringstream<char> stringstream;


  typedef basic_filebuf<char> filebuf;


  typedef basic_ifstream<char> ifstream;


  typedef basic_ofstream<char> ofstream;


  typedef basic_fstream<char> fstream;



  typedef basic_ios<wchar_t> wios;


  typedef basic_streambuf<wchar_t> wstreambuf;


  typedef basic_istream<wchar_t> wistream;


  typedef basic_ostream<wchar_t> wostream;


  typedef basic_iostream<wchar_t> wiostream;


  typedef basic_stringbuf<wchar_t> wstringbuf;


  typedef basic_istringstream<wchar_t> wistringstream;


  typedef basic_ostringstream<wchar_t> wostringstream;


  typedef basic_stringstream<wchar_t> wstringstream;


  typedef basic_filebuf<wchar_t> wfilebuf;


  typedef basic_ifstream<wchar_t> wifstream;


  typedef basic_ofstream<wchar_t> wofstream;


  typedef basic_fstream<wchar_t> wfstream;




}
# 39 "/usr/include/c++/10.2.0/ios" 2 3
# 1 "/usr/include/c++/10.2.0/exception" 1 3
# 33 "/usr/include/c++/10.2.0/exception" 3
       
# 34 "/usr/include/c++/10.2.0/exception" 3

#pragma GCC visibility push(default)


# 1 "/usr/include/c++/10.2.0/bits/exception.h" 1 3
# 34 "/usr/include/c++/10.2.0/bits/exception.h" 3
       
# 35 "/usr/include/c++/10.2.0/bits/exception.h" 3

#pragma GCC visibility push(default)



extern "C++" {

namespace std
{
# 60 "/usr/include/c++/10.2.0/bits/exception.h" 3
  class exception
  {
  public:
    exception() noexcept { }
    virtual ~exception() noexcept;

    exception(const exception&) = default;
    exception& operator=(const exception&) = default;
    exception(exception&&) = default;
    exception& operator=(exception&&) = default;




    virtual const char*
    what() const noexcept;
  };

}

}

#pragma GCC visibility pop
# 39 "/usr/include/c++/10.2.0/exception" 2 3

extern "C++" {

namespace std
{






  class bad_exception : public exception
  {
  public:
    bad_exception() noexcept { }



    virtual ~bad_exception() noexcept;


    virtual const char*
    what() const noexcept;
  };


  typedef void (*terminate_handler) ();


  typedef void (*unexpected_handler) ();


  terminate_handler set_terminate(terminate_handler) noexcept;



  terminate_handler get_terminate() noexcept;




  void terminate() noexcept __attribute__ ((__noreturn__));


  unexpected_handler set_unexpected(unexpected_handler) noexcept;



  unexpected_handler get_unexpected() noexcept;




  void unexpected() __attribute__ ((__noreturn__));
# 105 "/usr/include/c++/10.2.0/exception" 3
 
  bool uncaught_exception() noexcept __attribute__ ((__pure__));




  int uncaught_exceptions() noexcept __attribute__ ((__pure__));



}

namespace __gnu_cxx
{

# 137 "/usr/include/c++/10.2.0/exception" 3
  void __verbose_terminate_handler();


}

}

#pragma GCC visibility pop


# 1 "/usr/include/c++/10.2.0/bits/exception_ptr.h" 1 3
# 34 "/usr/include/c++/10.2.0/bits/exception_ptr.h" 3
#pragma GCC visibility push(default)


# 1 "/usr/include/c++/10.2.0/bits/exception_defines.h" 1 3
# 38 "/usr/include/c++/10.2.0/bits/exception_ptr.h" 2 3
# 1 "/usr/include/c++/10.2.0/bits/cxxabi_init_exception.h" 1 3
# 34 "/usr/include/c++/10.2.0/bits/cxxabi_init_exception.h" 3
       
# 35 "/usr/include/c++/10.2.0/bits/cxxabi_init_exception.h" 3

#pragma GCC visibility push(default)

# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/include/stddef.h" 1 3 4
# 39 "/usr/include/c++/10.2.0/bits/cxxabi_init_exception.h" 2 3
# 50 "/usr/include/c++/10.2.0/bits/cxxabi_init_exception.h" 3
namespace std
{
  class type_info;
}

namespace __cxxabiv1
{
  struct __cxa_refcounted_exception;

  extern "C"
    {

      void*
      __cxa_allocate_exception(size_t) noexcept;

      void
      __cxa_free_exception(void*) noexcept;


      __cxa_refcounted_exception*
      __cxa_init_primary_exception(void *object, std::type_info *tinfo,
                void ( *dest) (void *)) noexcept;

    }
}



#pragma GCC visibility pop
# 39 "/usr/include/c++/10.2.0/bits/exception_ptr.h" 2 3
# 1 "/usr/include/c++/10.2.0/typeinfo" 1 3
# 32 "/usr/include/c++/10.2.0/typeinfo" 3
       
# 33 "/usr/include/c++/10.2.0/typeinfo" 3



# 1 "/usr/include/c++/10.2.0/bits/hash_bytes.h" 1 3
# 33 "/usr/include/c++/10.2.0/bits/hash_bytes.h" 3
       
# 34 "/usr/include/c++/10.2.0/bits/hash_bytes.h" 3



namespace std
{







  size_t
  _Hash_bytes(const void* __ptr, size_t __len, size_t __seed);





  size_t
  _Fnv_hash_bytes(const void* __ptr, size_t __len, size_t __seed);


}
# 37 "/usr/include/c++/10.2.0/typeinfo" 2 3


#pragma GCC visibility push(default)

extern "C++" {

namespace __cxxabiv1
{
  class __class_type_info;
}
# 80 "/usr/include/c++/10.2.0/typeinfo" 3
namespace std
{






  class type_info
  {
  public:




    virtual ~type_info();



    const char* name() const noexcept
    { return __name[0] == '*' ? __name + 1 : __name; }
# 115 "/usr/include/c++/10.2.0/typeinfo" 3
    bool before(const type_info& __arg) const noexcept
    { return (__name[0] == '*' && __arg.__name[0] == '*')
 ? __name < __arg.__name
 : __builtin_strcmp (__name, __arg.__name) < 0; }

    bool operator==(const type_info& __arg) const noexcept
    {
      return ((__name == __arg.__name)
       || (__name[0] != '*' &&
    __builtin_strcmp (__name, __arg.__name) == 0));
    }
# 138 "/usr/include/c++/10.2.0/typeinfo" 3
    bool operator!=(const type_info& __arg) const noexcept
    { return !operator==(__arg); }



    size_t hash_code() const noexcept
    {

      return _Hash_bytes(name(), __builtin_strlen(name()),
    static_cast<size_t>(0xc70f6907UL));



    }



    virtual bool __is_pointer_p() const;


    virtual bool __is_function_p() const;







    virtual bool __do_catch(const type_info *__thr_type, void **__thr_obj,
       unsigned __outer) const;


    virtual bool __do_upcast(const __cxxabiv1::__class_type_info *__target,
        void **__obj_ptr) const;

  protected:
    const char *__name;

    explicit type_info(const char *__n): __name(__n) { }

  private:

    type_info& operator=(const type_info&);
    type_info(const type_info&);
  };







  class bad_cast : public exception
  {
  public:
    bad_cast() noexcept { }



    virtual ~bad_cast() noexcept;


    virtual const char* what() const noexcept;
  };





  class bad_typeid : public exception
  {
  public:
    bad_typeid () noexcept { }



    virtual ~bad_typeid() noexcept;


    virtual const char* what() const noexcept;
  };
}

}

#pragma GCC visibility pop
# 40 "/usr/include/c++/10.2.0/bits/exception_ptr.h" 2 3
# 1 "/usr/include/c++/10.2.0/new" 1 3
# 38 "/usr/include/c++/10.2.0/new" 3
       
# 39 "/usr/include/c++/10.2.0/new" 3


# 1 "/usr/include/c++/10.2.0/exception" 1 3
# 42 "/usr/include/c++/10.2.0/new" 2 3

#pragma GCC visibility push(default)

extern "C++" {

namespace std
{






  class bad_alloc : public exception
  {
  public:
    bad_alloc() throw() { }


    bad_alloc(const bad_alloc&) = default;
    bad_alloc& operator=(const bad_alloc&) = default;




    virtual ~bad_alloc() throw();


    virtual const char* what() const throw();
  };


  class bad_array_new_length : public bad_alloc
  {
  public:
    bad_array_new_length() throw() { }



    virtual ~bad_array_new_length() throw();


    virtual const char* what() const throw();
  };






  struct nothrow_t
  {

    explicit nothrow_t() = default;

  };

  extern const nothrow_t nothrow;



  typedef void (*new_handler)();



  new_handler set_new_handler(new_handler) throw();



  new_handler get_new_handler() noexcept;

}
# 126 "/usr/include/c++/10.2.0/new" 3
 void* operator new(std::size_t)
  __attribute__((__externally_visible__));
 void* operator new[](std::size_t)
  __attribute__((__externally_visible__));
void operator delete(void*) noexcept
  __attribute__((__externally_visible__));
void operator delete[](void*) noexcept
  __attribute__((__externally_visible__));

void operator delete(void*, std::size_t) noexcept
  __attribute__((__externally_visible__));
void operator delete[](void*, std::size_t) noexcept
  __attribute__((__externally_visible__));

 void* operator new(std::size_t, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__, __malloc__));
 void* operator new[](std::size_t, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__, __malloc__));
void operator delete(void*, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));
void operator delete[](void*, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));
# 174 "/usr/include/c++/10.2.0/new" 3
 inline void* operator new(std::size_t, void* __p) noexcept
{ return __p; }
 inline void* operator new[](std::size_t, void* __p) noexcept
{ return __p; }


inline void operator delete (void*, void*) noexcept { }
inline void operator delete[](void*, void*) noexcept { }

}
# 230 "/usr/include/c++/10.2.0/new" 3
#pragma GCC visibility pop
# 41 "/usr/include/c++/10.2.0/bits/exception_ptr.h" 2 3

extern "C++" {

namespace std
{
  class type_info;






  namespace __exception_ptr
  {
    class exception_ptr;
  }

  using __exception_ptr::exception_ptr;





  exception_ptr current_exception() noexcept;

  template<typename _Ex>
  exception_ptr make_exception_ptr(_Ex) noexcept;


  void rethrow_exception(exception_ptr) __attribute__ ((__noreturn__));

  namespace __exception_ptr
  {
    using std::rethrow_exception;





    class exception_ptr
    {
      void* _M_exception_object;

      explicit exception_ptr(void* __e) noexcept;

      void _M_addref() noexcept;
      void _M_release() noexcept;

      void *_M_get() const noexcept __attribute__ ((__pure__));

      friend exception_ptr std::current_exception() noexcept;
      friend void std::rethrow_exception(exception_ptr);
      template<typename _Ex>
      friend exception_ptr std::make_exception_ptr(_Ex) noexcept;

    public:
      exception_ptr() noexcept;

      exception_ptr(const exception_ptr&) noexcept;


      exception_ptr(nullptr_t) noexcept
      : _M_exception_object(0)
      { }

      exception_ptr(exception_ptr&& __o) noexcept
      : _M_exception_object(__o._M_exception_object)
      { __o._M_exception_object = 0; }
# 118 "/usr/include/c++/10.2.0/bits/exception_ptr.h" 3
      exception_ptr&
      operator=(const exception_ptr&) noexcept;


      exception_ptr&
      operator=(exception_ptr&& __o) noexcept
      {
        exception_ptr(static_cast<exception_ptr&&>(__o)).swap(*this);
        return *this;
      }


      ~exception_ptr() noexcept;

      void
      swap(exception_ptr&) noexcept;
# 145 "/usr/include/c++/10.2.0/bits/exception_ptr.h" 3
      explicit operator bool() const
      { return _M_exception_object; }


      friend bool
      operator==(const exception_ptr&, const exception_ptr&)
 noexcept __attribute__ ((__pure__));

      const class std::type_info*
      __cxa_exception_type() const noexcept
 __attribute__ ((__pure__));
    };



    bool
    operator==(const exception_ptr&, const exception_ptr&)
      noexcept __attribute__ ((__pure__));

    bool
    operator!=(const exception_ptr&, const exception_ptr&)
      noexcept __attribute__ ((__pure__));

    inline void
    swap(exception_ptr& __lhs, exception_ptr& __rhs)
    { __lhs.swap(__rhs); }




    template<typename _Ex>
      inline void
      __dest_thunk(void* __x)
      { static_cast<_Ex*>(__x)->~_Ex(); }


  }


  template<typename _Ex>
    exception_ptr
    make_exception_ptr(_Ex __ex) noexcept
    {

      void* __e = __cxxabiv1::__cxa_allocate_exception(sizeof(_Ex));
      (void) __cxxabiv1::__cxa_init_primary_exception(
   __e, const_cast<std::type_info*>(&typeid(__ex)),
   __exception_ptr::__dest_thunk<_Ex>);
      try
 {
          ::new (__e) _Ex(__ex);
          return exception_ptr(__e);
 }
      catch(...)
 {
   __cxxabiv1::__cxa_free_exception(__e);
   return current_exception();
 }
# 215 "/usr/include/c++/10.2.0/bits/exception_ptr.h" 3
    }


}

}

#pragma GCC visibility pop
# 148 "/usr/include/c++/10.2.0/exception" 2 3
# 1 "/usr/include/c++/10.2.0/bits/nested_exception.h" 1 3
# 33 "/usr/include/c++/10.2.0/bits/nested_exception.h" 3
#pragma GCC visibility push(default)






# 1 "/usr/include/c++/10.2.0/bits/move.h" 1 3
# 38 "/usr/include/c++/10.2.0/bits/move.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{







  template<typename _Tp>
    inline constexpr _Tp*
    __addressof(_Tp& __r) noexcept
    { return __builtin_addressof(__r); }




}



namespace std __attribute__ ((__visibility__ ("default")))
{

# 74 "/usr/include/c++/10.2.0/bits/move.h" 3
  template<typename _Tp>
    constexpr _Tp&&
    forward(typename std::remove_reference<_Tp>::type& __t) noexcept
    { return static_cast<_Tp&&>(__t); }







  template<typename _Tp>
    constexpr _Tp&&
    forward(typename std::remove_reference<_Tp>::type&& __t) noexcept
    {
      static_assert(!std::is_lvalue_reference<_Tp>::value, "template argument"
      " substituting _Tp is an lvalue reference type");
      return static_cast<_Tp&&>(__t);
    }






  template<typename _Tp>
    constexpr typename std::remove_reference<_Tp>::type&&
    move(_Tp&& __t) noexcept
    { return static_cast<typename std::remove_reference<_Tp>::type&&>(__t); }


  template<typename _Tp>
    struct __move_if_noexcept_cond
    : public __and_<__not_<is_nothrow_move_constructible<_Tp>>,
                    is_copy_constructible<_Tp>>::type { };
# 118 "/usr/include/c++/10.2.0/bits/move.h" 3
  template<typename _Tp>
    constexpr typename
    conditional<__move_if_noexcept_cond<_Tp>::value, const _Tp&, _Tp&&>::type
    move_if_noexcept(_Tp& __x) noexcept
    { return std::move(__x); }
# 138 "/usr/include/c++/10.2.0/bits/move.h" 3
  template<typename _Tp>
    inline _Tp*
    addressof(_Tp& __r) noexcept
    { return std::__addressof(__r); }



  template<typename _Tp>
    const _Tp* addressof(const _Tp&&) = delete;


  template <typename _Tp, typename _Up = _Tp>
   
    inline _Tp
    __exchange(_Tp& __obj, _Up&& __new_val)
    {
      _Tp __old_val = std::move(__obj);
      __obj = std::forward<_Up>(__new_val);
      return __old_val;
    }
# 179 "/usr/include/c++/10.2.0/bits/move.h" 3
  template<typename _Tp>
   
    inline

    typename enable_if<__and_<__not_<__is_tuple_like<_Tp>>,
         is_move_constructible<_Tp>,
         is_move_assignable<_Tp>>::value>::type



    swap(_Tp& __a, _Tp& __b)
    noexcept(__and_<is_nothrow_move_constructible<_Tp>, is_nothrow_move_assignable<_Tp>>::value)

    {




      _Tp __tmp = std::move(__a);
      __a = std::move(__b);
      __b = std::move(__tmp);
    }




  template<typename _Tp, size_t _Nm>
   
    inline

    typename enable_if<__is_swappable<_Tp>::value>::type



    swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])
    noexcept(__is_nothrow_swappable<_Tp>::value)
    {
      for (size_t __n = 0; __n < _Nm; ++__n)
 swap(__a[__n], __b[__n]);
    }



}
# 41 "/usr/include/c++/10.2.0/bits/nested_exception.h" 2 3

extern "C++" {

namespace std
{






  class nested_exception
  {
    exception_ptr _M_ptr;

  public:
    nested_exception() noexcept : _M_ptr(current_exception()) { }

    nested_exception(const nested_exception&) noexcept = default;

    nested_exception& operator=(const nested_exception&) noexcept = default;

    virtual ~nested_exception() noexcept;

    [[noreturn]]
    void
    rethrow_nested() const
    {
      if (_M_ptr)
 rethrow_exception(_M_ptr);
      std::terminate();
    }

    exception_ptr
    nested_ptr() const noexcept
    { return _M_ptr; }
  };



  template<typename _Except>
    struct _Nested_exception : public _Except, public nested_exception
    {
      explicit _Nested_exception(const _Except& __ex)
      : _Except(__ex)
      { }

      explicit _Nested_exception(_Except&& __ex)
      : _Except(static_cast<_Except&&>(__ex))
      { }
    };




  template<typename _Tp>
    [[noreturn]]
    inline void
    __throw_with_nested_impl(_Tp&& __t, true_type)
    {
      using _Up = typename remove_reference<_Tp>::type;
      throw _Nested_exception<_Up>{std::forward<_Tp>(__t)};
    }

  template<typename _Tp>
    [[noreturn]]
    inline void
    __throw_with_nested_impl(_Tp&& __t, false_type)
    { throw std::forward<_Tp>(__t); }





  template<typename _Tp>
    [[noreturn]]
    inline void
    throw_with_nested(_Tp&& __t)
    {
      using _Up = typename decay<_Tp>::type;
      using _CopyConstructible
 = __and_<is_copy_constructible<_Up>, is_move_constructible<_Up>>;
      static_assert(_CopyConstructible::value,
   "throw_with_nested argument must be CopyConstructible");
      using __nest = __and_<is_class<_Up>, __bool_constant<!__is_final(_Up)>,
       __not_<is_base_of<nested_exception, _Up>>>;
      std::__throw_with_nested_impl(std::forward<_Tp>(__t), __nest{});
    }




  template<typename _Tp>
    using __rethrow_if_nested_cond = typename enable_if<
      __and_<is_polymorphic<_Tp>,
      __or_<__not_<is_base_of<nested_exception, _Tp>>,
     is_convertible<_Tp*, nested_exception*>>>::value
    >::type;


  template<typename _Ex>
    inline __rethrow_if_nested_cond<_Ex>
    __rethrow_if_nested_impl(const _Ex* __ptr)
    {
      if (auto __ne_ptr = dynamic_cast<const nested_exception*>(__ptr))
 __ne_ptr->rethrow_nested();
    }


  inline void
  __rethrow_if_nested_impl(const void*)
  { }




  template<typename _Ex>
    inline void
    rethrow_if_nested(const _Ex& __ex)
    { std::__rethrow_if_nested_impl(std::__addressof(__ex)); }


}

}



#pragma GCC visibility pop
# 149 "/usr/include/c++/10.2.0/exception" 2 3
# 40 "/usr/include/c++/10.2.0/ios" 2 3
# 1 "/usr/include/c++/10.2.0/bits/char_traits.h" 1 3
# 37 "/usr/include/c++/10.2.0/bits/char_traits.h" 3
       
# 38 "/usr/include/c++/10.2.0/bits/char_traits.h" 3

# 1 "/usr/include/c++/10.2.0/bits/stl_algobase.h" 1 3
# 60 "/usr/include/c++/10.2.0/bits/stl_algobase.h" 3
# 1 "/usr/include/c++/10.2.0/bits/functexcept.h" 1 3
# 42 "/usr/include/c++/10.2.0/bits/functexcept.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  void
  __throw_bad_exception(void) __attribute__((__noreturn__));


  void
  __throw_bad_alloc(void) __attribute__((__noreturn__));


  void
  __throw_bad_cast(void) __attribute__((__noreturn__));

  void
  __throw_bad_typeid(void) __attribute__((__noreturn__));


  void
  __throw_logic_error(const char*) __attribute__((__noreturn__));

  void
  __throw_domain_error(const char*) __attribute__((__noreturn__));

  void
  __throw_invalid_argument(const char*) __attribute__((__noreturn__));

  void
  __throw_length_error(const char*) __attribute__((__noreturn__));

  void
  __throw_out_of_range(const char*) __attribute__((__noreturn__));

  void
  __throw_out_of_range_fmt(const char*, ...) __attribute__((__noreturn__))
    __attribute__((__format__(__gnu_printf__, 1, 2)));

  void
  __throw_runtime_error(const char*) __attribute__((__noreturn__));

  void
  __throw_range_error(const char*) __attribute__((__noreturn__));

  void
  __throw_overflow_error(const char*) __attribute__((__noreturn__));

  void
  __throw_underflow_error(const char*) __attribute__((__noreturn__));


  void
  __throw_ios_failure(const char*) __attribute__((__noreturn__));

  void
  __throw_ios_failure(const char*, int) __attribute__((__noreturn__));


  void
  __throw_system_error(int) __attribute__((__noreturn__));


  void
  __throw_future_error(int) __attribute__((__noreturn__));


  void
  __throw_bad_function_call() __attribute__((__noreturn__));


}
# 61 "/usr/include/c++/10.2.0/bits/stl_algobase.h" 2 3


# 1 "/usr/include/c++/10.2.0/ext/numeric_traits.h" 1 3
# 32 "/usr/include/c++/10.2.0/ext/numeric_traits.h" 3
       
# 33 "/usr/include/c++/10.2.0/ext/numeric_traits.h" 3




namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{

# 54 "/usr/include/c++/10.2.0/ext/numeric_traits.h" 3
  template<typename _Value>
    struct __numeric_traits_integer
    {

      static const _Value __min = (((_Value)(-1) < 0) ? -(((_Value)(-1) < 0) ? (((((_Value)1 << ((sizeof(_Value) * 8 - ((_Value)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(_Value)0) - 1 : (_Value)0);
      static const _Value __max = (((_Value)(-1) < 0) ? (((((_Value)1 << ((sizeof(_Value) * 8 - ((_Value)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(_Value)0);



      static const bool __is_signed = ((_Value)(-1) < 0);
      static const int __digits = (sizeof(_Value) * 8 - ((_Value)(-1) < 0));
    };

  template<typename _Value>
    const _Value __numeric_traits_integer<_Value>::__min;

  template<typename _Value>
    const _Value __numeric_traits_integer<_Value>::__max;

  template<typename _Value>
    const bool __numeric_traits_integer<_Value>::__is_signed;

  template<typename _Value>
    const int __numeric_traits_integer<_Value>::__digits;
# 99 "/usr/include/c++/10.2.0/ext/numeric_traits.h" 3
  template<typename _Value>
    struct __numeric_traits_floating
    {

      static const int __max_digits10 = (2 + (std::__are_same<_Value, float>::__value ? 24 : std::__are_same<_Value, double>::__value ? 53 : 64) * 643L / 2136);


      static const bool __is_signed = true;
      static const int __digits10 = (std::__are_same<_Value, float>::__value ? 6 : std::__are_same<_Value, double>::__value ? 15 : 18);
      static const int __max_exponent10 = (std::__are_same<_Value, float>::__value ? 38 : std::__are_same<_Value, double>::__value ? 308 : 4932);
    };

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__max_digits10;

  template<typename _Value>
    const bool __numeric_traits_floating<_Value>::__is_signed;

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__digits10;

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__max_exponent10;

  template<typename _Value>
    struct __numeric_traits
    : public __conditional_type<std::__is_integer<_Value>::__value,
    __numeric_traits_integer<_Value>,
    __numeric_traits_floating<_Value> >::__type
    { };


}
# 64 "/usr/include/c++/10.2.0/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/10.2.0/bits/stl_pair.h" 1 3
# 69 "/usr/include/c++/10.2.0/bits/stl_pair.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 80 "/usr/include/c++/10.2.0/bits/stl_pair.h" 3
  struct piecewise_construct_t { explicit piecewise_construct_t() = default; };


  constexpr piecewise_construct_t piecewise_construct =
    piecewise_construct_t();




  template<typename...>
    class tuple;

  template<std::size_t...>
    struct _Index_tuple;






  template <bool, typename _T1, typename _T2>
    struct _PCC
    {
      template <typename _U1, typename _U2>
      static constexpr bool _ConstructiblePair()
      {
 return __and_<is_constructible<_T1, const _U1&>,
        is_constructible<_T2, const _U2&>>::value;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _ImplicitlyConvertiblePair()
      {
 return __and_<is_convertible<const _U1&, _T1>,
        is_convertible<const _U2&, _T2>>::value;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _MoveConstructiblePair()
      {
 return __and_<is_constructible<_T1, _U1&&>,
        is_constructible<_T2, _U2&&>>::value;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _ImplicitlyMoveConvertiblePair()
      {
 return __and_<is_convertible<_U1&&, _T1>,
        is_convertible<_U2&&, _T2>>::value;
      }

      template <bool __implicit, typename _U1, typename _U2>
      static constexpr bool _CopyMovePair()
      {
 using __do_converts = __and_<is_convertible<const _U1&, _T1>,
      is_convertible<_U2&&, _T2>>;
 using __converts = typename conditional<__implicit,
           __do_converts,
           __not_<__do_converts>>::type;
 return __and_<is_constructible<_T1, const _U1&>,
        is_constructible<_T2, _U2&&>,
        __converts
        >::value;
      }

      template <bool __implicit, typename _U1, typename _U2>
      static constexpr bool _MoveCopyPair()
      {
 using __do_converts = __and_<is_convertible<_U1&&, _T1>,
      is_convertible<const _U2&, _T2>>;
 using __converts = typename conditional<__implicit,
           __do_converts,
           __not_<__do_converts>>::type;
 return __and_<is_constructible<_T1, _U1&&>,
        is_constructible<_T2, const _U2&&>,
        __converts
        >::value;
      }
  };

  template <typename _T1, typename _T2>
    struct _PCC<false, _T1, _T2>
    {
      template <typename _U1, typename _U2>
      static constexpr bool _ConstructiblePair()
      {
 return false;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _ImplicitlyConvertiblePair()
      {
 return false;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _MoveConstructiblePair()
      {
 return false;
      }

      template <typename _U1, typename _U2>
      static constexpr bool _ImplicitlyMoveConvertiblePair()
      {
 return false;
      }
  };


  template<typename _U1, typename _U2> class __pair_base
  {

    template<typename _T1, typename _T2> friend struct pair;
    __pair_base() = default;
    ~__pair_base() = default;
    __pair_base(const __pair_base&) = default;
    __pair_base& operator=(const __pair_base&) = delete;

  };
# 210 "/usr/include/c++/10.2.0/bits/stl_pair.h" 3
  template<typename _T1, typename _T2>
    struct pair
    : private __pair_base<_T1, _T2>
    {
      typedef _T1 first_type;
      typedef _T2 second_type;

      _T1 first;
      _T2 second;






      template <typename _U1 = _T1,
                typename _U2 = _T2,
                typename enable_if<__and_<
                                     __is_implicitly_default_constructible<_U1>,
                                     __is_implicitly_default_constructible<_U2>>
                                   ::value, bool>::type = true>

      constexpr pair()
      : first(), second() { }


      template <typename _U1 = _T1,
                typename _U2 = _T2,
                typename enable_if<__and_<
                       is_default_constructible<_U1>,
                       is_default_constructible<_U2>,
                       __not_<
                         __and_<__is_implicitly_default_constructible<_U1>,
                                __is_implicitly_default_constructible<_U2>>>>
                                   ::value, bool>::type = false>
      explicit constexpr pair()
      : first(), second() { }
# 256 "/usr/include/c++/10.2.0/bits/stl_pair.h" 3
      using _PCCP = _PCC<true, _T1, _T2>;



      template<typename _U1 = _T1, typename _U2=_T2, typename
        enable_if<_PCCP::template
      _ConstructiblePair<_U1, _U2>()
                  && _PCCP::template
      _ImplicitlyConvertiblePair<_U1, _U2>(),
                         bool>::type=true>
      constexpr pair(const _T1& __a, const _T2& __b)
      : first(__a), second(__b) { }


       template<typename _U1 = _T1, typename _U2=_T2, typename
  enable_if<_PCCP::template
       _ConstructiblePair<_U1, _U2>()
                   && !_PCCP::template
       _ImplicitlyConvertiblePair<_U1, _U2>(),
                         bool>::type=false>
      explicit constexpr pair(const _T1& __a, const _T2& __b)
      : first(__a), second(__b) { }
# 288 "/usr/include/c++/10.2.0/bits/stl_pair.h" 3
      template <typename _U1, typename _U2>
        using _PCCFP = _PCC<!is_same<_T1, _U1>::value
       || !is_same<_T2, _U2>::value,
       _T1, _T2>;


      template<typename _U1, typename _U2, typename
        enable_if<_PCCFP<_U1, _U2>::template
      _ConstructiblePair<_U1, _U2>()
                  && _PCCFP<_U1, _U2>::template
      _ImplicitlyConvertiblePair<_U1, _U2>(),
     bool>::type=true>
        constexpr pair(const pair<_U1, _U2>& __p)
        : first(__p.first), second(__p.second) { }

      template<typename _U1, typename _U2, typename
        enable_if<_PCCFP<_U1, _U2>::template
      _ConstructiblePair<_U1, _U2>()
    && !_PCCFP<_U1, _U2>::template
      _ImplicitlyConvertiblePair<_U1, _U2>(),
                         bool>::type=false>
 explicit constexpr pair(const pair<_U1, _U2>& __p)
 : first(__p.first), second(__p.second) { }



      constexpr pair(const pair&) = default;
      constexpr pair(pair&&) = default;


      template<typename _U1, typename
        enable_if<_PCCP::template
      _MoveCopyPair<true, _U1, _T2>(),
                         bool>::type=true>
       constexpr pair(_U1&& __x, const _T2& __y)
       : first(std::forward<_U1>(__x)), second(__y) { }

      template<typename _U1, typename
        enable_if<_PCCP::template
      _MoveCopyPair<false, _U1, _T2>(),
                         bool>::type=false>
       explicit constexpr pair(_U1&& __x, const _T2& __y)
       : first(std::forward<_U1>(__x)), second(__y) { }

      template<typename _U2, typename
        enable_if<_PCCP::template
      _CopyMovePair<true, _T1, _U2>(),
                         bool>::type=true>
       constexpr pair(const _T1& __x, _U2&& __y)
       : first(__x), second(std::forward<_U2>(__y)) { }

      template<typename _U2, typename
        enable_if<_PCCP::template
      _CopyMovePair<false, _T1, _U2>(),
                         bool>::type=false>
       explicit pair(const _T1& __x, _U2&& __y)
       : first(__x), second(std::forward<_U2>(__y)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_PCCP::template
      _MoveConstructiblePair<_U1, _U2>()
     && _PCCP::template
      _ImplicitlyMoveConvertiblePair<_U1, _U2>(),
                         bool>::type=true>
 constexpr pair(_U1&& __x, _U2&& __y)
 : first(std::forward<_U1>(__x)), second(std::forward<_U2>(__y)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_PCCP::template
      _MoveConstructiblePair<_U1, _U2>()
     && !_PCCP::template
      _ImplicitlyMoveConvertiblePair<_U1, _U2>(),
                         bool>::type=false>
 explicit constexpr pair(_U1&& __x, _U2&& __y)
 : first(std::forward<_U1>(__x)), second(std::forward<_U2>(__y)) { }


      template<typename _U1, typename _U2, typename
        enable_if<_PCCFP<_U1, _U2>::template
      _MoveConstructiblePair<_U1, _U2>()
     && _PCCFP<_U1, _U2>::template
      _ImplicitlyMoveConvertiblePair<_U1, _U2>(),
                         bool>::type=true>
 constexpr pair(pair<_U1, _U2>&& __p)
 : first(std::forward<_U1>(__p.first)),
   second(std::forward<_U2>(__p.second)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_PCCFP<_U1, _U2>::template
      _MoveConstructiblePair<_U1, _U2>()
     && !_PCCFP<_U1, _U2>::template
      _ImplicitlyMoveConvertiblePair<_U1, _U2>(),
                         bool>::type=false>
 explicit constexpr pair(pair<_U1, _U2>&& __p)
 : first(std::forward<_U1>(__p.first)),
   second(std::forward<_U2>(__p.second)) { }

      template<typename... _Args1, typename... _Args2>

        pair(piecewise_construct_t, tuple<_Args1...>, tuple<_Args2...>);

      pair&
      operator=(typename conditional<
  __and_<is_copy_assignable<_T1>,
         is_copy_assignable<_T2>>::value,
  const pair&, const __nonesuch&>::type __p)
      {
 first = __p.first;
 second = __p.second;
 return *this;
      }

      pair&
      operator=(typename conditional<
  __and_<is_move_assignable<_T1>,
         is_move_assignable<_T2>>::value,
  pair&&, __nonesuch&&>::type __p)
      noexcept(__and_<is_nothrow_move_assignable<_T1>,
        is_nothrow_move_assignable<_T2>>::value)
      {
 first = std::forward<first_type>(__p.first);
 second = std::forward<second_type>(__p.second);
 return *this;
      }

      template<typename _U1, typename _U2>

 typename enable_if<__and_<is_assignable<_T1&, const _U1&>,
      is_assignable<_T2&, const _U2&>>::value,
      pair&>::type
 operator=(const pair<_U1, _U2>& __p)
 {
   first = __p.first;
   second = __p.second;
   return *this;
 }

      template<typename _U1, typename _U2>

 typename enable_if<__and_<is_assignable<_T1&, _U1&&>,
      is_assignable<_T2&, _U2&&>>::value,
      pair&>::type
 operator=(pair<_U1, _U2>&& __p)
 {
   first = std::forward<_U1>(__p.first);
   second = std::forward<_U2>(__p.second);
   return *this;
 }


      void
      swap(pair& __p)
      noexcept(__and_<__is_nothrow_swappable<_T1>,
                      __is_nothrow_swappable<_T2>>::value)
      {
 using std::swap;
 swap(first, __p.first);
 swap(second, __p.second);
      }

    private:
      template<typename... _Args1, std::size_t... _Indexes1,
               typename... _Args2, std::size_t... _Indexes2>

        pair(tuple<_Args1...>&, tuple<_Args2...>&,
             _Index_tuple<_Indexes1...>, _Index_tuple<_Indexes2...>);

    };
# 464 "/usr/include/c++/10.2.0/bits/stl_pair.h" 3
  template<typename _T1, typename _T2>
    inline constexpr bool
    operator==(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first == __y.first && __x.second == __y.second; }
# 487 "/usr/include/c++/10.2.0/bits/stl_pair.h" 3
  template<typename _T1, typename _T2>
    inline constexpr bool
    operator<(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first < __y.first
      || (!(__y.first < __x.first) && __x.second < __y.second); }


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x == __y); }


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator>(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __y < __x; }


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator<=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__y < __x); }


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator>=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x < __y); }
# 524 "/usr/include/c++/10.2.0/bits/stl_pair.h" 3
  template<typename _T1, typename _T2>
    inline


    typename enable_if<__and_<__is_swappable<_T1>,
                              __is_swappable<_T2>>::value>::type



    swap(pair<_T1, _T2>& __x, pair<_T1, _T2>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }


  template<typename _T1, typename _T2>
    typename enable_if<!__and_<__is_swappable<_T1>,
          __is_swappable<_T2>>::value>::type
    swap(pair<_T1, _T2>&, pair<_T1, _T2>&) = delete;
# 564 "/usr/include/c++/10.2.0/bits/stl_pair.h" 3
  template<typename _T1, typename _T2>
    constexpr pair<typename __decay_and_strip<_T1>::__type,
                   typename __decay_and_strip<_T2>::__type>
    make_pair(_T1&& __x, _T2&& __y)
    {
      typedef typename __decay_and_strip<_T1>::__type __ds_type1;
      typedef typename __decay_and_strip<_T2>::__type __ds_type2;
      typedef pair<__ds_type1, __ds_type2> __pair_type;
      return __pair_type(std::forward<_T1>(__x), std::forward<_T2>(__y));
    }
# 583 "/usr/include/c++/10.2.0/bits/stl_pair.h" 3

}
# 65 "/usr/include/c++/10.2.0/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/10.2.0/bits/stl_iterator_base_types.h" 1 3
# 62 "/usr/include/c++/10.2.0/bits/stl_iterator_base_types.h" 3
       
# 63 "/usr/include/c++/10.2.0/bits/stl_iterator_base_types.h" 3
# 74 "/usr/include/c++/10.2.0/bits/stl_iterator_base_types.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 93 "/usr/include/c++/10.2.0/bits/stl_iterator_base_types.h" 3
  struct input_iterator_tag { };


  struct output_iterator_tag { };


  struct forward_iterator_tag : public input_iterator_tag { };



  struct bidirectional_iterator_tag : public forward_iterator_tag { };



  struct random_access_iterator_tag : public bidirectional_iterator_tag { };
# 125 "/usr/include/c++/10.2.0/bits/stl_iterator_base_types.h" 3
  template<typename _Category, typename _Tp, typename _Distance = ptrdiff_t,
           typename _Pointer = _Tp*, typename _Reference = _Tp&>
    struct iterator
    {

      typedef _Category iterator_category;

      typedef _Tp value_type;

      typedef _Distance difference_type;

      typedef _Pointer pointer;

      typedef _Reference reference;
    };
# 149 "/usr/include/c++/10.2.0/bits/stl_iterator_base_types.h" 3
  template<typename _Iterator>
    struct iterator_traits;




  template<typename _Iterator, typename = __void_t<>>
    struct __iterator_traits { };



  template<typename _Iterator>
    struct __iterator_traits<_Iterator,
        __void_t<typename _Iterator::iterator_category,
          typename _Iterator::value_type,
          typename _Iterator::difference_type,
          typename _Iterator::pointer,
          typename _Iterator::reference>>
    {
      typedef typename _Iterator::iterator_category iterator_category;
      typedef typename _Iterator::value_type value_type;
      typedef typename _Iterator::difference_type difference_type;
      typedef typename _Iterator::pointer pointer;
      typedef typename _Iterator::reference reference;
    };


  template<typename _Iterator>
    struct iterator_traits
    : public __iterator_traits<_Iterator> { };
# 209 "/usr/include/c++/10.2.0/bits/stl_iterator_base_types.h" 3
  template<typename _Tp>
    struct iterator_traits<_Tp*>
    {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef _Tp& reference;
    };


  template<typename _Tp>
    struct iterator_traits<const _Tp*>
    {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef const _Tp* pointer;
      typedef const _Tp& reference;
    };






  template<typename _Iter>
    inline constexpr
    typename iterator_traits<_Iter>::iterator_category
    __iterator_category(const _Iter&)
    { return typename iterator_traits<_Iter>::iterator_category(); }




  template<typename _Iter>
    using __iterator_category_t
      = typename iterator_traits<_Iter>::iterator_category;

  template<typename _InIter>
    using _RequireInputIter =
      __enable_if_t<is_convertible<__iterator_category_t<_InIter>,
       input_iterator_tag>::value>;

  template<typename _It,
    typename _Cat = __iterator_category_t<_It>>
    struct __is_random_access_iter
      : is_base_of<random_access_iterator_tag, _Cat>
    {
      typedef is_base_of<random_access_iterator_tag, _Cat> _Base;
      enum { __value = _Base::value };
    };








}
# 66 "/usr/include/c++/10.2.0/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/10.2.0/bits/stl_iterator_base_funcs.h" 1 3
# 62 "/usr/include/c++/10.2.0/bits/stl_iterator_base_funcs.h" 3
       
# 63 "/usr/include/c++/10.2.0/bits/stl_iterator_base_funcs.h" 3

# 1 "/usr/include/c++/10.2.0/bits/concept_check.h" 1 3
# 33 "/usr/include/c++/10.2.0/bits/concept_check.h" 3
       
# 34 "/usr/include/c++/10.2.0/bits/concept_check.h" 3
# 65 "/usr/include/c++/10.2.0/bits/stl_iterator_base_funcs.h" 2 3
# 1 "/usr/include/c++/10.2.0/debug/assertions.h" 1 3
# 66 "/usr/include/c++/10.2.0/bits/stl_iterator_base_funcs.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{




  template <typename> struct _List_iterator;
  template <typename> struct _List_const_iterator;


  template<typename _InputIterator>
    inline constexpr
    typename iterator_traits<_InputIterator>::difference_type
    __distance(_InputIterator __first, _InputIterator __last,
               input_iterator_tag)
    {

     

      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      while (__first != __last)
 {
   ++__first;
   ++__n;
 }
      return __n;
    }

  template<typename _RandomAccessIterator>
    inline constexpr
    typename iterator_traits<_RandomAccessIterator>::difference_type
    __distance(_RandomAccessIterator __first, _RandomAccessIterator __last,
               random_access_iterator_tag)
    {

     

      return __last - __first;
    }



  template<typename _Tp>
    ptrdiff_t
    __distance(std::_List_iterator<_Tp>,
        std::_List_iterator<_Tp>,
        input_iterator_tag);

  template<typename _Tp>
    ptrdiff_t
    __distance(std::_List_const_iterator<_Tp>,
        std::_List_const_iterator<_Tp>,
        input_iterator_tag);
# 135 "/usr/include/c++/10.2.0/bits/stl_iterator_base_funcs.h" 3
  template<typename _InputIterator>
    inline
    typename iterator_traits<_InputIterator>::difference_type
    distance(_InputIterator __first, _InputIterator __last)
    {

      return std::__distance(__first, __last,
        std::__iterator_category(__first));
    }

  template<typename _InputIterator, typename _Distance>
    inline constexpr void
    __advance(_InputIterator& __i, _Distance __n, input_iterator_tag)
    {

     
      ;
      while (__n--)
 ++__i;
    }

  template<typename _BidirectionalIterator, typename _Distance>
    inline constexpr void
    __advance(_BidirectionalIterator& __i, _Distance __n,
       bidirectional_iterator_tag)
    {

     

      if (__n > 0)
        while (__n--)
   ++__i;
      else
        while (__n++)
   --__i;
    }

  template<typename _RandomAccessIterator, typename _Distance>
    inline constexpr void
    __advance(_RandomAccessIterator& __i, _Distance __n,
              random_access_iterator_tag)
    {

     

      if (__builtin_constant_p(__n) && __n == 1)
 ++__i;
      else if (__builtin_constant_p(__n) && __n == -1)
 --__i;
      else
 __i += __n;
    }
# 200 "/usr/include/c++/10.2.0/bits/stl_iterator_base_funcs.h" 3
  template<typename _InputIterator, typename _Distance>
    inline void
    advance(_InputIterator& __i, _Distance __n)
    {

      typename iterator_traits<_InputIterator>::difference_type __d = __n;
      std::__advance(__i, __d, std::__iterator_category(__i));
    }



  template<typename _InputIterator>
    inline _InputIterator
    next(_InputIterator __x, typename
  iterator_traits<_InputIterator>::difference_type __n = 1)
    {

     
      std::advance(__x, __n);
      return __x;
    }

  template<typename _BidirectionalIterator>
    inline _BidirectionalIterator
    prev(_BidirectionalIterator __x, typename
  iterator_traits<_BidirectionalIterator>::difference_type __n = 1)
    {

     

      std::advance(__x, -__n);
      return __x;
    }




}
# 67 "/usr/include/c++/10.2.0/bits/stl_algobase.h" 2 3
# 1 "/usr/include/c++/10.2.0/bits/stl_iterator.h" 1 3
# 66 "/usr/include/c++/10.2.0/bits/stl_iterator.h" 3
# 1 "/usr/include/c++/10.2.0/bits/ptr_traits.h" 1 3
# 42 "/usr/include/c++/10.2.0/bits/ptr_traits.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  class __undefined;


  template<typename _Tp>
    struct __get_first_arg
    { using type = __undefined; };

  template<template<typename, typename...> class _Template, typename _Tp,
           typename... _Types>
    struct __get_first_arg<_Template<_Tp, _Types...>>
    { using type = _Tp; };

  template<typename _Tp>
    using __get_first_arg_t = typename __get_first_arg<_Tp>::type;


  template<typename _Tp, typename _Up>
    struct __replace_first_arg
    { };

  template<template<typename, typename...> class _Template, typename _Up,
           typename _Tp, typename... _Types>
    struct __replace_first_arg<_Template<_Tp, _Types...>, _Up>
    { using type = _Template<_Up, _Types...>; };

  template<typename _Tp, typename _Up>
    using __replace_first_arg_t = typename __replace_first_arg<_Tp, _Up>::type;

  template<typename _Tp>
    using __make_not_void
      = typename conditional<is_void<_Tp>::value, __undefined, _Tp>::type;





  template<typename _Ptr>
    struct pointer_traits
    {
    private:
      template<typename _Tp>
 using __element_type = typename _Tp::element_type;

      template<typename _Tp>
 using __difference_type = typename _Tp::difference_type;

      template<typename _Tp, typename _Up, typename = void>
 struct __rebind : __replace_first_arg<_Tp, _Up> { };

      template<typename _Tp, typename _Up>
 struct __rebind<_Tp, _Up, __void_t<typename _Tp::template rebind<_Up>>>
 { using type = typename _Tp::template rebind<_Up>; };

    public:

      using pointer = _Ptr;


      using element_type
 = __detected_or_t<__get_first_arg_t<_Ptr>, __element_type, _Ptr>;


      using difference_type
 = __detected_or_t<ptrdiff_t, __difference_type, _Ptr>;


      template<typename _Up>
        using rebind = typename __rebind<_Ptr, _Up>::type;

      static _Ptr
      pointer_to(__make_not_void<element_type>& __e)
      { return _Ptr::pointer_to(__e); }

      static_assert(!is_same<element_type, __undefined>::value,
   "pointer type defines element_type or is like SomePointer<T, Args>");
    };





  template<typename _Tp>
    struct pointer_traits<_Tp*>
    {

      typedef _Tp* pointer;

      typedef _Tp element_type;

      typedef ptrdiff_t difference_type;

      template<typename _Up>
        using rebind = _Up*;






      static pointer
      pointer_to(__make_not_void<element_type>& __r) noexcept
      { return std::addressof(__r); }
    };


  template<typename _Ptr, typename _Tp>
    using __ptr_rebind = typename pointer_traits<_Ptr>::template rebind<_Tp>;

  template<typename _Tp>
    constexpr _Tp*
    __to_address(_Tp* __ptr) noexcept
    {
      static_assert(!std::is_function<_Tp>::value, "not a function pointer");
      return __ptr;
    }


  template<typename _Ptr>
    constexpr typename std::pointer_traits<_Ptr>::element_type*
    __to_address(const _Ptr& __ptr)
    { return std::__to_address(__ptr.operator->()); }
# 210 "/usr/include/c++/10.2.0/bits/ptr_traits.h" 3

}
# 67 "/usr/include/c++/10.2.0/bits/stl_iterator.h" 2 3
# 85 "/usr/include/c++/10.2.0/bits/stl_iterator.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 124 "/usr/include/c++/10.2.0/bits/stl_iterator.h" 3
  template<typename _Iterator>
    class reverse_iterator
    : public iterator<typename iterator_traits<_Iterator>::iterator_category,
        typename iterator_traits<_Iterator>::value_type,
        typename iterator_traits<_Iterator>::difference_type,
        typename iterator_traits<_Iterator>::pointer,
                      typename iterator_traits<_Iterator>::reference>
    {
    protected:
      _Iterator current;

      typedef iterator_traits<_Iterator> __traits_type;

    public:
      typedef _Iterator iterator_type;
      typedef typename __traits_type::difference_type difference_type;
      typedef typename __traits_type::pointer pointer;
      typedef typename __traits_type::reference reference;
# 160 "/usr/include/c++/10.2.0/bits/stl_iterator.h" 3
     
      reverse_iterator() : current() { }




      explicit
      reverse_iterator(iterator_type __x) : current(__x) { }




     
      reverse_iterator(const reverse_iterator& __x)
      : current(__x.current) { }


      reverse_iterator& operator=(const reverse_iterator&) = default;






      template<typename _Iter>

        reverse_iterator(const reverse_iterator<_Iter>& __x)
 : current(__x.base()) { }




      iterator_type
      base() const
      { return current; }
# 206 "/usr/include/c++/10.2.0/bits/stl_iterator.h" 3
      reference
      operator*() const
      {
 _Iterator __tmp = current;
 return *--__tmp;
      }






      pointer
      operator->() const




      {


 _Iterator __tmp = current;
 --__tmp;
 return _S_to_pointer(__tmp);
      }






      reverse_iterator&
      operator++()
      {
 --current;
 return *this;
      }






      reverse_iterator
      operator++(int)
      {
 reverse_iterator __tmp = *this;
 --current;
 return __tmp;
      }






      reverse_iterator&
      operator--()
      {
 ++current;
 return *this;
      }






      reverse_iterator
      operator--(int)
      {
 reverse_iterator __tmp = *this;
 ++current;
 return __tmp;
      }






      reverse_iterator
      operator+(difference_type __n) const
      { return reverse_iterator(current - __n); }







      reverse_iterator&
      operator+=(difference_type __n)
      {
 current -= __n;
 return *this;
      }






      reverse_iterator
      operator-(difference_type __n) const
      { return reverse_iterator(current + __n); }







      reverse_iterator&
      operator-=(difference_type __n)
      {
 current += __n;
 return *this;
      }






      reference
      operator[](difference_type __n) const
      { return *(*this + __n); }

    private:
      template<typename _Tp>
 static _Tp*
 _S_to_pointer(_Tp* __p)
        { return __p; }

      template<typename _Tp>
 static pointer
 _S_to_pointer(_Tp __t)
        { return __t.operator->(); }
    };
# 358 "/usr/include/c++/10.2.0/bits/stl_iterator.h" 3
  template<typename _Iterator>
    inline bool
    operator==(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return __x.base() == __y.base(); }

  template<typename _Iterator>
    inline bool
    operator<(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y.base() < __x.base(); }

  template<typename _Iterator>
    inline bool
    operator!=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__x == __y); }

  template<typename _Iterator>
    inline bool
    operator>(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y < __x; }

  template<typename _Iterator>
    inline bool
    operator<=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__y < __x); }

  template<typename _Iterator>
    inline bool
    operator>=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__x < __y); }



  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator==(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return __x.base() == __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    { return __y.base() < __x.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator!=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__x == __y); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    { return __y < __x; }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__y < __x); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__x < __y); }
# 498 "/usr/include/c++/10.2.0/bits/stl_iterator.h" 3
  template<typename _IteratorL, typename _IteratorR>
    inline auto
    operator-(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    -> decltype(__y.base() - __x.base())
    { return __y.base() - __x.base(); }


  template<typename _Iterator>
    inline reverse_iterator<_Iterator>
    operator+(typename reverse_iterator<_Iterator>::difference_type __n,
       const reverse_iterator<_Iterator>& __x)
    { return reverse_iterator<_Iterator>(__x.base() - __n); }



  template<typename _Iterator>
    inline reverse_iterator<_Iterator>
    __make_reverse_iterator(_Iterator __i)
    { return reverse_iterator<_Iterator>(__i); }







  template<typename _Iterator>
    inline reverse_iterator<_Iterator>
    make_reverse_iterator(_Iterator __i)
    { return reverse_iterator<_Iterator>(__i); }
# 539 "/usr/include/c++/10.2.0/bits/stl_iterator.h" 3
  template<typename _Iterator>
   
    auto
    __niter_base(reverse_iterator<_Iterator> __it)
    -> decltype(__make_reverse_iterator(__niter_base(__it.base())))
    { return __make_reverse_iterator(__niter_base(__it.base())); }

  template<typename _Iterator>
    struct __is_move_iterator<reverse_iterator<_Iterator> >
      : __is_move_iterator<_Iterator>
    { };

  template<typename _Iterator>
   
    auto
    __miter_base(reverse_iterator<_Iterator> __it)
    -> decltype(__make_reverse_iterator(__miter_base(__it.base())))
    { return __make_reverse_iterator(__miter_base(__it.base())); }
# 570 "/usr/include/c++/10.2.0/bits/stl_iterator.h" 3
  template<typename _Container>
    class back_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;







      explicit
      back_insert_iterator(_Container& __x)
      : container(std::__addressof(__x)) { }
# 610 "/usr/include/c++/10.2.0/bits/stl_iterator.h" 3
     
      back_insert_iterator&
      operator=(const typename _Container::value_type& __value)
      {
 container->push_back(__value);
 return *this;
      }

     
      back_insert_iterator&
      operator=(typename _Container::value_type&& __value)
      {
 container->push_back(std::move(__value));
 return *this;
      }



     
      back_insert_iterator&
      operator*()
      { return *this; }


     
      back_insert_iterator&
      operator++()
      { return *this; }


     
      back_insert_iterator
      operator++(int)
      { return *this; }
    };
# 657 "/usr/include/c++/10.2.0/bits/stl_iterator.h" 3
  template<typename _Container>
   
    inline back_insert_iterator<_Container>
    back_inserter(_Container& __x)
    { return back_insert_iterator<_Container>(__x); }
# 673 "/usr/include/c++/10.2.0/bits/stl_iterator.h" 3
  template<typename _Container>
    class front_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;







      explicit
      front_insert_iterator(_Container& __x)
      : container(std::__addressof(__x)) { }
# 713 "/usr/include/c++/10.2.0/bits/stl_iterator.h" 3
     
      front_insert_iterator&
      operator=(const typename _Container::value_type& __value)
      {
 container->push_front(__value);
 return *this;
      }

     
      front_insert_iterator&
      operator=(typename _Container::value_type&& __value)
      {
 container->push_front(std::move(__value));
 return *this;
      }



     
      front_insert_iterator&
      operator*()
      { return *this; }


     
      front_insert_iterator&
      operator++()
      { return *this; }


     
      front_insert_iterator
      operator++(int)
      { return *this; }
    };
# 760 "/usr/include/c++/10.2.0/bits/stl_iterator.h" 3
  template<typename _Container>
   
    inline front_insert_iterator<_Container>
    front_inserter(_Container& __x)
    { return front_insert_iterator<_Container>(__x); }
# 780 "/usr/include/c++/10.2.0/bits/stl_iterator.h" 3
  template<typename _Container>
    class insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {







      typedef typename _Container::iterator _Iter;

    protected:
      _Container* container;
      _Iter iter;


    public:

      typedef _Container container_type;
# 812 "/usr/include/c++/10.2.0/bits/stl_iterator.h" 3
     
      insert_iterator(_Container& __x, _Iter __i)
      : container(std::__addressof(__x)), iter(__i) {}
# 848 "/usr/include/c++/10.2.0/bits/stl_iterator.h" 3
     
      insert_iterator&
      operator=(const typename _Container::value_type& __value)
      {
 iter = container->insert(iter, __value);
 ++iter;
 return *this;
      }

     
      insert_iterator&
      operator=(typename _Container::value_type&& __value)
      {
 iter = container->insert(iter, std::move(__value));
 ++iter;
 return *this;
      }



     
      insert_iterator&
      operator*()
      { return *this; }


     
      insert_iterator&
      operator++()
      { return *this; }


     
      insert_iterator&
      operator++(int)
      { return *this; }
    };
# 904 "/usr/include/c++/10.2.0/bits/stl_iterator.h" 3
  template<typename _Container, typename _Iterator>
    inline insert_iterator<_Container>
    inserter(_Container& __x, _Iterator __i)
    {
      return insert_iterator<_Container>(__x,
      typename _Container::iterator(__i));
    }





}

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{

# 929 "/usr/include/c++/10.2.0/bits/stl_iterator.h" 3
  template<typename _Iterator, typename _Container>
    class __normal_iterator
    {
    protected:
      _Iterator _M_current;

      typedef std::iterator_traits<_Iterator> __traits_type;

    public:
      typedef _Iterator iterator_type;
      typedef typename __traits_type::iterator_category iterator_category;
      typedef typename __traits_type::value_type value_type;
      typedef typename __traits_type::difference_type difference_type;
      typedef typename __traits_type::reference reference;
      typedef typename __traits_type::pointer pointer;





      constexpr __normal_iterator() noexcept
      : _M_current(_Iterator()) { }

      explicit
      __normal_iterator(const _Iterator& __i) noexcept
      : _M_current(__i) { }


      template<typename _Iter>
       
        __normal_iterator(const __normal_iterator<_Iter,
     typename __enable_if<
              (std::__are_same<_Iter, typename _Container::pointer>::__value),
        _Container>::__type>& __i) noexcept
        : _M_current(__i.base()) { }


     
      reference
      operator*() const noexcept
      { return *_M_current; }

     
      pointer
      operator->() const noexcept
      { return _M_current; }

     
      __normal_iterator&
      operator++() noexcept
      {
 ++_M_current;
 return *this;
      }

     
      __normal_iterator
      operator++(int) noexcept
      { return __normal_iterator(_M_current++); }


     
      __normal_iterator&
      operator--() noexcept
      {
 --_M_current;
 return *this;
      }

     
      __normal_iterator
      operator--(int) noexcept
      { return __normal_iterator(_M_current--); }


     
      reference
      operator[](difference_type __n) const noexcept
      { return _M_current[__n]; }

     
      __normal_iterator&
      operator+=(difference_type __n) noexcept
      { _M_current += __n; return *this; }

     
      __normal_iterator
      operator+(difference_type __n) const noexcept
      { return __normal_iterator(_M_current + __n); }

     
      __normal_iterator&
      operator-=(difference_type __n) noexcept
      { _M_current -= __n; return *this; }

     
      __normal_iterator
      operator-(difference_type __n) const noexcept
      { return __normal_iterator(_M_current - __n); }

     
      const _Iterator&
      base() const noexcept
      { return _M_current; }
    };
# 1061 "/usr/include/c++/10.2.0/bits/stl_iterator.h" 3
  template<typename _IteratorL, typename _IteratorR, typename _Container>
   
    inline bool
    operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() == __rhs.base(); }

  template<typename _Iterator, typename _Container>
   
    inline bool
    operator==(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() == __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
   
    inline bool
    operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() != __rhs.base(); }

  template<typename _Iterator, typename _Container>
   
    inline bool
    operator!=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() != __rhs.base(); }


  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() < __rhs.base(); }

  template<typename _Iterator, typename _Container>
   
    inline bool
    operator<(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() < __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator>(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() > __rhs.base(); }

  template<typename _Iterator, typename _Container>
   
    inline bool
    operator>(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() > __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator<=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() <= __rhs.base(); }

  template<typename _Iterator, typename _Container>
   
    inline bool
    operator<=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() <= __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator>=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() >= __rhs.base(); }

  template<typename _Iterator, typename _Container>
   
    inline bool
    operator>=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() >= __rhs.base(); }






  template<typename _IteratorL, typename _IteratorR, typename _Container>


   
    inline auto
    operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs) noexcept
    -> decltype(__lhs.base() - __rhs.base())





    { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
   
    inline typename __normal_iterator<_Iterator, _Container>::difference_type
    operator-(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
   
    inline __normal_iterator<_Iterator, _Container>
    operator+(typename __normal_iterator<_Iterator, _Container>::difference_type
       __n, const __normal_iterator<_Iterator, _Container>& __i)
    noexcept
    { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); }


}

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Iterator, typename _Container>
   
    _Iterator
    __niter_base(__gnu_cxx::__normal_iterator<_Iterator, _Container> __it)
    noexcept(std::is_nothrow_copy_constructible<_Iterator>::value)
    { return __it.base(); }
# 1260 "/usr/include/c++/10.2.0/bits/stl_iterator.h" 3
  template<typename _Iterator>
    class move_iterator
    {
      _Iterator _M_current;

      using __traits_type = iterator_traits<_Iterator>;



      using __base_ref = typename __traits_type::reference;


    public:
      using iterator_type = _Iterator;
# 1284 "/usr/include/c++/10.2.0/bits/stl_iterator.h" 3
      typedef typename __traits_type::iterator_category iterator_category;
      typedef typename __traits_type::value_type value_type;
      typedef typename __traits_type::difference_type difference_type;

      typedef _Iterator pointer;


      typedef typename conditional<is_reference<__base_ref>::value,
    typename remove_reference<__base_ref>::type&&,
    __base_ref>::type reference;


     
      move_iterator()
      : _M_current() { }

      explicit
      move_iterator(iterator_type __i)
      : _M_current(std::move(__i)) { }

      template<typename _Iter>

 move_iterator(const move_iterator<_Iter>& __i)
 : _M_current(__i.base()) { }


      iterator_type
      base() const
      { return _M_current; }
# 1326 "/usr/include/c++/10.2.0/bits/stl_iterator.h" 3
      reference
      operator*() const
      { return static_cast<reference>(*_M_current); }

      pointer
      operator->() const
      { return _M_current; }

      move_iterator&
      operator++()
      {
 ++_M_current;
 return *this;
      }

      move_iterator
      operator++(int)
      {
 move_iterator __tmp = *this;
 ++_M_current;
 return __tmp;
      }







      move_iterator&
      operator--()
      {
 --_M_current;
 return *this;
      }

      move_iterator
      operator--(int)
      {
 move_iterator __tmp = *this;
 --_M_current;
 return __tmp;
      }

      move_iterator
      operator+(difference_type __n) const
      { return move_iterator(_M_current + __n); }

      move_iterator&
      operator+=(difference_type __n)
      {
 _M_current += __n;
 return *this;
      }

      move_iterator
      operator-(difference_type __n) const
      { return move_iterator(_M_current - __n); }

      move_iterator&
      operator-=(difference_type __n)
      {
 _M_current -= __n;
 return *this;
      }

      reference
      operator[](difference_type __n) const
      { return std::move(_M_current[__n]); }
# 1423 "/usr/include/c++/10.2.0/bits/stl_iterator.h" 3
    };

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator==(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)



    { return __x.base() == __y.base(); }
# 1442 "/usr/include/c++/10.2.0/bits/stl_iterator.h" 3
  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator!=(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)
    { return !(__x == __y); }


  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<(const move_iterator<_IteratorL>& __x,
       const move_iterator<_IteratorR>& __y)



    { return __x.base() < __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<=(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)



    { return !(__y < __x); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>(const move_iterator<_IteratorL>& __x,
       const move_iterator<_IteratorR>& __y)



    { return __y < __x; }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>=(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)



    { return !(__x < __y); }
# 1493 "/usr/include/c++/10.2.0/bits/stl_iterator.h" 3
  template<typename _Iterator>
    inline bool
    operator==(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return __x.base() == __y.base(); }

  template<typename _Iterator>
    inline bool
    operator!=(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return !(__x == __y); }

  template<typename _Iterator>
    inline bool
    operator<(const move_iterator<_Iterator>& __x,
       const move_iterator<_Iterator>& __y)
    { return __x.base() < __y.base(); }

  template<typename _Iterator>
    inline bool
    operator<=(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return !(__y < __x); }

  template<typename _Iterator>
    inline bool
    operator>(const move_iterator<_Iterator>& __x,
       const move_iterator<_Iterator>& __y)
    { return __y < __x; }

  template<typename _Iterator>
    inline bool
    operator>=(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return !(__x < __y); }



  template<typename _IteratorL, typename _IteratorR>
    inline auto
    operator-(const move_iterator<_IteratorL>& __x,
       const move_iterator<_IteratorR>& __y)
    -> decltype(__x.base() - __y.base())
    { return __x.base() - __y.base(); }

  template<typename _Iterator>
    inline move_iterator<_Iterator>
    operator+(typename move_iterator<_Iterator>::difference_type __n,
       const move_iterator<_Iterator>& __x)
    { return __x + __n; }

  template<typename _Iterator>
    inline move_iterator<_Iterator>
    make_move_iterator(_Iterator __i)
    { return move_iterator<_Iterator>(std::move(__i)); }

  template<typename _Iterator, typename _ReturnType
    = typename conditional<__move_if_noexcept_cond
      <typename iterator_traits<_Iterator>::value_type>::value,
                _Iterator, move_iterator<_Iterator>>::type>
    inline _ReturnType
    __make_move_if_noexcept_iterator(_Iterator __i)
    { return _ReturnType(__i); }



  template<typename _Tp, typename _ReturnType
    = typename conditional<__move_if_noexcept_cond<_Tp>::value,
      const _Tp*, move_iterator<_Tp*>>::type>
    inline _ReturnType
    __make_move_if_noexcept_iterator(_Tp* __i)
    { return _ReturnType(__i); }
# 2154 "/usr/include/c++/10.2.0/bits/stl_iterator.h" 3
  template<typename _Iterator>
    auto
    __niter_base(move_iterator<_Iterator> __it)
    -> decltype(make_move_iterator(__niter_base(__it.base())))
    { return make_move_iterator(__niter_base(__it.base())); }

  template<typename _Iterator>
    struct __is_move_iterator<move_iterator<_Iterator> >
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<typename _Iterator>
    auto
    __miter_base(move_iterator<_Iterator> __it)
    -> decltype(__miter_base(__it.base()))
    { return __miter_base(__it.base()); }
# 2201 "/usr/include/c++/10.2.0/bits/stl_iterator.h" 3

}
# 68 "/usr/include/c++/10.2.0/bits/stl_algobase.h" 2 3

# 1 "/usr/include/c++/10.2.0/debug/debug.h" 1 3
# 48 "/usr/include/c++/10.2.0/debug/debug.h" 3
namespace std
{
  namespace __debug { }
}




namespace __gnu_debug
{
  using namespace std::__debug;

  template<typename _Ite, typename _Seq, typename _Cat>
    struct _Safe_iterator;
}
# 70 "/usr/include/c++/10.2.0/bits/stl_algobase.h" 2 3

# 1 "/usr/include/c++/10.2.0/bits/predefined_ops.h" 1 3
# 33 "/usr/include/c++/10.2.0/bits/predefined_ops.h" 3
namespace __gnu_cxx
{
namespace __ops
{
  struct _Iter_less_iter
  {
    template<typename _Iterator1, typename _Iterator2>
      constexpr
      bool
      operator()(_Iterator1 __it1, _Iterator2 __it2) const
      { return *__it1 < *__it2; }
  };

  constexpr
  inline _Iter_less_iter
  __iter_less_iter()
  { return _Iter_less_iter(); }

  struct _Iter_less_val
  {

    constexpr _Iter_less_val() = default;




   
    explicit
    _Iter_less_val(_Iter_less_iter) { }

    template<typename _Iterator, typename _Value>
     
      bool
      operator()(_Iterator __it, _Value& __val) const
      { return *__it < __val; }
  };

 
  inline _Iter_less_val
  __iter_less_val()
  { return _Iter_less_val(); }

 
  inline _Iter_less_val
  __iter_comp_val(_Iter_less_iter)
  { return _Iter_less_val(); }

  struct _Val_less_iter
  {

    constexpr _Val_less_iter() = default;




   
    explicit
    _Val_less_iter(_Iter_less_iter) { }

    template<typename _Value, typename _Iterator>
     
      bool
      operator()(_Value& __val, _Iterator __it) const
      { return __val < *__it; }
  };

 
  inline _Val_less_iter
  __val_less_iter()
  { return _Val_less_iter(); }

 
  inline _Val_less_iter
  __val_comp_iter(_Iter_less_iter)
  { return _Val_less_iter(); }

  struct _Iter_equal_to_iter
  {
    template<typename _Iterator1, typename _Iterator2>
     
      bool
      operator()(_Iterator1 __it1, _Iterator2 __it2) const
      { return *__it1 == *__it2; }
  };

 
  inline _Iter_equal_to_iter
  __iter_equal_to_iter()
  { return _Iter_equal_to_iter(); }

  struct _Iter_equal_to_val
  {
    template<typename _Iterator, typename _Value>
     
      bool
      operator()(_Iterator __it, _Value& __val) const
      { return *__it == __val; }
  };

 
  inline _Iter_equal_to_val
  __iter_equal_to_val()
  { return _Iter_equal_to_val(); }

 
  inline _Iter_equal_to_val
  __iter_comp_val(_Iter_equal_to_iter)
  { return _Iter_equal_to_val(); }

  template<typename _Compare>
    struct _Iter_comp_iter
    {
      _Compare _M_comp;

      explicit constexpr
      _Iter_comp_iter(_Compare __comp)
 : _M_comp(std::move(__comp))
      { }

      template<typename _Iterator1, typename _Iterator2>
        constexpr
        bool
        operator()(_Iterator1 __it1, _Iterator2 __it2)
        { return bool(_M_comp(*__it1, *__it2)); }
    };

  template<typename _Compare>
    constexpr
    inline _Iter_comp_iter<_Compare>
    __iter_comp_iter(_Compare __comp)
    { return _Iter_comp_iter<_Compare>(std::move(__comp)); }

  template<typename _Compare>
    struct _Iter_comp_val
    {
      _Compare _M_comp;

     
      explicit
      _Iter_comp_val(_Compare __comp)
 : _M_comp(std::move(__comp))
      { }

     
      explicit
      _Iter_comp_val(const _Iter_comp_iter<_Compare>& __comp)
 : _M_comp(__comp._M_comp)
      { }


     
      explicit
      _Iter_comp_val(_Iter_comp_iter<_Compare>&& __comp)
 : _M_comp(std::move(__comp._M_comp))
      { }


      template<typename _Iterator, typename _Value>

 bool
 operator()(_Iterator __it, _Value& __val)
 { return bool(_M_comp(*__it, __val)); }
    };

  template<typename _Compare>
   
    inline _Iter_comp_val<_Compare>
    __iter_comp_val(_Compare __comp)
    { return _Iter_comp_val<_Compare>(std::move(__comp)); }

  template<typename _Compare>
   
    inline _Iter_comp_val<_Compare>
    __iter_comp_val(_Iter_comp_iter<_Compare> __comp)
    { return _Iter_comp_val<_Compare>(std::move(__comp)); }

  template<typename _Compare>
    struct _Val_comp_iter
    {
      _Compare _M_comp;

     
      explicit
      _Val_comp_iter(_Compare __comp)
 : _M_comp(std::move(__comp))
      { }

     
      explicit
      _Val_comp_iter(const _Iter_comp_iter<_Compare>& __comp)
 : _M_comp(__comp._M_comp)
      { }


     
      explicit
      _Val_comp_iter(_Iter_comp_iter<_Compare>&& __comp)
 : _M_comp(std::move(__comp._M_comp))
      { }


      template<typename _Value, typename _Iterator>

 bool
 operator()(_Value& __val, _Iterator __it)
 { return bool(_M_comp(__val, *__it)); }
    };

  template<typename _Compare>
   
    inline _Val_comp_iter<_Compare>
    __val_comp_iter(_Compare __comp)
    { return _Val_comp_iter<_Compare>(std::move(__comp)); }

  template<typename _Compare>
   
    inline _Val_comp_iter<_Compare>
    __val_comp_iter(_Iter_comp_iter<_Compare> __comp)
    { return _Val_comp_iter<_Compare>(std::move(__comp)); }

  template<typename _Value>
    struct _Iter_equals_val
    {
      _Value& _M_value;

     
      explicit
      _Iter_equals_val(_Value& __value)
 : _M_value(__value)
      { }

      template<typename _Iterator>

 bool
 operator()(_Iterator __it)
 { return *__it == _M_value; }
    };

  template<typename _Value>
   
    inline _Iter_equals_val<_Value>
    __iter_equals_val(_Value& __val)
    { return _Iter_equals_val<_Value>(__val); }

  template<typename _Iterator1>
    struct _Iter_equals_iter
    {
      _Iterator1 _M_it1;

     
      explicit
      _Iter_equals_iter(_Iterator1 __it1)
 : _M_it1(__it1)
      { }

      template<typename _Iterator2>

 bool
 operator()(_Iterator2 __it2)
 { return *__it2 == *_M_it1; }
    };

  template<typename _Iterator>
   
    inline _Iter_equals_iter<_Iterator>
    __iter_comp_iter(_Iter_equal_to_iter, _Iterator __it)
    { return _Iter_equals_iter<_Iterator>(__it); }

  template<typename _Predicate>
    struct _Iter_pred
    {
      _Predicate _M_pred;

     
      explicit
      _Iter_pred(_Predicate __pred)
 : _M_pred(std::move(__pred))
      { }

      template<typename _Iterator>

 bool
 operator()(_Iterator __it)
 { return bool(_M_pred(*__it)); }
    };

  template<typename _Predicate>
   
    inline _Iter_pred<_Predicate>
    __pred_iter(_Predicate __pred)
    { return _Iter_pred<_Predicate>(std::move(__pred)); }

  template<typename _Compare, typename _Value>
    struct _Iter_comp_to_val
    {
      _Compare _M_comp;
      _Value& _M_value;

     
      _Iter_comp_to_val(_Compare __comp, _Value& __value)
 : _M_comp(std::move(__comp)), _M_value(__value)
      { }

      template<typename _Iterator>

 bool
 operator()(_Iterator __it)
 { return bool(_M_comp(*__it, _M_value)); }
    };

  template<typename _Compare, typename _Value>
    _Iter_comp_to_val<_Compare, _Value>
   
    __iter_comp_val(_Compare __comp, _Value &__val)
    {
      return _Iter_comp_to_val<_Compare, _Value>(std::move(__comp), __val);
    }

  template<typename _Compare, typename _Iterator1>
    struct _Iter_comp_to_iter
    {
      _Compare _M_comp;
      _Iterator1 _M_it1;

     
      _Iter_comp_to_iter(_Compare __comp, _Iterator1 __it1)
 : _M_comp(std::move(__comp)), _M_it1(__it1)
      { }

      template<typename _Iterator2>

 bool
 operator()(_Iterator2 __it2)
 { return bool(_M_comp(*__it2, *_M_it1)); }
    };

  template<typename _Compare, typename _Iterator>
   
    inline _Iter_comp_to_iter<_Compare, _Iterator>
    __iter_comp_iter(_Iter_comp_iter<_Compare> __comp, _Iterator __it)
    {
      return _Iter_comp_to_iter<_Compare, _Iterator>(
   std::move(__comp._M_comp), __it);
    }

  template<typename _Predicate>
    struct _Iter_negate
    {
      _Predicate _M_pred;

     
      explicit
      _Iter_negate(_Predicate __pred)
 : _M_pred(std::move(__pred))
      { }

      template<typename _Iterator>

 bool
 operator()(_Iterator __it)
 { return !bool(_M_pred(*__it)); }
    };

  template<typename _Predicate>
   
    inline _Iter_negate<_Predicate>
    __negate(_Iter_pred<_Predicate> __pred)
    { return _Iter_negate<_Predicate>(std::move(__pred._M_pred)); }

}
}
# 72 "/usr/include/c++/10.2.0/bits/stl_algobase.h" 2 3







namespace std __attribute__ ((__visibility__ ("default")))
{






  template<typename _Tp, typename _Up>
    constexpr
    inline int
    __memcmp(const _Tp* __first1, const _Up* __first2, size_t __num)
    {

      static_assert(sizeof(_Tp) == sizeof(_Up), "can be compared with memcmp");
# 105 "/usr/include/c++/10.2.0/bits/stl_algobase.h" 3
 return __builtin_memcmp(__first1, __first2, sizeof(_Tp) * __num);
    }
# 149 "/usr/include/c++/10.2.0/bits/stl_algobase.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
   
    inline void
    iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
    {

     

     
# 182 "/usr/include/c++/10.2.0/bits/stl_algobase.h" 3
      swap(*__a, *__b);

    }
# 198 "/usr/include/c++/10.2.0/bits/stl_algobase.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
   
    _ForwardIterator2
    swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
  _ForwardIterator2 __first2)
    {

     

     

      ;

      for (; __first1 != __last1; ++__first1, (void)++__first2)
 std::iter_swap(__first1, __first2);
      return __first2;
    }
# 227 "/usr/include/c++/10.2.0/bits/stl_algobase.h" 3
  template<typename _Tp>
    constexpr
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b)
    {

     

      if (__b < __a)
 return __b;
      return __a;
    }
# 251 "/usr/include/c++/10.2.0/bits/stl_algobase.h" 3
  template<typename _Tp>
    constexpr
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b)
    {

     

      if (__a < __b)
 return __b;
      return __a;
    }
# 275 "/usr/include/c++/10.2.0/bits/stl_algobase.h" 3
  template<typename _Tp, typename _Compare>
    constexpr
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__b, __a))
 return __b;
      return __a;
    }
# 297 "/usr/include/c++/10.2.0/bits/stl_algobase.h" 3
  template<typename _Tp, typename _Compare>
    constexpr
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__a, __b))
 return __b;
      return __a;
    }



  template<typename _Iterator>
   
    inline _Iterator
    __niter_base(_Iterator __it)
    noexcept(std::is_nothrow_copy_constructible<_Iterator>::value)
    { return __it; }




  template<typename _From, typename _To>
   
    inline _From
    __niter_wrap(_From __from, _To __res)
    { return __from + (__res - std::__niter_base(__from)); }


  template<typename _Iterator>
   
    inline _Iterator
    __niter_wrap(const _Iterator&, _Iterator __res)
    { return __res; }







  template<bool _IsMove, bool _IsSimple, typename _Category>
    struct __copy_move
    {
      template<typename _II, typename _OI>

 static _OI
 __copy_m(_II __first, _II __last, _OI __result)
 {
   for (; __first != __last; ++__result, (void)++__first)
     *__result = *__first;
   return __result;
 }
    };


  template<typename _Category>
    struct __copy_move<true, false, _Category>
    {
      template<typename _II, typename _OI>

 static _OI
 __copy_m(_II __first, _II __last, _OI __result)
 {
   for (; __first != __last; ++__result, (void)++__first)
     *__result = std::move(*__first);
   return __result;
 }
    };


  template<>
    struct __copy_move<false, false, random_access_iterator_tag>
    {
      template<typename _II, typename _OI>

 static _OI
 __copy_m(_II __first, _II __last, _OI __result)
 {
   typedef typename iterator_traits<_II>::difference_type _Distance;
   for(_Distance __n = __last - __first; __n > 0; --__n)
     {
       *__result = *__first;
       ++__first;
       ++__result;
     }
   return __result;
 }
    };


  template<>
    struct __copy_move<true, false, random_access_iterator_tag>
    {
      template<typename _II, typename _OI>

 static _OI
 __copy_m(_II __first, _II __last, _OI __result)
 {
   typedef typename iterator_traits<_II>::difference_type _Distance;
   for(_Distance __n = __last - __first; __n > 0; --__n)
     {
       *__result = std::move(*__first);
       ++__first;
       ++__result;
     }
   return __result;
 }
    };


  template<bool _IsMove>
    struct __copy_move<_IsMove, true, random_access_iterator_tag>
    {
      template<typename _Tp>

 static _Tp*
 __copy_m(const _Tp* __first, const _Tp* __last, _Tp* __result)
 {

   using __assignable = conditional<_IsMove,
        is_move_assignable<_Tp>,
        is_copy_assignable<_Tp>>;

   static_assert( __assignable::type::value, "type is not assignable" );

   const ptrdiff_t _Num = __last - __first;
   if (_Num)
     __builtin_memmove(__result, __first, sizeof(_Tp) * _Num);
   return __result + _Num;
 }
    };



  template<typename _CharT>
    struct char_traits;

  template<typename _CharT, typename _Traits>
    class istreambuf_iterator;

  template<typename _CharT, typename _Traits>
    class ostreambuf_iterator;

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
      ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
    __copy_move_a2(_CharT*, _CharT*,
     ostreambuf_iterator<_CharT, char_traits<_CharT> >);

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
      ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
    __copy_move_a2(const _CharT*, const _CharT*,
     ostreambuf_iterator<_CharT, char_traits<_CharT> >);

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        _CharT*>::__type
    __copy_move_a2(istreambuf_iterator<_CharT, char_traits<_CharT> >,
     istreambuf_iterator<_CharT, char_traits<_CharT> >, _CharT*);

  template<bool _IsMove, typename _II, typename _OI>
   
    inline _OI
    __copy_move_a2(_II __first, _II __last, _OI __result)
    {
      typedef typename iterator_traits<_II>::iterator_category _Category;





      return std::__copy_move<_IsMove, __memcpyable<_OI, _II>::__value,
         _Category>::__copy_m(__first, __last, __result);
    }



  template<typename _Tp, typename _Ref, typename _Ptr>
    struct _Deque_iterator;



  template<bool _IsMove,
    typename _Tp, typename _Ref, typename _Ptr, typename _OI>
    _OI
    __copy_move_a1(std::_Deque_iterator<_Tp, _Ref, _Ptr>,
     std::_Deque_iterator<_Tp, _Ref, _Ptr>,
     _OI);

  template<bool _IsMove,
    typename _ITp, typename _IRef, typename _IPtr, typename _OTp>
    std::_Deque_iterator<_OTp, _OTp&, _OTp*>
    __copy_move_a1(std::_Deque_iterator<_ITp, _IRef, _IPtr>,
     std::_Deque_iterator<_ITp, _IRef, _IPtr>,
     std::_Deque_iterator<_OTp, _OTp&, _OTp*>);

  template<bool _IsMove, typename _II, typename _Tp>
    typename __gnu_cxx::__enable_if<
      __is_random_access_iter<_II>::__value,
      std::_Deque_iterator<_Tp, _Tp&, _Tp*> >::__type
    __copy_move_a1(_II, _II, std::_Deque_iterator<_Tp, _Tp&, _Tp*>);

  template<bool _IsMove, typename _II, typename _OI>
   
    inline _OI
    __copy_move_a1(_II __first, _II __last, _OI __result)
    { return std::__copy_move_a2<_IsMove>(__first, __last, __result); }

  template<bool _IsMove, typename _II, typename _OI>
   
    inline _OI
    __copy_move_a(_II __first, _II __last, _OI __result)
    {
      return std::__niter_wrap(__result,
  std::__copy_move_a1<_IsMove>(std::__niter_base(__first),
          std::__niter_base(__last),
          std::__niter_base(__result)));
    }

  template<bool _IsMove,
    typename _Ite, typename _Seq, typename _Cat, typename _OI>
    _OI
    __copy_move_a(const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,
    const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,
    _OI);

  template<bool _IsMove,
    typename _II, typename _Ite, typename _Seq, typename _Cat>
    __gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>
    __copy_move_a(_II, _II,
    const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&);

  template<bool _IsMove,
    typename _IIte, typename _ISeq, typename _ICat,
    typename _OIte, typename _OSeq, typename _OCat>
    ::__gnu_debug::_Safe_iterator<_OIte, _OSeq, _OCat>
    __copy_move_a(const ::__gnu_debug::_Safe_iterator<_IIte, _ISeq, _ICat>&,
    const ::__gnu_debug::_Safe_iterator<_IIte, _ISeq, _ICat>&,
    const ::__gnu_debug::_Safe_iterator<_OIte, _OSeq, _OCat>&);
# 557 "/usr/include/c++/10.2.0/bits/stl_algobase.h" 3
  template<typename _II, typename _OI>
   
    inline _OI
    copy(_II __first, _II __last, _OI __result)
    {

     
     

      ;

      return std::__copy_move_a<__is_move_iterator<_II>::__value>
      (std::__miter_base(__first), std::__miter_base(__last), __result);
    }
# 590 "/usr/include/c++/10.2.0/bits/stl_algobase.h" 3
  template<typename _II, typename _OI>
   
    inline _OI
    move(_II __first, _II __last, _OI __result)
    {

     
     

      ;

      return std::__copy_move_a<true>(std::__miter_base(__first),
          std::__miter_base(__last), __result);
    }






  template<bool _IsMove, bool _IsSimple, typename _Category>
    struct __copy_move_backward
    {
      template<typename _BI1, typename _BI2>

 static _BI2
 __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
 {
   while (__first != __last)
     *--__result = *--__last;
   return __result;
 }
    };


  template<typename _Category>
    struct __copy_move_backward<true, false, _Category>
    {
      template<typename _BI1, typename _BI2>

 static _BI2
 __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
 {
   while (__first != __last)
     *--__result = std::move(*--__last);
   return __result;
 }
    };


  template<>
    struct __copy_move_backward<false, false, random_access_iterator_tag>
    {
      template<typename _BI1, typename _BI2>

 static _BI2
 __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
 {
   typename iterator_traits<_BI1>::difference_type
     __n = __last - __first;
   for (; __n > 0; --__n)
     *--__result = *--__last;
   return __result;
 }
    };


  template<>
    struct __copy_move_backward<true, false, random_access_iterator_tag>
    {
      template<typename _BI1, typename _BI2>

 static _BI2
 __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
 {
   typename iterator_traits<_BI1>::difference_type
     __n = __last - __first;
   for (; __n > 0; --__n)
     *--__result = std::move(*--__last);
   return __result;
 }
    };


  template<bool _IsMove>
    struct __copy_move_backward<_IsMove, true, random_access_iterator_tag>
    {
      template<typename _Tp>

 static _Tp*
 __copy_move_b(const _Tp* __first, const _Tp* __last, _Tp* __result)
 {

   using __assignable = conditional<_IsMove,
        is_move_assignable<_Tp>,
        is_copy_assignable<_Tp>>;

   static_assert( __assignable::type::value, "type is not assignable" );

   const ptrdiff_t _Num = __last - __first;
   if (_Num)
     __builtin_memmove(__result - _Num, __first, sizeof(_Tp) * _Num);
   return __result - _Num;
 }
    };

  template<bool _IsMove, typename _BI1, typename _BI2>
   
    inline _BI2
    __copy_move_backward_a2(_BI1 __first, _BI1 __last, _BI2 __result)
    {
      typedef typename iterator_traits<_BI1>::iterator_category _Category;





      return std::__copy_move_backward<_IsMove,
           __memcpyable<_BI2, _BI1>::__value,
           _Category>::__copy_move_b(__first,
         __last,
         __result);
    }

  template<bool _IsMove, typename _BI1, typename _BI2>
   
    inline _BI2
    __copy_move_backward_a1(_BI1 __first, _BI1 __last, _BI2 __result)
    { return std::__copy_move_backward_a2<_IsMove>(__first, __last, __result); }

  template<bool _IsMove,
    typename _Tp, typename _Ref, typename _Ptr, typename _OI>
    _OI
    __copy_move_backward_a1(std::_Deque_iterator<_Tp, _Ref, _Ptr>,
       std::_Deque_iterator<_Tp, _Ref, _Ptr>,
       _OI);

  template<bool _IsMove,
    typename _ITp, typename _IRef, typename _IPtr, typename _OTp>
    std::_Deque_iterator<_OTp, _OTp&, _OTp*>
    __copy_move_backward_a1(
   std::_Deque_iterator<_ITp, _IRef, _IPtr>,
   std::_Deque_iterator<_ITp, _IRef, _IPtr>,
   std::_Deque_iterator<_OTp, _OTp&, _OTp*>);

  template<bool _IsMove, typename _II, typename _Tp>
    typename __gnu_cxx::__enable_if<
      __is_random_access_iter<_II>::__value,
      std::_Deque_iterator<_Tp, _Tp&, _Tp*> >::__type
    __copy_move_backward_a1(_II, _II,
       std::_Deque_iterator<_Tp, _Tp&, _Tp*>);

  template<bool _IsMove, typename _II, typename _OI>
   
    inline _OI
    __copy_move_backward_a(_II __first, _II __last, _OI __result)
    {
      return std::__niter_wrap(__result,
  std::__copy_move_backward_a1<_IsMove>
    (std::__niter_base(__first), std::__niter_base(__last),
     std::__niter_base(__result)));
    }

  template<bool _IsMove,
    typename _Ite, typename _Seq, typename _Cat, typename _OI>
    _OI
    __copy_move_backward_a(
  const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,
  const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,
  _OI);

  template<bool _IsMove,
    typename _II, typename _Ite, typename _Seq, typename _Cat>
    __gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>
    __copy_move_backward_a(_II, _II,
  const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&);

  template<bool _IsMove,
    typename _IIte, typename _ISeq, typename _ICat,
    typename _OIte, typename _OSeq, typename _OCat>
    ::__gnu_debug::_Safe_iterator<_OIte, _OSeq, _OCat>
    __copy_move_backward_a(
  const ::__gnu_debug::_Safe_iterator<_IIte, _ISeq, _ICat>&,
  const ::__gnu_debug::_Safe_iterator<_IIte, _ISeq, _ICat>&,
  const ::__gnu_debug::_Safe_iterator<_OIte, _OSeq, _OCat>&);
# 794 "/usr/include/c++/10.2.0/bits/stl_algobase.h" 3
  template<typename _BI1, typename _BI2>
   
    inline _BI2
    copy_backward(_BI1 __first, _BI1 __last, _BI2 __result)
    {

     
     
     


      ;

      return std::__copy_move_backward_a<__is_move_iterator<_BI1>::__value>
      (std::__miter_base(__first), std::__miter_base(__last), __result);
    }
# 830 "/usr/include/c++/10.2.0/bits/stl_algobase.h" 3
  template<typename _BI1, typename _BI2>
   
    inline _BI2
    move_backward(_BI1 __first, _BI1 __last, _BI2 __result)
    {

     
     
     


      ;

      return std::__copy_move_backward_a<true>(std::__miter_base(__first),
            std::__miter_base(__last),
            __result);
    }






  template<typename _ForwardIterator, typename _Tp>
   
    inline typename
    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, void>::__type
    __fill_a1(_ForwardIterator __first, _ForwardIterator __last,
       const _Tp& __value)
    {
      for (; __first != __last; ++__first)
 *__first = __value;
    }

  template<typename _ForwardIterator, typename _Tp>
   
    inline typename
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
    __fill_a1(_ForwardIterator __first, _ForwardIterator __last,
       const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __first != __last; ++__first)
 *__first = __tmp;
    }


  template<typename _Tp>
   
    inline typename
    __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, void>::__type
    __fill_a1(_Tp* __first, _Tp* __last, const _Tp& __c)
    {
      const _Tp __tmp = __c;
# 892 "/usr/include/c++/10.2.0/bits/stl_algobase.h" 3
      if (const size_t __len = __last - __first)
 __builtin_memset(__first, static_cast<unsigned char>(__tmp), __len);
    }

  template<typename _Ite, typename _Cont, typename _Tp>
   
    inline void
    __fill_a1(::__gnu_cxx::__normal_iterator<_Ite, _Cont> __first,
       ::__gnu_cxx::__normal_iterator<_Ite, _Cont> __last,
       const _Tp& __value)
    { std::__fill_a1(__first.base(), __last.base(), __value); }

  template<typename _Tp, typename _VTp>
    void
    __fill_a1(const std::_Deque_iterator<_Tp, _Tp&, _Tp*>&,
       const std::_Deque_iterator<_Tp, _Tp&, _Tp*>&,
       const _VTp&);

  template<typename _FIte, typename _Tp>
   
    inline void
    __fill_a(_FIte __first, _FIte __last, const _Tp& __value)
    { std::__fill_a1(__first, __last, __value); }

  template<typename _Ite, typename _Seq, typename _Cat, typename _Tp>
    void
    __fill_a(const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,
      const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>&,
      const _Tp&);
# 934 "/usr/include/c++/10.2.0/bits/stl_algobase.h" 3
  template<typename _ForwardIterator, typename _Tp>
   
    inline void
    fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value)
    {

     

      ;

      std::__fill_a(__first, __last, __value);
    }


  inline constexpr int
  __size_to_integer(int __n) { return __n; }
  inline constexpr unsigned
  __size_to_integer(unsigned __n) { return __n; }
  inline constexpr long
  __size_to_integer(long __n) { return __n; }
  inline constexpr unsigned long
  __size_to_integer(unsigned long __n) { return __n; }
  inline constexpr long long
  __size_to_integer(long long __n) { return __n; }
  inline constexpr unsigned long long
  __size_to_integer(unsigned long long __n) { return __n; }


  inline constexpr __int128
  __size_to_integer(__int128 __n) { return __n; }
  inline constexpr unsigned __int128
  __size_to_integer(unsigned __int128 __n) { return __n; }
# 986 "/usr/include/c++/10.2.0/bits/stl_algobase.h" 3
  inline constexpr long long
  __size_to_integer(float __n) { return __n; }
  inline constexpr long long
  __size_to_integer(double __n) { return __n; }
  inline constexpr long long
  __size_to_integer(long double __n) { return __n; }

  inline constexpr long long
  __size_to_integer(__float128 __n) { return __n; }


  template<typename _OutputIterator, typename _Size, typename _Tp>
   
    inline typename
    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, _OutputIterator>::__type
    __fill_n_a1(_OutputIterator __first, _Size __n, const _Tp& __value)
    {
      for (; __n > 0; --__n, (void) ++__first)
 *__first = __value;
      return __first;
    }

  template<typename _OutputIterator, typename _Size, typename _Tp>
   
    inline typename
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, _OutputIterator>::__type
    __fill_n_a1(_OutputIterator __first, _Size __n, const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __n > 0; --__n, (void) ++__first)
 *__first = __tmp;
      return __first;
    }

  template<typename _Ite, typename _Seq, typename _Cat, typename _Size,
    typename _Tp>
    ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>
    __fill_n_a(const ::__gnu_debug::_Safe_iterator<_Ite, _Seq, _Cat>& __first,
        _Size __n, const _Tp& __value,
        std::input_iterator_tag);

  template<typename _OutputIterator, typename _Size, typename _Tp>
   
    inline _OutputIterator
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value,
        std::output_iterator_tag)
    {

      static_assert(is_integral<_Size>{}, "fill_n must pass integral size");

      return __fill_n_a1(__first, __n, __value);
    }

  template<typename _OutputIterator, typename _Size, typename _Tp>
   
    inline _OutputIterator
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value,
        std::input_iterator_tag)
    {

      static_assert(is_integral<_Size>{}, "fill_n must pass integral size");

      return __fill_n_a1(__first, __n, __value);
    }

  template<typename _OutputIterator, typename _Size, typename _Tp>
   
    inline _OutputIterator
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value,
        std::random_access_iterator_tag)
    {

      static_assert(is_integral<_Size>{}, "fill_n must pass integral size");

      if (__n <= 0)
 return __first;

      ;

      std::__fill_a(__first, __first + __n, __value);
      return __first + __n;
    }
# 1086 "/usr/include/c++/10.2.0/bits/stl_algobase.h" 3
  template<typename _OI, typename _Size, typename _Tp>
   
    inline _OI
    fill_n(_OI __first, _Size __n, const _Tp& __value)
    {

     

      return std::__fill_n_a(__first, std::__size_to_integer(__n), __value,
          std::__iterator_category(__first));
    }

  template<bool _BoolType>
    struct __equal
    {
      template<typename _II1, typename _II2>

 static bool
 equal(_II1 __first1, _II1 __last1, _II2 __first2)
 {
   for (; __first1 != __last1; ++__first1, (void) ++__first2)
     if (!(*__first1 == *__first2))
       return false;
   return true;
 }
    };

  template<>
    struct __equal<true>
    {
      template<typename _Tp>

 static bool
 equal(const _Tp* __first1, const _Tp* __last1, const _Tp* __first2)
 {
   if (const size_t __len = (__last1 - __first1))
     return !std::__memcmp(__first1, __first2, __len);
   return true;
 }
    };

  template<typename _Tp, typename _Ref, typename _Ptr, typename _II>
    typename __gnu_cxx::__enable_if<
      __is_random_access_iter<_II>::__value, bool>::__type
    __equal_aux1(std::_Deque_iterator<_Tp, _Ref, _Ptr>,
   std::_Deque_iterator<_Tp, _Ref, _Ptr>,
   _II);

  template<typename _Tp1, typename _Ref1, typename _Ptr1,
    typename _Tp2, typename _Ref2, typename _Ptr2>
    bool
    __equal_aux1(std::_Deque_iterator<_Tp1, _Ref1, _Ptr1>,
   std::_Deque_iterator<_Tp1, _Ref1, _Ptr1>,
   std::_Deque_iterator<_Tp2, _Ref2, _Ptr2>);

  template<typename _II, typename _Tp, typename _Ref, typename _Ptr>
    typename __gnu_cxx::__enable_if<
      __is_random_access_iter<_II>::__value, bool>::__type
    __equal_aux1(_II, _II,
  std::_Deque_iterator<_Tp, _Ref, _Ptr>);

  template<typename _II1, typename _II2>
   
    inline bool
    __equal_aux1(_II1 __first1, _II1 __last1, _II2 __first2)
    {
      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      const bool __simple = ((__is_integer<_ValueType1>::__value
         || __is_pointer<_ValueType1>::__value)
        && __memcmpable<_II1, _II2>::__value);
      return std::__equal<__simple>::equal(__first1, __last1, __first2);
    }

  template<typename _II1, typename _II2>
   
    inline bool
    __equal_aux(_II1 __first1, _II1 __last1, _II2 __first2)
    {
      return std::__equal_aux1(std::__niter_base(__first1),
          std::__niter_base(__last1),
          std::__niter_base(__first2));
    }

  template<typename _II1, typename _Seq1, typename _Cat1, typename _II2>
    bool
    __equal_aux(const ::__gnu_debug::_Safe_iterator<_II1, _Seq1, _Cat1>&,
  const ::__gnu_debug::_Safe_iterator<_II1, _Seq1, _Cat1>&,
  _II2);

  template<typename _II1, typename _II2, typename _Seq2, typename _Cat2>
    bool
    __equal_aux(_II1, _II1,
  const ::__gnu_debug::_Safe_iterator<_II2, _Seq2, _Cat2>&);

  template<typename _II1, typename _Seq1, typename _Cat1,
    typename _II2, typename _Seq2, typename _Cat2>
    bool
    __equal_aux(const ::__gnu_debug::_Safe_iterator<_II1, _Seq1, _Cat1>&,
  const ::__gnu_debug::_Safe_iterator<_II1, _Seq1, _Cat1>&,
  const ::__gnu_debug::_Safe_iterator<_II2, _Seq2, _Cat2>&);

  template<typename, typename>
    struct __lc_rai
    {
      template<typename _II1, typename _II2>

 static _II1
 __newlast1(_II1, _II1 __last1, _II2, _II2)
 { return __last1; }

      template<typename _II>

 static bool
 __cnd2(_II __first, _II __last)
 { return __first != __last; }
    };

  template<>
    struct __lc_rai<random_access_iterator_tag, random_access_iterator_tag>
    {
      template<typename _RAI1, typename _RAI2>

 static _RAI1
 __newlast1(_RAI1 __first1, _RAI1 __last1,
     _RAI2 __first2, _RAI2 __last2)
 {
   const typename iterator_traits<_RAI1>::difference_type
     __diff1 = __last1 - __first1;
   const typename iterator_traits<_RAI2>::difference_type
     __diff2 = __last2 - __first2;
   return __diff2 < __diff1 ? __first1 + __diff2 : __last1;
 }

      template<typename _RAI>
 static bool
 __cnd2(_RAI, _RAI)
 { return true; }
    };

  template<typename _II1, typename _II2, typename _Compare>
   
    bool
    __lexicographical_compare_impl(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2,
       _Compare __comp)
    {
      typedef typename iterator_traits<_II1>::iterator_category _Category1;
      typedef typename iterator_traits<_II2>::iterator_category _Category2;
      typedef std::__lc_rai<_Category1, _Category2> __rai_type;

      __last1 = __rai_type::__newlast1(__first1, __last1, __first2, __last2);
      for (; __first1 != __last1 && __rai_type::__cnd2(__first2, __last2);
    ++__first1, (void)++__first2)
 {
   if (__comp(__first1, __first2))
     return true;
   if (__comp(__first2, __first1))
     return false;
 }
      return __first1 == __last1 && __first2 != __last2;
    }

  template<bool _BoolType>
    struct __lexicographical_compare
    {
      template<typename _II1, typename _II2>

 static bool
 __lc(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
 {
   using __gnu_cxx::__ops::__iter_less_iter;
   return std::__lexicographical_compare_impl(__first1, __last1,
           __first2, __last2,
           __iter_less_iter());
 }
    };

  template<>
    struct __lexicographical_compare<true>
    {
      template<typename _Tp, typename _Up>

 static bool
 __lc(const _Tp* __first1, const _Tp* __last1,
      const _Up* __first2, const _Up* __last2)
 {
   const size_t __len1 = __last1 - __first1;
   const size_t __len2 = __last2 - __first2;
   if (const size_t __len = std::min(__len1, __len2))
     if (int __result = std::__memcmp(__first1, __first2, __len))
       return __result < 0;
   return __len1 < __len2;
 }
    };

  template<typename _II1, typename _II2>
   
    inline bool
    __lexicographical_compare_aux(_II1 __first1, _II1 __last1,
      _II2 __first2, _II2 __last2)
    {
      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      typedef typename iterator_traits<_II2>::value_type _ValueType2;
      const bool __simple =
 (__is_byte<_ValueType1>::__value && __is_byte<_ValueType2>::__value
  && !__gnu_cxx::__numeric_traits<_ValueType1>::__is_signed
  && !__gnu_cxx::__numeric_traits<_ValueType2>::__is_signed
  && __is_pointer<_II1>::__value
  && __is_pointer<_II2>::__value







  );

      return std::__lexicographical_compare<__simple>::__lc(__first1, __last1,
           __first2, __last2);
    }

  template<typename _ForwardIterator, typename _Tp, typename _Compare>
   
    _ForwardIterator
    __lower_bound(_ForwardIterator __first, _ForwardIterator __last,
    const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;

      _DistanceType __len = std::distance(__first, __last);

      while (__len > 0)
 {
   _DistanceType __half = __len >> 1;
   _ForwardIterator __middle = __first;
   std::advance(__middle, __half);
   if (__comp(__middle, __val))
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else
     __len = __half;
 }
      return __first;
    }
# 1347 "/usr/include/c++/10.2.0/bits/stl_algobase.h" 3
  template<typename _ForwardIterator, typename _Tp>
   
    inline _ForwardIterator
    lower_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {

     
     

      ;

      return std::__lower_bound(__first, __last, __val,
    __gnu_cxx::__ops::__iter_less_val());
    }



  inline constexpr int
  __lg(int __n)
  { return (int)sizeof(int) * 8 - 1 - __builtin_clz(__n); }

  inline constexpr unsigned
  __lg(unsigned __n)
  { return (int)sizeof(int) * 8 - 1 - __builtin_clz(__n); }

  inline constexpr long
  __lg(long __n)
  { return (int)sizeof(long) * 8 - 1 - __builtin_clzl(__n); }

  inline constexpr unsigned long
  __lg(unsigned long __n)
  { return (int)sizeof(long) * 8 - 1 - __builtin_clzl(__n); }

  inline constexpr long long
  __lg(long long __n)
  { return (int)sizeof(long long) * 8 - 1 - __builtin_clzll(__n); }

  inline constexpr unsigned long long
  __lg(unsigned long long __n)
  { return (int)sizeof(long long) * 8 - 1 - __builtin_clzll(__n); }


# 1403 "/usr/include/c++/10.2.0/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2>
   
    inline bool
    equal(_II1 __first1, _II1 __last1, _II2 __first2)
    {

     
     
     


      ;

      return std::__equal_aux(__first1, __last1, __first2);
    }
# 1434 "/usr/include/c++/10.2.0/bits/stl_algobase.h" 3
  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
   
    inline bool
    equal(_IIter1 __first1, _IIter1 __last1,
   _IIter2 __first2, _BinaryPredicate __binary_pred)
    {

     
     
      ;

      for (; __first1 != __last1; ++__first1, (void)++__first2)
 if (!bool(__binary_pred(*__first1, *__first2)))
   return false;
      return true;
    }



  template<typename _II1, typename _II2>
   
    inline bool
    __equal4(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
    {
      using _RATag = random_access_iterator_tag;
      using _Cat1 = typename iterator_traits<_II1>::iterator_category;
      using _Cat2 = typename iterator_traits<_II2>::iterator_category;
      using _RAIters = __and_<is_same<_Cat1, _RATag>, is_same<_Cat2, _RATag>>;
      if (_RAIters())
 {
   auto __d1 = std::distance(__first1, __last1);
   auto __d2 = std::distance(__first2, __last2);
   if (__d1 != __d2)
     return false;
   return std::equal(__first1, __last1, __first2);
 }

      for (; __first1 != __last1 && __first2 != __last2;
   ++__first1, (void)++__first2)
 if (!(*__first1 == *__first2))
   return false;
      return __first1 == __last1 && __first2 == __last2;
    }


  template<typename _II1, typename _II2, typename _BinaryPredicate>
   
    inline bool
    __equal4(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2,
      _BinaryPredicate __binary_pred)
    {
      using _RATag = random_access_iterator_tag;
      using _Cat1 = typename iterator_traits<_II1>::iterator_category;
      using _Cat2 = typename iterator_traits<_II2>::iterator_category;
      using _RAIters = __and_<is_same<_Cat1, _RATag>, is_same<_Cat2, _RATag>>;
      if (_RAIters())
 {
   auto __d1 = std::distance(__first1, __last1);
   auto __d2 = std::distance(__first2, __last2);
   if (__d1 != __d2)
     return false;
   return std::equal(__first1, __last1, __first2,
           __binary_pred);
 }

      for (; __first1 != __last1 && __first2 != __last2;
   ++__first1, (void)++__first2)
 if (!bool(__binary_pred(*__first1, *__first2)))
   return false;
      return __first1 == __last1 && __first2 == __last2;
    }
# 1524 "/usr/include/c++/10.2.0/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2>
   
    inline bool
    equal(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
    {

     
     
     


      ;
      ;

      return std::__equal4(__first1, __last1, __first2, __last2);
    }
# 1557 "/usr/include/c++/10.2.0/bits/stl_algobase.h" 3
  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
   
    inline bool
    equal(_IIter1 __first1, _IIter1 __last1,
   _IIter2 __first2, _IIter2 __last2, _BinaryPredicate __binary_pred)
    {

     
     
      ;
      ;

      return std::__equal4(__first1, __last1, __first2, __last2,
          __binary_pred);
    }
# 1589 "/usr/include/c++/10.2.0/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2>
   
    inline bool
    lexicographical_compare(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2)
    {





     
     
     
     
      ;
      ;

      return std::__lexicographical_compare_aux(std::__niter_base(__first1),
      std::__niter_base(__last1),
      std::__niter_base(__first2),
      std::__niter_base(__last2));
    }
# 1626 "/usr/include/c++/10.2.0/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2, typename _Compare>
   
    inline bool
    lexicographical_compare(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2, _Compare __comp)
    {

     
     
      ;
      ;

      return std::__lexicographical_compare_impl
 (__first1, __last1, __first2, __last2,
  __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }
# 1740 "/usr/include/c++/10.2.0/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
   
    pair<_InputIterator1, _InputIterator2>
    __mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _BinaryPredicate __binary_pred)
    {
      while (__first1 != __last1 && __binary_pred(__first1, __first2))
 {
   ++__first1;
   ++__first2;
 }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }
# 1768 "/usr/include/c++/10.2.0/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
   
    inline pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2)
    {

     
     
     


      ;

      return std::__mismatch(__first1, __last1, __first2,
        __gnu_cxx::__ops::__iter_equal_to_iter());
    }
# 1802 "/usr/include/c++/10.2.0/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
   
    inline pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _BinaryPredicate __binary_pred)
    {

     
     
      ;

      return std::__mismatch(__first1, __last1, __first2,
 __gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
    }



  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
   
    pair<_InputIterator1, _InputIterator2>
    __mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _BinaryPredicate __binary_pred)
    {
      while (__first1 != __last1 && __first2 != __last2
      && __binary_pred(__first1, __first2))
 {
   ++__first1;
   ++__first2;
 }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }
# 1851 "/usr/include/c++/10.2.0/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
   
    inline pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2)
    {

     
     
     


      ;
      ;

      return std::__mismatch(__first1, __last1, __first2, __last2,
        __gnu_cxx::__ops::__iter_equal_to_iter());
    }
# 1887 "/usr/include/c++/10.2.0/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
   
    inline pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2,
      _BinaryPredicate __binary_pred)
    {

     
     
      ;
      ;

      return std::__mismatch(__first1, __last1, __first2, __last2,
        __gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
    }





  template<typename _InputIterator, typename _Predicate>
   
    inline _InputIterator
    __find_if(_InputIterator __first, _InputIterator __last,
       _Predicate __pred, input_iterator_tag)
    {
      while (__first != __last && !__pred(__first))
 ++__first;
      return __first;
    }


  template<typename _RandomAccessIterator, typename _Predicate>
   
    _RandomAccessIterator
    __find_if(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Predicate __pred, random_access_iterator_tag)
    {
      typename iterator_traits<_RandomAccessIterator>::difference_type
 __trip_count = (__last - __first) >> 2;

      for (; __trip_count > 0; --__trip_count)
 {
   if (__pred(__first))
     return __first;
   ++__first;

   if (__pred(__first))
     return __first;
   ++__first;

   if (__pred(__first))
     return __first;
   ++__first;

   if (__pred(__first))
     return __first;
   ++__first;
 }

      switch (__last - __first)
 {
 case 3:
   if (__pred(__first))
     return __first;
   ++__first;

 case 2:
   if (__pred(__first))
     return __first;
   ++__first;

 case 1:
   if (__pred(__first))
     return __first;
   ++__first;

 case 0:
 default:
   return __last;
 }
    }

  template<typename _Iterator, typename _Predicate>
   
    inline _Iterator
    __find_if(_Iterator __first, _Iterator __last, _Predicate __pred)
    {
      return __find_if(__first, __last, __pred,
         std::__iterator_category(__first));
    }

  template<typename _InputIterator, typename _Predicate>
   
    typename iterator_traits<_InputIterator>::difference_type
    __count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    {
      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      for (; __first != __last; ++__first)
 if (__pred(__first))
   ++__n;
      return __n;
    }


  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
   
    bool
    __is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
       _ForwardIterator2 __first2, _BinaryPredicate __pred)
    {


      for (; __first1 != __last1; ++__first1, (void)++__first2)
 if (!__pred(__first1, __first2))
   break;

      if (__first1 == __last1)
 return true;



      _ForwardIterator2 __last2 = __first2;
      std::advance(__last2, std::distance(__first1, __last1));
      for (_ForwardIterator1 __scan = __first1; __scan != __last1; ++__scan)
 {
   if (__scan != std::__find_if(__first1, __scan,
     __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan)))
     continue;

   auto __matches
     = std::__count_if(__first2, __last2,
   __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan));
   if (0 == __matches ||
       std::__count_if(__scan, __last1,
   __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan))
       != __matches)
     return false;
 }
      return true;
    }
# 2044 "/usr/include/c++/10.2.0/bits/stl_algobase.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
   
    inline bool
    is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
     _ForwardIterator2 __first2)
    {

     
     
     


      ;

      return std::__is_permutation(__first1, __last1, __first2,
       __gnu_cxx::__ops::__iter_equal_to_iter());
    }



}
# 40 "/usr/include/c++/10.2.0/bits/char_traits.h" 2 3

# 1 "/usr/include/c++/10.2.0/cwchar" 1 3
# 39 "/usr/include/c++/10.2.0/cwchar" 3
       
# 40 "/usr/include/c++/10.2.0/cwchar" 3
# 42 "/usr/include/c++/10.2.0/bits/char_traits.h" 2 3
# 50 "/usr/include/c++/10.2.0/bits/char_traits.h" 3
namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{

# 64 "/usr/include/c++/10.2.0/bits/char_traits.h" 3
  template<typename _CharT>
    struct _Char_types
    {
      typedef unsigned long int_type;
      typedef std::streampos pos_type;
      typedef std::streamoff off_type;
      typedef std::mbstate_t state_type;
    };
# 89 "/usr/include/c++/10.2.0/bits/char_traits.h" 3
  template<typename _CharT>
    struct char_traits
    {
      typedef _CharT char_type;
      typedef typename _Char_types<_CharT>::int_type int_type;
      typedef typename _Char_types<_CharT>::pos_type pos_type;
      typedef typename _Char_types<_CharT>::off_type off_type;
      typedef typename _Char_types<_CharT>::state_type state_type;




      static constexpr void
      assign(char_type& __c1, const char_type& __c2)
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }

      static constexpr int
      compare(const char_type* __s1, const char_type* __s2, std::size_t __n);

      static constexpr std::size_t
      length(const char_type* __s);

      static constexpr const char_type*
      find(const char_type* __s, std::size_t __n, const char_type& __a);

      static char_type*
      move(char_type* __s1, const char_type* __s2, std::size_t __n);

      static char_type*
      copy(char_type* __s1, const char_type* __s2, std::size_t __n);

      static char_type*
      assign(char_type* __s, std::size_t __n, char_type __a);

      static constexpr char_type
      to_char_type(const int_type& __c)
      { return static_cast<char_type>(__c); }

      static constexpr int_type
      to_int_type(const char_type& __c)
      { return static_cast<int_type>(__c); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2)
      { return __c1 == __c2; }

      static constexpr int_type
      eof()
      { return static_cast<int_type>(-1); }

      static constexpr int_type
      not_eof(const int_type& __c)
      { return !eq_int_type(__c, eof()) ? __c : to_int_type(char_type()); }
    };

  template<typename _CharT>
    constexpr int
    char_traits<_CharT>::
    compare(const char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      for (std::size_t __i = 0; __i < __n; ++__i)
 if (lt(__s1[__i], __s2[__i]))
   return -1;
 else if (lt(__s2[__i], __s1[__i]))
   return 1;
      return 0;
    }

  template<typename _CharT>
    constexpr std::size_t
    char_traits<_CharT>::
    length(const char_type* __p)
    {
      std::size_t __i = 0;
      while (!eq(__p[__i], char_type()))
        ++__i;
      return __i;
    }

  template<typename _CharT>
    constexpr const typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    find(const char_type* __s, std::size_t __n, const char_type& __a)
    {
      for (std::size_t __i = 0; __i < __n; ++__i)
        if (eq(__s[__i], __a))
          return __s + __i;
      return 0;
    }

  template<typename _CharT>
   
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    move(char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      if (__n == 0)
 return __s1;
# 205 "/usr/include/c++/10.2.0/bits/char_traits.h" 3
      return static_cast<_CharT*>(__builtin_memmove(__s1, __s2,
          __n * sizeof(char_type)));
    }

  template<typename _CharT>
   
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    copy(char_type* __s1, const char_type* __s2, std::size_t __n)
    {

      std::copy(__s2, __s2 + __n, __s1);
      return __s1;
    }

  template<typename _CharT>
   
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    assign(char_type* __s, std::size_t __n, char_type __a)
    {

      std::fill_n(__s, __n, __a);
      return __s;
    }


}

namespace std __attribute__ ((__visibility__ ("default")))
{

# 302 "/usr/include/c++/10.2.0/bits/char_traits.h" 3
  template<class _CharT>
    struct char_traits : public __gnu_cxx::char_traits<_CharT>
    { };



  template<>
    struct char_traits<char>
    {
      typedef char char_type;
      typedef int int_type;
      typedef streampos pos_type;
      typedef streamoff off_type;
      typedef mbstate_t state_type;




      static void
      assign(char_type& __c1, const char_type& __c2) noexcept
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2) noexcept
      {

 return (static_cast<unsigned char>(__c1)
  < static_cast<unsigned char>(__c2));
      }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return 0;






 return __builtin_memcmp(__s1, __s2, __n);
      }

      static size_t
      length(const char_type* __s)
      {




 return __builtin_strlen(__s);
      }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      {
 if (__n == 0)
   return 0;






 return static_cast<const char_type*>(__builtin_memchr(__s, __a, __n));
      }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;




 return static_cast<char_type*>(__builtin_memmove(__s1, __s2, __n));
      }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;




 return static_cast<char_type*>(__builtin_memcpy(__s1, __s2, __n));
      }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      {
 if (__n == 0)
   return __s;




 return static_cast<char_type*>(__builtin_memset(__s, __a, __n));
      }

      static constexpr char_type
      to_char_type(const int_type& __c) noexcept
      { return static_cast<char_type>(__c); }



      static constexpr int_type
      to_int_type(const char_type& __c) noexcept
      { return static_cast<int_type>(static_cast<unsigned char>(__c)); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr int_type
      eof() noexcept
      { return static_cast<int_type>(-1); }

      static constexpr int_type
      not_eof(const int_type& __c) noexcept
      { return (__c == eof()) ? 0 : __c; }
  };




  template<>
    struct char_traits<wchar_t>
    {
      typedef wchar_t char_type;
      typedef wint_t int_type;
      typedef streamoff off_type;
      typedef wstreampos pos_type;
      typedef mbstate_t state_type;




      static void
      assign(char_type& __c1, const char_type& __c2) noexcept
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return 0;






 return wmemcmp(__s1, __s2, __n);
      }

      static size_t
      length(const char_type* __s)
      {




 return wcslen(__s);
      }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      {
 if (__n == 0)
   return 0;






 return wmemchr(__s, __a, __n);
      }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;




 return wmemmove(__s1, __s2, __n);
      }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;




 return wmemcpy(__s1, __s2, __n);
      }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      {
 if (__n == 0)
   return __s;




 return wmemset(__s, __a, __n);
      }

      static constexpr char_type
      to_char_type(const int_type& __c) noexcept
      { return char_type(__c); }

      static constexpr int_type
      to_int_type(const char_type& __c) noexcept
      { return int_type(__c); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr int_type
      eof() noexcept
      { return static_cast<int_type>((0xffffffffu)); }

      static constexpr int_type
      not_eof(const int_type& __c) noexcept
      { return eq_int_type(__c, eof()) ? 0 : __c; }
  };
# 680 "/usr/include/c++/10.2.0/bits/char_traits.h" 3

}



# 1 "/usr/include/c++/10.2.0/cstdint" 1 3
# 32 "/usr/include/c++/10.2.0/cstdint" 3
       
# 33 "/usr/include/c++/10.2.0/cstdint" 3
# 44 "/usr/include/c++/10.2.0/cstdint" 3
namespace std
{

  using ::int8_t;
  using ::int16_t;
  using ::int32_t;
  using ::int64_t;

  using ::int_fast8_t;
  using ::int_fast16_t;
  using ::int_fast32_t;
  using ::int_fast64_t;

  using ::int_least8_t;
  using ::int_least16_t;
  using ::int_least32_t;
  using ::int_least64_t;

  using ::intmax_t;
  using ::intptr_t;

  using ::uint8_t;
  using ::uint16_t;
  using ::uint32_t;
  using ::uint64_t;

  using ::uint_fast8_t;
  using ::uint_fast16_t;
  using ::uint_fast32_t;
  using ::uint_fast64_t;

  using ::uint_least8_t;
  using ::uint_least16_t;
  using ::uint_least32_t;
  using ::uint_least64_t;

  using ::uintmax_t;
  using ::uintptr_t;





}
# 686 "/usr/include/c++/10.2.0/bits/char_traits.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<>
    struct char_traits<char16_t>
    {
      typedef char16_t char_type;

      typedef uint_least16_t int_type;





      typedef streamoff off_type;
      typedef u16streampos pos_type;
      typedef mbstate_t state_type;




      static void
      assign(char_type& __c1, const char_type& __c2) noexcept
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   if (lt(__s1[__i], __s2[__i]))
     return -1;
   else if (lt(__s2[__i], __s1[__i]))
     return 1;
 return 0;
      }

      static size_t
      length(const char_type* __s)
      {
 size_t __i = 0;
 while (!eq(__s[__i], char_type()))
   ++__i;
 return __i;
      }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   if (eq(__s[__i], __a))
     return __s + __i;
 return 0;
      }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;




 return (static_cast<char_type*>
  (__builtin_memmove(__s1, __s2, __n * sizeof(char_type))));
      }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;




 return (static_cast<char_type*>
  (__builtin_memcpy(__s1, __s2, __n * sizeof(char_type))));
      }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   assign(__s[__i], __a);
 return __s;
      }

      static constexpr char_type
      to_char_type(const int_type& __c) noexcept
      { return char_type(__c); }

      static constexpr int_type
      to_int_type(const char_type& __c) noexcept
      { return __c == eof() ? int_type(0xfffd) : int_type(__c); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr int_type
      eof() noexcept
      { return static_cast<int_type>(-1); }

      static constexpr int_type
      not_eof(const int_type& __c) noexcept
      { return eq_int_type(__c, eof()) ? 0 : __c; }
    };

  template<>
    struct char_traits<char32_t>
    {
      typedef char32_t char_type;

      typedef uint_least32_t int_type;





      typedef streamoff off_type;
      typedef u32streampos pos_type;
      typedef mbstate_t state_type;




      static void
      assign(char_type& __c1, const char_type& __c2) noexcept
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   if (lt(__s1[__i], __s2[__i]))
     return -1;
   else if (lt(__s2[__i], __s1[__i]))
     return 1;
 return 0;
      }

      static size_t
      length(const char_type* __s)
      {
 size_t __i = 0;
 while (!eq(__s[__i], char_type()))
   ++__i;
 return __i;
      }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   if (eq(__s[__i], __a))
     return __s + __i;
 return 0;
      }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;




 return (static_cast<char_type*>
  (__builtin_memmove(__s1, __s2, __n * sizeof(char_type))));
      }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;




 return (static_cast<char_type*>
  (__builtin_memcpy(__s1, __s2, __n * sizeof(char_type))));
      }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   assign(__s[__i], __a);
 return __s;
      }

      static constexpr char_type
      to_char_type(const int_type& __c) noexcept
      { return char_type(__c); }

      static constexpr int_type
      to_int_type(const char_type& __c) noexcept
      { return int_type(__c); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr int_type
      eof() noexcept
      { return static_cast<int_type>(-1); }

      static constexpr int_type
      not_eof(const int_type& __c) noexcept
      { return eq_int_type(__c, eof()) ? 0 : __c; }
    };
# 938 "/usr/include/c++/10.2.0/bits/char_traits.h" 3

}
# 41 "/usr/include/c++/10.2.0/ios" 2 3
# 1 "/usr/include/c++/10.2.0/bits/localefwd.h" 1 3
# 37 "/usr/include/c++/10.2.0/bits/localefwd.h" 3
       
# 38 "/usr/include/c++/10.2.0/bits/localefwd.h" 3


# 1 "/usr/include/c++/10.2.0/x86_64-pc-linux-gnu/bits/c++locale.h" 1 3
# 39 "/usr/include/c++/10.2.0/x86_64-pc-linux-gnu/bits/c++locale.h" 3
       
# 40 "/usr/include/c++/10.2.0/x86_64-pc-linux-gnu/bits/c++locale.h" 3

# 1 "/usr/include/c++/10.2.0/clocale" 1 3
# 39 "/usr/include/c++/10.2.0/clocale" 3
       
# 40 "/usr/include/c++/10.2.0/clocale" 3


# 1 "/usr/include/locale.h" 1 3 4
# 28 "/usr/include/locale.h" 3 4
# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/include/stddef.h" 1 3 4
# 29 "/usr/include/locale.h" 2 3 4
# 1 "/usr/include/bits/locale.h" 1 3 4
# 30 "/usr/include/locale.h" 2 3 4

extern "C" {
# 51 "/usr/include/locale.h" 3 4
struct lconv
{


  char *decimal_point;
  char *thousands_sep;





  char *grouping;





  char *int_curr_symbol;
  char *currency_symbol;
  char *mon_decimal_point;
  char *mon_thousands_sep;
  char *mon_grouping;
  char *positive_sign;
  char *negative_sign;
  char int_frac_digits;
  char frac_digits;

  char p_cs_precedes;

  char p_sep_by_space;

  char n_cs_precedes;

  char n_sep_by_space;






  char p_sign_posn;
  char n_sign_posn;


  char int_p_cs_precedes;

  char int_p_sep_by_space;

  char int_n_cs_precedes;

  char int_n_sep_by_space;






  char int_p_sign_posn;
  char int_n_sign_posn;
# 118 "/usr/include/locale.h" 3 4
};



extern char *setlocale (int __category, const char *__locale) noexcept (true);


extern struct lconv *localeconv (void) noexcept (true);
# 141 "/usr/include/locale.h" 3 4
extern locale_t newlocale (int __category_mask, const char *__locale,
      locale_t __base) noexcept (true);
# 176 "/usr/include/locale.h" 3 4
extern locale_t duplocale (locale_t __dataset) noexcept (true);



extern void freelocale (locale_t __dataset) noexcept (true);






extern locale_t uselocale (locale_t __dataset) noexcept (true);







}
# 43 "/usr/include/c++/10.2.0/clocale" 2 3
# 51 "/usr/include/c++/10.2.0/clocale" 3
namespace std
{
  using ::lconv;
  using ::setlocale;
  using ::localeconv;
}
# 42 "/usr/include/c++/10.2.0/x86_64-pc-linux-gnu/bits/c++locale.h" 2 3






namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{


  extern "C" __typeof(uselocale) __uselocale;


}


namespace std __attribute__ ((__visibility__ ("default")))
{


  typedef __locale_t __c_locale;





  inline int
  __convert_from_v(const __c_locale& __cloc __attribute__ ((__unused__)),
     char* __out,
     const int __size __attribute__ ((__unused__)),
     const char* __fmt, ...)
  {

    __c_locale __old = __gnu_cxx::__uselocale(__cloc);
# 88 "/usr/include/c++/10.2.0/x86_64-pc-linux-gnu/bits/c++locale.h" 3
    __builtin_va_list __args;
    __builtin_va_start(__args, __fmt);


    const int __ret = __builtin_vsnprintf(__out, __size, __fmt, __args);




    __builtin_va_end(__args);


    __gnu_cxx::__uselocale(__old);







    return __ret;
  }


}
# 41 "/usr/include/c++/10.2.0/bits/localefwd.h" 2 3

# 1 "/usr/include/c++/10.2.0/cctype" 1 3
# 39 "/usr/include/c++/10.2.0/cctype" 3
       
# 40 "/usr/include/c++/10.2.0/cctype" 3
# 43 "/usr/include/c++/10.2.0/bits/localefwd.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 55 "/usr/include/c++/10.2.0/bits/localefwd.h" 3
  class locale;

  template<typename _Facet>
    bool
    has_facet(const locale&) throw();

  template<typename _Facet>
    const _Facet&
    use_facet(const locale&);


  template<typename _CharT>
    bool
    isspace(_CharT, const locale&);

  template<typename _CharT>
    bool
    isprint(_CharT, const locale&);

  template<typename _CharT>
    bool
    iscntrl(_CharT, const locale&);

  template<typename _CharT>
    bool
    isupper(_CharT, const locale&);

  template<typename _CharT>
    bool
    islower(_CharT, const locale&);

  template<typename _CharT>
    bool
    isalpha(_CharT, const locale&);

  template<typename _CharT>
    bool
    isdigit(_CharT, const locale&);

  template<typename _CharT>
    bool
    ispunct(_CharT, const locale&);

  template<typename _CharT>
    bool
    isxdigit(_CharT, const locale&);

  template<typename _CharT>
    bool
    isalnum(_CharT, const locale&);

  template<typename _CharT>
    bool
    isgraph(_CharT, const locale&);


  template<typename _CharT>
    bool
    isblank(_CharT, const locale&);


  template<typename _CharT>
    _CharT
    toupper(_CharT, const locale&);

  template<typename _CharT>
    _CharT
    tolower(_CharT, const locale&);


  class ctype_base;
  template<typename _CharT>
    class ctype;
  template<> class ctype<char>;

  template<> class ctype<wchar_t>;

  template<typename _CharT>
    class ctype_byname;


  class codecvt_base;
  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt;
  template<> class codecvt<char, char, mbstate_t>;

  template<> class codecvt<wchar_t, char, mbstate_t>;


  template<> class codecvt<char16_t, char, mbstate_t>;
  template<> class codecvt<char32_t, char, mbstate_t>;





  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt_byname;



  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class num_get;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class num_put;

namespace __cxx11 {
  template<typename _CharT> class numpunct;
  template<typename _CharT> class numpunct_byname;
}

namespace __cxx11 {

  template<typename _CharT>
    class collate;
  template<typename _CharT>
    class collate_byname;
}


  class time_base;
namespace __cxx11 {
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class time_get;
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class time_get_byname;
}
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class time_put;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class time_put_byname;


  class money_base;
namespace __cxx11 {
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class money_get;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class money_put;
}
namespace __cxx11 {
  template<typename _CharT, bool _Intl = false>
    class moneypunct;
  template<typename _CharT, bool _Intl = false>
    class moneypunct_byname;
}


  class messages_base;
namespace __cxx11 {
  template<typename _CharT>
    class messages;
  template<typename _CharT>
    class messages_byname;
}


}
# 42 "/usr/include/c++/10.2.0/ios" 2 3
# 1 "/usr/include/c++/10.2.0/bits/ios_base.h" 1 3
# 37 "/usr/include/c++/10.2.0/bits/ios_base.h" 3
       
# 38 "/usr/include/c++/10.2.0/bits/ios_base.h" 3

# 1 "/usr/include/c++/10.2.0/ext/atomicity.h" 1 3
# 32 "/usr/include/c++/10.2.0/ext/atomicity.h" 3
       
# 33 "/usr/include/c++/10.2.0/ext/atomicity.h" 3


# 1 "/usr/include/c++/10.2.0/x86_64-pc-linux-gnu/bits/gthr.h" 1 3
# 30 "/usr/include/c++/10.2.0/x86_64-pc-linux-gnu/bits/gthr.h" 3
#pragma GCC visibility push(default)
# 148 "/usr/include/c++/10.2.0/x86_64-pc-linux-gnu/bits/gthr.h" 3
# 1 "/usr/include/c++/10.2.0/x86_64-pc-linux-gnu/bits/gthr-default.h" 1 3
# 35 "/usr/include/c++/10.2.0/x86_64-pc-linux-gnu/bits/gthr-default.h" 3
# 1 "/usr/include/pthread.h" 1 3 4
# 22 "/usr/include/pthread.h" 3 4
# 1 "/usr/include/sched.h" 1 3 4
# 29 "/usr/include/sched.h" 3 4
# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/include/stddef.h" 1 3 4
# 30 "/usr/include/sched.h" 2 3 4
# 43 "/usr/include/sched.h" 3 4
# 1 "/usr/include/bits/sched.h" 1 3 4
# 76 "/usr/include/bits/sched.h" 3 4
# 1 "/usr/include/bits/types/struct_sched_param.h" 1 3 4
# 23 "/usr/include/bits/types/struct_sched_param.h" 3 4
struct sched_param
{
  int sched_priority;
};
# 77 "/usr/include/bits/sched.h" 2 3 4

extern "C" {



extern int clone (int (*__fn) (void *__arg), void *__child_stack,
    int __flags, void *__arg, ...) noexcept (true);


extern int unshare (int __flags) noexcept (true);


extern int sched_getcpu (void) noexcept (true);


extern int getcpu (unsigned int *, unsigned int *) noexcept (true);


extern int setns (int __fd, int __nstype) noexcept (true);


}
# 44 "/usr/include/sched.h" 2 3 4
# 1 "/usr/include/bits/cpu-set.h" 1 3 4
# 32 "/usr/include/bits/cpu-set.h" 3 4
typedef unsigned long int __cpu_mask;






typedef struct
{
  __cpu_mask __bits[1024 / (8 * sizeof (__cpu_mask))];
} cpu_set_t;
# 115 "/usr/include/bits/cpu-set.h" 3 4
extern "C" {

extern int __sched_cpucount (size_t __setsize, const cpu_set_t *__setp)
     noexcept (true);
extern cpu_set_t *__sched_cpualloc (size_t __count) noexcept (true) ;
extern void __sched_cpufree (cpu_set_t *__set) noexcept (true);

}
# 45 "/usr/include/sched.h" 2 3 4






extern "C" {


extern int sched_setparam (__pid_t __pid, const struct sched_param *__param)
     noexcept (true);


extern int sched_getparam (__pid_t __pid, struct sched_param *__param) noexcept (true);


extern int sched_setscheduler (__pid_t __pid, int __policy,
          const struct sched_param *__param) noexcept (true);


extern int sched_getscheduler (__pid_t __pid) noexcept (true);


extern int sched_yield (void) noexcept (true);


extern int sched_get_priority_max (int __algorithm) noexcept (true);


extern int sched_get_priority_min (int __algorithm) noexcept (true);


extern int sched_rr_get_interval (__pid_t __pid, struct timespec *__t) noexcept (true);
# 121 "/usr/include/sched.h" 3 4
extern int sched_setaffinity (__pid_t __pid, size_t __cpusetsize,
         const cpu_set_t *__cpuset) noexcept (true);


extern int sched_getaffinity (__pid_t __pid, size_t __cpusetsize,
         cpu_set_t *__cpuset) noexcept (true);


}
# 23 "/usr/include/pthread.h" 2 3 4




# 1 "/usr/include/bits/setjmp.h" 1 3 4
# 26 "/usr/include/bits/setjmp.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 27 "/usr/include/bits/setjmp.h" 2 3 4




typedef long int __jmp_buf[8];
# 28 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 29 "/usr/include/pthread.h" 2 3 4


# 1 "/usr/include/bits/types/struct___jmp_buf_tag.h" 1 3 4
# 26 "/usr/include/bits/types/struct___jmp_buf_tag.h" 3 4
struct __jmp_buf_tag
  {




    __jmp_buf __jmpbuf;
    int __mask_was_saved;
    __sigset_t __saved_mask;
  };
# 32 "/usr/include/pthread.h" 2 3 4



enum
{
  PTHREAD_CREATE_JOINABLE,

  PTHREAD_CREATE_DETACHED

};



enum
{
  PTHREAD_MUTEX_TIMED_NP,
  PTHREAD_MUTEX_RECURSIVE_NP,
  PTHREAD_MUTEX_ERRORCHECK_NP,
  PTHREAD_MUTEX_ADAPTIVE_NP

  ,
  PTHREAD_MUTEX_NORMAL = PTHREAD_MUTEX_TIMED_NP,
  PTHREAD_MUTEX_RECURSIVE = PTHREAD_MUTEX_RECURSIVE_NP,
  PTHREAD_MUTEX_ERRORCHECK = PTHREAD_MUTEX_ERRORCHECK_NP,
  PTHREAD_MUTEX_DEFAULT = PTHREAD_MUTEX_NORMAL



  , PTHREAD_MUTEX_FAST_NP = PTHREAD_MUTEX_TIMED_NP

};




enum
{
  PTHREAD_MUTEX_STALLED,
  PTHREAD_MUTEX_STALLED_NP = PTHREAD_MUTEX_STALLED,
  PTHREAD_MUTEX_ROBUST,
  PTHREAD_MUTEX_ROBUST_NP = PTHREAD_MUTEX_ROBUST
};





enum
{
  PTHREAD_PRIO_NONE,
  PTHREAD_PRIO_INHERIT,
  PTHREAD_PRIO_PROTECT
};
# 102 "/usr/include/pthread.h" 3 4
enum
{
  PTHREAD_RWLOCK_PREFER_READER_NP,
  PTHREAD_RWLOCK_PREFER_WRITER_NP,
  PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP,
  PTHREAD_RWLOCK_DEFAULT_NP = PTHREAD_RWLOCK_PREFER_READER_NP
};
# 122 "/usr/include/pthread.h" 3 4
enum
{
  PTHREAD_INHERIT_SCHED,

  PTHREAD_EXPLICIT_SCHED

};



enum
{
  PTHREAD_SCOPE_SYSTEM,

  PTHREAD_SCOPE_PROCESS

};



enum
{
  PTHREAD_PROCESS_PRIVATE,

  PTHREAD_PROCESS_SHARED

};
# 157 "/usr/include/pthread.h" 3 4
struct _pthread_cleanup_buffer
{
  void (*__routine) (void *);
  void *__arg;
  int __canceltype;
  struct _pthread_cleanup_buffer *__prev;
};


enum
{
  PTHREAD_CANCEL_ENABLE,

  PTHREAD_CANCEL_DISABLE

};
enum
{
  PTHREAD_CANCEL_DEFERRED,

  PTHREAD_CANCEL_ASYNCHRONOUS

};
# 195 "/usr/include/pthread.h" 3 4
extern "C" {




extern int pthread_create (pthread_t *__restrict __newthread,
      const pthread_attr_t *__restrict __attr,
      void *(*__start_routine) (void *),
      void *__restrict __arg) noexcept (true) __attribute__ ((__nonnull__ (1, 3)));





extern void pthread_exit (void *__retval) __attribute__ ((__noreturn__));







extern int pthread_join (pthread_t __th, void **__thread_return);




extern int pthread_tryjoin_np (pthread_t __th, void **__thread_return) noexcept (true);







extern int pthread_timedjoin_np (pthread_t __th, void **__thread_return,
     const struct timespec *__abstime);
# 240 "/usr/include/pthread.h" 3 4
extern int pthread_clockjoin_np (pthread_t __th, void **__thread_return,
                                 clockid_t __clockid,
     const struct timespec *__abstime);






extern int pthread_detach (pthread_t __th) noexcept (true);



extern pthread_t pthread_self (void) noexcept (true) __attribute__ ((__const__));


extern int pthread_equal (pthread_t __thread1, pthread_t __thread2)
  noexcept (true) __attribute__ ((__const__));







extern int pthread_attr_init (pthread_attr_t *__attr) noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_destroy (pthread_attr_t *__attr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getdetachstate (const pthread_attr_t *__attr,
     int *__detachstate)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setdetachstate (pthread_attr_t *__attr,
     int __detachstate)
     noexcept (true) __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getguardsize (const pthread_attr_t *__attr,
          size_t *__guardsize)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setguardsize (pthread_attr_t *__attr,
          size_t __guardsize)
     noexcept (true) __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getschedparam (const pthread_attr_t *__restrict __attr,
           struct sched_param *__restrict __param)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setschedparam (pthread_attr_t *__restrict __attr,
           const struct sched_param *__restrict
           __param) noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_getschedpolicy (const pthread_attr_t *__restrict
     __attr, int *__restrict __policy)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setschedpolicy (pthread_attr_t *__attr, int __policy)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getinheritsched (const pthread_attr_t *__restrict
      __attr, int *__restrict __inherit)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setinheritsched (pthread_attr_t *__attr,
      int __inherit)
     noexcept (true) __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getscope (const pthread_attr_t *__restrict __attr,
      int *__restrict __scope)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setscope (pthread_attr_t *__attr, int __scope)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getstackaddr (const pthread_attr_t *__restrict
          __attr, void **__restrict __stackaddr)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__deprecated__));





extern int pthread_attr_setstackaddr (pthread_attr_t *__attr,
          void *__stackaddr)
     noexcept (true) __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__));


extern int pthread_attr_getstacksize (const pthread_attr_t *__restrict
          __attr, size_t *__restrict __stacksize)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));




extern int pthread_attr_setstacksize (pthread_attr_t *__attr,
          size_t __stacksize)
     noexcept (true) __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getstack (const pthread_attr_t *__restrict __attr,
      void **__restrict __stackaddr,
      size_t *__restrict __stacksize)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2, 3)));




extern int pthread_attr_setstack (pthread_attr_t *__attr, void *__stackaddr,
      size_t __stacksize) noexcept (true) __attribute__ ((__nonnull__ (1)));





extern int pthread_attr_setaffinity_np (pthread_attr_t *__attr,
     size_t __cpusetsize,
     const cpu_set_t *__cpuset)
     noexcept (true) __attribute__ ((__nonnull__ (1, 3)));



extern int pthread_attr_getaffinity_np (const pthread_attr_t *__attr,
     size_t __cpusetsize,
     cpu_set_t *__cpuset)
     noexcept (true) __attribute__ ((__nonnull__ (1, 3)));


extern int pthread_getattr_default_np (pthread_attr_t *__attr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_setsigmask_np (pthread_attr_t *__attr,
           const __sigset_t *sigmask);




extern int pthread_attr_getsigmask_np (const pthread_attr_t *__attr,
           __sigset_t *sigmask);







extern int pthread_setattr_default_np (const pthread_attr_t *__attr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));




extern int pthread_getattr_np (pthread_t __th, pthread_attr_t *__attr)
     noexcept (true) __attribute__ ((__nonnull__ (2)));







extern int pthread_setschedparam (pthread_t __target_thread, int __policy,
      const struct sched_param *__param)
     noexcept (true) __attribute__ ((__nonnull__ (3)));


extern int pthread_getschedparam (pthread_t __target_thread,
      int *__restrict __policy,
      struct sched_param *__restrict __param)
     noexcept (true) __attribute__ ((__nonnull__ (2, 3)));


extern int pthread_setschedprio (pthread_t __target_thread, int __prio)
     noexcept (true);




extern int pthread_getname_np (pthread_t __target_thread, char *__buf,
          size_t __buflen)
     noexcept (true) __attribute__ ((__nonnull__ (2)));


extern int pthread_setname_np (pthread_t __target_thread, const char *__name)
     noexcept (true) __attribute__ ((__nonnull__ (2)));





extern int pthread_getconcurrency (void) noexcept (true);


extern int pthread_setconcurrency (int __level) noexcept (true);







extern int pthread_yield (void) noexcept (true);




extern int pthread_setaffinity_np (pthread_t __th, size_t __cpusetsize,
       const cpu_set_t *__cpuset)
     noexcept (true) __attribute__ ((__nonnull__ (3)));


extern int pthread_getaffinity_np (pthread_t __th, size_t __cpusetsize,
       cpu_set_t *__cpuset)
     noexcept (true) __attribute__ ((__nonnull__ (3)));
# 486 "/usr/include/pthread.h" 3 4
extern int pthread_once (pthread_once_t *__once_control,
    void (*__init_routine) (void)) __attribute__ ((__nonnull__ (1, 2)));
# 498 "/usr/include/pthread.h" 3 4
extern int pthread_setcancelstate (int __state, int *__oldstate);



extern int pthread_setcanceltype (int __type, int *__oldtype);


extern int pthread_cancel (pthread_t __th);




extern void pthread_testcancel (void);




struct __cancel_jmp_buf_tag
{
  __jmp_buf __cancel_jmp_buf;
  int __mask_was_saved;
};

typedef struct
{
  struct __cancel_jmp_buf_tag __cancel_jmp_buf[1];
  void *__pad[4];
} __pthread_unwind_buf_t __attribute__ ((__aligned__));
# 534 "/usr/include/pthread.h" 3 4
struct __pthread_cleanup_frame
{
  void (*__cancel_routine) (void *);
  void *__cancel_arg;
  int __do_it;
  int __cancel_type;
};




class __pthread_cleanup_class
{
  void (*__cancel_routine) (void *);
  void *__cancel_arg;
  int __do_it;
  int __cancel_type;

 public:
  __pthread_cleanup_class (void (*__fct) (void *), void *__arg)
    : __cancel_routine (__fct), __cancel_arg (__arg), __do_it (1) { }
  ~__pthread_cleanup_class () { if (__do_it) __cancel_routine (__cancel_arg); }
  void __setdoit (int __newval) { __do_it = __newval; }
  void __defer () { pthread_setcanceltype (PTHREAD_CANCEL_DEFERRED,
        &__cancel_type); }
  void __restore () const { pthread_setcanceltype (__cancel_type, 0); }
};
# 750 "/usr/include/pthread.h" 3 4
extern int __sigsetjmp (struct __jmp_buf_tag __env[1],
   int __savemask) noexcept (true);






extern int pthread_mutex_init (pthread_mutex_t *__mutex,
          const pthread_mutexattr_t *__mutexattr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_destroy (pthread_mutex_t *__mutex)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_trylock (pthread_mutex_t *__mutex)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_lock (pthread_mutex_t *__mutex)
     noexcept (true) __attribute__ ((__nonnull__ (1)));



extern int pthread_mutex_timedlock (pthread_mutex_t *__restrict __mutex,
        const struct timespec *__restrict
        __abstime) noexcept (true) __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutex_clocklock (pthread_mutex_t *__restrict __mutex,
        clockid_t __clockid,
        const struct timespec *__restrict
        __abstime) noexcept (true) __attribute__ ((__nonnull__ (1, 3)));



extern int pthread_mutex_unlock (pthread_mutex_t *__mutex)
     noexcept (true) __attribute__ ((__nonnull__ (1)));



extern int pthread_mutex_getprioceiling (const pthread_mutex_t *
      __restrict __mutex,
      int *__restrict __prioceiling)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutex_setprioceiling (pthread_mutex_t *__restrict __mutex,
      int __prioceiling,
      int *__restrict __old_ceiling)
     noexcept (true) __attribute__ ((__nonnull__ (1, 3)));




extern int pthread_mutex_consistent (pthread_mutex_t *__mutex)
     noexcept (true) __attribute__ ((__nonnull__ (1)));

extern int pthread_mutex_consistent_np (pthread_mutex_t *__mutex)
     noexcept (true) __attribute__ ((__nonnull__ (1)));
# 822 "/usr/include/pthread.h" 3 4
extern int pthread_mutexattr_init (pthread_mutexattr_t *__attr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_destroy (pthread_mutexattr_t *__attr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_getpshared (const pthread_mutexattr_t *
      __restrict __attr,
      int *__restrict __pshared)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_mutexattr_setpshared (pthread_mutexattr_t *__attr,
      int __pshared)
     noexcept (true) __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_gettype (const pthread_mutexattr_t *__restrict
          __attr, int *__restrict __kind)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));




extern int pthread_mutexattr_settype (pthread_mutexattr_t *__attr, int __kind)
     noexcept (true) __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_getprotocol (const pthread_mutexattr_t *
       __restrict __attr,
       int *__restrict __protocol)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutexattr_setprotocol (pthread_mutexattr_t *__attr,
       int __protocol)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_getprioceiling (const pthread_mutexattr_t *
          __restrict __attr,
          int *__restrict __prioceiling)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_mutexattr_setprioceiling (pthread_mutexattr_t *__attr,
          int __prioceiling)
     noexcept (true) __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_getrobust (const pthread_mutexattr_t *__attr,
     int *__robustness)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));

extern int pthread_mutexattr_getrobust_np (const pthread_mutexattr_t *__attr,
        int *__robustness)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutexattr_setrobust (pthread_mutexattr_t *__attr,
     int __robustness)
     noexcept (true) __attribute__ ((__nonnull__ (1)));

extern int pthread_mutexattr_setrobust_np (pthread_mutexattr_t *__attr,
        int __robustness)
     noexcept (true) __attribute__ ((__nonnull__ (1)));
# 904 "/usr/include/pthread.h" 3 4
extern int pthread_rwlock_init (pthread_rwlock_t *__restrict __rwlock,
    const pthread_rwlockattr_t *__restrict
    __attr) noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_destroy (pthread_rwlock_t *__rwlock)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_rdlock (pthread_rwlock_t *__rwlock)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_tryrdlock (pthread_rwlock_t *__rwlock)
  noexcept (true) __attribute__ ((__nonnull__ (1)));



extern int pthread_rwlock_timedrdlock (pthread_rwlock_t *__restrict __rwlock,
           const struct timespec *__restrict
           __abstime) noexcept (true) __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_rwlock_clockrdlock (pthread_rwlock_t *__restrict __rwlock,
           clockid_t __clockid,
           const struct timespec *__restrict
           __abstime) noexcept (true) __attribute__ ((__nonnull__ (1, 3)));



extern int pthread_rwlock_wrlock (pthread_rwlock_t *__rwlock)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_trywrlock (pthread_rwlock_t *__rwlock)
     noexcept (true) __attribute__ ((__nonnull__ (1)));



extern int pthread_rwlock_timedwrlock (pthread_rwlock_t *__restrict __rwlock,
           const struct timespec *__restrict
           __abstime) noexcept (true) __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_rwlock_clockwrlock (pthread_rwlock_t *__restrict __rwlock,
           clockid_t __clockid,
           const struct timespec *__restrict
           __abstime) noexcept (true) __attribute__ ((__nonnull__ (1, 3)));



extern int pthread_rwlock_unlock (pthread_rwlock_t *__rwlock)
     noexcept (true) __attribute__ ((__nonnull__ (1)));





extern int pthread_rwlockattr_init (pthread_rwlockattr_t *__attr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_destroy (pthread_rwlockattr_t *__attr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_getpshared (const pthread_rwlockattr_t *
       __restrict __attr,
       int *__restrict __pshared)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_rwlockattr_setpshared (pthread_rwlockattr_t *__attr,
       int __pshared)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_getkind_np (const pthread_rwlockattr_t *
       __restrict __attr,
       int *__restrict __pref)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_rwlockattr_setkind_np (pthread_rwlockattr_t *__attr,
       int __pref) noexcept (true) __attribute__ ((__nonnull__ (1)));







extern int pthread_cond_init (pthread_cond_t *__restrict __cond,
         const pthread_condattr_t *__restrict __cond_attr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_destroy (pthread_cond_t *__cond)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_signal (pthread_cond_t *__cond)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_broadcast (pthread_cond_t *__cond)
     noexcept (true) __attribute__ ((__nonnull__ (1)));






extern int pthread_cond_wait (pthread_cond_t *__restrict __cond,
         pthread_mutex_t *__restrict __mutex)
     __attribute__ ((__nonnull__ (1, 2)));
# 1030 "/usr/include/pthread.h" 3 4
extern int pthread_cond_timedwait (pthread_cond_t *__restrict __cond,
       pthread_mutex_t *__restrict __mutex,
       const struct timespec *__restrict __abstime)
     __attribute__ ((__nonnull__ (1, 2, 3)));
# 1043 "/usr/include/pthread.h" 3 4
extern int pthread_cond_clockwait (pthread_cond_t *__restrict __cond,
       pthread_mutex_t *__restrict __mutex,
       __clockid_t __clock_id,
       const struct timespec *__restrict __abstime)
     __attribute__ ((__nonnull__ (1, 2, 4)));





extern int pthread_condattr_init (pthread_condattr_t *__attr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_condattr_destroy (pthread_condattr_t *__attr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_condattr_getpshared (const pthread_condattr_t *
     __restrict __attr,
     int *__restrict __pshared)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_condattr_setpshared (pthread_condattr_t *__attr,
     int __pshared) noexcept (true) __attribute__ ((__nonnull__ (1)));



extern int pthread_condattr_getclock (const pthread_condattr_t *
          __restrict __attr,
          __clockid_t *__restrict __clock_id)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_condattr_setclock (pthread_condattr_t *__attr,
          __clockid_t __clock_id)
     noexcept (true) __attribute__ ((__nonnull__ (1)));
# 1089 "/usr/include/pthread.h" 3 4
extern int pthread_spin_init (pthread_spinlock_t *__lock, int __pshared)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_destroy (pthread_spinlock_t *__lock)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_lock (pthread_spinlock_t *__lock)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_trylock (pthread_spinlock_t *__lock)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_unlock (pthread_spinlock_t *__lock)
     noexcept (true) __attribute__ ((__nonnull__ (1)));






extern int pthread_barrier_init (pthread_barrier_t *__restrict __barrier,
     const pthread_barrierattr_t *__restrict
     __attr, unsigned int __count)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_barrier_destroy (pthread_barrier_t *__barrier)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_barrier_wait (pthread_barrier_t *__barrier)
     noexcept (true) __attribute__ ((__nonnull__ (1)));



extern int pthread_barrierattr_init (pthread_barrierattr_t *__attr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_barrierattr_destroy (pthread_barrierattr_t *__attr)
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_barrierattr_getpshared (const pthread_barrierattr_t *
        __restrict __attr,
        int *__restrict __pshared)
     noexcept (true) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_barrierattr_setpshared (pthread_barrierattr_t *__attr,
        int __pshared)
     noexcept (true) __attribute__ ((__nonnull__ (1)));
# 1156 "/usr/include/pthread.h" 3 4
extern int pthread_key_create (pthread_key_t *__key,
          void (*__destr_function) (void *))
     noexcept (true) __attribute__ ((__nonnull__ (1)));


extern int pthread_key_delete (pthread_key_t __key) noexcept (true);


extern void *pthread_getspecific (pthread_key_t __key) noexcept (true);


extern int pthread_setspecific (pthread_key_t __key,
    const void *__pointer) noexcept (true) ;




extern int pthread_getcpuclockid (pthread_t __thread_id,
      __clockid_t *__clock_id)
     noexcept (true) __attribute__ ((__nonnull__ (2)));
# 1190 "/usr/include/pthread.h" 3 4
extern int pthread_atfork (void (*__prepare) (void),
      void (*__parent) (void),
      void (*__child) (void)) noexcept (true);
# 1204 "/usr/include/pthread.h" 3 4
}
# 36 "/usr/include/c++/10.2.0/x86_64-pc-linux-gnu/bits/gthr-default.h" 2 3
# 47 "/usr/include/c++/10.2.0/x86_64-pc-linux-gnu/bits/gthr-default.h" 3
typedef pthread_t __gthread_t;
typedef pthread_key_t __gthread_key_t;
typedef pthread_once_t __gthread_once_t;
typedef pthread_mutex_t __gthread_mutex_t;
typedef pthread_mutex_t __gthread_recursive_mutex_t;
typedef pthread_cond_t __gthread_cond_t;
typedef struct timespec __gthread_time_t;
# 102 "/usr/include/c++/10.2.0/x86_64-pc-linux-gnu/bits/gthr-default.h" 3
static __typeof(pthread_once) __gthrw_pthread_once __attribute__ ((__weakref__("pthread_once"), __copy__ (pthread_once)));
static __typeof(pthread_getspecific) __gthrw_pthread_getspecific __attribute__ ((__weakref__("pthread_getspecific"), __copy__ (pthread_getspecific)));
static __typeof(pthread_setspecific) __gthrw_pthread_setspecific __attribute__ ((__weakref__("pthread_setspecific"), __copy__ (pthread_setspecific)));

static __typeof(pthread_create) __gthrw_pthread_create __attribute__ ((__weakref__("pthread_create"), __copy__ (pthread_create)));
static __typeof(pthread_join) __gthrw_pthread_join __attribute__ ((__weakref__("pthread_join"), __copy__ (pthread_join)));
static __typeof(pthread_equal) __gthrw_pthread_equal __attribute__ ((__weakref__("pthread_equal"), __copy__ (pthread_equal)));
static __typeof(pthread_self) __gthrw_pthread_self __attribute__ ((__weakref__("pthread_self"), __copy__ (pthread_self)));
static __typeof(pthread_detach) __gthrw_pthread_detach __attribute__ ((__weakref__("pthread_detach"), __copy__ (pthread_detach)));

static __typeof(pthread_cancel) __gthrw_pthread_cancel __attribute__ ((__weakref__("pthread_cancel"), __copy__ (pthread_cancel)));

static __typeof(sched_yield) __gthrw_sched_yield __attribute__ ((__weakref__("sched_yield"), __copy__ (sched_yield)));

static __typeof(pthread_mutex_lock) __gthrw_pthread_mutex_lock __attribute__ ((__weakref__("pthread_mutex_lock"), __copy__ (pthread_mutex_lock)));
static __typeof(pthread_mutex_trylock) __gthrw_pthread_mutex_trylock __attribute__ ((__weakref__("pthread_mutex_trylock"), __copy__ (pthread_mutex_trylock)));

static __typeof(pthread_mutex_timedlock) __gthrw_pthread_mutex_timedlock __attribute__ ((__weakref__("pthread_mutex_timedlock"), __copy__ (pthread_mutex_timedlock)));

static __typeof(pthread_mutex_unlock) __gthrw_pthread_mutex_unlock __attribute__ ((__weakref__("pthread_mutex_unlock"), __copy__ (pthread_mutex_unlock)));
static __typeof(pthread_mutex_init) __gthrw_pthread_mutex_init __attribute__ ((__weakref__("pthread_mutex_init"), __copy__ (pthread_mutex_init)));
static __typeof(pthread_mutex_destroy) __gthrw_pthread_mutex_destroy __attribute__ ((__weakref__("pthread_mutex_destroy"), __copy__ (pthread_mutex_destroy)));

static __typeof(pthread_cond_init) __gthrw_pthread_cond_init __attribute__ ((__weakref__("pthread_cond_init"), __copy__ (pthread_cond_init)));
static __typeof(pthread_cond_broadcast) __gthrw_pthread_cond_broadcast __attribute__ ((__weakref__("pthread_cond_broadcast"), __copy__ (pthread_cond_broadcast)));
static __typeof(pthread_cond_signal) __gthrw_pthread_cond_signal __attribute__ ((__weakref__("pthread_cond_signal"), __copy__ (pthread_cond_signal)));
static __typeof(pthread_cond_wait) __gthrw_pthread_cond_wait __attribute__ ((__weakref__("pthread_cond_wait"), __copy__ (pthread_cond_wait)));
static __typeof(pthread_cond_timedwait) __gthrw_pthread_cond_timedwait __attribute__ ((__weakref__("pthread_cond_timedwait"), __copy__ (pthread_cond_timedwait)));
static __typeof(pthread_cond_destroy) __gthrw_pthread_cond_destroy __attribute__ ((__weakref__("pthread_cond_destroy"), __copy__ (pthread_cond_destroy)));

static __typeof(pthread_key_create) __gthrw_pthread_key_create __attribute__ ((__weakref__("pthread_key_create"), __copy__ (pthread_key_create)));
static __typeof(pthread_key_delete) __gthrw_pthread_key_delete __attribute__ ((__weakref__("pthread_key_delete"), __copy__ (pthread_key_delete)));
static __typeof(pthread_mutexattr_init) __gthrw_pthread_mutexattr_init __attribute__ ((__weakref__("pthread_mutexattr_init"), __copy__ (pthread_mutexattr_init)));
static __typeof(pthread_mutexattr_settype) __gthrw_pthread_mutexattr_settype __attribute__ ((__weakref__("pthread_mutexattr_settype"), __copy__ (pthread_mutexattr_settype)));
static __typeof(pthread_mutexattr_destroy) __gthrw_pthread_mutexattr_destroy __attribute__ ((__weakref__("pthread_mutexattr_destroy"), __copy__ (pthread_mutexattr_destroy)));
# 237 "/usr/include/c++/10.2.0/x86_64-pc-linux-gnu/bits/gthr-default.h" 3
static __typeof(pthread_key_create) __gthrw___pthread_key_create __attribute__ ((__weakref__("__pthread_key_create"), __copy__ (pthread_key_create)));
# 247 "/usr/include/c++/10.2.0/x86_64-pc-linux-gnu/bits/gthr-default.h" 3
static inline int
__gthread_active_p (void)
{
  static void *const __gthread_active_ptr
    = __extension__ (void *) &__gthrw___pthread_key_create;
  return __gthread_active_ptr != 0;
}
# 659 "/usr/include/c++/10.2.0/x86_64-pc-linux-gnu/bits/gthr-default.h" 3
static inline int
__gthread_create (__gthread_t *__threadid, void *(*__func) (void*),
    void *__args)
{
  return __gthrw_pthread_create (__threadid, __null, __func, __args);
}

static inline int
__gthread_join (__gthread_t __threadid, void **__value_ptr)
{
  return __gthrw_pthread_join (__threadid, __value_ptr);
}

static inline int
__gthread_detach (__gthread_t __threadid)
{
  return __gthrw_pthread_detach (__threadid);
}

static inline int
__gthread_equal (__gthread_t __t1, __gthread_t __t2)
{
  return __gthrw_pthread_equal (__t1, __t2);
}

static inline __gthread_t
__gthread_self (void)
{
  return __gthrw_pthread_self ();
}

static inline int
__gthread_yield (void)
{
  return __gthrw_sched_yield ();
}

static inline int
__gthread_once (__gthread_once_t *__once, void (*__func) (void))
{
  if (__gthread_active_p ())
    return __gthrw_pthread_once (__once, __func);
  else
    return -1;
}

static inline int
__gthread_key_create (__gthread_key_t *__key, void (*__dtor) (void *))
{
  return __gthrw_pthread_key_create (__key, __dtor);
}

static inline int
__gthread_key_delete (__gthread_key_t __key)
{
  return __gthrw_pthread_key_delete (__key);
}

static inline void *
__gthread_getspecific (__gthread_key_t __key)
{
  return __gthrw_pthread_getspecific (__key);
}

static inline int
__gthread_setspecific (__gthread_key_t __key, const void *__ptr)
{
  return __gthrw_pthread_setspecific (__key, __ptr);
}

static inline void
__gthread_mutex_init_function (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    __gthrw_pthread_mutex_init (__mutex, __null);
}

static inline int
__gthread_mutex_destroy (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_destroy (__mutex);
  else
    return 0;
}

static inline int
__gthread_mutex_lock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_lock (__mutex);
  else
    return 0;
}

static inline int
__gthread_mutex_trylock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_trylock (__mutex);
  else
    return 0;
}


static inline int
__gthread_mutex_timedlock (__gthread_mutex_t *__mutex,
      const __gthread_time_t *__abs_timeout)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_timedlock (__mutex, __abs_timeout);
  else
    return 0;
}


static inline int
__gthread_mutex_unlock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_unlock (__mutex);
  else
    return 0;
}
# 808 "/usr/include/c++/10.2.0/x86_64-pc-linux-gnu/bits/gthr-default.h" 3
static inline int
__gthread_recursive_mutex_lock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_lock (__mutex);
}

static inline int
__gthread_recursive_mutex_trylock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_trylock (__mutex);
}


static inline int
__gthread_recursive_mutex_timedlock (__gthread_recursive_mutex_t *__mutex,
         const __gthread_time_t *__abs_timeout)
{
  return __gthread_mutex_timedlock (__mutex, __abs_timeout);
}


static inline int
__gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_unlock (__mutex);
}

static inline int
__gthread_recursive_mutex_destroy (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_destroy (__mutex);
}
# 850 "/usr/include/c++/10.2.0/x86_64-pc-linux-gnu/bits/gthr-default.h" 3
static inline int
__gthread_cond_broadcast (__gthread_cond_t *__cond)
{
  return __gthrw_pthread_cond_broadcast (__cond);
}

static inline int
__gthread_cond_signal (__gthread_cond_t *__cond)
{
  return __gthrw_pthread_cond_signal (__cond);
}

static inline int
__gthread_cond_wait (__gthread_cond_t *__cond, __gthread_mutex_t *__mutex)
{
  return __gthrw_pthread_cond_wait (__cond, __mutex);
}

static inline int
__gthread_cond_timedwait (__gthread_cond_t *__cond, __gthread_mutex_t *__mutex,
     const __gthread_time_t *__abs_timeout)
{
  return __gthrw_pthread_cond_timedwait (__cond, __mutex, __abs_timeout);
}

static inline int
__gthread_cond_wait_recursive (__gthread_cond_t *__cond,
          __gthread_recursive_mutex_t *__mutex)
{
  return __gthread_cond_wait (__cond, __mutex);
}

static inline int
__gthread_cond_destroy (__gthread_cond_t* __cond)
{
  return __gthrw_pthread_cond_destroy (__cond);
}
# 149 "/usr/include/c++/10.2.0/x86_64-pc-linux-gnu/bits/gthr.h" 2 3


#pragma GCC visibility pop
# 36 "/usr/include/c++/10.2.0/ext/atomicity.h" 2 3
# 1 "/usr/include/c++/10.2.0/x86_64-pc-linux-gnu/bits/atomic_word.h" 1 3
# 32 "/usr/include/c++/10.2.0/x86_64-pc-linux-gnu/bits/atomic_word.h" 3
typedef int _Atomic_word;
# 37 "/usr/include/c++/10.2.0/ext/atomicity.h" 2 3

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{







  inline _Atomic_word
  __attribute__((__always_inline__))
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, 4); }

  inline void
  __attribute__((__always_inline__))
  __atomic_add(volatile _Atomic_word* __mem, int __val)
  { __atomic_fetch_add(__mem, __val, 4); }
# 64 "/usr/include/c++/10.2.0/ext/atomicity.h" 3
  inline _Atomic_word
  __attribute__((__always_inline__))
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
    *__mem += __val;
    return __result;
  }

  inline void
  __attribute__((__always_inline__))
  __atomic_add_single(_Atomic_word* __mem, int __val)
  { *__mem += __val; }

  inline _Atomic_word
  __attribute__ ((__always_inline__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {

    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);

    return __exchange_and_add_single(__mem, __val);
  }

  inline void
  __attribute__ ((__always_inline__))
  __atomic_add_dispatch(_Atomic_word* __mem, int __val)
  {

    if (__gthread_active_p())
      {
 __atomic_add(__mem, __val);
 return;
      }

    __atomic_add_single(__mem, __val);
  }


}
# 40 "/usr/include/c++/10.2.0/bits/ios_base.h" 2 3

# 1 "/usr/include/c++/10.2.0/bits/locale_classes.h" 1 3
# 37 "/usr/include/c++/10.2.0/bits/locale_classes.h" 3
       
# 38 "/usr/include/c++/10.2.0/bits/locale_classes.h" 3


# 1 "/usr/include/c++/10.2.0/string" 1 3
# 36 "/usr/include/c++/10.2.0/string" 3
       
# 37 "/usr/include/c++/10.2.0/string" 3




# 1 "/usr/include/c++/10.2.0/bits/allocator.h" 1 3
# 46 "/usr/include/c++/10.2.0/bits/allocator.h" 3
# 1 "/usr/include/c++/10.2.0/x86_64-pc-linux-gnu/bits/c++allocator.h" 1 3
# 33 "/usr/include/c++/10.2.0/x86_64-pc-linux-gnu/bits/c++allocator.h" 3
# 1 "/usr/include/c++/10.2.0/ext/new_allocator.h" 1 3
# 40 "/usr/include/c++/10.2.0/ext/new_allocator.h" 3
namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{

# 54 "/usr/include/c++/10.2.0/ext/new_allocator.h" 3
  template<typename _Tp>
    class new_allocator
    {
    public:
      typedef _Tp value_type;
      typedef std::size_t size_type;
      typedef std::ptrdiff_t difference_type;

      typedef _Tp* pointer;
      typedef const _Tp* const_pointer;
      typedef _Tp& reference;
      typedef const _Tp& const_reference;

      template<typename _Tp1>
 struct rebind
 { typedef new_allocator<_Tp1> other; };





      typedef std::true_type propagate_on_container_move_assignment;


     
      new_allocator() noexcept { }

     
      new_allocator(const new_allocator&) noexcept { }

      template<typename _Tp1>

 new_allocator(const new_allocator<_Tp1>&) noexcept { }


      ~new_allocator() noexcept { }

      pointer
      address(reference __x) const noexcept
      { return std::__addressof(__x); }

      const_pointer
      address(const_reference __x) const noexcept
      { return std::__addressof(__x); }




      _Tp*
      allocate(size_type __n, const void* = static_cast<const void*>(0))
      {
 if (__n > this->_M_max_size())
   std::__throw_bad_alloc();
# 115 "/usr/include/c++/10.2.0/ext/new_allocator.h" 3
 return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
      }


      void
      deallocate(_Tp* __p, size_type __t)
      {
# 133 "/usr/include/c++/10.2.0/ext/new_allocator.h" 3
 ::operator delete(__p

     , __t * sizeof(_Tp)

    );
      }


      size_type
      max_size() const noexcept
      { return _M_max_size(); }


      template<typename _Up, typename... _Args>
 void
 construct(_Up* __p, _Args&&... __args)
 noexcept(std::is_nothrow_constructible<_Up, _Args...>::value)
 { ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }

      template<typename _Up>
 void
 destroy(_Up* __p)
 noexcept(std::is_nothrow_destructible<_Up>::value)
 { __p->~_Up(); }
# 169 "/usr/include/c++/10.2.0/ext/new_allocator.h" 3
      template<typename _Up>
 friend bool
 operator==(const new_allocator&, const new_allocator<_Up>&)
 noexcept
 { return true; }


      template<typename _Up>
 friend bool
 operator!=(const new_allocator&, const new_allocator<_Up>&)
 noexcept
 { return false; }


    private:
      constexpr size_type
      _M_max_size() const noexcept
      {

 return std::size_t(0x7fffffffffffffffL) / sizeof(_Tp);



      }
    };


}
# 34 "/usr/include/c++/10.2.0/x86_64-pc-linux-gnu/bits/c++allocator.h" 2 3


namespace std
{
# 47 "/usr/include/c++/10.2.0/x86_64-pc-linux-gnu/bits/c++allocator.h" 3
  template<typename _Tp>
    using __allocator_base = __gnu_cxx::new_allocator<_Tp>;
}
# 47 "/usr/include/c++/10.2.0/bits/allocator.h" 2 3







namespace std __attribute__ ((__visibility__ ("default")))
{








  template<>
    class allocator<void>
    {
    public:
      typedef void value_type;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;

      typedef void* pointer;
      typedef const void* const_pointer;

      template<typename _Tp1>
 struct rebind
 { typedef allocator<_Tp1> other; };
# 89 "/usr/include/c++/10.2.0/bits/allocator.h" 3
      typedef true_type propagate_on_container_move_assignment;

      typedef true_type is_always_equal;

      template<typename _Up, typename... _Args>
 void
 construct(_Up* __p, _Args&&... __args)
 noexcept(std::is_nothrow_constructible<_Up, _Args...>::value)
 { ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }

      template<typename _Up>
 void
 destroy(_Up* __p)
 noexcept(std::is_nothrow_destructible<_Up>::value)
 { __p->~_Up(); }

    };
# 115 "/usr/include/c++/10.2.0/bits/allocator.h" 3
  template<typename _Tp>
    class allocator : public __allocator_base<_Tp>
    {
    public:
      typedef _Tp value_type;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;

      typedef _Tp* pointer;
      typedef const _Tp* const_pointer;
      typedef _Tp& reference;
      typedef const _Tp& const_reference;

      template<typename _Tp1>
 struct rebind
 { typedef allocator<_Tp1> other; };





      typedef true_type propagate_on_container_move_assignment;

      typedef true_type is_always_equal;




     
      allocator() noexcept { }

     
      allocator(const allocator& __a) noexcept
      : __allocator_base<_Tp>(__a) { }



      allocator& operator=(const allocator&) = default;


      template<typename _Tp1>

 allocator(const allocator<_Tp1>&) noexcept { }




      ~allocator() noexcept { }
# 191 "/usr/include/c++/10.2.0/bits/allocator.h" 3
      friend bool
      operator==(const allocator&, const allocator&) noexcept
      { return true; }


      friend bool
      operator!=(const allocator&, const allocator&) noexcept
      { return false; }



    };

  template<typename _T1, typename _T2>
    inline bool
    operator==(const allocator<_T1>&, const allocator<_T2>&)
    noexcept
    { return true; }


  template<typename _T1, typename _T2>
    inline bool
    operator!=(const allocator<_T1>&, const allocator<_T2>&)
    noexcept
    { return false; }




  template<typename _Tp>
    class allocator<const _Tp>
    {
    public:
      typedef _Tp value_type;
      template<typename _Up> allocator(const allocator<_Up>&) { }
    };

  template<typename _Tp>
    class allocator<volatile _Tp>
    {
    public:
      typedef _Tp value_type;
      template<typename _Up> allocator(const allocator<_Up>&) { }
    };

  template<typename _Tp>
    class allocator<const volatile _Tp>
    {
    public:
      typedef _Tp value_type;
      template<typename _Up> allocator(const allocator<_Up>&) { }
    };






  extern template class allocator<char>;
  extern template class allocator<wchar_t>;






  template<typename _Alloc, bool = __is_empty(_Alloc)>
    struct __alloc_swap
    { static void _S_do_it(_Alloc&, _Alloc&) noexcept { } };

  template<typename _Alloc>
    struct __alloc_swap<_Alloc, false>
    {
      static void
      _S_do_it(_Alloc& __one, _Alloc& __two) noexcept
      {

 if (__one != __two)
   swap(__one, __two);
      }
    };


  template<typename _Alloc, bool = __is_empty(_Alloc)>
    struct __alloc_neq
    {
      static bool
      _S_do_it(const _Alloc&, const _Alloc&)
      { return false; }
    };

  template<typename _Alloc>
    struct __alloc_neq<_Alloc, false>
    {
      static bool
      _S_do_it(const _Alloc& __one, const _Alloc& __two)
      { return __one != __two; }
    };


  template<typename _Tp, bool
    = __or_<is_copy_constructible<typename _Tp::value_type>,
            is_nothrow_move_constructible<typename _Tp::value_type>>::value>
    struct __shrink_to_fit_aux
    { static bool _S_do_it(_Tp&) noexcept { return false; } };

  template<typename _Tp>
    struct __shrink_to_fit_aux<_Tp, true>
    {
      static bool
      _S_do_it(_Tp& __c) noexcept
      {

 try
   {
     _Tp(__make_move_if_noexcept_iterator(__c.begin()),
  __make_move_if_noexcept_iterator(__c.end()),
  __c.get_allocator()).swap(__c);
     return true;
   }
 catch(...)
   { return false; }



      }
    };



}
# 42 "/usr/include/c++/10.2.0/string" 2 3


# 1 "/usr/include/c++/10.2.0/bits/ostream_insert.h" 1 3
# 33 "/usr/include/c++/10.2.0/bits/ostream_insert.h" 3
       
# 34 "/usr/include/c++/10.2.0/bits/ostream_insert.h" 3


# 1 "/usr/include/c++/10.2.0/bits/cxxabi_forced.h" 1 3
# 34 "/usr/include/c++/10.2.0/bits/cxxabi_forced.h" 3
       
# 35 "/usr/include/c++/10.2.0/bits/cxxabi_forced.h" 3

#pragma GCC visibility push(default)


namespace __cxxabiv1
{







  class __forced_unwind
  {
    virtual ~__forced_unwind() throw();


    virtual void __pure_dummy() = 0;
  };
}


#pragma GCC visibility pop
# 37 "/usr/include/c++/10.2.0/bits/ostream_insert.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    inline void
    __ostream_write(basic_ostream<_CharT, _Traits>& __out,
      const _CharT* __s, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const streamsize __put = __out.rdbuf()->sputn(__s, __n);
      if (__put != __n)
 __out.setstate(__ios_base::badbit);
    }

  template<typename _CharT, typename _Traits>
    inline void
    __ostream_fill(basic_ostream<_CharT, _Traits>& __out, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const _CharT __c = __out.fill();
      for (; __n > 0; --__n)
 {
   const typename _Traits::int_type __put = __out.rdbuf()->sputc(__c);
   if (_Traits::eq_int_type(__put, _Traits::eof()))
     {
       __out.setstate(__ios_base::badbit);
       break;
     }
 }
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    __ostream_insert(basic_ostream<_CharT, _Traits>& __out,
       const _CharT* __s, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      typename __ostream_type::sentry __cerb(__out);
      if (__cerb)
 {
   try
     {
       const streamsize __w = __out.width();
       if (__w > __n)
  {
    const bool __left = ((__out.flags()
     & __ios_base::adjustfield)
           == __ios_base::left);
    if (!__left)
      __ostream_fill(__out, __w - __n);
    if (__out.good())
      __ostream_write(__out, __s, __n);
    if (__left && __out.good())
      __ostream_fill(__out, __w - __n);
  }
       else
  __ostream_write(__out, __s, __n);
       __out.width(0);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __out._M_setstate(__ios_base::badbit);
       throw;
     }
   catch(...)
     { __out._M_setstate(__ios_base::badbit); }
 }
      return __out;
    }




  extern template ostream& __ostream_insert(ostream&, const char*, streamsize);


  extern template wostream& __ostream_insert(wostream&, const wchar_t*,
          streamsize);




}
# 45 "/usr/include/c++/10.2.0/string" 2 3



# 1 "/usr/include/c++/10.2.0/bits/stl_function.h" 1 3
# 63 "/usr/include/c++/10.2.0/bits/stl_function.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 104 "/usr/include/c++/10.2.0/bits/stl_function.h" 3
  template<typename _Arg, typename _Result>
    struct unary_function
    {

      typedef _Arg argument_type;


      typedef _Result result_type;
    };




  template<typename _Arg1, typename _Arg2, typename _Result>
    struct binary_function
    {

      typedef _Arg1 first_argument_type;


      typedef _Arg2 second_argument_type;


      typedef _Result result_type;
    };
# 144 "/usr/include/c++/10.2.0/bits/stl_function.h" 3
  struct __is_transparent;

  template<typename _Tp = void>
    struct plus;

  template<typename _Tp = void>
    struct minus;

  template<typename _Tp = void>
    struct multiplies;

  template<typename _Tp = void>
    struct divides;

  template<typename _Tp = void>
    struct modulus;

  template<typename _Tp = void>
    struct negate;



  template<typename _Tp>
    struct plus : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x + __y; }
    };


  template<typename _Tp>
    struct minus : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x - __y; }
    };


  template<typename _Tp>
    struct multiplies : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x * __y; }
    };


  template<typename _Tp>
    struct divides : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x / __y; }
    };


  template<typename _Tp>
    struct modulus : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x % __y; }
    };


  template<typename _Tp>
    struct negate : public unary_function<_Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x) const
      { return -__x; }
    };





  template<>
    struct plus<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) + std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) + std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) + std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct minus<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) - std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) - std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) - std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct multiplies<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) * std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) * std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) * std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct divides<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) / std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) / std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) / std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct modulus<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) % std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) % std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) % std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct negate<void>
    {
      template <typename _Tp>
 constexpr
 auto
 operator()(_Tp&& __t) const
 noexcept(noexcept(-std::forward<_Tp>(__t)))
 -> decltype(-std::forward<_Tp>(__t))
 { return -std::forward<_Tp>(__t); }

      typedef __is_transparent is_transparent;
    };
# 330 "/usr/include/c++/10.2.0/bits/stl_function.h" 3
  template<typename _Tp = void>
    struct equal_to;

  template<typename _Tp = void>
    struct not_equal_to;

  template<typename _Tp = void>
    struct greater;

  template<typename _Tp = void>
    struct less;

  template<typename _Tp = void>
    struct greater_equal;

  template<typename _Tp = void>
    struct less_equal;



  template<typename _Tp>
    struct equal_to : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x == __y; }
    };


  template<typename _Tp>
    struct not_equal_to : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x != __y; }
    };


  template<typename _Tp>
    struct greater : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x > __y; }
    };


  template<typename _Tp>
    struct less : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x < __y; }
    };


  template<typename _Tp>
    struct greater_equal : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x >= __y; }
    };


  template<typename _Tp>
    struct less_equal : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x <= __y; }
    };


  template<typename _Tp>
    struct greater<_Tp*> : public binary_function<_Tp*, _Tp*, bool>
    {
      constexpr bool
      operator()(_Tp* __x, _Tp* __y) const noexcept
      {


 if (__builtin_is_constant_evaluated())



   return __x > __y;

 return (long unsigned int)__x > (long unsigned int)__y;
      }
    };


  template<typename _Tp>
    struct less<_Tp*> : public binary_function<_Tp*, _Tp*, bool>
    {
      constexpr bool
      operator()(_Tp* __x, _Tp* __y) const noexcept
      {


 if (__builtin_is_constant_evaluated())



   return __x < __y;

 return (long unsigned int)__x < (long unsigned int)__y;
      }
    };


  template<typename _Tp>
    struct greater_equal<_Tp*> : public binary_function<_Tp*, _Tp*, bool>
    {
      constexpr bool
      operator()(_Tp* __x, _Tp* __y) const noexcept
      {


 if (__builtin_is_constant_evaluated())



   return __x >= __y;

 return (long unsigned int)__x >= (long unsigned int)__y;
      }
    };


  template<typename _Tp>
    struct less_equal<_Tp*> : public binary_function<_Tp*, _Tp*, bool>
    {
      constexpr bool
      operator()(_Tp* __x, _Tp* __y) const noexcept
      {


 if (__builtin_is_constant_evaluated())



   return __x <= __y;

 return (long unsigned int)__x <= (long unsigned int)__y;
      }
    };



  template<>
    struct equal_to<void>
    {
      template <typename _Tp, typename _Up>
 constexpr auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) == std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) == std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) == std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct not_equal_to<void>
    {
      template <typename _Tp, typename _Up>
 constexpr auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) != std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) != std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) != std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct greater<void>
    {
      template <typename _Tp, typename _Up>
 constexpr auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) > std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) > std::forward<_Up>(__u))
 {
   return _S_cmp(std::forward<_Tp>(__t), std::forward<_Up>(__u),
   __ptr_cmp<_Tp, _Up>{});
 }

      template<typename _Tp, typename _Up>
 constexpr bool
 operator()(_Tp* __t, _Up* __u) const noexcept
 { return greater<common_type_t<_Tp*, _Up*>>{}(__t, __u); }

      typedef __is_transparent is_transparent;

    private:
      template <typename _Tp, typename _Up>
 static constexpr decltype(auto)
 _S_cmp(_Tp&& __t, _Up&& __u, false_type)
 { return std::forward<_Tp>(__t) > std::forward<_Up>(__u); }

      template <typename _Tp, typename _Up>
 static constexpr bool
 _S_cmp(_Tp&& __t, _Up&& __u, true_type) noexcept
 {
   return greater<const volatile void*>{}(
       static_cast<const volatile void*>(std::forward<_Tp>(__t)),
       static_cast<const volatile void*>(std::forward<_Up>(__u)));
 }


      template<typename _Tp, typename _Up, typename = void>
 struct __not_overloaded2 : true_type { };


      template<typename _Tp, typename _Up>
 struct __not_overloaded2<_Tp, _Up, __void_t<
   decltype(std::declval<_Tp>().operator>(std::declval<_Up>()))>>
 : false_type { };


      template<typename _Tp, typename _Up, typename = void>
 struct __not_overloaded : __not_overloaded2<_Tp, _Up> { };


      template<typename _Tp, typename _Up>
 struct __not_overloaded<_Tp, _Up, __void_t<
   decltype(operator>(std::declval<_Tp>(), std::declval<_Up>()))>>
 : false_type { };

      template<typename _Tp, typename _Up>
 using __ptr_cmp = __and_<__not_overloaded<_Tp, _Up>,
       is_convertible<_Tp, const volatile void*>,
       is_convertible<_Up, const volatile void*>>;
    };


  template<>
    struct less<void>
    {
      template <typename _Tp, typename _Up>
 constexpr auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) < std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) < std::forward<_Up>(__u))
 {
   return _S_cmp(std::forward<_Tp>(__t), std::forward<_Up>(__u),
   __ptr_cmp<_Tp, _Up>{});
 }

      template<typename _Tp, typename _Up>
 constexpr bool
 operator()(_Tp* __t, _Up* __u) const noexcept
 { return less<common_type_t<_Tp*, _Up*>>{}(__t, __u); }

      typedef __is_transparent is_transparent;

    private:
      template <typename _Tp, typename _Up>
 static constexpr decltype(auto)
 _S_cmp(_Tp&& __t, _Up&& __u, false_type)
 { return std::forward<_Tp>(__t) < std::forward<_Up>(__u); }

      template <typename _Tp, typename _Up>
 static constexpr bool
 _S_cmp(_Tp&& __t, _Up&& __u, true_type) noexcept
 {
   return less<const volatile void*>{}(
       static_cast<const volatile void*>(std::forward<_Tp>(__t)),
       static_cast<const volatile void*>(std::forward<_Up>(__u)));
 }


      template<typename _Tp, typename _Up, typename = void>
 struct __not_overloaded2 : true_type { };


      template<typename _Tp, typename _Up>
 struct __not_overloaded2<_Tp, _Up, __void_t<
   decltype(std::declval<_Tp>().operator<(std::declval<_Up>()))>>
 : false_type { };


      template<typename _Tp, typename _Up, typename = void>
 struct __not_overloaded : __not_overloaded2<_Tp, _Up> { };


      template<typename _Tp, typename _Up>
 struct __not_overloaded<_Tp, _Up, __void_t<
   decltype(operator<(std::declval<_Tp>(), std::declval<_Up>()))>>
 : false_type { };

      template<typename _Tp, typename _Up>
 using __ptr_cmp = __and_<__not_overloaded<_Tp, _Up>,
       is_convertible<_Tp, const volatile void*>,
       is_convertible<_Up, const volatile void*>>;
    };


  template<>
    struct greater_equal<void>
    {
      template <typename _Tp, typename _Up>
 constexpr auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) >= std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) >= std::forward<_Up>(__u))
 {
   return _S_cmp(std::forward<_Tp>(__t), std::forward<_Up>(__u),
   __ptr_cmp<_Tp, _Up>{});
 }

      template<typename _Tp, typename _Up>
 constexpr bool
 operator()(_Tp* __t, _Up* __u) const noexcept
 { return greater_equal<common_type_t<_Tp*, _Up*>>{}(__t, __u); }

      typedef __is_transparent is_transparent;

    private:
      template <typename _Tp, typename _Up>
 static constexpr decltype(auto)
 _S_cmp(_Tp&& __t, _Up&& __u, false_type)
 { return std::forward<_Tp>(__t) >= std::forward<_Up>(__u); }

      template <typename _Tp, typename _Up>
 static constexpr bool
 _S_cmp(_Tp&& __t, _Up&& __u, true_type) noexcept
 {
   return greater_equal<const volatile void*>{}(
       static_cast<const volatile void*>(std::forward<_Tp>(__t)),
       static_cast<const volatile void*>(std::forward<_Up>(__u)));
 }


      template<typename _Tp, typename _Up, typename = void>
 struct __not_overloaded2 : true_type { };


      template<typename _Tp, typename _Up>
 struct __not_overloaded2<_Tp, _Up, __void_t<
   decltype(std::declval<_Tp>().operator>=(std::declval<_Up>()))>>
 : false_type { };


      template<typename _Tp, typename _Up, typename = void>
 struct __not_overloaded : __not_overloaded2<_Tp, _Up> { };


      template<typename _Tp, typename _Up>
 struct __not_overloaded<_Tp, _Up, __void_t<
   decltype(operator>=(std::declval<_Tp>(), std::declval<_Up>()))>>
 : false_type { };

      template<typename _Tp, typename _Up>
 using __ptr_cmp = __and_<__not_overloaded<_Tp, _Up>,
       is_convertible<_Tp, const volatile void*>,
       is_convertible<_Up, const volatile void*>>;
    };


  template<>
    struct less_equal<void>
    {
      template <typename _Tp, typename _Up>
 constexpr auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) <= std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) <= std::forward<_Up>(__u))
 {
   return _S_cmp(std::forward<_Tp>(__t), std::forward<_Up>(__u),
   __ptr_cmp<_Tp, _Up>{});
 }

      template<typename _Tp, typename _Up>
 constexpr bool
 operator()(_Tp* __t, _Up* __u) const noexcept
 { return less_equal<common_type_t<_Tp*, _Up*>>{}(__t, __u); }

      typedef __is_transparent is_transparent;

    private:
      template <typename _Tp, typename _Up>
 static constexpr decltype(auto)
 _S_cmp(_Tp&& __t, _Up&& __u, false_type)
 { return std::forward<_Tp>(__t) <= std::forward<_Up>(__u); }

      template <typename _Tp, typename _Up>
 static constexpr bool
 _S_cmp(_Tp&& __t, _Up&& __u, true_type) noexcept
 {
   return less_equal<const volatile void*>{}(
       static_cast<const volatile void*>(std::forward<_Tp>(__t)),
       static_cast<const volatile void*>(std::forward<_Up>(__u)));
 }


      template<typename _Tp, typename _Up, typename = void>
 struct __not_overloaded2 : true_type { };


      template<typename _Tp, typename _Up>
 struct __not_overloaded2<_Tp, _Up, __void_t<
   decltype(std::declval<_Tp>().operator<=(std::declval<_Up>()))>>
 : false_type { };


      template<typename _Tp, typename _Up, typename = void>
 struct __not_overloaded : __not_overloaded2<_Tp, _Up> { };


      template<typename _Tp, typename _Up>
 struct __not_overloaded<_Tp, _Up, __void_t<
   decltype(operator<=(std::declval<_Tp>(), std::declval<_Up>()))>>
 : false_type { };

      template<typename _Tp, typename _Up>
 using __ptr_cmp = __and_<__not_overloaded<_Tp, _Up>,
       is_convertible<_Tp, const volatile void*>,
       is_convertible<_Up, const volatile void*>>;
    };
# 774 "/usr/include/c++/10.2.0/bits/stl_function.h" 3
  template<typename _Tp = void>
    struct logical_and;

  template<typename _Tp = void>
    struct logical_or;

  template<typename _Tp = void>
    struct logical_not;



  template<typename _Tp>
    struct logical_and : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x && __y; }
    };


  template<typename _Tp>
    struct logical_or : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x || __y; }
    };


  template<typename _Tp>
    struct logical_not : public unary_function<_Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x) const
      { return !__x; }
    };



  template<>
    struct logical_and<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) && std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) && std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) && std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct logical_or<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) || std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) || std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) || std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct logical_not<void>
    {
      template <typename _Tp>
 constexpr
 auto
 operator()(_Tp&& __t) const
 noexcept(noexcept(!std::forward<_Tp>(__t)))
 -> decltype(!std::forward<_Tp>(__t))
 { return !std::forward<_Tp>(__t); }

      typedef __is_transparent is_transparent;
    };




  template<typename _Tp = void>
    struct bit_and;

  template<typename _Tp = void>
    struct bit_or;

  template<typename _Tp = void>
    struct bit_xor;

  template<typename _Tp = void>
    struct bit_not;




  template<typename _Tp>
    struct bit_and : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x & __y; }
    };

  template<typename _Tp>
    struct bit_or : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x | __y; }
    };

  template<typename _Tp>
    struct bit_xor : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x ^ __y; }
    };

  template<typename _Tp>
    struct bit_not : public unary_function<_Tp, _Tp>
    {
    constexpr
      _Tp
      operator()(const _Tp& __x) const
      { return ~__x; }
    };


  template <>
    struct bit_and<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) & std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) & std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) & std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };

  template <>
    struct bit_or<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) | std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) | std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) | std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };

  template <>
    struct bit_xor<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) ^ std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) ^ std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) ^ std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };

  template <>
    struct bit_not<void>
    {
      template <typename _Tp>
 constexpr
 auto
 operator()(_Tp&& __t) const
 noexcept(noexcept(~std::forward<_Tp>(__t)))
 -> decltype(~std::forward<_Tp>(__t))
 { return ~std::forward<_Tp>(__t); }

      typedef __is_transparent is_transparent;
    };
# 1002 "/usr/include/c++/10.2.0/bits/stl_function.h" 3
  template<typename _Predicate>
    class unary_negate
    : public unary_function<typename _Predicate::argument_type, bool>
    {
    protected:
      _Predicate _M_pred;

    public:
      constexpr
      explicit
      unary_negate(const _Predicate& __x) : _M_pred(__x) { }

      constexpr
      bool
      operator()(const typename _Predicate::argument_type& __x) const
      { return !_M_pred(__x); }
    };


  template<typename _Predicate>
    constexpr
    inline unary_negate<_Predicate>
    not1(const _Predicate& __pred)
    { return unary_negate<_Predicate>(__pred); }


  template<typename _Predicate>
    class binary_negate
    : public binary_function<typename _Predicate::first_argument_type,
        typename _Predicate::second_argument_type, bool>
    {
    protected:
      _Predicate _M_pred;

    public:
      constexpr
      explicit
      binary_negate(const _Predicate& __x) : _M_pred(__x) { }

      constexpr
      bool
      operator()(const typename _Predicate::first_argument_type& __x,
   const typename _Predicate::second_argument_type& __y) const
      { return !_M_pred(__x, __y); }
    };


  template<typename _Predicate>
    constexpr
    inline binary_negate<_Predicate>
    not2(const _Predicate& __pred)
    { return binary_negate<_Predicate>(__pred); }
# 1079 "/usr/include/c++/10.2.0/bits/stl_function.h" 3
  template<typename _Arg, typename _Result>
    class pointer_to_unary_function : public unary_function<_Arg, _Result>
    {
    protected:
      _Result (*_M_ptr)(_Arg);

    public:
      pointer_to_unary_function() { }

      explicit
      pointer_to_unary_function(_Result (*__x)(_Arg))
      : _M_ptr(__x) { }

      _Result
      operator()(_Arg __x) const
      { return _M_ptr(__x); }
    };


  template<typename _Arg, typename _Result>
    inline pointer_to_unary_function<_Arg, _Result>
    ptr_fun(_Result (*__x)(_Arg))
    { return pointer_to_unary_function<_Arg, _Result>(__x); }


  template<typename _Arg1, typename _Arg2, typename _Result>
    class pointer_to_binary_function
    : public binary_function<_Arg1, _Arg2, _Result>
    {
    protected:
      _Result (*_M_ptr)(_Arg1, _Arg2);

    public:
      pointer_to_binary_function() { }

      explicit
      pointer_to_binary_function(_Result (*__x)(_Arg1, _Arg2))
      : _M_ptr(__x) { }

      _Result
      operator()(_Arg1 __x, _Arg2 __y) const
      { return _M_ptr(__x, __y); }
    };


  template<typename _Arg1, typename _Arg2, typename _Result>
    inline pointer_to_binary_function<_Arg1, _Arg2, _Result>
    ptr_fun(_Result (*__x)(_Arg1, _Arg2))
    { return pointer_to_binary_function<_Arg1, _Arg2, _Result>(__x); }


  template<typename _Tp>
    struct _Identity
    : public unary_function<_Tp, _Tp>
    {
      _Tp&
      operator()(_Tp& __x) const
      { return __x; }

      const _Tp&
      operator()(const _Tp& __x) const
      { return __x; }
    };


  template<typename _Tp> struct _Identity<const _Tp> : _Identity<_Tp> { };

  template<typename _Pair>
    struct _Select1st
    : public unary_function<_Pair, typename _Pair::first_type>
    {
      typename _Pair::first_type&
      operator()(_Pair& __x) const
      { return __x.first; }

      const typename _Pair::first_type&
      operator()(const _Pair& __x) const
      { return __x.first; }


      template<typename _Pair2>
        typename _Pair2::first_type&
        operator()(_Pair2& __x) const
        { return __x.first; }

      template<typename _Pair2>
        const typename _Pair2::first_type&
        operator()(const _Pair2& __x) const
        { return __x.first; }

    };

  template<typename _Pair>
    struct _Select2nd
    : public unary_function<_Pair, typename _Pair::second_type>
    {
      typename _Pair::second_type&
      operator()(_Pair& __x) const
      { return __x.second; }

      const typename _Pair::second_type&
      operator()(const _Pair& __x) const
      { return __x.second; }
    };
# 1202 "/usr/include/c++/10.2.0/bits/stl_function.h" 3
  template<typename _Ret, typename _Tp>
    class mem_fun_t : public unary_function<_Tp*, _Ret>
    {
    public:
      explicit
      mem_fun_t(_Ret (_Tp::*__pf)())
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp* __p) const
      { return (__p->*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)();
    };



  template<typename _Ret, typename _Tp>
    class const_mem_fun_t : public unary_function<const _Tp*, _Ret>
    {
    public:
      explicit
      const_mem_fun_t(_Ret (_Tp::*__pf)() const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp* __p) const
      { return (__p->*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)() const;
    };



  template<typename _Ret, typename _Tp>
    class mem_fun_ref_t : public unary_function<_Tp, _Ret>
    {
    public:
      explicit
      mem_fun_ref_t(_Ret (_Tp::*__pf)())
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp& __r) const
      { return (__r.*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)();
  };



  template<typename _Ret, typename _Tp>
    class const_mem_fun_ref_t : public unary_function<_Tp, _Ret>
    {
    public:
      explicit
      const_mem_fun_ref_t(_Ret (_Tp::*__pf)() const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp& __r) const
      { return (__r.*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)() const;
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class mem_fun1_t : public binary_function<_Tp*, _Arg, _Ret>
    {
    public:
      explicit
      mem_fun1_t(_Ret (_Tp::*__pf)(_Arg))
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp* __p, _Arg __x) const
      { return (__p->*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg);
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class const_mem_fun1_t : public binary_function<const _Tp*, _Arg, _Ret>
    {
    public:
      explicit
      const_mem_fun1_t(_Ret (_Tp::*__pf)(_Arg) const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp* __p, _Arg __x) const
      { return (__p->*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg) const;
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
    {
    public:
      explicit
      mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg))
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp& __r, _Arg __x) const
      { return (__r.*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg);
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class const_mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
    {
    public:
      explicit
      const_mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg) const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp& __r, _Arg __x) const
      { return (__r.*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg) const;
    };



  template<typename _Ret, typename _Tp>
    inline mem_fun_t<_Ret, _Tp>
    mem_fun(_Ret (_Tp::*__f)())
    { return mem_fun_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline const_mem_fun_t<_Ret, _Tp>
    mem_fun(_Ret (_Tp::*__f)() const)
    { return const_mem_fun_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline mem_fun_ref_t<_Ret, _Tp>
    mem_fun_ref(_Ret (_Tp::*__f)())
    { return mem_fun_ref_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline const_mem_fun_ref_t<_Ret, _Tp>
    mem_fun_ref(_Ret (_Tp::*__f)() const)
    { return const_mem_fun_ref_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline mem_fun1_t<_Ret, _Tp, _Arg>
    mem_fun(_Ret (_Tp::*__f)(_Arg))
    { return mem_fun1_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline const_mem_fun1_t<_Ret, _Tp, _Arg>
    mem_fun(_Ret (_Tp::*__f)(_Arg) const)
    { return const_mem_fun1_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline mem_fun1_ref_t<_Ret, _Tp, _Arg>
    mem_fun_ref(_Ret (_Tp::*__f)(_Arg))
    { return mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline const_mem_fun1_ref_t<_Ret, _Tp, _Arg>
    mem_fun_ref(_Ret (_Tp::*__f)(_Arg) const)
    { return const_mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }




}


# 1 "/usr/include/c++/10.2.0/backward/binders.h" 1 3
# 60 "/usr/include/c++/10.2.0/backward/binders.h" 3
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

namespace std __attribute__ ((__visibility__ ("default")))
{

# 107 "/usr/include/c++/10.2.0/backward/binders.h" 3
  template<typename _Operation>
    class binder1st
    : public unary_function<typename _Operation::second_argument_type,
       typename _Operation::result_type>
    {
    protected:
      _Operation op;
      typename _Operation::first_argument_type value;

    public:
      binder1st(const _Operation& __x,
  const typename _Operation::first_argument_type& __y)
      : op(__x), value(__y) { }

      typename _Operation::result_type
      operator()(const typename _Operation::second_argument_type& __x) const
      { return op(value, __x); }



      typename _Operation::result_type
      operator()(typename _Operation::second_argument_type& __x) const
      { return op(value, __x); }
    } __attribute__ ((__deprecated__));


  template<typename _Operation, typename _Tp>
    inline binder1st<_Operation>
    bind1st(const _Operation& __fn, const _Tp& __x)
    {
      typedef typename _Operation::first_argument_type _Arg1_type;
      return binder1st<_Operation>(__fn, _Arg1_type(__x));
    }


  template<typename _Operation>
    class binder2nd
    : public unary_function<typename _Operation::first_argument_type,
       typename _Operation::result_type>
    {
    protected:
      _Operation op;
      typename _Operation::second_argument_type value;

    public:
      binder2nd(const _Operation& __x,
  const typename _Operation::second_argument_type& __y)
      : op(__x), value(__y) { }

      typename _Operation::result_type
      operator()(const typename _Operation::first_argument_type& __x) const
      { return op(__x, value); }



      typename _Operation::result_type
      operator()(typename _Operation::first_argument_type& __x) const
      { return op(__x, value); }
    } __attribute__ ((__deprecated__));


  template<typename _Operation, typename _Tp>
    inline binder2nd<_Operation>
    bind2nd(const _Operation& __fn, const _Tp& __x)
    {
      typedef typename _Operation::second_argument_type _Arg2_type;
      return binder2nd<_Operation>(__fn, _Arg2_type(__x));
    }



}

#pragma GCC diagnostic pop
# 1393 "/usr/include/c++/10.2.0/bits/stl_function.h" 2 3
# 49 "/usr/include/c++/10.2.0/string" 2 3





# 1 "/usr/include/c++/10.2.0/bits/range_access.h" 1 3
# 33 "/usr/include/c++/10.2.0/bits/range_access.h" 3
       
# 34 "/usr/include/c++/10.2.0/bits/range_access.h" 3


# 1 "/usr/include/c++/10.2.0/initializer_list" 1 3
# 33 "/usr/include/c++/10.2.0/initializer_list" 3
       
# 34 "/usr/include/c++/10.2.0/initializer_list" 3





#pragma GCC visibility push(default)



namespace std
{

  template<class _E>
    class initializer_list
    {
    public:
      typedef _E value_type;
      typedef const _E& reference;
      typedef const _E& const_reference;
      typedef size_t size_type;
      typedef const _E* iterator;
      typedef const _E* const_iterator;

    private:
      iterator _M_array;
      size_type _M_len;


      constexpr initializer_list(const_iterator __a, size_type __l)
      : _M_array(__a), _M_len(__l) { }

    public:
      constexpr initializer_list() noexcept
      : _M_array(0), _M_len(0) { }


      constexpr size_type
      size() const noexcept { return _M_len; }


      constexpr const_iterator
      begin() const noexcept { return _M_array; }


      constexpr const_iterator
      end() const noexcept { return begin() + size(); }
    };







  template<class _Tp>
    constexpr const _Tp*
    begin(initializer_list<_Tp> __ils) noexcept
    { return __ils.begin(); }







  template<class _Tp>
    constexpr const _Tp*
    end(initializer_list<_Tp> __ils) noexcept
    { return __ils.end(); }
}

#pragma GCC visibility pop
# 37 "/usr/include/c++/10.2.0/bits/range_access.h" 2 3
# 1 "/usr/include/c++/10.2.0/bits/iterator_concepts.h" 1 3
# 33 "/usr/include/c++/10.2.0/bits/iterator_concepts.h" 3
       
# 34 "/usr/include/c++/10.2.0/bits/iterator_concepts.h" 3

# 1 "/usr/include/c++/10.2.0/concepts" 1 3
# 36 "/usr/include/c++/10.2.0/bits/iterator_concepts.h" 2 3

# 1 "/usr/include/c++/10.2.0/bits/range_cmp.h" 1 3
# 38 "/usr/include/c++/10.2.0/bits/iterator_concepts.h" 2 3
# 38 "/usr/include/c++/10.2.0/bits/range_access.h" 2 3
# 1 "/usr/include/c++/10.2.0/bits/int_limits.h" 1 3
# 33 "/usr/include/c++/10.2.0/bits/int_limits.h" 3
       
# 34 "/usr/include/c++/10.2.0/bits/int_limits.h" 3




namespace std __attribute__ ((__visibility__ ("default")))
{

namespace __detail
{






  template<typename _Tp, bool = is_signed<_Tp>::value>
    struct __int_limits
    {
      static_assert(is_integral<_Tp>::value, "unsupported specialization");
      using _Up = typename make_unsigned<_Tp>::type;
      static constexpr int digits = sizeof(_Tp) * 8 - 1;
      static constexpr _Tp min() noexcept { return _Tp(_Up(1) << digits); }
      static constexpr _Tp max() noexcept { return _Tp(_Up(~_Up(0)) >> 1); }
    };


  template<typename _Tp>
    struct __int_limits<_Tp, false>
    {
      static_assert(is_integral<_Tp>::value, "unsupported specialization");
      static constexpr int digits = sizeof(_Tp) * 8;
      static constexpr _Tp min() noexcept { return 0; }
      static constexpr _Tp max() noexcept { return _Tp(-1); }
    };

  template<> struct __int_limits<bool>;
}

}
# 39 "/usr/include/c++/10.2.0/bits/range_access.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{







  template<typename _Container>
    inline auto
    begin(_Container& __cont) -> decltype(__cont.begin())
    { return __cont.begin(); }






  template<typename _Container>
    inline auto
    begin(const _Container& __cont) -> decltype(__cont.begin())
    { return __cont.begin(); }






  template<typename _Container>
    inline auto
    end(_Container& __cont) -> decltype(__cont.end())
    { return __cont.end(); }






  template<typename _Container>
    inline auto
    end(const _Container& __cont) -> decltype(__cont.end())
    { return __cont.end(); }





  template<typename _Tp, size_t _Nm>
    inline constexpr _Tp*
    begin(_Tp (&__arr)[_Nm])
    { return __arr; }






  template<typename _Tp, size_t _Nm>
    inline constexpr _Tp*
    end(_Tp (&__arr)[_Nm])
    { return __arr + _Nm; }



  template<typename _Tp> class valarray;

  template<typename _Tp> _Tp* begin(valarray<_Tp>&);
  template<typename _Tp> const _Tp* begin(const valarray<_Tp>&);
  template<typename _Tp> _Tp* end(valarray<_Tp>&);
  template<typename _Tp> const _Tp* end(const valarray<_Tp>&);






  template<typename _Container>
    inline constexpr auto
    cbegin(const _Container& __cont) noexcept(noexcept(std::begin(__cont)))
      -> decltype(std::begin(__cont))
    { return std::begin(__cont); }






  template<typename _Container>
    inline constexpr auto
    cend(const _Container& __cont) noexcept(noexcept(std::end(__cont)))
      -> decltype(std::end(__cont))
    { return std::end(__cont); }






  template<typename _Container>
    inline auto
    rbegin(_Container& __cont) -> decltype(__cont.rbegin())
    { return __cont.rbegin(); }






  template<typename _Container>
    inline auto
    rbegin(const _Container& __cont) -> decltype(__cont.rbegin())
    { return __cont.rbegin(); }






  template<typename _Container>
    inline auto
    rend(_Container& __cont) -> decltype(__cont.rend())
    { return __cont.rend(); }






  template<typename _Container>
    inline auto
    rend(const _Container& __cont) -> decltype(__cont.rend())
    { return __cont.rend(); }






  template<typename _Tp, size_t _Nm>
    inline reverse_iterator<_Tp*>
    rbegin(_Tp (&__arr)[_Nm])
    { return reverse_iterator<_Tp*>(__arr + _Nm); }






  template<typename _Tp, size_t _Nm>
    inline reverse_iterator<_Tp*>
    rend(_Tp (&__arr)[_Nm])
    { return reverse_iterator<_Tp*>(__arr); }






  template<typename _Tp>
    inline reverse_iterator<const _Tp*>
    rbegin(initializer_list<_Tp> __il)
    { return reverse_iterator<const _Tp*>(__il.end()); }






  template<typename _Tp>
    inline reverse_iterator<const _Tp*>
    rend(initializer_list<_Tp> __il)
    { return reverse_iterator<const _Tp*>(__il.begin()); }






  template<typename _Container>
    inline auto
    crbegin(const _Container& __cont) -> decltype(std::rbegin(__cont))
    { return std::rbegin(__cont); }






  template<typename _Container>
    inline auto
    crend(const _Container& __cont) -> decltype(std::rend(__cont))
    { return std::rend(__cont); }
# 1143 "/usr/include/c++/10.2.0/bits/range_access.h" 3

}
# 55 "/usr/include/c++/10.2.0/string" 2 3
# 1 "/usr/include/c++/10.2.0/bits/basic_string.h" 1 3
# 37 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
       
# 38 "/usr/include/c++/10.2.0/bits/basic_string.h" 3


# 1 "/usr/include/c++/10.2.0/ext/alloc_traits.h" 1 3
# 32 "/usr/include/c++/10.2.0/ext/alloc_traits.h" 3
       
# 33 "/usr/include/c++/10.2.0/ext/alloc_traits.h" 3

# 1 "/usr/include/c++/10.2.0/bits/alloc_traits.h" 1 3
# 33 "/usr/include/c++/10.2.0/bits/alloc_traits.h" 3
# 1 "/usr/include/c++/10.2.0/bits/stl_construct.h" 1 3
# 73 "/usr/include/c++/10.2.0/bits/stl_construct.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 106 "/usr/include/c++/10.2.0/bits/stl_construct.h" 3
  template<typename _Tp, typename... _Args>
    inline void
    _Construct(_Tp* __p, _Args&&... __args)
    { ::new(static_cast<void*>(__p)) _Tp(std::forward<_Args>(__args)...); }
# 121 "/usr/include/c++/10.2.0/bits/stl_construct.h" 3
  template<typename _T1>
    inline void
    _Construct_novalue(_T1* __p)
    { ::new(static_cast<void*>(__p)) _T1; }

  template<typename _ForwardIterator>
    void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last);




  template<typename _Tp>
    constexpr inline void
    _Destroy(_Tp* __pointer)
    {



      __pointer->~_Tp();

    }

  template<bool>
    struct _Destroy_aux
    {
      template<typename _ForwardIterator>
 static void
 __destroy(_ForwardIterator __first, _ForwardIterator __last)
 {
   for (; __first != __last; ++__first)
     std::_Destroy(std::__addressof(*__first));
 }
    };

  template<>
    struct _Destroy_aux<true>
    {
      template<typename _ForwardIterator>
        static void
        __destroy(_ForwardIterator, _ForwardIterator) { }
    };






  template<typename _ForwardIterator>
    inline void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
                       _Value_type;


      static_assert(is_destructible<_Value_type>::value,
      "value type is destructible");





      std::_Destroy_aux<__has_trivial_destructor(_Value_type)>::
 __destroy(__first, __last);
    }

  template<bool>
    struct _Destroy_n_aux
    {
      template<typename _ForwardIterator, typename _Size>
 static _ForwardIterator
 __destroy_n(_ForwardIterator __first, _Size __count)
 {
   for (; __count > 0; (void)++__first, --__count)
     std::_Destroy(std::__addressof(*__first));
   return __first;
 }
    };

  template<>
    struct _Destroy_n_aux<true>
    {
      template<typename _ForwardIterator, typename _Size>
        static _ForwardIterator
        __destroy_n(_ForwardIterator __first, _Size __count)
 {
   std::advance(__first, __count);
   return __first;
 }
    };






  template<typename _ForwardIterator, typename _Size>
    inline _ForwardIterator
    _Destroy_n(_ForwardIterator __first, _Size __count)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
                       _Value_type;


      static_assert(is_destructible<_Value_type>::value,
      "value type is destructible");





      return std::_Destroy_n_aux<__has_trivial_destructor(_Value_type)>::
 __destroy_n(__first, __count);
    }
# 253 "/usr/include/c++/10.2.0/bits/stl_construct.h" 3

}
# 34 "/usr/include/c++/10.2.0/bits/alloc_traits.h" 2 3







namespace std __attribute__ ((__visibility__ ("default")))
{





  struct __allocator_traits_base
  {
    template<typename _Tp, typename _Up, typename = void>
      struct __rebind : __replace_first_arg<_Tp, _Up> { };

    template<typename _Tp, typename _Up>
      struct __rebind<_Tp, _Up,
        __void_t<typename _Tp::template rebind<_Up>::other>>
      { using type = typename _Tp::template rebind<_Up>::other; };

  protected:
    template<typename _Tp>
      using __pointer = typename _Tp::pointer;
    template<typename _Tp>
      using __c_pointer = typename _Tp::const_pointer;
    template<typename _Tp>
      using __v_pointer = typename _Tp::void_pointer;
    template<typename _Tp>
      using __cv_pointer = typename _Tp::const_void_pointer;
    template<typename _Tp>
      using __pocca = typename _Tp::propagate_on_container_copy_assignment;
    template<typename _Tp>
      using __pocma = typename _Tp::propagate_on_container_move_assignment;
    template<typename _Tp>
      using __pocs = typename _Tp::propagate_on_container_swap;
    template<typename _Tp>
      using __equal = typename _Tp::is_always_equal;
  };

  template<typename _Alloc, typename _Up>
    using __alloc_rebind
      = typename __allocator_traits_base::template __rebind<_Alloc, _Up>::type;





  template<typename _Alloc>
    struct allocator_traits : __allocator_traits_base
    {

      typedef _Alloc allocator_type;

      typedef typename _Alloc::value_type value_type;






      using pointer = __detected_or_t<value_type*, __pointer, _Alloc>;

    private:

      template<template<typename> class _Func, typename _Tp, typename = void>
 struct _Ptr
 {
   using type = typename pointer_traits<pointer>::template rebind<_Tp>;
 };

      template<template<typename> class _Func, typename _Tp>
 struct _Ptr<_Func, _Tp, __void_t<_Func<_Alloc>>>
 {
   using type = _Func<_Alloc>;
 };


      template<typename _A2, typename _PtrT, typename = void>
 struct _Diff
 { using type = typename pointer_traits<_PtrT>::difference_type; };

      template<typename _A2, typename _PtrT>
 struct _Diff<_A2, _PtrT, __void_t<typename _A2::difference_type>>
 { using type = typename _A2::difference_type; };


      template<typename _A2, typename _DiffT, typename = void>
 struct _Size : make_unsigned<_DiffT> { };

      template<typename _A2, typename _DiffT>
 struct _Size<_A2, _DiffT, __void_t<typename _A2::size_type>>
 { using type = typename _A2::size_type; };

    public:






      using const_pointer = typename _Ptr<__c_pointer, const value_type>::type;







      using void_pointer = typename _Ptr<__v_pointer, void>::type;







      using const_void_pointer = typename _Ptr<__cv_pointer, const void>::type;







      using difference_type = typename _Diff<_Alloc, pointer>::type;







      using size_type = typename _Size<_Alloc, difference_type>::type;







      using propagate_on_container_copy_assignment
 = __detected_or_t<false_type, __pocca, _Alloc>;







      using propagate_on_container_move_assignment
 = __detected_or_t<false_type, __pocma, _Alloc>;







      using propagate_on_container_swap
 = __detected_or_t<false_type, __pocs, _Alloc>;







      using is_always_equal
 = __detected_or_t<typename is_empty<_Alloc>::type, __equal, _Alloc>;

      template<typename _Tp>
 using rebind_alloc = __alloc_rebind<_Alloc, _Tp>;
      template<typename _Tp>
 using rebind_traits = allocator_traits<rebind_alloc<_Tp>>;

    private:
      template<typename _Alloc2>
 static constexpr auto
 _S_allocate(_Alloc2& __a, size_type __n, const_void_pointer __hint, int)
 -> decltype(__a.allocate(__n, __hint))
 { return __a.allocate(__n, __hint); }

      template<typename _Alloc2>
 static constexpr pointer
 _S_allocate(_Alloc2& __a, size_type __n, const_void_pointer, ...)
 { return __a.allocate(__n); }

      template<typename _Tp, typename... _Args>
 struct __construct_helper
 {
   template<typename _Alloc2,
     typename = decltype(std::declval<_Alloc2*>()->construct(
    std::declval<_Tp*>(), std::declval<_Args>()...))>
     static true_type __test(int);

   template<typename>
     static false_type __test(...);

   using type = decltype(__test<_Alloc>(0));
 };

      template<typename _Tp, typename... _Args>
 using __has_construct
   = typename __construct_helper<_Tp, _Args...>::type;

      template<typename _Tp, typename... _Args>
 static constexpr _Require<__has_construct<_Tp, _Args...>>
 _S_construct(_Alloc& __a, _Tp* __p, _Args&&... __args)
 noexcept(noexcept(__a.construct(__p, std::forward<_Args>(__args)...)))
 { __a.construct(__p, std::forward<_Args>(__args)...); }

      template<typename _Tp, typename... _Args>
 static constexpr
 _Require<__and_<__not_<__has_construct<_Tp, _Args...>>,
          is_constructible<_Tp, _Args...>>>
 _S_construct(_Alloc&, _Tp* __p, _Args&&... __args)
 noexcept(std::is_nothrow_constructible<_Tp, _Args...>::value)
 {

   ::new((void*)__p) _Tp(std::forward<_Args>(__args)...);



 }

      template<typename _Alloc2, typename _Tp>
 static constexpr auto
 _S_destroy(_Alloc2& __a, _Tp* __p, int)
 noexcept(noexcept(__a.destroy(__p)))
 -> decltype(__a.destroy(__p))
 { __a.destroy(__p); }

      template<typename _Alloc2, typename _Tp>
 static constexpr void
 _S_destroy(_Alloc2&, _Tp* __p, ...)
 noexcept(std::is_nothrow_destructible<_Tp>::value)
 { std::_Destroy(__p); }

      template<typename _Alloc2>
 static constexpr auto
 _S_max_size(_Alloc2& __a, int)
 -> decltype(__a.max_size())
 { return __a.max_size(); }

      template<typename _Alloc2>
 static constexpr size_type
 _S_max_size(_Alloc2&, ...)
 {


   return __gnu_cxx::__numeric_traits<size_type>::__max
     / sizeof(value_type);
 }

      template<typename _Alloc2>
 static constexpr auto
 _S_select(_Alloc2& __a, int)
 -> decltype(__a.select_on_container_copy_construction())
 { return __a.select_on_container_copy_construction(); }

      template<typename _Alloc2>
 static constexpr _Alloc2
 _S_select(_Alloc2& __a, ...)
 { return __a; }

    public:
# 312 "/usr/include/c++/10.2.0/bits/alloc_traits.h" 3
      static pointer
      allocate(_Alloc& __a, size_type __n)
      { return __a.allocate(__n); }
# 327 "/usr/include/c++/10.2.0/bits/alloc_traits.h" 3
      static pointer
      allocate(_Alloc& __a, size_type __n, const_void_pointer __hint)
      { return _S_allocate(__a, __n, __hint, 0); }
# 339 "/usr/include/c++/10.2.0/bits/alloc_traits.h" 3
      static void
      deallocate(_Alloc& __a, pointer __p, size_type __n)
      { __a.deallocate(__p, __n); }
# 354 "/usr/include/c++/10.2.0/bits/alloc_traits.h" 3
      template<typename _Tp, typename... _Args>
 static auto
 construct(_Alloc& __a, _Tp* __p, _Args&&... __args)
 noexcept(noexcept(_S_construct(__a, __p,
           std::forward<_Args>(__args)...)))
 -> decltype(_S_construct(__a, __p, std::forward<_Args>(__args)...))
 { _S_construct(__a, __p, std::forward<_Args>(__args)...); }
# 370 "/usr/include/c++/10.2.0/bits/alloc_traits.h" 3
      template<typename _Tp>
 static void
 destroy(_Alloc& __a, _Tp* __p)
 noexcept(noexcept(_S_destroy(__a, __p, 0)))
 { _S_destroy(__a, __p, 0); }
# 384 "/usr/include/c++/10.2.0/bits/alloc_traits.h" 3
      static size_type
      max_size(const _Alloc& __a) noexcept
      { return _S_max_size(__a, 0); }
# 396 "/usr/include/c++/10.2.0/bits/alloc_traits.h" 3
      static _Alloc
      select_on_container_copy_construction(const _Alloc& __rhs)
      { return _S_select(__rhs, 0); }
    };






  template<typename _Tp>
    struct allocator_traits<allocator<_Tp>>
    {

      using allocator_type = allocator<_Tp>;


      using value_type = _Tp;


      using pointer = _Tp*;


      using const_pointer = const _Tp*;


      using void_pointer = void*;


      using const_void_pointer = const void*;


      using difference_type = std::ptrdiff_t;


      using size_type = std::size_t;


      using propagate_on_container_copy_assignment = false_type;


      using propagate_on_container_move_assignment = true_type;


      using propagate_on_container_swap = false_type;


      using is_always_equal = true_type;

      template<typename _Up>
 using rebind_alloc = allocator<_Up>;

      template<typename _Up>
 using rebind_traits = allocator_traits<allocator<_Up>>;
# 458 "/usr/include/c++/10.2.0/bits/alloc_traits.h" 3
      static pointer
      allocate(allocator_type& __a, size_type __n)
      { return __a.allocate(__n); }
# 472 "/usr/include/c++/10.2.0/bits/alloc_traits.h" 3
      static pointer
      allocate(allocator_type& __a, size_type __n, const_void_pointer __hint)
      {

 return __a.allocate(__n, __hint);



      }
# 490 "/usr/include/c++/10.2.0/bits/alloc_traits.h" 3
      static void
      deallocate(allocator_type& __a, pointer __p, size_type __n)
      { __a.deallocate(__p, __n); }
# 505 "/usr/include/c++/10.2.0/bits/alloc_traits.h" 3
      template<typename _Up, typename... _Args>
 static void
 construct(allocator_type& __a __attribute__((__unused__)), _Up* __p,
    _Args&&... __args)
 noexcept(std::is_nothrow_constructible<_Up, _Args...>::value)
 {

   __a.construct(__p, std::forward<_Args>(__args)...);



 }
# 525 "/usr/include/c++/10.2.0/bits/alloc_traits.h" 3
      template<typename _Up>
 static void
 destroy(allocator_type& __a __attribute__((__unused__)), _Up* __p)
 noexcept(is_nothrow_destructible<_Up>::value)
 {

   __a.destroy(__p);



 }






      static size_type
      max_size(const allocator_type& __a __attribute__((__unused__))) noexcept
      {

 return __a.max_size();



      }






      static allocator_type
      select_on_container_copy_construction(const allocator_type& __rhs)
      { return __rhs; }
    };


  template<typename _Alloc>
    inline void
    __do_alloc_on_copy(_Alloc& __one, const _Alloc& __two, true_type)
    { __one = __two; }

  template<typename _Alloc>
    inline void
    __do_alloc_on_copy(_Alloc&, const _Alloc&, false_type)
    { }


  template<typename _Alloc>
    constexpr inline void
    __alloc_on_copy(_Alloc& __one, const _Alloc& __two)
    {
      typedef allocator_traits<_Alloc> __traits;
      typedef typename __traits::propagate_on_container_copy_assignment __pocca;




      __do_alloc_on_copy(__one, __two, __pocca());

    }

  template<typename _Alloc>
    constexpr _Alloc
    __alloc_on_copy(const _Alloc& __a)
    {
      typedef allocator_traits<_Alloc> __traits;
      return __traits::select_on_container_copy_construction(__a);
    }


  template<typename _Alloc>
    inline void __do_alloc_on_move(_Alloc& __one, _Alloc& __two, true_type)
    { __one = std::move(__two); }

  template<typename _Alloc>
    inline void __do_alloc_on_move(_Alloc&, _Alloc&, false_type)
    { }


  template<typename _Alloc>
    constexpr inline void
    __alloc_on_move(_Alloc& __one, _Alloc& __two)
    {
      typedef allocator_traits<_Alloc> __traits;
      typedef typename __traits::propagate_on_container_move_assignment __pocma;




      __do_alloc_on_move(__one, __two, __pocma());

    }


  template<typename _Alloc>
    inline void __do_alloc_on_swap(_Alloc& __one, _Alloc& __two, true_type)
    {
      using std::swap;
      swap(__one, __two);
    }

  template<typename _Alloc>
    inline void __do_alloc_on_swap(_Alloc&, _Alloc&, false_type)
    { }


  template<typename _Alloc>
    constexpr inline void
    __alloc_on_swap(_Alloc& __one, _Alloc& __two)
    {
      typedef allocator_traits<_Alloc> __traits;
      typedef typename __traits::propagate_on_container_swap __pocs;







      __do_alloc_on_swap(__one, __two, __pocs());

    }

  template<typename _Alloc, typename _Tp,
    typename _ValueT = __remove_cvref_t<typename _Alloc::value_type>,
    typename = void>
    struct __is_alloc_insertable_impl
    : false_type
    { };

  template<typename _Alloc, typename _Tp, typename _ValueT>
    struct __is_alloc_insertable_impl<_Alloc, _Tp, _ValueT,
      __void_t<decltype(allocator_traits<_Alloc>::construct(
     std::declval<_Alloc&>(), std::declval<_ValueT*>(),
     std::declval<_Tp>()))>>
    : true_type
    { };




  template<typename _Alloc>
    struct __is_copy_insertable
    : __is_alloc_insertable_impl<_Alloc,
     typename _Alloc::value_type const&>::type
    { };


  template<typename _Tp>
    struct __is_copy_insertable<allocator<_Tp>>
    : is_copy_constructible<_Tp>
    { };




  template<typename _Alloc>
    struct __is_move_insertable
    : __is_alloc_insertable_impl<_Alloc, typename _Alloc::value_type>::type
    { };


  template<typename _Tp>
    struct __is_move_insertable<allocator<_Tp>>
    : is_move_constructible<_Tp>
    { };


  template<typename _Alloc, typename = void>
    struct __is_allocator : false_type { };

  template<typename _Alloc>
    struct __is_allocator<_Alloc,
      __void_t<typename _Alloc::value_type,
        decltype(std::declval<_Alloc&>().allocate(size_t{}))>>
    : true_type { };

  template<typename _Alloc>
    using _RequireAllocator
      = typename enable_if<__is_allocator<_Alloc>::value, _Alloc>::type;

  template<typename _Alloc>
    using _RequireNotAllocator
      = typename enable_if<!__is_allocator<_Alloc>::value, _Alloc>::type;
# 719 "/usr/include/c++/10.2.0/bits/alloc_traits.h" 3
  template<typename _ForwardIterator, typename _Allocator>
    void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last,
      _Allocator& __alloc)
    {
      for (; __first != __last; ++__first)



 allocator_traits<_Allocator>::destroy(__alloc,
           std::__addressof(*__first));

    }

  template<typename _ForwardIterator, typename _Tp>
    inline void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last,
      allocator<_Tp>&)
    {
      _Destroy(__first, __last);
    }


}
# 35 "/usr/include/c++/10.2.0/ext/alloc_traits.h" 2 3




namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{






template<typename _Alloc, typename = typename _Alloc::value_type>
  struct __alloc_traits

  : std::allocator_traits<_Alloc>

  {
    typedef _Alloc allocator_type;

    typedef std::allocator_traits<_Alloc> _Base_type;
    typedef typename _Base_type::value_type value_type;
    typedef typename _Base_type::pointer pointer;
    typedef typename _Base_type::const_pointer const_pointer;
    typedef typename _Base_type::size_type size_type;
    typedef typename _Base_type::difference_type difference_type;

    typedef value_type& reference;
    typedef const value_type& const_reference;
    using _Base_type::allocate;
    using _Base_type::deallocate;
    using _Base_type::construct;
    using _Base_type::destroy;
    using _Base_type::max_size;

  private:
    template<typename _Ptr>
      using __is_custom_pointer
 = std::__and_<std::is_same<pointer, _Ptr>,
        std::__not_<std::is_pointer<_Ptr>>>;

  public:

    template<typename _Ptr, typename... _Args>
      static constexpr
      std::__enable_if_t<__is_custom_pointer<_Ptr>::value>
      construct(_Alloc& __a, _Ptr __p, _Args&&... __args)
      noexcept(noexcept(_Base_type::construct(__a, std::__to_address(__p),
           std::forward<_Args>(__args)...)))
      {
 _Base_type::construct(__a, std::__to_address(__p),
         std::forward<_Args>(__args)...);
      }


    template<typename _Ptr>
      static constexpr
      std::__enable_if_t<__is_custom_pointer<_Ptr>::value>
      destroy(_Alloc& __a, _Ptr __p)
      noexcept(noexcept(_Base_type::destroy(__a, std::__to_address(__p))))
      { _Base_type::destroy(__a, std::__to_address(__p)); }

    static constexpr _Alloc _S_select_on_copy(const _Alloc& __a)
    { return _Base_type::select_on_container_copy_construction(__a); }

    static constexpr void _S_on_swap(_Alloc& __a, _Alloc& __b)
    { std::__alloc_on_swap(__a, __b); }

    static constexpr bool _S_propagate_on_copy_assign()
    { return _Base_type::propagate_on_container_copy_assignment::value; }

    static constexpr bool _S_propagate_on_move_assign()
    { return _Base_type::propagate_on_container_move_assignment::value; }

    static constexpr bool _S_propagate_on_swap()
    { return _Base_type::propagate_on_container_swap::value; }

    static constexpr bool _S_always_equal()
    { return _Base_type::is_always_equal::value; }

    static constexpr bool _S_nothrow_move()
    { return _S_propagate_on_move_assign() || _S_always_equal(); }

    template<typename _Tp>
      struct rebind
      { typedef typename _Base_type::template rebind_alloc<_Tp> other; };
# 166 "/usr/include/c++/10.2.0/ext/alloc_traits.h" 3
  };


}
# 41 "/usr/include/c++/10.2.0/bits/basic_string.h" 2 3
# 52 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



namespace __cxx11 {
# 76 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_string
    {
      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
 rebind<_CharT>::other _Char_alloc_type;
      typedef __gnu_cxx::__alloc_traits<_Char_alloc_type> _Alloc_traits;


    public:
      typedef _Traits traits_type;
      typedef typename _Traits::char_type value_type;
      typedef _Char_alloc_type allocator_type;
      typedef typename _Alloc_traits::size_type size_type;
      typedef typename _Alloc_traits::difference_type difference_type;
      typedef typename _Alloc_traits::reference reference;
      typedef typename _Alloc_traits::const_reference const_reference;
      typedef typename _Alloc_traits::pointer pointer;
      typedef typename _Alloc_traits::const_pointer const_pointer;
      typedef __gnu_cxx::__normal_iterator<pointer, basic_string> iterator;
      typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string>
       const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;


      static const size_type npos = static_cast<size_type>(-1);

    protected:




      typedef const_iterator __const_iterator;


    private:
# 150 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      struct _Alloc_hider : allocator_type
      {




 _Alloc_hider(pointer __dat, const _Alloc& __a)
 : allocator_type(__a), _M_p(__dat) { }

 _Alloc_hider(pointer __dat, _Alloc&& __a = _Alloc())
 : allocator_type(std::move(__a)), _M_p(__dat) { }


 pointer _M_p;
      };

      _Alloc_hider _M_dataplus;
      size_type _M_string_length;

      enum { _S_local_capacity = 15 / sizeof(_CharT) };

      union
      {
 _CharT _M_local_buf[_S_local_capacity + 1];
 size_type _M_allocated_capacity;
      };

      void
      _M_data(pointer __p)
      { _M_dataplus._M_p = __p; }

      void
      _M_length(size_type __length)
      { _M_string_length = __length; }

      pointer
      _M_data() const
      { return _M_dataplus._M_p; }

      pointer
      _M_local_data()
      {

 return std::pointer_traits<pointer>::pointer_to(*_M_local_buf);



      }

      const_pointer
      _M_local_data() const
      {

 return std::pointer_traits<const_pointer>::pointer_to(*_M_local_buf);



      }

      void
      _M_capacity(size_type __capacity)
      { _M_allocated_capacity = __capacity; }

      void
      _M_set_length(size_type __n)
      {
 _M_length(__n);
 traits_type::assign(_M_data()[__n], _CharT());
      }

      bool
      _M_is_local() const
      { return _M_data() == _M_local_data(); }


      pointer
      _M_create(size_type&, size_type);

      void
      _M_dispose()
      {
 if (!_M_is_local())
   _M_destroy(_M_allocated_capacity);
      }

      void
      _M_destroy(size_type __size) throw()
      { _Alloc_traits::deallocate(_M_get_allocator(), _M_data(), __size + 1); }



      template<typename _InIterator>
        void
        _M_construct_aux(_InIterator __beg, _InIterator __end,
    std::__false_type)
 {
          typedef typename iterator_traits<_InIterator>::iterator_category _Tag;
          _M_construct(__beg, __end, _Tag());
 }



      template<typename _Integer>
        void
        _M_construct_aux(_Integer __beg, _Integer __end, std::__true_type)
 { _M_construct_aux_2(static_cast<size_type>(__beg), __end); }

      void
      _M_construct_aux_2(size_type __req, _CharT __c)
      { _M_construct(__req, __c); }

      template<typename _InIterator>
        void
        _M_construct(_InIterator __beg, _InIterator __end)
 {
   typedef typename std::__is_integer<_InIterator>::__type _Integral;
   _M_construct_aux(__beg, __end, _Integral());
        }


      template<typename _InIterator>
        void
        _M_construct(_InIterator __beg, _InIterator __end,
       std::input_iterator_tag);



      template<typename _FwdIterator>
        void
        _M_construct(_FwdIterator __beg, _FwdIterator __end,
       std::forward_iterator_tag);

      void
      _M_construct(size_type __req, _CharT __c);

      allocator_type&
      _M_get_allocator()
      { return _M_dataplus; }

      const allocator_type&
      _M_get_allocator() const
      { return _M_dataplus; }

    private:
# 309 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      size_type
      _M_check(size_type __pos, const char* __s) const
      {
 if (__pos > this->size())
   __throw_out_of_range_fmt(("%s: __pos (which is %zu) > " "this->size() (which is %zu)")
                                         ,
       __s, __pos, this->size());
 return __pos;
      }

      void
      _M_check_length(size_type __n1, size_type __n2, const char* __s) const
      {
 if (this->max_size() - (this->size() - __n1) < __n2)
   __throw_length_error((__s));
      }



      size_type
      _M_limit(size_type __pos, size_type __off) const noexcept
      {
 const bool __testoff = __off < this->size() - __pos;
 return __testoff ? __off : this->size() - __pos;
      }


      bool
      _M_disjunct(const _CharT* __s) const noexcept
      {
 return (less<const _CharT*>()(__s, _M_data())
  || less<const _CharT*>()(_M_data() + this->size(), __s));
      }



      static void
      _S_copy(_CharT* __d, const _CharT* __s, size_type __n)
      {
 if (__n == 1)
   traits_type::assign(*__d, *__s);
 else
   traits_type::copy(__d, __s, __n);
      }

      static void
      _S_move(_CharT* __d, const _CharT* __s, size_type __n)
      {
 if (__n == 1)
   traits_type::assign(*__d, *__s);
 else
   traits_type::move(__d, __s, __n);
      }

      static void
      _S_assign(_CharT* __d, size_type __n, _CharT __c)
      {
 if (__n == 1)
   traits_type::assign(*__d, __c);
 else
   traits_type::assign(__d, __n, __c);
      }



      template<class _Iterator>
        static void
        _S_copy_chars(_CharT* __p, _Iterator __k1, _Iterator __k2)
        {
   for (; __k1 != __k2; ++__k1, (void)++__p)
     traits_type::assign(*__p, *__k1);
 }

      static void
      _S_copy_chars(_CharT* __p, iterator __k1, iterator __k2) noexcept
      { _S_copy_chars(__p, __k1.base(), __k2.base()); }

      static void
      _S_copy_chars(_CharT* __p, const_iterator __k1, const_iterator __k2)
      noexcept
      { _S_copy_chars(__p, __k1.base(), __k2.base()); }

      static void
      _S_copy_chars(_CharT* __p, _CharT* __k1, _CharT* __k2) noexcept
      { _S_copy(__p, __k1, __k2 - __k1); }

      static void
      _S_copy_chars(_CharT* __p, const _CharT* __k1, const _CharT* __k2)
      noexcept
      { _S_copy(__p, __k1, __k2 - __k1); }

      static int
      _S_compare(size_type __n1, size_type __n2) noexcept
      {
 const difference_type __d = difference_type(__n1 - __n2);

 if (__d > __gnu_cxx::__numeric_traits<int>::__max)
   return __gnu_cxx::__numeric_traits<int>::__max;
 else if (__d < __gnu_cxx::__numeric_traits<int>::__min)
   return __gnu_cxx::__numeric_traits<int>::__min;
 else
   return int(__d);
      }

      void
      _M_assign(const basic_string&);

      void
      _M_mutate(size_type __pos, size_type __len1, const _CharT* __s,
  size_type __len2);

      void
      _M_erase(size_type __pos, size_type __n);

    public:







      basic_string()
      noexcept(is_nothrow_default_constructible<_Alloc>::value)
      : _M_dataplus(_M_local_data())
      { _M_set_length(0); }




      explicit
      basic_string(const _Alloc& __a) noexcept
      : _M_dataplus(_M_local_data(), __a)
      { _M_set_length(0); }





      basic_string(const basic_string& __str)
      : _M_dataplus(_M_local_data(),
      _Alloc_traits::_S_select_on_copy(__str._M_get_allocator()))
      { _M_construct(__str._M_data(), __str._M_data() + __str.length()); }
# 461 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      basic_string(const basic_string& __str, size_type __pos,
     const _Alloc& __a = _Alloc())
      : _M_dataplus(_M_local_data(), __a)
      {
 const _CharT* __start = __str._M_data()
   + __str._M_check(__pos, "basic_string::basic_string");
 _M_construct(__start, __start + __str._M_limit(__pos, npos));
      }







      basic_string(const basic_string& __str, size_type __pos,
     size_type __n)
      : _M_dataplus(_M_local_data())
      {
 const _CharT* __start = __str._M_data()
   + __str._M_check(__pos, "basic_string::basic_string");
 _M_construct(__start, __start + __str._M_limit(__pos, __n));
      }
# 492 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      basic_string(const basic_string& __str, size_type __pos,
     size_type __n, const _Alloc& __a)
      : _M_dataplus(_M_local_data(), __a)
      {
 const _CharT* __start
   = __str._M_data() + __str._M_check(__pos, "string::string");
 _M_construct(__start, __start + __str._M_limit(__pos, __n));
      }
# 510 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      basic_string(const _CharT* __s, size_type __n,
     const _Alloc& __a = _Alloc())
      : _M_dataplus(_M_local_data(), __a)
      { _M_construct(__s, __s + __n); }
# 525 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      basic_string(const _CharT* __s, const _Alloc& __a = _Alloc())
      : _M_dataplus(_M_local_data(), __a)
      { _M_construct(__s, __s ? __s + traits_type::length(__s) : __s+npos); }
# 540 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      basic_string(size_type __n, _CharT __c, const _Alloc& __a = _Alloc())
      : _M_dataplus(_M_local_data(), __a)
      { _M_construct(__n, __c); }
# 552 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      basic_string(basic_string&& __str) noexcept
      : _M_dataplus(_M_local_data(), std::move(__str._M_get_allocator()))
      {
 if (__str._M_is_local())
   {
     traits_type::copy(_M_local_buf, __str._M_local_buf,
         _S_local_capacity + 1);
   }
 else
   {
     _M_data(__str._M_data());
     _M_capacity(__str._M_allocated_capacity);
   }




 _M_length(__str.length());
 __str._M_data(__str._M_local_data());
 __str._M_set_length(0);
      }






      basic_string(initializer_list<_CharT> __l, const _Alloc& __a = _Alloc())
      : _M_dataplus(_M_local_data(), __a)
      { _M_construct(__l.begin(), __l.end()); }

      basic_string(const basic_string& __str, const _Alloc& __a)
      : _M_dataplus(_M_local_data(), __a)
      { _M_construct(__str.begin(), __str.end()); }

      basic_string(basic_string&& __str, const _Alloc& __a)
      noexcept(_Alloc_traits::_S_always_equal())
      : _M_dataplus(_M_local_data(), __a)
      {
 if (__str._M_is_local())
   {
     traits_type::copy(_M_local_buf, __str._M_local_buf,
         _S_local_capacity + 1);
     _M_length(__str.length());
     __str._M_set_length(0);
   }
 else if (_Alloc_traits::_S_always_equal()
     || __str.get_allocator() == __a)
   {
     _M_data(__str._M_data());
     _M_length(__str.length());
     _M_capacity(__str._M_allocated_capacity);
     __str._M_data(__str._M_local_buf);
     __str._M_set_length(0);
   }
 else
   _M_construct(__str.begin(), __str.end());
      }
# 620 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>



        basic_string(_InputIterator __beg, _InputIterator __end,
       const _Alloc& __a = _Alloc())
 : _M_dataplus(_M_local_data(), __a)
 { _M_construct(__beg, __end); }
# 657 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      ~basic_string()
      { _M_dispose(); }





      basic_string&
      operator=(const basic_string& __str)
      {
 return this->assign(__str);
      }





      basic_string&
      operator=(const _CharT* __s)
      { return this->assign(__s); }
# 685 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      basic_string&
      operator=(_CharT __c)
      {
 this->assign(1, __c);
 return *this;
      }
# 702 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      basic_string&
      operator=(basic_string&& __str)
      noexcept(_Alloc_traits::_S_nothrow_move())
      {
 if (!_M_is_local() && _Alloc_traits::_S_propagate_on_move_assign()
     && !_Alloc_traits::_S_always_equal()
     && _M_get_allocator() != __str._M_get_allocator())
   {

     _M_destroy(_M_allocated_capacity);
     _M_data(_M_local_data());
     _M_set_length(0);
   }

 std::__alloc_on_move(_M_get_allocator(), __str._M_get_allocator());

 if (__str._M_is_local())
   {

     if (__str.size())
       this->_S_copy(_M_data(), __str._M_data(), __str.size());
     _M_set_length(__str.size());
   }
 else if (_Alloc_traits::_S_propagate_on_move_assign()
     || _Alloc_traits::_S_always_equal()
     || _M_get_allocator() == __str._M_get_allocator())
   {

     pointer __data = nullptr;
     size_type __capacity;
     if (!_M_is_local())
       {
  if (_Alloc_traits::_S_always_equal())
    {

      __data = _M_data();
      __capacity = _M_allocated_capacity;
    }
  else
    _M_destroy(_M_allocated_capacity);
       }

     _M_data(__str._M_data());
     _M_length(__str.length());
     _M_capacity(__str._M_allocated_capacity);
     if (__data)
       {
  __str._M_data(__data);
  __str._M_capacity(__capacity);
       }
     else
       __str._M_data(__str._M_local_buf);
   }
 else
   assign(__str);
 __str.clear();
 return *this;
      }





      basic_string&
      operator=(initializer_list<_CharT> __l)
      {
 this->assign(__l.begin(), __l.size());
 return *this;
      }
# 796 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      iterator
      begin() noexcept
      { return iterator(_M_data()); }





      const_iterator
      begin() const noexcept
      { return const_iterator(_M_data()); }





      iterator
      end() noexcept
      { return iterator(_M_data() + this->size()); }





      const_iterator
      end() const noexcept
      { return const_iterator(_M_data() + this->size()); }






      reverse_iterator
      rbegin() noexcept
      { return reverse_iterator(this->end()); }






      const_reverse_iterator
      rbegin() const noexcept
      { return const_reverse_iterator(this->end()); }






      reverse_iterator
      rend() noexcept
      { return reverse_iterator(this->begin()); }






      const_reverse_iterator
      rend() const noexcept
      { return const_reverse_iterator(this->begin()); }






      const_iterator
      cbegin() const noexcept
      { return const_iterator(this->_M_data()); }





      const_iterator
      cend() const noexcept
      { return const_iterator(this->_M_data() + this->size()); }






      const_reverse_iterator
      crbegin() const noexcept
      { return const_reverse_iterator(this->end()); }






      const_reverse_iterator
      crend() const noexcept
      { return const_reverse_iterator(this->begin()); }


    public:



      size_type
      size() const noexcept
      { return _M_string_length; }



      size_type
      length() const noexcept
      { return _M_string_length; }


      size_type
      max_size() const noexcept
      { return (_Alloc_traits::max_size(_M_get_allocator()) - 1) / 2; }
# 925 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      void
      resize(size_type __n, _CharT __c);
# 938 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      void
      resize(size_type __n)
      { this->resize(__n, _CharT()); }



      void
      shrink_to_fit() noexcept
      {

 if (capacity() > size())
   {
     try
       { reserve(0); }
     catch(...)
       { }
   }

      }






      size_type
      capacity() const noexcept
      {
 return _M_is_local() ? size_type(_S_local_capacity)
                      : _M_allocated_capacity;
      }
# 987 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      void
      reserve(size_type __res_arg = 0);




      void
      clear() noexcept
      { _M_set_length(0); }





      bool
      empty() const noexcept
      { return this->size() == 0; }
# 1016 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      const_reference
      operator[] (size_type __pos) const noexcept
      {
 ;
 return _M_data()[__pos];
      }
# 1033 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      reference
      operator[](size_type __pos)
      {


 ;

 ;
 return _M_data()[__pos];
      }
# 1054 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      const_reference
      at(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range_fmt(("basic_string::at: __n " "(which is %zu) >= this->size() " "(which is %zu)")

                            ,
       __n, this->size());
 return _M_data()[__n];
      }
# 1075 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      reference
      at(size_type __n)
      {
 if (__n >= size())
   __throw_out_of_range_fmt(("basic_string::at: __n " "(which is %zu) >= this->size() " "(which is %zu)")

                            ,
       __n, this->size());
 return _M_data()[__n];
      }






      reference
      front() noexcept
      {
 ;
 return operator[](0);
      }





      const_reference
      front() const noexcept
      {
 ;
 return operator[](0);
      }





      reference
      back() noexcept
      {
 ;
 return operator[](this->size() - 1);
      }





      const_reference
      back() const noexcept
      {
 ;
 return operator[](this->size() - 1);
      }
# 1138 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      basic_string&
      operator+=(const basic_string& __str)
      { return this->append(__str); }






      basic_string&
      operator+=(const _CharT* __s)
      { return this->append(__s); }






      basic_string&
      operator+=(_CharT __c)
      {
 this->push_back(__c);
 return *this;
      }







      basic_string&
      operator+=(initializer_list<_CharT> __l)
      { return this->append(__l.begin(), __l.size()); }
# 1191 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      basic_string&
      append(const basic_string& __str)
      { return _M_append(__str._M_data(), __str.size()); }
# 1208 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      basic_string&
      append(const basic_string& __str, size_type __pos, size_type __n = npos)
      { return _M_append(__str._M_data()
    + __str._M_check(__pos, "basic_string::append"),
    __str._M_limit(__pos, __n)); }







      basic_string&
      append(const _CharT* __s, size_type __n)
      {
 ;
 _M_check_length(size_type(0), __n, "basic_string::append");
 return _M_append(__s, __n);
      }






      basic_string&
      append(const _CharT* __s)
      {
 ;
 const size_type __n = traits_type::length(__s);
 _M_check_length(size_type(0), __n, "basic_string::append");
 return _M_append(__s, __n);
      }
# 1250 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      basic_string&
      append(size_type __n, _CharT __c)
      { return _M_replace_aux(this->size(), size_type(0), __n, __c); }







      basic_string&
      append(initializer_list<_CharT> __l)
      { return this->append(__l.begin(), __l.size()); }
# 1274 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      template<class _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>



        basic_string&
        append(_InputIterator __first, _InputIterator __last)
        { return this->replace(end(), end(), __first, __last); }
# 1319 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      void
      push_back(_CharT __c)
      {
 const size_type __size = this->size();
 if (__size + 1 > this->capacity())
   this->_M_mutate(__size, size_type(0), 0, size_type(1));
 traits_type::assign(this->_M_data()[__size], __c);
 this->_M_set_length(__size + 1);
      }






      basic_string&
      assign(const basic_string& __str)
      {

 if (_Alloc_traits::_S_propagate_on_copy_assign())
   {
     if (!_Alloc_traits::_S_always_equal() && !_M_is_local()
  && _M_get_allocator() != __str._M_get_allocator())
       {


  if (__str.size() <= _S_local_capacity)
    {
      _M_destroy(_M_allocated_capacity);
      _M_data(_M_local_data());
      _M_set_length(0);
    }
  else
    {
      const auto __len = __str.size();
      auto __alloc = __str._M_get_allocator();

      auto __ptr = _Alloc_traits::allocate(__alloc, __len + 1);
      _M_destroy(_M_allocated_capacity);
      _M_data(__ptr);
      _M_capacity(__len);
      _M_set_length(__len);
    }
       }
     std::__alloc_on_copy(_M_get_allocator(), __str._M_get_allocator());
   }

 this->_M_assign(__str);
 return *this;
      }
# 1379 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      basic_string&
      assign(basic_string&& __str)
      noexcept(_Alloc_traits::_S_nothrow_move())
      {


 return *this = std::move(__str);
      }
# 1402 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      basic_string&
      assign(const basic_string& __str, size_type __pos, size_type __n = npos)
      { return _M_replace(size_type(0), this->size(), __str._M_data()
     + __str._M_check(__pos, "basic_string::assign"),
     __str._M_limit(__pos, __n)); }
# 1418 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      basic_string&
      assign(const _CharT* __s, size_type __n)
      {
 ;
 return _M_replace(size_type(0), this->size(), __s, __n);
      }
# 1434 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      basic_string&
      assign(const _CharT* __s)
      {
 ;
 return _M_replace(size_type(0), this->size(), __s,
     traits_type::length(__s));
      }
# 1451 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      basic_string&
      assign(size_type __n, _CharT __c)
      { return _M_replace_aux(size_type(0), this->size(), __n, __c); }
# 1464 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      template<class _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>



        basic_string&
        assign(_InputIterator __first, _InputIterator __last)
        { return this->replace(begin(), end(), __first, __last); }







      basic_string&
      assign(initializer_list<_CharT> __l)
      { return this->assign(__l.begin(), __l.size()); }
# 1533 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      iterator
      insert(const_iterator __p, size_type __n, _CharT __c)
      {
 ;
 const size_type __pos = __p - begin();
 this->replace(__p, __p, __n, __c);
 return iterator(this->_M_data() + __pos);
      }
# 1575 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      template<class _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
 iterator
        insert(const_iterator __p, _InputIterator __beg, _InputIterator __end)
        {
   ;
   const size_type __pos = __p - begin();
   this->replace(__p, __p, __beg, __end);
   return iterator(this->_M_data() + __pos);
 }
# 1611 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      iterator
      insert(const_iterator __p, initializer_list<_CharT> __l)
      { return this->insert(__p, __l.begin(), __l.end()); }
# 1638 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos1, const basic_string& __str)
      { return this->replace(__pos1, size_type(0),
        __str._M_data(), __str.size()); }
# 1661 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos1, const basic_string& __str,
      size_type __pos2, size_type __n = npos)
      { return this->replace(__pos1, size_type(0), __str._M_data()
        + __str._M_check(__pos2, "basic_string::insert"),
        __str._M_limit(__pos2, __n)); }
# 1684 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, const _CharT* __s, size_type __n)
      { return this->replace(__pos, size_type(0), __s, __n); }
# 1703 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, const _CharT* __s)
      {
 ;
 return this->replace(__pos, size_type(0), __s,
        traits_type::length(__s));
      }
# 1727 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, size_type __n, _CharT __c)
      { return _M_replace_aux(_M_check(__pos, "basic_string::insert"),
         size_type(0), __n, __c); }
# 1745 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      iterator
      insert(__const_iterator __p, _CharT __c)
      {
 ;
 const size_type __pos = __p - begin();
 _M_replace_aux(__pos, size_type(0), size_type(1), __c);
 return iterator(_M_data() + __pos);
      }
# 1805 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      basic_string&
      erase(size_type __pos = 0, size_type __n = npos)
      {
 _M_check(__pos, "basic_string::erase");
 if (__n == npos)
   this->_M_set_length(__pos);
 else if (__n != 0)
   this->_M_erase(__pos, _M_limit(__pos, __n));
 return *this;
      }
# 1824 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      iterator
      erase(__const_iterator __position)
      {

                           ;
 const size_type __pos = __position - begin();
 this->_M_erase(__pos, size_type(1));
 return iterator(_M_data() + __pos);
      }
# 1843 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      iterator
      erase(__const_iterator __first, __const_iterator __last)
      {

                        ;
        const size_type __pos = __first - begin();
 if (__last == end())
   this->_M_set_length(__pos);
 else
   this->_M_erase(__pos, __last - __first);
 return iterator(this->_M_data() + __pos);
      }







      void
      pop_back() noexcept
      {
 ;
 _M_erase(size() - 1, 1);
      }
# 1887 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n, const basic_string& __str)
      { return this->replace(__pos, __n, __str._M_data(), __str.size()); }
# 1909 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos1, size_type __n1, const basic_string& __str,
       size_type __pos2, size_type __n2 = npos)
      { return this->replace(__pos1, __n1, __str._M_data()
        + __str._M_check(__pos2, "basic_string::replace"),
        __str._M_limit(__pos2, __n2)); }
# 1934 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, const _CharT* __s,
       size_type __n2)
      {
 ;
 return _M_replace(_M_check(__pos, "basic_string::replace"),
     _M_limit(__pos, __n1), __s, __n2);
      }
# 1959 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, const _CharT* __s)
      {
 ;
 return this->replace(__pos, __n1, __s, traits_type::length(__s));
      }
# 1983 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, size_type __n2, _CharT __c)
      { return _M_replace_aux(_M_check(__pos, "basic_string::replace"),
         _M_limit(__pos, __n1), __n2, __c); }
# 2001 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
       const basic_string& __str)
      { return this->replace(__i1, __i2, __str._M_data(), __str.size()); }
# 2021 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
       const _CharT* __s, size_type __n)
      {

                      ;
 return this->replace(__i1 - begin(), __i2 - __i1, __s, __n);
      }
# 2043 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2, const _CharT* __s)
      {
 ;
 return this->replace(__i1, __i2, __s, traits_type::length(__s));
      }
# 2064 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2, size_type __n,
       _CharT __c)
      {

                      ;
 return _M_replace_aux(__i1 - begin(), __i2 - __i1, __n, __c);
      }
# 2089 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      template<class _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
        basic_string&
        replace(const_iterator __i1, const_iterator __i2,
  _InputIterator __k1, _InputIterator __k2)
        {
  
                        ;
   ;
   return this->_M_replace_dispatch(__i1, __i2, __k1, __k2,
        std::__false_type());
 }
# 2121 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
       _CharT* __k1, _CharT* __k2)
      {

                      ;
 ;
 return this->replace(__i1 - begin(), __i2 - __i1,
        __k1, __k2 - __k1);
      }

      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
       const _CharT* __k1, const _CharT* __k2)
      {

                      ;
 ;
 return this->replace(__i1 - begin(), __i2 - __i1,
        __k1, __k2 - __k1);
      }

      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
       iterator __k1, iterator __k2)
      {

                      ;
 ;
 return this->replace(__i1 - begin(), __i2 - __i1,
        __k1.base(), __k2 - __k1);
      }

      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
       const_iterator __k1, const_iterator __k2)
      {

                      ;
 ;
 return this->replace(__i1 - begin(), __i2 - __i1,
        __k1.base(), __k2 - __k1);
      }
# 2180 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      basic_string& replace(const_iterator __i1, const_iterator __i2,
       initializer_list<_CharT> __l)
      { return this->replace(__i1, __i2, __l.begin(), __l.size()); }
# 2240 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
    private:
      template<class _Integer>
 basic_string&
 _M_replace_dispatch(const_iterator __i1, const_iterator __i2,
       _Integer __n, _Integer __val, __true_type)
        { return _M_replace_aux(__i1 - begin(), __i2 - __i1, __n, __val); }

      template<class _InputIterator>
 basic_string&
 _M_replace_dispatch(const_iterator __i1, const_iterator __i2,
       _InputIterator __k1, _InputIterator __k2,
       __false_type);

      basic_string&
      _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
       _CharT __c);

      basic_string&
      _M_replace(size_type __pos, size_type __len1, const _CharT* __s,
   const size_type __len2);

      basic_string&
      _M_append(const _CharT* __s, size_type __n);

    public:
# 2278 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      size_type
      copy(_CharT* __s, size_type __n, size_type __pos = 0) const;
# 2288 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      void
      swap(basic_string& __s) noexcept;
# 2298 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      const _CharT*
      c_str() const noexcept
      { return _M_data(); }
# 2310 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      const _CharT*
      data() const noexcept
      { return _M_data(); }
# 2329 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      allocator_type
      get_allocator() const noexcept
      { return _M_get_allocator(); }
# 2345 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      size_type
      find(const _CharT* __s, size_type __pos, size_type __n) const
      noexcept;
# 2359 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      size_type
      find(const basic_string& __str, size_type __pos = 0) const
      noexcept
      { return this->find(__str.data(), __pos, __str.size()); }
# 2391 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      size_type
      find(const _CharT* __s, size_type __pos = 0) const noexcept
      {
 ;
 return this->find(__s, __pos, traits_type::length(__s));
      }
# 2408 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      size_type
      find(_CharT __c, size_type __pos = 0) const noexcept;
# 2421 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      size_type
      rfind(const basic_string& __str, size_type __pos = npos) const
      noexcept
      { return this->rfind(__str.data(), __pos, __str.size()); }
# 2455 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      size_type
      rfind(const _CharT* __s, size_type __pos, size_type __n) const
      noexcept;
# 2469 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      size_type
      rfind(const _CharT* __s, size_type __pos = npos) const
      {
 ;
 return this->rfind(__s, __pos, traits_type::length(__s));
      }
# 2486 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      size_type
      rfind(_CharT __c, size_type __pos = npos) const noexcept;
# 2500 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      size_type
      find_first_of(const basic_string& __str, size_type __pos = 0) const
      noexcept
      { return this->find_first_of(__str.data(), __pos, __str.size()); }
# 2535 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      size_type
      find_first_of(const _CharT* __s, size_type __pos, size_type __n) const
      noexcept;
# 2549 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      size_type
      find_first_of(const _CharT* __s, size_type __pos = 0) const
      noexcept
      {
 ;
 return this->find_first_of(__s, __pos, traits_type::length(__s));
      }
# 2569 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      size_type
      find_first_of(_CharT __c, size_type __pos = 0) const noexcept
      { return this->find(__c, __pos); }
# 2584 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      size_type
      find_last_of(const basic_string& __str, size_type __pos = npos) const
      noexcept
      { return this->find_last_of(__str.data(), __pos, __str.size()); }
# 2619 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      size_type
      find_last_of(const _CharT* __s, size_type __pos, size_type __n) const
      noexcept;
# 2633 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      size_type
      find_last_of(const _CharT* __s, size_type __pos = npos) const
      noexcept
      {
 ;
 return this->find_last_of(__s, __pos, traits_type::length(__s));
      }
# 2653 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      size_type
      find_last_of(_CharT __c, size_type __pos = npos) const noexcept
      { return this->rfind(__c, __pos); }
# 2667 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      size_type
      find_first_not_of(const basic_string& __str, size_type __pos = 0) const
      noexcept
      { return this->find_first_not_of(__str.data(), __pos, __str.size()); }
# 2702 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      size_type
      find_first_not_of(const _CharT* __s, size_type __pos,
   size_type __n) const noexcept;
# 2716 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      size_type
      find_first_not_of(const _CharT* __s, size_type __pos = 0) const
      noexcept
      {
 ;
 return this->find_first_not_of(__s, __pos, traits_type::length(__s));
      }
# 2734 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      size_type
      find_first_not_of(_CharT __c, size_type __pos = 0) const
      noexcept;
# 2749 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      size_type
      find_last_not_of(const basic_string& __str, size_type __pos = npos) const
      noexcept
      { return this->find_last_not_of(__str.data(), __pos, __str.size()); }
# 2784 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      size_type
      find_last_not_of(const _CharT* __s, size_type __pos,
         size_type __n) const noexcept;
# 2798 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      size_type
      find_last_not_of(const _CharT* __s, size_type __pos = npos) const
      noexcept
      {
 ;
 return this->find_last_not_of(__s, __pos, traits_type::length(__s));
      }
# 2816 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      size_type
      find_last_not_of(_CharT __c, size_type __pos = npos) const
      noexcept;
# 2832 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      basic_string
      substr(size_type __pos = 0, size_type __n = npos) const
      { return basic_string(*this,
       _M_check(__pos, "basic_string::substr"), __n); }
# 2851 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      int
      compare(const basic_string& __str) const
      {
 const size_type __size = this->size();
 const size_type __osize = __str.size();
 const size_type __len = std::min(__size, __osize);

 int __r = traits_type::compare(_M_data(), __str.data(), __len);
 if (!__r)
   __r = _S_compare(__size, __osize);
 return __r;
      }
# 2944 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n, const basic_string& __str) const;
# 2970 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      int
      compare(size_type __pos1, size_type __n1, const basic_string& __str,
       size_type __pos2, size_type __n2 = npos) const;
# 2988 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      int
      compare(const _CharT* __s) const noexcept;
# 3012 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n1, const _CharT* __s) const;
# 3039 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n1, const _CharT* __s,
       size_type __n2) const;
# 3070 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
      template<typename, typename, typename> friend class basic_stringbuf;
    };
}
# 6020 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
      __str.append(__rhs);
      return __str;
    }







  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT,_Traits,_Alloc>
    operator+(const _CharT* __lhs,
       const basic_string<_CharT,_Traits,_Alloc>& __rhs);







  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT,_Traits,_Alloc>
    operator+(_CharT __lhs, const basic_string<_CharT,_Traits,_Alloc>& __rhs);







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
      __str.append(__rhs);
      return __str;
    }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs, _CharT __rhs)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      __string_type __str(__lhs);
      __str.append(__size_type(1), __rhs);
      return __str;
    }


  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return std::move(__lhs.append(__rhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       basic_string<_CharT, _Traits, _Alloc>&& __rhs)
    { return std::move(__rhs.insert(0, __lhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
       basic_string<_CharT, _Traits, _Alloc>&& __rhs)
    {

      using _Alloc_traits = allocator_traits<_Alloc>;
      bool __use_rhs = false;
      if (typename _Alloc_traits::is_always_equal{})
 __use_rhs = true;
      else if (__lhs.get_allocator() == __rhs.get_allocator())
 __use_rhs = true;
      if (__use_rhs)

 {
   const auto __size = __lhs.size() + __rhs.size();
   if (__size > __lhs.capacity() && __size <= __rhs.capacity())
     return std::move(__rhs.insert(0, __lhs));
 }
      return std::move(__lhs.append(__rhs));
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const _CharT* __lhs,
       basic_string<_CharT, _Traits, _Alloc>&& __rhs)
    { return std::move(__rhs.insert(0, __lhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(_CharT __lhs,
       basic_string<_CharT, _Traits, _Alloc>&& __rhs)
    { return std::move(__rhs.insert(0, 1, __lhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
       const _CharT* __rhs)
    { return std::move(__lhs.append(__rhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
       _CharT __rhs)
    { return std::move(__lhs.append(1, __rhs)); }
# 6151 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept
    { return __lhs.compare(__rhs) == 0; }

  template<typename _CharT>
    inline
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, bool>::__type
    operator==(const basic_string<_CharT>& __lhs,
        const basic_string<_CharT>& __rhs) noexcept
    { return (__lhs.size() == __rhs.size()
       && !std::char_traits<_CharT>::compare(__lhs.data(), __rhs.data(),
          __lhs.size())); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) == 0; }
# 6214 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) == 0; }
# 6227 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept
    { return !(__lhs == __rhs); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return !(__lhs == __rhs); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return !(__lhs == __rhs); }
# 6265 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept
    { return __lhs.compare(__rhs) < 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    { return __lhs.compare(__rhs) < 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) > 0; }
# 6303 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept
    { return __lhs.compare(__rhs) > 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    { return __lhs.compare(__rhs) > 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) < 0; }
# 6341 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept
    { return __lhs.compare(__rhs) <= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) <= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) >= 0; }
# 6379 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept
    { return __lhs.compare(__rhs) >= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) >= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const _CharT* __lhs,
      const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) <= 0; }
# 6418 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline void
    swap(basic_string<_CharT, _Traits, _Alloc>& __lhs,
  basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept(noexcept(__lhs.swap(__rhs)))
    { __lhs.swap(__rhs); }
# 6438 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is,
        basic_string<_CharT, _Traits, _Alloc>& __str);

  template<>
    basic_istream<char>&
    operator>>(basic_istream<char>& __is, basic_string<char>& __str);
# 6456 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os,
        const basic_string<_CharT, _Traits, _Alloc>& __str)
    {


      return __ostream_insert(__os, __str.data(), __str.size());
    }
# 6479 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim);
# 6496 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str)
    { return std::getline(__is, __str, __is.widen('\n')); }



  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>&& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim)
    { return std::getline(__is, __str, __delim); }


  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>&& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str)
    { return std::getline(__is, __str); }


  template<>
    basic_istream<char>&
    getline(basic_istream<char>& __in, basic_string<char>& __str,
     char __delim);


  template<>
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>& __in, basic_string<wchar_t>& __str,
     wchar_t __delim);



}



# 1 "/usr/include/c++/10.2.0/ext/string_conversions.h" 1 3
# 32 "/usr/include/c++/10.2.0/ext/string_conversions.h" 3
       
# 33 "/usr/include/c++/10.2.0/ext/string_conversions.h" 3
# 41 "/usr/include/c++/10.2.0/ext/string_conversions.h" 3
# 1 "/usr/include/c++/10.2.0/cstdlib" 1 3
# 39 "/usr/include/c++/10.2.0/cstdlib" 3
       
# 40 "/usr/include/c++/10.2.0/cstdlib" 3
# 42 "/usr/include/c++/10.2.0/ext/string_conversions.h" 2 3
# 1 "/usr/include/c++/10.2.0/cwchar" 1 3
# 39 "/usr/include/c++/10.2.0/cwchar" 3
       
# 40 "/usr/include/c++/10.2.0/cwchar" 3
# 43 "/usr/include/c++/10.2.0/ext/string_conversions.h" 2 3
# 1 "/usr/include/c++/10.2.0/cstdio" 1 3
# 39 "/usr/include/c++/10.2.0/cstdio" 3
       
# 40 "/usr/include/c++/10.2.0/cstdio" 3


# 1 "/usr/include/stdio.h" 1 3 4
# 27 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/bits/libc-header-start.h" 1 3 4
# 28 "/usr/include/stdio.h" 2 3 4

extern "C" {



# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/include/stddef.h" 1 3 4
# 34 "/usr/include/stdio.h" 2 3 4


# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/include/stdarg.h" 1 3 4
# 37 "/usr/include/stdio.h" 2 3 4


# 1 "/usr/include/bits/types/__fpos_t.h" 1 3 4
# 10 "/usr/include/bits/types/__fpos_t.h" 3 4
typedef struct _G_fpos_t
{
  __off_t __pos;
  __mbstate_t __state;
} __fpos_t;
# 40 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/bits/types/__fpos64_t.h" 1 3 4
# 10 "/usr/include/bits/types/__fpos64_t.h" 3 4
typedef struct _G_fpos64_t
{
  __off64_t __pos;
  __mbstate_t __state;
} __fpos64_t;
# 41 "/usr/include/stdio.h" 2 3 4


# 1 "/usr/include/bits/types/struct_FILE.h" 1 3 4
# 35 "/usr/include/bits/types/struct_FILE.h" 3 4
struct _IO_FILE;
struct _IO_marker;
struct _IO_codecvt;
struct _IO_wide_data;




typedef void _IO_lock_t;





struct _IO_FILE
{
  int _flags;


  char *_IO_read_ptr;
  char *_IO_read_end;
  char *_IO_read_base;
  char *_IO_write_base;
  char *_IO_write_ptr;
  char *_IO_write_end;
  char *_IO_buf_base;
  char *_IO_buf_end;


  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;
  int _flags2;
  __off_t _old_offset;


  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];

  _IO_lock_t *_lock;







  __off64_t _offset;

  struct _IO_codecvt *_codecvt;
  struct _IO_wide_data *_wide_data;
  struct _IO_FILE *_freeres_list;
  void *_freeres_buf;
  size_t __pad5;
  int _mode;

  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];
};
# 44 "/usr/include/stdio.h" 2 3 4


# 1 "/usr/include/bits/types/cookie_io_functions_t.h" 1 3 4
# 27 "/usr/include/bits/types/cookie_io_functions_t.h" 3 4
typedef __ssize_t cookie_read_function_t (void *__cookie, char *__buf,
                                          size_t __nbytes);







typedef __ssize_t cookie_write_function_t (void *__cookie, const char *__buf,
                                           size_t __nbytes);







typedef int cookie_seek_function_t (void *__cookie, __off64_t *__pos, int __w);


typedef int cookie_close_function_t (void *__cookie);






typedef struct _IO_cookie_io_functions_t
{
  cookie_read_function_t *read;
  cookie_write_function_t *write;
  cookie_seek_function_t *seek;
  cookie_close_function_t *close;
} cookie_io_functions_t;
# 47 "/usr/include/stdio.h" 2 3 4





typedef __gnuc_va_list va_list;
# 84 "/usr/include/stdio.h" 3 4
typedef __fpos_t fpos_t;




typedef __fpos64_t fpos64_t;
# 133 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/bits/stdio_lim.h" 1 3 4
# 134 "/usr/include/stdio.h" 2 3 4



extern FILE *stdin;
extern FILE *stdout;
extern FILE *stderr;






extern int remove (const char *__filename) noexcept (true);

extern int rename (const char *__old, const char *__new) noexcept (true);



extern int renameat (int __oldfd, const char *__old, int __newfd,
       const char *__new) noexcept (true);
# 164 "/usr/include/stdio.h" 3 4
extern int renameat2 (int __oldfd, const char *__old, int __newfd,
        const char *__new, unsigned int __flags) noexcept (true);







extern FILE *tmpfile (void) ;
# 183 "/usr/include/stdio.h" 3 4
extern FILE *tmpfile64 (void) ;



extern char *tmpnam (char *__s) noexcept (true) ;




extern char *tmpnam_r (char *__s) noexcept (true) ;
# 204 "/usr/include/stdio.h" 3 4
extern char *tempnam (const char *__dir, const char *__pfx)
     noexcept (true) __attribute__ ((__malloc__)) ;







extern int fclose (FILE *__stream);




extern int fflush (FILE *__stream);
# 227 "/usr/include/stdio.h" 3 4
extern int fflush_unlocked (FILE *__stream);
# 237 "/usr/include/stdio.h" 3 4
extern int fcloseall (void);
# 246 "/usr/include/stdio.h" 3 4
extern FILE *fopen (const char *__restrict __filename,
      const char *__restrict __modes) ;




extern FILE *freopen (const char *__restrict __filename,
        const char *__restrict __modes,
        FILE *__restrict __stream) ;
# 270 "/usr/include/stdio.h" 3 4
extern FILE *fopen64 (const char *__restrict __filename,
        const char *__restrict __modes) ;
extern FILE *freopen64 (const char *__restrict __filename,
   const char *__restrict __modes,
   FILE *__restrict __stream) ;




extern FILE *fdopen (int __fd, const char *__modes) noexcept (true) ;





extern FILE *fopencookie (void *__restrict __magic_cookie,
     const char *__restrict __modes,
     cookie_io_functions_t __io_funcs) noexcept (true) ;




extern FILE *fmemopen (void *__s, size_t __len, const char *__modes)
  noexcept (true) ;




extern FILE *open_memstream (char **__bufloc, size_t *__sizeloc) noexcept (true) ;





extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) noexcept (true);



extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
      int __modes, size_t __n) noexcept (true);




extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf,
         size_t __size) noexcept (true);


extern void setlinebuf (FILE *__stream) noexcept (true);







extern int fprintf (FILE *__restrict __stream,
      const char *__restrict __format, ...);




extern int printf (const char *__restrict __format, ...);

extern int sprintf (char *__restrict __s,
      const char *__restrict __format, ...) noexcept (true);





extern int vfprintf (FILE *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg);




extern int vprintf (const char *__restrict __format, __gnuc_va_list __arg);

extern int vsprintf (char *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg) noexcept (true);



extern int snprintf (char *__restrict __s, size_t __maxlen,
       const char *__restrict __format, ...)
     noexcept (true) __attribute__ ((__format__ (__printf__, 3, 4)));

extern int vsnprintf (char *__restrict __s, size_t __maxlen,
        const char *__restrict __format, __gnuc_va_list __arg)
     noexcept (true) __attribute__ ((__format__ (__printf__, 3, 0)));





extern int vasprintf (char **__restrict __ptr, const char *__restrict __f,
        __gnuc_va_list __arg)
     noexcept (true) __attribute__ ((__format__ (__printf__, 2, 0))) ;
extern int __asprintf (char **__restrict __ptr,
         const char *__restrict __fmt, ...)
     noexcept (true) __attribute__ ((__format__ (__printf__, 2, 3))) ;
extern int asprintf (char **__restrict __ptr,
       const char *__restrict __fmt, ...)
     noexcept (true) __attribute__ ((__format__ (__printf__, 2, 3))) ;




extern int vdprintf (int __fd, const char *__restrict __fmt,
       __gnuc_va_list __arg)
     __attribute__ ((__format__ (__printf__, 2, 0)));
extern int dprintf (int __fd, const char *__restrict __fmt, ...)
     __attribute__ ((__format__ (__printf__, 2, 3)));







extern int fscanf (FILE *__restrict __stream,
     const char *__restrict __format, ...) ;




extern int scanf (const char *__restrict __format, ...) ;

extern int sscanf (const char *__restrict __s,
     const char *__restrict __format, ...) noexcept (true);
# 410 "/usr/include/stdio.h" 3 4
extern int fscanf (FILE *__restrict __stream, const char *__restrict __format, ...) __asm__ ("" "__isoc99_fscanf")

                               ;
extern int scanf (const char *__restrict __format, ...) __asm__ ("" "__isoc99_scanf")
                              ;
extern int sscanf (const char *__restrict __s, const char *__restrict __format, ...) noexcept (true) __asm__ ("" "__isoc99_sscanf")

                      ;
# 435 "/usr/include/stdio.h" 3 4
extern int vfscanf (FILE *__restrict __s, const char *__restrict __format,
      __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 2, 0))) ;





extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 1, 0))) ;


extern int vsscanf (const char *__restrict __s,
      const char *__restrict __format, __gnuc_va_list __arg)
     noexcept (true) __attribute__ ((__format__ (__scanf__, 2, 0)));





extern int vfscanf (FILE *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vfscanf")



     __attribute__ ((__format__ (__scanf__, 2, 0))) ;
extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vscanf")

     __attribute__ ((__format__ (__scanf__, 1, 0))) ;
extern int vsscanf (const char *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) noexcept (true) __asm__ ("" "__isoc99_vsscanf")



     __attribute__ ((__format__ (__scanf__, 2, 0)));
# 489 "/usr/include/stdio.h" 3 4
extern int fgetc (FILE *__stream);
extern int getc (FILE *__stream);





extern int getchar (void);






extern int getc_unlocked (FILE *__stream);
extern int getchar_unlocked (void);
# 514 "/usr/include/stdio.h" 3 4
extern int fgetc_unlocked (FILE *__stream);
# 525 "/usr/include/stdio.h" 3 4
extern int fputc (int __c, FILE *__stream);
extern int putc (int __c, FILE *__stream);





extern int putchar (int __c);
# 541 "/usr/include/stdio.h" 3 4
extern int fputc_unlocked (int __c, FILE *__stream);







extern int putc_unlocked (int __c, FILE *__stream);
extern int putchar_unlocked (int __c);






extern int getw (FILE *__stream);


extern int putw (int __w, FILE *__stream);







extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
     __attribute__ ((__access__ (__write_only__, 1, 2)));
# 591 "/usr/include/stdio.h" 3 4
extern char *fgets_unlocked (char *__restrict __s, int __n,
        FILE *__restrict __stream)
    __attribute__ ((__access__ (__write_only__, 1, 2)));
# 608 "/usr/include/stdio.h" 3 4
extern __ssize_t __getdelim (char **__restrict __lineptr,
                             size_t *__restrict __n, int __delimiter,
                             FILE *__restrict __stream) ;
extern __ssize_t getdelim (char **__restrict __lineptr,
                           size_t *__restrict __n, int __delimiter,
                           FILE *__restrict __stream) ;







extern __ssize_t getline (char **__restrict __lineptr,
                          size_t *__restrict __n,
                          FILE *__restrict __stream) ;







extern int fputs (const char *__restrict __s, FILE *__restrict __stream);





extern int puts (const char *__s);






extern int ungetc (int __c, FILE *__stream);






extern size_t fread (void *__restrict __ptr, size_t __size,
       size_t __n, FILE *__restrict __stream) ;




extern size_t fwrite (const void *__restrict __ptr, size_t __size,
        size_t __n, FILE *__restrict __s);
# 667 "/usr/include/stdio.h" 3 4
extern int fputs_unlocked (const char *__restrict __s,
      FILE *__restrict __stream);
# 678 "/usr/include/stdio.h" 3 4
extern size_t fread_unlocked (void *__restrict __ptr, size_t __size,
         size_t __n, FILE *__restrict __stream) ;
extern size_t fwrite_unlocked (const void *__restrict __ptr, size_t __size,
          size_t __n, FILE *__restrict __stream);







extern int fseek (FILE *__stream, long int __off, int __whence);




extern long int ftell (FILE *__stream) ;




extern void rewind (FILE *__stream);
# 712 "/usr/include/stdio.h" 3 4
extern int fseeko (FILE *__stream, __off_t __off, int __whence);




extern __off_t ftello (FILE *__stream) ;
# 736 "/usr/include/stdio.h" 3 4
extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos);




extern int fsetpos (FILE *__stream, const fpos_t *__pos);
# 755 "/usr/include/stdio.h" 3 4
extern int fseeko64 (FILE *__stream, __off64_t __off, int __whence);
extern __off64_t ftello64 (FILE *__stream) ;
extern int fgetpos64 (FILE *__restrict __stream, fpos64_t *__restrict __pos);
extern int fsetpos64 (FILE *__stream, const fpos64_t *__pos);



extern void clearerr (FILE *__stream) noexcept (true);

extern int feof (FILE *__stream) noexcept (true) ;

extern int ferror (FILE *__stream) noexcept (true) ;



extern void clearerr_unlocked (FILE *__stream) noexcept (true);
extern int feof_unlocked (FILE *__stream) noexcept (true) ;
extern int ferror_unlocked (FILE *__stream) noexcept (true) ;







extern void perror (const char *__s);




extern int fileno (FILE *__stream) noexcept (true) ;




extern int fileno_unlocked (FILE *__stream) noexcept (true) ;
# 799 "/usr/include/stdio.h" 3 4
extern FILE *popen (const char *__command, const char *__modes) ;





extern int pclose (FILE *__stream);





extern char *ctermid (char *__s) noexcept (true);





extern char *cuserid (char *__s);




struct obstack;


extern int obstack_printf (struct obstack *__restrict __obstack,
      const char *__restrict __format, ...)
     noexcept (true) __attribute__ ((__format__ (__printf__, 2, 3)));
extern int obstack_vprintf (struct obstack *__restrict __obstack,
       const char *__restrict __format,
       __gnuc_va_list __args)
     noexcept (true) __attribute__ ((__format__ (__printf__, 2, 0)));







extern void flockfile (FILE *__stream) noexcept (true);



extern int ftrylockfile (FILE *__stream) noexcept (true) ;


extern void funlockfile (FILE *__stream) noexcept (true);
# 857 "/usr/include/stdio.h" 3 4
extern int __uflow (FILE *);
extern int __overflow (FILE *, int);
# 874 "/usr/include/stdio.h" 3 4
}
# 43 "/usr/include/c++/10.2.0/cstdio" 2 3
# 96 "/usr/include/c++/10.2.0/cstdio" 3
namespace std
{
  using ::FILE;
  using ::fpos_t;

  using ::clearerr;
  using ::fclose;
  using ::feof;
  using ::ferror;
  using ::fflush;
  using ::fgetc;
  using ::fgetpos;
  using ::fgets;
  using ::fopen;
  using ::fprintf;
  using ::fputc;
  using ::fputs;
  using ::fread;
  using ::freopen;
  using ::fscanf;
  using ::fseek;
  using ::fsetpos;
  using ::ftell;
  using ::fwrite;
  using ::getc;
  using ::getchar;




  using ::perror;
  using ::printf;
  using ::putc;
  using ::putchar;
  using ::puts;
  using ::remove;
  using ::rename;
  using ::rewind;
  using ::scanf;
  using ::setbuf;
  using ::setvbuf;
  using ::sprintf;
  using ::sscanf;
  using ::tmpfile;

  using ::tmpnam;

  using ::ungetc;
  using ::vfprintf;
  using ::vprintf;
  using ::vsprintf;
}
# 157 "/usr/include/c++/10.2.0/cstdio" 3
namespace __gnu_cxx
{
# 175 "/usr/include/c++/10.2.0/cstdio" 3
  using ::snprintf;
  using ::vfscanf;
  using ::vscanf;
  using ::vsnprintf;
  using ::vsscanf;

}

namespace std
{
  using ::__gnu_cxx::snprintf;
  using ::__gnu_cxx::vfscanf;
  using ::__gnu_cxx::vscanf;
  using ::__gnu_cxx::vsnprintf;
  using ::__gnu_cxx::vsscanf;
}
# 44 "/usr/include/c++/10.2.0/ext/string_conversions.h" 2 3
# 1 "/usr/include/c++/10.2.0/cerrno" 1 3
# 39 "/usr/include/c++/10.2.0/cerrno" 3
       
# 40 "/usr/include/c++/10.2.0/cerrno" 3


# 1 "/usr/include/errno.h" 1 3 4
# 28 "/usr/include/errno.h" 3 4
# 1 "/usr/include/bits/errno.h" 1 3 4
# 26 "/usr/include/bits/errno.h" 3 4
# 1 "/usr/include/linux/errno.h" 1 3 4
# 1 "/usr/include/asm/errno.h" 1 3 4
# 1 "/usr/include/asm-generic/errno.h" 1 3 4




# 1 "/usr/include/asm-generic/errno-base.h" 1 3 4
# 6 "/usr/include/asm-generic/errno.h" 2 3 4
# 2 "/usr/include/asm/errno.h" 2 3 4
# 2 "/usr/include/linux/errno.h" 2 3 4
# 27 "/usr/include/bits/errno.h" 2 3 4
# 29 "/usr/include/errno.h" 2 3 4





extern "C" {


extern int *__errno_location (void) noexcept (true) __attribute__ ((__const__));







extern char *program_invocation_name;
extern char *program_invocation_short_name;

# 1 "/usr/include/bits/types/error_t.h" 1 3 4
# 22 "/usr/include/bits/types/error_t.h" 3 4
typedef int error_t;
# 49 "/usr/include/errno.h" 2 3 4



}
# 43 "/usr/include/c++/10.2.0/cerrno" 2 3
# 45 "/usr/include/c++/10.2.0/ext/string_conversions.h" 2 3

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{



  template<typename _TRet, typename _Ret = _TRet, typename _CharT,
    typename... _Base>
    _Ret
    __stoa(_TRet (*__convf) (const _CharT*, _CharT**, _Base...),
    const char* __name, const _CharT* __str, std::size_t* __idx,
    _Base... __base)
    {
      _Ret __ret;

      _CharT* __endptr;

      struct _Save_errno {
 _Save_errno() : _M_errno((*__errno_location ())) { (*__errno_location ()) = 0; }
 ~_Save_errno() { if ((*__errno_location ()) == 0) (*__errno_location ()) = _M_errno; }
 int _M_errno;
      } const __save_errno;

      struct _Range_chk {
   static bool
   _S_chk(_TRet, std::false_type) { return false; }

   static bool
   _S_chk(_TRet __val, std::true_type)
   {
     return __val < _TRet(__numeric_traits<int>::__min)
       || __val > _TRet(__numeric_traits<int>::__max);
   }
      };

      const _TRet __tmp = __convf(__str, &__endptr, __base...);

      if (__endptr == __str)
 std::__throw_invalid_argument(__name);
      else if ((*__errno_location ()) == 34
   || _Range_chk::_S_chk(__tmp, std::is_same<_Ret, int>{}))
 std::__throw_out_of_range(__name);
      else
 __ret = __tmp;

      if (__idx)
 *__idx = __endptr - __str;

      return __ret;
    }


  template<typename _String, typename _CharT = typename _String::value_type>
    _String
    __to_xstring(int (*__convf) (_CharT*, std::size_t, const _CharT*,
     __builtin_va_list), std::size_t __n,
   const _CharT* __fmt, ...)
    {


      _CharT* __s = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
         * __n));

      __builtin_va_list __args;
      __builtin_va_start(__args, __fmt);

      const int __len = __convf(__s, __n, __fmt, __args);

      __builtin_va_end(__args);

      return _String(__s, __s + __len);
    }


}
# 6536 "/usr/include/c++/10.2.0/bits/basic_string.h" 2 3
# 1 "/usr/include/c++/10.2.0/bits/charconv.h" 1 3
# 33 "/usr/include/c++/10.2.0/bits/charconv.h" 3
       
# 34 "/usr/include/c++/10.2.0/bits/charconv.h" 3





namespace std __attribute__ ((__visibility__ ("default")))
{

namespace __detail
{

  template<typename _Tp>
    constexpr unsigned
    __to_chars_len(_Tp __value, int __base = 10) noexcept
    {
      static_assert(is_integral<_Tp>::value, "implementation bug");
      static_assert(is_unsigned<_Tp>::value, "implementation bug");

      unsigned __n = 1;
      const unsigned __b2 = __base * __base;
      const unsigned __b3 = __b2 * __base;
      const unsigned long __b4 = __b3 * __base;
      for (;;)
 {
   if (__value < (unsigned)__base) return __n;
   if (__value < __b2) return __n + 1;
   if (__value < __b3) return __n + 2;
   if (__value < __b4) return __n + 3;
   __value /= __b4;
   __n += 4;
 }
    }




  template<typename _Tp>
    void
    __to_chars_10_impl(char* __first, unsigned __len, _Tp __val) noexcept
    {
      static_assert(is_integral<_Tp>::value, "implementation bug");
      static_assert(is_unsigned<_Tp>::value, "implementation bug");

      static constexpr char __digits[201] =
 "0001020304050607080910111213141516171819"
 "2021222324252627282930313233343536373839"
 "4041424344454647484950515253545556575859"
 "6061626364656667686970717273747576777879"
 "8081828384858687888990919293949596979899";
      unsigned __pos = __len - 1;
      while (__val >= 100)
 {
   auto const __num = (__val % 100) * 2;
   __val /= 100;
   __first[__pos] = __digits[__num + 1];
   __first[__pos - 1] = __digits[__num];
   __pos -= 2;
 }
      if (__val >= 10)
 {
   auto const __num = __val * 2;
   __first[1] = __digits[__num + 1];
   __first[0] = __digits[__num];
 }
      else
 __first[0] = '0' + __val;
    }

}

}
# 6537 "/usr/include/c++/10.2.0/bits/basic_string.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

namespace __cxx11 {



  inline int
  stoi(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa<long, int>(&std::strtol, "stoi", __str.c_str(),
     __idx, __base); }

  inline long
  stol(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::strtol, "stol", __str.c_str(),
        __idx, __base); }

  inline unsigned long
  stoul(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::strtoul, "stoul", __str.c_str(),
        __idx, __base); }

  inline long long
  stoll(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::strtoll, "stoll", __str.c_str(),
        __idx, __base); }

  inline unsigned long long
  stoull(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::strtoull, "stoull", __str.c_str(),
        __idx, __base); }


  inline float
  stof(const string& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::strtof, "stof", __str.c_str(), __idx); }

  inline double
  stod(const string& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::strtod, "stod", __str.c_str(), __idx); }

  inline long double
  stold(const string& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::strtold, "stold", __str.c_str(), __idx); }




  inline string
  to_string(int __val)
  {
    const bool __neg = __val < 0;
    const unsigned __uval = __neg ? (unsigned)~__val + 1u : __val;
    const auto __len = __detail::__to_chars_len(__uval);
    string __str(__neg + __len, '-');
    __detail::__to_chars_10_impl(&__str[__neg], __len, __uval);
    return __str;
  }

  inline string
  to_string(unsigned __val)
  {
    string __str(__detail::__to_chars_len(__val), '\0');
    __detail::__to_chars_10_impl(&__str[0], __str.size(), __val);
    return __str;
  }

  inline string
  to_string(long __val)
  {
    const bool __neg = __val < 0;
    const unsigned long __uval = __neg ? (unsigned long)~__val + 1ul : __val;
    const auto __len = __detail::__to_chars_len(__uval);
    string __str(__neg + __len, '-');
    __detail::__to_chars_10_impl(&__str[__neg], __len, __uval);
    return __str;
  }

  inline string
  to_string(unsigned long __val)
  {
    string __str(__detail::__to_chars_len(__val), '\0');
    __detail::__to_chars_10_impl(&__str[0], __str.size(), __val);
    return __str;
  }

  inline string
  to_string(long long __val)
  {
    const bool __neg = __val < 0;
    const unsigned long long __uval
      = __neg ? (unsigned long long)~__val + 1ull : __val;
    const auto __len = __detail::__to_chars_len(__uval);
    string __str(__neg + __len, '-');
    __detail::__to_chars_10_impl(&__str[__neg], __len, __uval);
    return __str;
  }

  inline string
  to_string(unsigned long long __val)
  {
    string __str(__detail::__to_chars_len(__val), '\0');
    __detail::__to_chars_10_impl(&__str[0], __str.size(), __val);
    return __str;
  }




  inline string
  to_string(float __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<float>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n,
        "%f", __val);
  }

  inline string
  to_string(double __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<double>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n,
        "%f", __val);
  }

  inline string
  to_string(long double __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<long double>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n,
        "%Lf", __val);
  }



  inline int
  stoi(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa<long, int>(&std::wcstol, "stoi", __str.c_str(),
     __idx, __base); }

  inline long
  stol(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::wcstol, "stol", __str.c_str(),
        __idx, __base); }

  inline unsigned long
  stoul(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::wcstoul, "stoul", __str.c_str(),
        __idx, __base); }

  inline long long
  stoll(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::wcstoll, "stoll", __str.c_str(),
        __idx, __base); }

  inline unsigned long long
  stoull(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::wcstoull, "stoull", __str.c_str(),
        __idx, __base); }


  inline float
  stof(const wstring& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::wcstof, "stof", __str.c_str(), __idx); }

  inline double
  stod(const wstring& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::wcstod, "stod", __str.c_str(), __idx); }

  inline long double
  stold(const wstring& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::wcstold, "stold", __str.c_str(), __idx); }



  inline wstring
  to_wstring(int __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, 4 * sizeof(int),
         L"%d", __val); }

  inline wstring
  to_wstring(unsigned __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
         4 * sizeof(unsigned),
         L"%u", __val); }

  inline wstring
  to_wstring(long __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, 4 * sizeof(long),
         L"%ld", __val); }

  inline wstring
  to_wstring(unsigned long __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
         4 * sizeof(unsigned long),
         L"%lu", __val); }

  inline wstring
  to_wstring(long long __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
         4 * sizeof(long long),
         L"%lld", __val); }

  inline wstring
  to_wstring(unsigned long long __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
         4 * sizeof(unsigned long long),
         L"%llu", __val); }

  inline wstring
  to_wstring(float __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<float>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, __n,
         L"%f", __val);
  }

  inline wstring
  to_wstring(double __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<double>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, __n,
         L"%f", __val);
  }

  inline wstring
  to_wstring(long double __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<long double>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, __n,
         L"%Lf", __val);
  }



}

}





# 1 "/usr/include/c++/10.2.0/bits/functional_hash.h" 1 3
# 33 "/usr/include/c++/10.2.0/bits/functional_hash.h" 3
       
# 34 "/usr/include/c++/10.2.0/bits/functional_hash.h" 3



namespace std __attribute__ ((__visibility__ ("default")))
{

# 49 "/usr/include/c++/10.2.0/bits/functional_hash.h" 3
  template<typename _Result, typename _Arg>
    struct __hash_base
    {
      typedef _Result result_type ;
      typedef _Arg argument_type ;
    };


  template<typename _Tp>
    struct hash;

  template<typename _Tp, typename = void>
    struct __poison_hash
    {
      static constexpr bool __enable_hash_call = false;
    private:

      __poison_hash(__poison_hash&&);
      ~__poison_hash();
    };

  template<typename _Tp>
    struct __poison_hash<_Tp, __void_t<decltype(hash<_Tp>()(declval<_Tp>()))>>
    {
      static constexpr bool __enable_hash_call = true;
    };


  template<typename _Tp, bool = is_enum<_Tp>::value>
    struct __hash_enum
    {
    private:

      __hash_enum(__hash_enum&&);
      ~__hash_enum();
    };


  template<typename _Tp>
    struct __hash_enum<_Tp, true> : public __hash_base<size_t, _Tp>
    {
      size_t
      operator()(_Tp __val) const noexcept
      {
       using __type = typename underlying_type<_Tp>::type;
       return hash<__type>{}(static_cast<__type>(__val));
      }
    };



  template<typename _Tp>
    struct hash : __hash_enum<_Tp>
    { };


  template<typename _Tp>
    struct hash<_Tp*> : public __hash_base<size_t, _Tp*>
    {
      size_t
      operator()(_Tp* __p) const noexcept
      { return reinterpret_cast<size_t>(__p); }
    };
# 124 "/usr/include/c++/10.2.0/bits/functional_hash.h" 3
  template<> struct hash<bool> : public __hash_base<size_t, bool> { size_t operator()(bool __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<char> : public __hash_base<size_t, char> { size_t operator()(char __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<signed char> : public __hash_base<size_t, signed char> { size_t operator()(signed char __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned char> : public __hash_base<size_t, unsigned char> { size_t operator()(unsigned char __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<wchar_t> : public __hash_base<size_t, wchar_t> { size_t operator()(wchar_t __val) const noexcept { return static_cast<size_t>(__val); } };







  template<> struct hash<char16_t> : public __hash_base<size_t, char16_t> { size_t operator()(char16_t __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<char32_t> : public __hash_base<size_t, char32_t> { size_t operator()(char32_t __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<short> : public __hash_base<size_t, short> { size_t operator()(short __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<int> : public __hash_base<size_t, int> { size_t operator()(int __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<long> : public __hash_base<size_t, long> { size_t operator()(long __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<long long> : public __hash_base<size_t, long long> { size_t operator()(long long __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned short> : public __hash_base<size_t, unsigned short> { size_t operator()(unsigned short __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned int> : public __hash_base<size_t, unsigned int> { size_t operator()(unsigned int __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned long> : public __hash_base<size_t, unsigned long> { size_t operator()(unsigned long __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned long long> : public __hash_base<size_t, unsigned long long> { size_t operator()(unsigned long long __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<__int128> : public __hash_base<size_t, __int128> { size_t operator()(__int128 __val) const noexcept { return static_cast<size_t>(__val); } };
  template<> struct hash<__int128 unsigned> : public __hash_base<size_t, __int128 unsigned> { size_t operator()(__int128 unsigned __val) const noexcept { return static_cast<size_t>(__val); } };
# 192 "/usr/include/c++/10.2.0/bits/functional_hash.h" 3
  struct _Hash_impl
  {
    static size_t
    hash(const void* __ptr, size_t __clength,
  size_t __seed = static_cast<size_t>(0xc70f6907UL))
    { return _Hash_bytes(__ptr, __clength, __seed); }

    template<typename _Tp>
      static size_t
      hash(const _Tp& __val)
      { return hash(&__val, sizeof(__val)); }

    template<typename _Tp>
      static size_t
      __hash_combine(const _Tp& __val, size_t __hash)
      { return hash(&__val, sizeof(__val), __hash); }
  };


  struct _Fnv_hash_impl
  {
    static size_t
    hash(const void* __ptr, size_t __clength,
  size_t __seed = static_cast<size_t>(2166136261UL))
    { return _Fnv_hash_bytes(__ptr, __clength, __seed); }

    template<typename _Tp>
      static size_t
      hash(const _Tp& __val)
      { return hash(&__val, sizeof(__val)); }

    template<typename _Tp>
      static size_t
      __hash_combine(const _Tp& __val, size_t __hash)
      { return hash(&__val, sizeof(__val), __hash); }
  };


  template<>
    struct hash<float> : public __hash_base<size_t, float>
    {
      size_t
      operator()(float __val) const noexcept
      {

 return __val != 0.0f ? std::_Hash_impl::hash(__val) : 0;
      }
    };


  template<>
    struct hash<double> : public __hash_base<size_t, double>
    {
      size_t
      operator()(double __val) const noexcept
      {

 return __val != 0.0 ? std::_Hash_impl::hash(__val) : 0;
      }
    };


  template<>
    struct hash<long double>
    : public __hash_base<size_t, long double>
    {
      __attribute__ ((__pure__)) size_t
      operator()(long double __val) const noexcept;
    };
# 278 "/usr/include/c++/10.2.0/bits/functional_hash.h" 3
  template<typename _Hash>
    struct __is_fast_hash : public std::true_type
    { };

  template<>
    struct __is_fast_hash<hash<long double>> : public std::false_type
    { };


}
# 6788 "/usr/include/c++/10.2.0/bits/basic_string.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{






  template<>
    struct hash<string>
    : public __hash_base<size_t, string>
    {
      size_t
      operator()(const string& __s) const noexcept
      { return std::_Hash_impl::hash(__s.data(), __s.length()); }
    };

  template<>
    struct __is_fast_hash<hash<string>> : std::false_type
    { };



  template<>
    struct hash<wstring>
    : public __hash_base<size_t, wstring>
    {
      size_t
      operator()(const wstring& __s) const noexcept
      { return std::_Hash_impl::hash(__s.data(),
                                     __s.length() * sizeof(wchar_t)); }
    };

  template<>
    struct __is_fast_hash<hash<wstring>> : std::false_type
    { };
# 6846 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
  template<>
    struct hash<u16string>
    : public __hash_base<size_t, u16string>
    {
      size_t
      operator()(const u16string& __s) const noexcept
      { return std::_Hash_impl::hash(__s.data(),
                                     __s.length() * sizeof(char16_t)); }
    };

  template<>
    struct __is_fast_hash<hash<u16string>> : std::false_type
    { };


  template<>
    struct hash<u32string>
    : public __hash_base<size_t, u32string>
    {
      size_t
      operator()(const u32string& __s) const noexcept
      { return std::_Hash_impl::hash(__s.data(),
                                     __s.length() * sizeof(char32_t)); }
    };

  template<>
    struct __is_fast_hash<hash<u32string>> : std::false_type
    { };





  inline namespace literals
  {
  inline namespace string_literals
  {
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wliteral-suffix"
    __attribute ((__abi_tag__ ("cxx11")))
    inline basic_string<char>
    operator""s(const char* __str, size_t __len)
    { return basic_string<char>{__str, __len}; }


    __attribute ((__abi_tag__ ("cxx11")))
    inline basic_string<wchar_t>
    operator""s(const wchar_t* __str, size_t __len)
    { return basic_string<wchar_t>{__str, __len}; }
# 6904 "/usr/include/c++/10.2.0/bits/basic_string.h" 3
    __attribute ((__abi_tag__ ("cxx11")))
    inline basic_string<char16_t>
    operator""s(const char16_t* __str, size_t __len)
    { return basic_string<char16_t>{__str, __len}; }

    __attribute ((__abi_tag__ ("cxx11")))
    inline basic_string<char32_t>
    operator""s(const char32_t* __str, size_t __len)
    { return basic_string<char32_t>{__str, __len}; }

#pragma GCC diagnostic pop
  }
  }
# 6936 "/usr/include/c++/10.2.0/bits/basic_string.h" 3

}
# 56 "/usr/include/c++/10.2.0/string" 2 3
# 1 "/usr/include/c++/10.2.0/bits/basic_string.tcc" 1 3
# 42 "/usr/include/c++/10.2.0/bits/basic_string.tcc" 3
       
# 43 "/usr/include/c++/10.2.0/bits/basic_string.tcc" 3



namespace std __attribute__ ((__visibility__ ("default")))
{




  template<typename _CharT, typename _Traits, typename _Alloc>
    const typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::npos;

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    swap(basic_string& __s) noexcept
    {
      if (this == &__s)
 return;

      _Alloc_traits::_S_on_swap(_M_get_allocator(), __s._M_get_allocator());

      if (_M_is_local())
 if (__s._M_is_local())
   {
     if (length() && __s.length())
       {
  _CharT __tmp_data[_S_local_capacity + 1];
  traits_type::copy(__tmp_data, __s._M_local_buf,
      _S_local_capacity + 1);
  traits_type::copy(__s._M_local_buf, _M_local_buf,
      _S_local_capacity + 1);
  traits_type::copy(_M_local_buf, __tmp_data,
      _S_local_capacity + 1);
       }
     else if (__s.length())
       {
  traits_type::copy(_M_local_buf, __s._M_local_buf,
      _S_local_capacity + 1);
  _M_length(__s.length());
  __s._M_set_length(0);
  return;
       }
     else if (length())
       {
  traits_type::copy(__s._M_local_buf, _M_local_buf,
      _S_local_capacity + 1);
  __s._M_length(length());
  _M_set_length(0);
  return;
       }
   }
 else
   {
     const size_type __tmp_capacity = __s._M_allocated_capacity;
     traits_type::copy(__s._M_local_buf, _M_local_buf,
         _S_local_capacity + 1);
     _M_data(__s._M_data());
     __s._M_data(__s._M_local_buf);
     _M_capacity(__tmp_capacity);
   }
      else
 {
   const size_type __tmp_capacity = _M_allocated_capacity;
   if (__s._M_is_local())
     {
       traits_type::copy(_M_local_buf, __s._M_local_buf,
    _S_local_capacity + 1);
       __s._M_data(_M_data());
       _M_data(_M_local_buf);
     }
   else
     {
       pointer __tmp_ptr = _M_data();
       _M_data(__s._M_data());
       __s._M_data(__tmp_ptr);
       _M_capacity(__s._M_allocated_capacity);
     }
   __s._M_capacity(__tmp_capacity);
 }

      const size_type __tmp_length = length();
      _M_length(__s.length());
      __s._M_length(__tmp_length);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::pointer
    basic_string<_CharT, _Traits, _Alloc>::
    _M_create(size_type& __capacity, size_type __old_capacity)
    {


      if (__capacity > max_size())
 std::__throw_length_error(("basic_string::_M_create"));




      if (__capacity > __old_capacity && __capacity < 2 * __old_capacity)
 {
   __capacity = 2 * __old_capacity;

   if (__capacity > max_size())
     __capacity = max_size();
 }



      return _Alloc_traits::allocate(_M_get_allocator(), __capacity + 1);
    }





  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InIterator>
      void
      basic_string<_CharT, _Traits, _Alloc>::
      _M_construct(_InIterator __beg, _InIterator __end,
     std::input_iterator_tag)
      {
 size_type __len = 0;
 size_type __capacity = size_type(_S_local_capacity);

 while (__beg != __end && __len < __capacity)
   {
     _M_data()[__len++] = *__beg;
     ++__beg;
   }

 try
   {
     while (__beg != __end)
       {
  if (__len == __capacity)
    {

      __capacity = __len + 1;
      pointer __another = _M_create(__capacity, __len);
      this->_S_copy(__another, _M_data(), __len);
      _M_dispose();
      _M_data(__another);
      _M_capacity(__capacity);
    }
  _M_data()[__len++] = *__beg;
  ++__beg;
       }
   }
 catch(...)
   {
     _M_dispose();
     throw;
   }

 _M_set_length(__len);
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InIterator>
      void
      basic_string<_CharT, _Traits, _Alloc>::
      _M_construct(_InIterator __beg, _InIterator __end,
     std::forward_iterator_tag)
      {

 if (__gnu_cxx::__is_null_pointer(__beg) && __beg != __end)
   std::__throw_logic_error(("basic_string::" "_M_construct null not valid")
                                         );

 size_type __dnew = static_cast<size_type>(std::distance(__beg, __end));

 if (__dnew > size_type(_S_local_capacity))
   {
     _M_data(_M_create(__dnew, size_type(0)));
     _M_capacity(__dnew);
   }


 try
   { this->_S_copy_chars(_M_data(), __beg, __end); }
 catch(...)
   {
     _M_dispose();
     throw;
   }

 _M_set_length(__dnew);
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_construct(size_type __n, _CharT __c)
    {
      if (__n > size_type(_S_local_capacity))
 {
   _M_data(_M_create(__n, size_type(0)));
   _M_capacity(__n);
 }

      if (__n)
 this->_S_assign(_M_data(), __n, __c);

      _M_set_length(__n);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_assign(const basic_string& __str)
    {
      if (this != &__str)
 {
   const size_type __rsize = __str.length();
   const size_type __capacity = capacity();

   if (__rsize > __capacity)
     {
       size_type __new_capacity = __rsize;
       pointer __tmp = _M_create(__new_capacity, __capacity);
       _M_dispose();
       _M_data(__tmp);
       _M_capacity(__new_capacity);
     }

   if (__rsize)
     this->_S_copy(_M_data(), __str._M_data(), __rsize);

   _M_set_length(__rsize);
 }
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    reserve(size_type __res)
    {

      if (__res < length())
 __res = length();

      const size_type __capacity = capacity();
      if (__res != __capacity)
 {
   if (__res > __capacity
       || __res > size_type(_S_local_capacity))
     {
       pointer __tmp = _M_create(__res, __capacity);
       this->_S_copy(__tmp, _M_data(), length() + 1);
       _M_dispose();
       _M_data(__tmp);
       _M_capacity(__res);
     }
   else if (!_M_is_local())
     {
       this->_S_copy(_M_local_data(), _M_data(), length() + 1);
       _M_destroy(__capacity);
       _M_data(_M_local_data());
     }
 }
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_mutate(size_type __pos, size_type __len1, const _CharT* __s,
       size_type __len2)
    {
      const size_type __how_much = length() - __pos - __len1;

      size_type __new_capacity = length() + __len2 - __len1;
      pointer __r = _M_create(__new_capacity, capacity());

      if (__pos)
 this->_S_copy(__r, _M_data(), __pos);
      if (__s && __len2)
 this->_S_copy(__r + __pos, __s, __len2);
      if (__how_much)
 this->_S_copy(__r + __pos + __len2,
        _M_data() + __pos + __len1, __how_much);

      _M_dispose();
      _M_data(__r);
      _M_capacity(__new_capacity);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_erase(size_type __pos, size_type __n)
    {
      const size_type __how_much = length() - __pos - __n;

      if (__how_much && __n)
 this->_S_move(_M_data() + __pos, _M_data() + __pos + __n, __how_much);

      _M_set_length(length() - __n);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    resize(size_type __n, _CharT __c)
    {
      const size_type __size = this->size();
      if (__size < __n)
 this->append(__n - __size, __c);
      else if (__n < __size)
 this->_M_set_length(__n);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_append(const _CharT* __s, size_type __n)
    {
      const size_type __len = __n + this->size();

      if (__len <= this->capacity())
 {
   if (__n)
     this->_S_copy(this->_M_data() + this->size(), __s, __n);
 }
      else
 this->_M_mutate(this->size(), size_type(0), __s, __n);

      this->_M_set_length(__len);
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InputIterator>
      basic_string<_CharT, _Traits, _Alloc>&
      basic_string<_CharT, _Traits, _Alloc>::
      _M_replace_dispatch(const_iterator __i1, const_iterator __i2,
     _InputIterator __k1, _InputIterator __k2,
     std::__false_type)
      {


 const basic_string __s(__k1, __k2, this->get_allocator());
 const size_type __n1 = __i2 - __i1;
 return _M_replace(__i1 - begin(), __n1, __s._M_data(),
     __s.size());
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
     _CharT __c)
    {
      _M_check_length(__n1, __n2, "basic_string::_M_replace_aux");

      const size_type __old_size = this->size();
      const size_type __new_size = __old_size + __n2 - __n1;

      if (__new_size <= this->capacity())
 {
   pointer __p = this->_M_data() + __pos1;

   const size_type __how_much = __old_size - __pos1 - __n1;
   if (__how_much && __n1 != __n2)
     this->_S_move(__p + __n2, __p + __n1, __how_much);
 }
      else
 this->_M_mutate(__pos1, __n1, 0, __n2);

      if (__n2)
 this->_S_assign(this->_M_data() + __pos1, __n2, __c);

      this->_M_set_length(__new_size);
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_replace(size_type __pos, size_type __len1, const _CharT* __s,
        const size_type __len2)
    {
      _M_check_length(__len1, __len2, "basic_string::_M_replace");

      const size_type __old_size = this->size();
      const size_type __new_size = __old_size + __len2 - __len1;

      if (__new_size <= this->capacity())
 {
   pointer __p = this->_M_data() + __pos;

   const size_type __how_much = __old_size - __pos - __len1;
   if (_M_disjunct(__s))
     {
       if (__how_much && __len1 != __len2)
  this->_S_move(__p + __len2, __p + __len1, __how_much);
       if (__len2)
  this->_S_copy(__p, __s, __len2);
     }
   else
     {

       if (__len2 && __len2 <= __len1)
  this->_S_move(__p, __s, __len2);
       if (__how_much && __len1 != __len2)
  this->_S_move(__p + __len2, __p + __len1, __how_much);
       if (__len2 > __len1)
  {
    if (__s + __len2 <= __p + __len1)
      this->_S_move(__p, __s, __len2);
    else if (__s >= __p + __len1)
      this->_S_copy(__p, __s + __len2 - __len1, __len2);
    else
      {
        const size_type __nleft = (__p + __len1) - __s;
        this->_S_move(__p, __s, __nleft);
        this->_S_copy(__p + __nleft, __p + __len2,
        __len2 - __nleft);
      }
  }
     }
 }
      else
 this->_M_mutate(__pos, __len1, __s, __len2);

      this->_M_set_length(__new_size);
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    copy(_CharT* __s, size_type __n, size_type __pos) const
    {
      _M_check(__pos, "basic_string::copy");
      __n = _M_limit(__pos, __n);
      ;
      if (__n)
 _S_copy(__s, _M_data() + __pos, __n);

      return __n;
    }
# 1158 "/usr/include/c++/10.2.0/bits/basic_string.tcc" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      ;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
 rebind<_CharT>::other _Char_alloc_type;
      typedef __gnu_cxx::__alloc_traits<_Char_alloc_type> _Alloc_traits;
      const __size_type __len = _Traits::length(__lhs);
      __string_type __str(_Alloc_traits::_S_select_on_copy(
          __rhs.get_allocator()));
      __str.reserve(__len + __rhs.size());
      __str.append(__lhs, __len);
      __str.append(__rhs);
      return __str;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(_CharT __lhs, const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
 rebind<_CharT>::other _Char_alloc_type;
      typedef __gnu_cxx::__alloc_traits<_Char_alloc_type> _Alloc_traits;
      __string_type __str(_Alloc_traits::_S_select_on_copy(
          __rhs.get_allocator()));
      const __size_type __len = __rhs.size();
      __str.reserve(__len + 1);
      __str.append(__size_type(1), __lhs);
      __str.append(__rhs);
      return __str;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find(const _CharT* __s, size_type __pos, size_type __n) const
    noexcept
    {
      ;
      const size_type __size = this->size();

      if (__n == 0)
 return __pos <= __size ? __pos : npos;
      if (__pos >= __size)
 return npos;

      const _CharT __elem0 = __s[0];
      const _CharT* const __data = data();
      const _CharT* __first = __data + __pos;
      const _CharT* const __last = __data + __size;
      size_type __len = __size - __pos;

      while (__len >= __n)
 {

   __first = traits_type::find(__first, __len - __n + 1, __elem0);
   if (!__first)
     return npos;



   if (traits_type::compare(__first, __s, __n) == 0)
     return __first - __data;
   __len = __last - ++__first;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find(_CharT __c, size_type __pos) const noexcept
    {
      size_type __ret = npos;
      const size_type __size = this->size();
      if (__pos < __size)
 {
   const _CharT* __data = _M_data();
   const size_type __n = __size - __pos;
   const _CharT* __p = traits_type::find(__data + __pos, __n, __c);
   if (__p)
     __ret = __p - __data;
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    rfind(const _CharT* __s, size_type __pos, size_type __n) const
    noexcept
    {
      ;
      const size_type __size = this->size();
      if (__n <= __size)
 {
   __pos = std::min(size_type(__size - __n), __pos);
   const _CharT* __data = _M_data();
   do
     {
       if (traits_type::compare(__data + __pos, __s, __n) == 0)
  return __pos;
     }
   while (__pos-- > 0);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    rfind(_CharT __c, size_type __pos) const noexcept
    {
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   for (++__size; __size-- > 0; )
     if (traits_type::eq(_M_data()[__size], __c))
       return __size;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_of(const _CharT* __s, size_type __pos, size_type __n) const
    noexcept
    {
      ;
      for (; __n && __pos < this->size(); ++__pos)
 {
   const _CharT* __p = traits_type::find(__s, __n, _M_data()[__pos]);
   if (__p)
     return __pos;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_of(const _CharT* __s, size_type __pos, size_type __n) const
    noexcept
    {
      ;
      size_type __size = this->size();
      if (__size && __n)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (traits_type::find(__s, __n, _M_data()[__size]))
  return __size;
     }
   while (__size-- != 0);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_not_of(const _CharT* __s, size_type __pos, size_type __n) const
    noexcept
    {
      ;
      for (; __pos < this->size(); ++__pos)
 if (!traits_type::find(__s, __n, _M_data()[__pos]))
   return __pos;
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_not_of(_CharT __c, size_type __pos) const noexcept
    {
      for (; __pos < this->size(); ++__pos)
 if (!traits_type::eq(_M_data()[__pos], __c))
   return __pos;
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_not_of(const _CharT* __s, size_type __pos, size_type __n) const
    noexcept
    {
      ;
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (!traits_type::find(__s, __n, _M_data()[__size]))
  return __size;
     }
   while (__size--);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_not_of(_CharT __c, size_type __pos) const noexcept
    {
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (!traits_type::eq(_M_data()[__size], __c))
  return __size;
     }
   while (__size--);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n, const basic_string& __str) const
    {
      _M_check(__pos, "basic_string::compare");
      __n = _M_limit(__pos, __n);
      const size_type __osize = __str.size();
      const size_type __len = std::min(__n, __osize);
      int __r = traits_type::compare(_M_data() + __pos, __str.data(), __len);
      if (!__r)
 __r = _S_compare(__n, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(size_type __pos1, size_type __n1, const basic_string& __str,
     size_type __pos2, size_type __n2) const
    {
      _M_check(__pos1, "basic_string::compare");
      __str._M_check(__pos2, "basic_string::compare");
      __n1 = _M_limit(__pos1, __n1);
      __n2 = __str._M_limit(__pos2, __n2);
      const size_type __len = std::min(__n1, __n2);
      int __r = traits_type::compare(_M_data() + __pos1,
         __str.data() + __pos2, __len);
      if (!__r)
 __r = _S_compare(__n1, __n2);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(const _CharT* __s) const noexcept
    {
      ;
      const size_type __size = this->size();
      const size_type __osize = traits_type::length(__s);
      const size_type __len = std::min(__size, __osize);
      int __r = traits_type::compare(_M_data(), __s, __len);
      if (!__r)
 __r = _S_compare(__size, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string <_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n1, const _CharT* __s) const
    {
      ;
      _M_check(__pos, "basic_string::compare");
      __n1 = _M_limit(__pos, __n1);
      const size_type __osize = traits_type::length(__s);
      const size_type __len = std::min(__n1, __osize);
      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
      if (!__r)
 __r = _S_compare(__n1, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string <_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n1, const _CharT* __s,
     size_type __n2) const
    {
      ;
      _M_check(__pos, "basic_string::compare");
      __n1 = _M_limit(__pos, __n1);
      const size_type __len = std::min(__n1, __n2);
      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
      if (!__r)
 __r = _S_compare(__n1, __n2);
      return __r;
    }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in,
        basic_string<_CharT, _Traits, _Alloc>& __str)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __istream_type::ios_base __ios_base;
      typedef typename __istream_type::int_type __int_type;
      typedef typename __string_type::size_type __size_type;
      typedef ctype<_CharT> __ctype_type;
      typedef typename __ctype_type::ctype_base __ctype_base;

      __size_type __extracted = 0;
      typename __ios_base::iostate __err = __ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   try
     {

       __str.erase();
       _CharT __buf[128];
       __size_type __len = 0;
       const streamsize __w = __in.width();
       const __size_type __n = __w > 0 ? static_cast<__size_type>(__w)
                                : __str.max_size();
       const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());
       const __int_type __eof = _Traits::eof();
       __int_type __c = __in.rdbuf()->sgetc();

       while (__extracted < __n
       && !_Traits::eq_int_type(__c, __eof)
       && !__ct.is(__ctype_base::space,
     _Traits::to_char_type(__c)))
  {
    if (__len == sizeof(__buf) / sizeof(_CharT))
      {
        __str.append(__buf, sizeof(__buf) / sizeof(_CharT));
        __len = 0;
      }
    __buf[__len++] = _Traits::to_char_type(__c);
    ++__extracted;
    __c = __in.rdbuf()->snextc();
  }
       __str.append(__buf, __len);

       if (_Traits::eq_int_type(__c, __eof))
  __err |= __ios_base::eofbit;
       __in.width(0);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(__ios_base::badbit);
       throw;
     }
   catch(...)
     {



       __in._M_setstate(__ios_base::badbit);
     }
 }

      if (!__extracted)
 __err |= __ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __in,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __istream_type::ios_base __ios_base;
      typedef typename __istream_type::int_type __int_type;
      typedef typename __string_type::size_type __size_type;

      __size_type __extracted = 0;
      const __size_type __n = __str.max_size();
      typename __ios_base::iostate __err = __ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, true);
      if (__cerb)
 {
   try
     {
       __str.erase();
       const __int_type __idelim = _Traits::to_int_type(__delim);
       const __int_type __eof = _Traits::eof();
       __int_type __c = __in.rdbuf()->sgetc();

       while (__extracted < __n
       && !_Traits::eq_int_type(__c, __eof)
       && !_Traits::eq_int_type(__c, __idelim))
  {
    __str += _Traits::to_char_type(__c);
    ++__extracted;
    __c = __in.rdbuf()->snextc();
  }

       if (_Traits::eq_int_type(__c, __eof))
  __err |= __ios_base::eofbit;
       else if (_Traits::eq_int_type(__c, __idelim))
  {
    ++__extracted;
    __in.rdbuf()->sbumpc();
  }
       else
  __err |= __ios_base::failbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(__ios_base::badbit);
       throw;
     }
   catch(...)
     {



       __in._M_setstate(__ios_base::badbit);
     }
 }
      if (!__extracted)
 __err |= __ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }
# 1618 "/usr/include/c++/10.2.0/bits/basic_string.tcc" 3
  extern template class basic_string<char>;







  extern template
    basic_istream<char>&
    operator>>(basic_istream<char>&, string&);
  extern template
    basic_ostream<char>&
    operator<<(basic_ostream<char>&, const string&);
  extern template
    basic_istream<char>&
    getline(basic_istream<char>&, string&, char);
  extern template
    basic_istream<char>&
    getline(basic_istream<char>&, string&);



  extern template class basic_string<wchar_t>;





  extern template
    basic_istream<wchar_t>&
    operator>>(basic_istream<wchar_t>&, wstring&);
  extern template
    basic_ostream<wchar_t>&
    operator<<(basic_ostream<wchar_t>&, const wstring&);
  extern template
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>&, wstring&, wchar_t);
  extern template
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>&, wstring&);




}
# 57 "/usr/include/c++/10.2.0/string" 2 3
# 41 "/usr/include/c++/10.2.0/bits/locale_classes.h" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{

# 62 "/usr/include/c++/10.2.0/bits/locale_classes.h" 3
  class locale
  {
  public:


    typedef int category;


    class facet;
    class id;
    class _Impl;

    friend class facet;
    friend class _Impl;

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Cache>
      friend struct __use_cache;
# 98 "/usr/include/c++/10.2.0/bits/locale_classes.h" 3
    static const category none = 0;
    static const category ctype = 1L << 0;
    static const category numeric = 1L << 1;
    static const category collate = 1L << 2;
    static const category time = 1L << 3;
    static const category monetary = 1L << 4;
    static const category messages = 1L << 5;
    static const category all = (ctype | numeric | collate |
        time | monetary | messages);
# 117 "/usr/include/c++/10.2.0/bits/locale_classes.h" 3
    locale() throw();
# 126 "/usr/include/c++/10.2.0/bits/locale_classes.h" 3
    locale(const locale& __other) throw();
# 136 "/usr/include/c++/10.2.0/bits/locale_classes.h" 3
    explicit
    locale(const char* __s);
# 151 "/usr/include/c++/10.2.0/bits/locale_classes.h" 3
    locale(const locale& __base, const char* __s, category __cat);
# 162 "/usr/include/c++/10.2.0/bits/locale_classes.h" 3
    explicit
    locale(const std::string& __s) : locale(__s.c_str()) { }
# 177 "/usr/include/c++/10.2.0/bits/locale_classes.h" 3
    locale(const locale& __base, const std::string& __s, category __cat)
    : locale(__base, __s.c_str(), __cat) { }
# 192 "/usr/include/c++/10.2.0/bits/locale_classes.h" 3
    locale(const locale& __base, const locale& __add, category __cat);
# 205 "/usr/include/c++/10.2.0/bits/locale_classes.h" 3
    template<typename _Facet>
      locale(const locale& __other, _Facet* __f);


    ~locale() throw();
# 219 "/usr/include/c++/10.2.0/bits/locale_classes.h" 3
    const locale&
    operator=(const locale& __other) throw();
# 234 "/usr/include/c++/10.2.0/bits/locale_classes.h" 3
    template<typename _Facet>
      locale
      combine(const locale& __other) const;






    __attribute ((__abi_tag__ ("cxx11")))
    string
    name() const;
# 254 "/usr/include/c++/10.2.0/bits/locale_classes.h" 3
    bool
    operator==(const locale& __other) const throw();
# 264 "/usr/include/c++/10.2.0/bits/locale_classes.h" 3
    bool
    operator!=(const locale& __other) const throw()
    { return !(this->operator==(__other)); }
# 284 "/usr/include/c++/10.2.0/bits/locale_classes.h" 3
    template<typename _Char, typename _Traits, typename _Alloc>
      bool
      operator()(const basic_string<_Char, _Traits, _Alloc>& __s1,
   const basic_string<_Char, _Traits, _Alloc>& __s2) const;
# 300 "/usr/include/c++/10.2.0/bits/locale_classes.h" 3
    static locale
    global(const locale& __loc);




    static const locale&
    classic();

  private:

    _Impl* _M_impl;


    static _Impl* _S_classic;


    static _Impl* _S_global;





    static const char* const* const _S_categories;
# 335 "/usr/include/c++/10.2.0/bits/locale_classes.h" 3
    enum { _S_categories_size = 6 + 6 };


    static __gthread_once_t _S_once;


    explicit
    locale(_Impl*) throw();

    static void
    _S_initialize();

    static void
    _S_initialize_once() throw();

    static category
    _S_normalize_category(category);

    void
    _M_coalesce(const locale& __base, const locale& __add, category __cat);


    static const id* const _S_twinned_facets[];

  };
# 373 "/usr/include/c++/10.2.0/bits/locale_classes.h" 3
  class locale::facet
  {
  private:
    friend class locale;
    friend class locale::_Impl;

    mutable _Atomic_word _M_refcount;


    static __c_locale _S_c_locale;


    static const char _S_c_name[2];


    static __gthread_once_t _S_once;


    static void
    _S_initialize_once();

  protected:
# 404 "/usr/include/c++/10.2.0/bits/locale_classes.h" 3
    explicit
    facet(size_t __refs = 0) throw() : _M_refcount(__refs ? 1 : 0)
    { }


    virtual
    ~facet();

    static void
    _S_create_c_locale(__c_locale& __cloc, const char* __s,
         __c_locale __old = 0);

    static __c_locale
    _S_clone_c_locale(__c_locale& __cloc) throw();

    static void
    _S_destroy_c_locale(__c_locale& __cloc);

    static __c_locale
    _S_lc_ctype_c_locale(__c_locale __cloc, const char* __s);



    static __c_locale
    _S_get_c_locale();

    __attribute__ ((__const__)) static const char*
    _S_get_c_name() throw();
# 440 "/usr/include/c++/10.2.0/bits/locale_classes.h" 3
    facet(const facet&) = delete;

    facet&
    operator=(const facet&) = delete;


  private:
    void
    _M_add_reference() const throw()
    { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }

    void
    _M_remove_reference() const throw()
    {

      ;
      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1) == 1)
 {
          ;
   try
     { delete this; }
   catch(...)
     { }
 }
    }

    const facet* _M_sso_shim(const id*) const;
    const facet* _M_cow_shim(const id*) const;

  protected:
    class __shim;
  };
# 485 "/usr/include/c++/10.2.0/bits/locale_classes.h" 3
  class locale::id
  {
  private:
    friend class locale;
    friend class locale::_Impl;

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();




    mutable size_t _M_index;


    static _Atomic_word _S_refcount;

    void
    operator=(const id&);

    id(const id&);

  public:



    id() { }

    size_t
    _M_id() const throw();
  };



  class locale::_Impl
  {
  public:

    friend class locale;
    friend class locale::facet;

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Cache>
      friend struct __use_cache;

  private:

    _Atomic_word _M_refcount;
    const facet** _M_facets;
    size_t _M_facets_size;
    const facet** _M_caches;
    char** _M_names;
    static const locale::id* const _S_id_ctype[];
    static const locale::id* const _S_id_numeric[];
    static const locale::id* const _S_id_collate[];
    static const locale::id* const _S_id_time[];
    static const locale::id* const _S_id_monetary[];
    static const locale::id* const _S_id_messages[];
    static const locale::id* const* const _S_facet_categories[];

    void
    _M_add_reference() throw()
    { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }

    void
    _M_remove_reference() throw()
    {

      ;
      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1) == 1)
 {
          ;
   try
     { delete this; }
   catch(...)
     { }
 }
    }

    _Impl(const _Impl&, size_t);
    _Impl(const char*, size_t);
    _Impl(size_t) throw();

   ~_Impl() throw();

    _Impl(const _Impl&);

    void
    operator=(const _Impl&);

    bool
    _M_check_same_name()
    {
      bool __ret = true;
      if (_M_names[1])

 for (size_t __i = 0; __ret && __i < _S_categories_size - 1; ++__i)
   __ret = __builtin_strcmp(_M_names[__i], _M_names[__i + 1]) == 0;
      return __ret;
    }

    void
    _M_replace_categories(const _Impl*, category);

    void
    _M_replace_category(const _Impl*, const locale::id* const*);

    void
    _M_replace_facet(const _Impl*, const locale::id*);

    void
    _M_install_facet(const locale::id*, const facet*);

    template<typename _Facet>
      void
      _M_init_facet(_Facet* __facet)
      { _M_install_facet(&_Facet::id, __facet); }

    template<typename _Facet>
      void
      _M_init_facet_unchecked(_Facet* __facet)
      {
 __facet->_M_add_reference();
 _M_facets[_Facet::id._M_id()] = __facet;
      }

    void
    _M_install_cache(const facet*, size_t);

    void _M_init_extra(facet**);
    void _M_init_extra(void*, void*, const char*, const char*);
  };
# 643 "/usr/include/c++/10.2.0/bits/locale_classes.h" 3
  template<typename _CharT>
    class __cxx11:: collate : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;


    protected:


      __c_locale _M_c_locale_collate;

    public:

      static locale::id id;
# 670 "/usr/include/c++/10.2.0/bits/locale_classes.h" 3
      explicit
      collate(size_t __refs = 0)
      : facet(__refs), _M_c_locale_collate(_S_get_c_locale())
      { }
# 684 "/usr/include/c++/10.2.0/bits/locale_classes.h" 3
      explicit
      collate(__c_locale __cloc, size_t __refs = 0)
      : facet(__refs), _M_c_locale_collate(_S_clone_c_locale(__cloc))
      { }
# 701 "/usr/include/c++/10.2.0/bits/locale_classes.h" 3
      int
      compare(const _CharT* __lo1, const _CharT* __hi1,
       const _CharT* __lo2, const _CharT* __hi2) const
      { return this->do_compare(__lo1, __hi1, __lo2, __hi2); }
# 720 "/usr/include/c++/10.2.0/bits/locale_classes.h" 3
      string_type
      transform(const _CharT* __lo, const _CharT* __hi) const
      { return this->do_transform(__lo, __hi); }
# 734 "/usr/include/c++/10.2.0/bits/locale_classes.h" 3
      long
      hash(const _CharT* __lo, const _CharT* __hi) const
      { return this->do_hash(__lo, __hi); }


      int
      _M_compare(const _CharT*, const _CharT*) const throw();

      size_t
      _M_transform(_CharT*, const _CharT*, size_t) const throw();

  protected:

      virtual
      ~collate()
      { _S_destroy_c_locale(_M_c_locale_collate); }
# 763 "/usr/include/c++/10.2.0/bits/locale_classes.h" 3
      virtual int
      do_compare(const _CharT* __lo1, const _CharT* __hi1,
   const _CharT* __lo2, const _CharT* __hi2) const;
# 777 "/usr/include/c++/10.2.0/bits/locale_classes.h" 3
      virtual string_type
      do_transform(const _CharT* __lo, const _CharT* __hi) const;
# 790 "/usr/include/c++/10.2.0/bits/locale_classes.h" 3
      virtual long
      do_hash(const _CharT* __lo, const _CharT* __hi) const;
    };

  template<typename _CharT>
    locale::id collate<_CharT>::id;


  template<>
    int
    collate<char>::_M_compare(const char*, const char*) const throw();

  template<>
    size_t
    collate<char>::_M_transform(char*, const char*, size_t) const throw();


  template<>
    int
    collate<wchar_t>::_M_compare(const wchar_t*, const wchar_t*) const throw();

  template<>
    size_t
    collate<wchar_t>::_M_transform(wchar_t*, const wchar_t*, size_t) const throw();



  template<typename _CharT>
    class __cxx11:: collate_byname : public collate<_CharT>
    {
    public:


      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;


      explicit
      collate_byname(const char* __s, size_t __refs = 0)
      : collate<_CharT>(__refs)
      {
 if (__builtin_strcmp(__s, "C") != 0
     && __builtin_strcmp(__s, "POSIX") != 0)
   {
     this->_S_destroy_c_locale(this->_M_c_locale_collate);
     this->_S_create_c_locale(this->_M_c_locale_collate, __s);
   }
      }


      explicit
      collate_byname(const string& __s, size_t __refs = 0)
      : collate_byname(__s.c_str(), __refs) { }


    protected:
      virtual
      ~collate_byname() { }
    };


}

# 1 "/usr/include/c++/10.2.0/bits/locale_classes.tcc" 1 3
# 37 "/usr/include/c++/10.2.0/bits/locale_classes.tcc" 3
       
# 38 "/usr/include/c++/10.2.0/bits/locale_classes.tcc" 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Facet>
    locale::
    locale(const locale& __other, _Facet* __f)
    {
      _M_impl = new _Impl(*__other._M_impl, 1);

      try
 { _M_impl->_M_install_facet(&_Facet::id, __f); }
      catch(...)
 {
   _M_impl->_M_remove_reference();
   throw;
 }
      delete [] _M_impl->_M_names[0];
      _M_impl->_M_names[0] = 0;
    }

  template<typename _Facet>
    locale
    locale::
    combine(const locale& __other) const
    {
      _Impl* __tmp = new _Impl(*_M_impl, 1);
      try
 {
   __tmp->_M_replace_facet(__other._M_impl, &_Facet::id);
 }
      catch(...)
 {
   __tmp->_M_remove_reference();
   throw;
 }
      return locale(__tmp);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    bool
    locale::
    operator()(const basic_string<_CharT, _Traits, _Alloc>& __s1,
        const basic_string<_CharT, _Traits, _Alloc>& __s2) const
    {
      typedef std::collate<_CharT> __collate_type;
      const __collate_type& __collate = use_facet<__collate_type>(*this);
      return (__collate.compare(__s1.data(), __s1.data() + __s1.length(),
    __s2.data(), __s2.data() + __s2.length()) < 0);
    }
# 102 "/usr/include/c++/10.2.0/bits/locale_classes.tcc" 3
  template<typename _Facet>
    bool
    has_facet(const locale& __loc) throw()
    {
      const size_t __i = _Facet::id._M_id();
      const locale::facet** __facets = __loc._M_impl->_M_facets;
      return (__i < __loc._M_impl->_M_facets_size

       && dynamic_cast<const _Facet*>(__facets[__i]));



    }
# 130 "/usr/include/c++/10.2.0/bits/locale_classes.tcc" 3
  template<typename _Facet>
    const _Facet&
    use_facet(const locale& __loc)
    {
      const size_t __i = _Facet::id._M_id();
      const locale::facet** __facets = __loc._M_impl->_M_facets;
      if (__i >= __loc._M_impl->_M_facets_size || !__facets[__i])
        __throw_bad_cast();

      return dynamic_cast<const _Facet&>(*__facets[__i]);



    }



  template<typename _CharT>
    int
    collate<_CharT>::_M_compare(const _CharT*, const _CharT*) const throw ()
    { return 0; }


  template<typename _CharT>
    size_t
    collate<_CharT>::_M_transform(_CharT*, const _CharT*, size_t) const throw ()
    { return 0; }

  template<typename _CharT>
    int
    collate<_CharT>::
    do_compare(const _CharT* __lo1, const _CharT* __hi1,
        const _CharT* __lo2, const _CharT* __hi2) const
    {


      const string_type __one(__lo1, __hi1);
      const string_type __two(__lo2, __hi2);

      const _CharT* __p = __one.c_str();
      const _CharT* __pend = __one.data() + __one.length();
      const _CharT* __q = __two.c_str();
      const _CharT* __qend = __two.data() + __two.length();




      for (;;)
 {
   const int __res = _M_compare(__p, __q);
   if (__res)
     return __res;

   __p += char_traits<_CharT>::length(__p);
   __q += char_traits<_CharT>::length(__q);
   if (__p == __pend && __q == __qend)
     return 0;
   else if (__p == __pend)
     return -1;
   else if (__q == __qend)
     return 1;

   __p++;
   __q++;
 }
    }

  template<typename _CharT>
    typename collate<_CharT>::string_type
    collate<_CharT>::
    do_transform(const _CharT* __lo, const _CharT* __hi) const
    {
      string_type __ret;


      const string_type __str(__lo, __hi);

      const _CharT* __p = __str.c_str();
      const _CharT* __pend = __str.data() + __str.length();

      size_t __len = (__hi - __lo) * 2;

      _CharT* __c = new _CharT[__len];

      try
 {



   for (;;)
     {

       size_t __res = _M_transform(__c, __p, __len);


       if (__res >= __len)
  {
    __len = __res + 1;
    delete [] __c, __c = 0;
    __c = new _CharT[__len];
    __res = _M_transform(__c, __p, __len);
  }

       __ret.append(__c, __res);
       __p += char_traits<_CharT>::length(__p);
       if (__p == __pend)
  break;

       __p++;
       __ret.push_back(_CharT());
     }
 }
      catch(...)
 {
   delete [] __c;
   throw;
 }

      delete [] __c;

      return __ret;
    }

  template<typename _CharT>
    long
    collate<_CharT>::
    do_hash(const _CharT* __lo, const _CharT* __hi) const
    {
      unsigned long __val = 0;
      for (; __lo < __hi; ++__lo)
 __val =
   *__lo + ((__val << 7)
     | (__val >> (__gnu_cxx::__numeric_traits<unsigned long>::
    __digits - 7)));
      return static_cast<long>(__val);
    }




  extern template class collate<char>;
  extern template class collate_byname<char>;

  extern template
    const collate<char>&
    use_facet<collate<char> >(const locale&);

  extern template
    bool
    has_facet<collate<char> >(const locale&);


  extern template class collate<wchar_t>;
  extern template class collate_byname<wchar_t>;

  extern template
    const collate<wchar_t>&
    use_facet<collate<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<collate<wchar_t> >(const locale&);




}
# 854 "/usr/include/c++/10.2.0/bits/locale_classes.h" 2 3
# 42 "/usr/include/c++/10.2.0/bits/ios_base.h" 2 3




# 1 "/usr/include/c++/10.2.0/system_error" 1 3
# 32 "/usr/include/c++/10.2.0/system_error" 3
       
# 33 "/usr/include/c++/10.2.0/system_error" 3






# 1 "/usr/include/c++/10.2.0/x86_64-pc-linux-gnu/bits/error_constants.h" 1 3
# 34 "/usr/include/c++/10.2.0/x86_64-pc-linux-gnu/bits/error_constants.h" 3
# 1 "/usr/include/c++/10.2.0/cerrno" 1 3
# 39 "/usr/include/c++/10.2.0/cerrno" 3
       
# 40 "/usr/include/c++/10.2.0/cerrno" 3
# 35 "/usr/include/c++/10.2.0/x86_64-pc-linux-gnu/bits/error_constants.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  enum class errc
    {
      address_family_not_supported = 97,
      address_in_use = 98,
      address_not_available = 99,
      already_connected = 106,
      argument_list_too_long = 7,
      argument_out_of_domain = 33,
      bad_address = 14,
      bad_file_descriptor = 9,


      bad_message = 74,


      broken_pipe = 32,
      connection_aborted = 103,
      connection_already_in_progress = 114,
      connection_refused = 111,
      connection_reset = 104,
      cross_device_link = 18,
      destination_address_required = 89,
      device_or_resource_busy = 16,
      directory_not_empty = 39,
      executable_format_error = 8,
      file_exists = 17,
      file_too_large = 27,
      filename_too_long = 36,
      function_not_supported = 38,
      host_unreachable = 113,


      identifier_removed = 43,


      illegal_byte_sequence = 84,
      inappropriate_io_control_operation = 25,
      interrupted = 4,
      invalid_argument = 22,
      invalid_seek = 29,
      io_error = 5,
      is_a_directory = 21,
      message_size = 90,
      network_down = 100,
      network_reset = 102,
      network_unreachable = 101,
      no_buffer_space = 105,
      no_child_process = 10,


      no_link = 67,


      no_lock_available = 37,


      no_message_available = 61,


      no_message = 42,
      no_protocol_option = 92,
      no_space_on_device = 28,


      no_stream_resources = 63,


      no_such_device_or_address = 6,
      no_such_device = 19,
      no_such_file_or_directory = 2,
      no_such_process = 3,
      not_a_directory = 20,
      not_a_socket = 88,


      not_a_stream = 60,


      not_connected = 107,
      not_enough_memory = 12,


      not_supported = 95,



      operation_canceled = 125,


      operation_in_progress = 115,
      operation_not_permitted = 1,
      operation_not_supported = 95,
      operation_would_block = 11,


      owner_dead = 130,


      permission_denied = 13,


      protocol_error = 71,


      protocol_not_supported = 93,
      read_only_file_system = 30,
      resource_deadlock_would_occur = 35,
      resource_unavailable_try_again = 11,
      result_out_of_range = 34,


      state_not_recoverable = 131,



      stream_timeout = 62,



      text_file_busy = 26,


      timed_out = 110,
      too_many_files_open_in_system = 23,
      too_many_files_open = 24,
      too_many_links = 31,
      too_many_symbolic_link_levels = 40,


      value_too_large = 75,


      wrong_protocol_type = 91
    };


}
# 40 "/usr/include/c++/10.2.0/system_error" 2 3

# 1 "/usr/include/c++/10.2.0/stdexcept" 1 3
# 36 "/usr/include/c++/10.2.0/stdexcept" 3
       
# 37 "/usr/include/c++/10.2.0/stdexcept" 3




namespace std __attribute__ ((__visibility__ ("default")))
{





  struct __cow_string
  {
    union {
      const char* _M_p;
      char _M_bytes[sizeof(const char*)];
    };

    __cow_string();
    __cow_string(const std::string&);
    __cow_string(const char*, size_t);
    __cow_string(const __cow_string&) noexcept;
    __cow_string& operator=(const __cow_string&) noexcept;
    ~__cow_string();

    __cow_string(__cow_string&&) noexcept;
    __cow_string& operator=(__cow_string&&) noexcept;

  };

  typedef basic_string<char> __sso_string;
# 113 "/usr/include/c++/10.2.0/stdexcept" 3
  class logic_error : public exception
  {
    __cow_string _M_msg;

  public:

    explicit
    logic_error(const string& __arg) ;


    explicit
    logic_error(const char*) ;

    logic_error(logic_error&&) noexcept;
    logic_error& operator=(logic_error&&) noexcept;



    logic_error(const logic_error&) noexcept;
    logic_error& operator=(const logic_error&) noexcept;





    virtual ~logic_error() noexcept;



    virtual const char*
    what() const noexcept;





  };



  class domain_error : public logic_error
  {
  public:
    explicit domain_error(const string& __arg) ;

    explicit domain_error(const char*) ;
    domain_error(const domain_error&) = default;
    domain_error& operator=(const domain_error&) = default;
    domain_error(domain_error&&) = default;
    domain_error& operator=(domain_error&&) = default;

    virtual ~domain_error() noexcept;
  };


  class invalid_argument : public logic_error
  {
  public:
    explicit invalid_argument(const string& __arg) ;

    explicit invalid_argument(const char*) ;
    invalid_argument(const invalid_argument&) = default;
    invalid_argument& operator=(const invalid_argument&) = default;
    invalid_argument(invalid_argument&&) = default;
    invalid_argument& operator=(invalid_argument&&) = default;

    virtual ~invalid_argument() noexcept;
  };



  class length_error : public logic_error
  {
  public:
    explicit length_error(const string& __arg) ;

    explicit length_error(const char*) ;
    length_error(const length_error&) = default;
    length_error& operator=(const length_error&) = default;
    length_error(length_error&&) = default;
    length_error& operator=(length_error&&) = default;

    virtual ~length_error() noexcept;
  };



  class out_of_range : public logic_error
  {
  public:
    explicit out_of_range(const string& __arg) ;

    explicit out_of_range(const char*) ;
    out_of_range(const out_of_range&) = default;
    out_of_range& operator=(const out_of_range&) = default;
    out_of_range(out_of_range&&) = default;
    out_of_range& operator=(out_of_range&&) = default;

    virtual ~out_of_range() noexcept;
  };






  class runtime_error : public exception
  {
    __cow_string _M_msg;

  public:

    explicit
    runtime_error(const string& __arg) ;


    explicit
    runtime_error(const char*) ;

    runtime_error(runtime_error&&) noexcept;
    runtime_error& operator=(runtime_error&&) noexcept;



    runtime_error(const runtime_error&) noexcept;
    runtime_error& operator=(const runtime_error&) noexcept;





    virtual ~runtime_error() noexcept;



    virtual const char*
    what() const noexcept;





  };


  class range_error : public runtime_error
  {
  public:
    explicit range_error(const string& __arg) ;

    explicit range_error(const char*) ;
    range_error(const range_error&) = default;
    range_error& operator=(const range_error&) = default;
    range_error(range_error&&) = default;
    range_error& operator=(range_error&&) = default;

    virtual ~range_error() noexcept;
  };


  class overflow_error : public runtime_error
  {
  public:
    explicit overflow_error(const string& __arg) ;

    explicit overflow_error(const char*) ;
    overflow_error(const overflow_error&) = default;
    overflow_error& operator=(const overflow_error&) = default;
    overflow_error(overflow_error&&) = default;
    overflow_error& operator=(overflow_error&&) = default;

    virtual ~overflow_error() noexcept;
  };


  class underflow_error : public runtime_error
  {
  public:
    explicit underflow_error(const string& __arg) ;

    explicit underflow_error(const char*) ;
    underflow_error(const underflow_error&) = default;
    underflow_error& operator=(const underflow_error&) = default;
    underflow_error(underflow_error&&) = default;
    underflow_error& operator=(underflow_error&&) = default;

    virtual ~underflow_error() noexcept;
  };




}
# 42 "/usr/include/c++/10.2.0/system_error" 2 3




namespace std __attribute__ ((__visibility__ ("default")))
{






  class error_code;
  class error_condition;
  class system_error;


  template<typename _Tp>
    struct is_error_code_enum : public false_type { };


  template<typename _Tp>
    struct is_error_condition_enum : public false_type { };

  template<>
    struct is_error_condition_enum<errc>
    : public true_type { };
# 78 "/usr/include/c++/10.2.0/system_error" 3
  inline namespace _V2 {
# 89 "/usr/include/c++/10.2.0/system_error" 3
  class error_category
  {
  public:
    constexpr error_category() noexcept = default;

    virtual ~error_category();

    error_category(const error_category&) = delete;
    error_category& operator=(const error_category&) = delete;

    virtual const char*
    name() const noexcept = 0;






  private:
    __attribute ((__abi_tag__ ("cxx11")))
    virtual __cow_string
    _M_message(int) const;

  public:
    __attribute ((__abi_tag__ ("cxx11")))
    virtual string
    message(int) const = 0;
# 125 "/usr/include/c++/10.2.0/system_error" 3
  public:
    virtual error_condition
    default_error_condition(int __i) const noexcept;

    virtual bool
    equivalent(int __i, const error_condition& __cond) const noexcept;

    virtual bool
    equivalent(const error_code& __code, int __i) const noexcept;

    bool
    operator==(const error_category& __other) const noexcept
    { return this == &__other; }






    bool
    operator!=(const error_category& __other) const noexcept
    { return this != &__other; }

    bool
    operator<(const error_category& __other) const noexcept
    { return less<const error_category*>()(this, &__other); }

  };




  __attribute__ ((__const__)) const error_category& generic_category() noexcept;


  __attribute__ ((__const__)) const error_category& system_category() noexcept;

  }

  error_code make_error_code(errc) noexcept;
# 180 "/usr/include/c++/10.2.0/system_error" 3
  struct error_code
  {
    error_code() noexcept
    : _M_value(0), _M_cat(&system_category()) { }

    error_code(int __v, const error_category& __cat) noexcept
    : _M_value(__v), _M_cat(&__cat) { }

    template<typename _ErrorCodeEnum, typename = typename
      enable_if<is_error_code_enum<_ErrorCodeEnum>::value>::type>
      error_code(_ErrorCodeEnum __e) noexcept
      { *this = make_error_code(__e); }

    void
    assign(int __v, const error_category& __cat) noexcept
    {
      _M_value = __v;
      _M_cat = &__cat;
    }

    void
    clear() noexcept
    { assign(0, system_category()); }


    template<typename _ErrorCodeEnum>
      typename enable_if<is_error_code_enum<_ErrorCodeEnum>::value,
    error_code&>::type
      operator=(_ErrorCodeEnum __e) noexcept
      { return *this = make_error_code(__e); }

    int
    value() const noexcept { return _M_value; }

    const error_category&
    category() const noexcept { return *_M_cat; }

    error_condition
    default_error_condition() const noexcept;

    __attribute ((__abi_tag__ ("cxx11")))
    string
    message() const
    { return category().message(value()); }

    explicit operator bool() const noexcept
    { return _M_value != 0; }


  private:
    int _M_value;
    const error_category* _M_cat;
  };





  inline error_code
  make_error_code(errc __e) noexcept
  { return error_code(static_cast<int>(__e), generic_category()); }
# 251 "/usr/include/c++/10.2.0/system_error" 3
  inline bool
  operator<(const error_code& __lhs, const error_code& __rhs) noexcept
  {
    return (__lhs.category() < __rhs.category()
     || (__lhs.category() == __rhs.category()
  && __lhs.value() < __rhs.value()));
  }


  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, const error_code& __e)
    { return (__os << __e.category().name() << ':' << __e.value()); }



  error_condition make_error_condition(errc) noexcept;
# 278 "/usr/include/c++/10.2.0/system_error" 3
  struct error_condition
  {
    error_condition() noexcept
    : _M_value(0), _M_cat(&generic_category()) { }

    error_condition(int __v, const error_category& __cat) noexcept
    : _M_value(__v), _M_cat(&__cat) { }

    template<typename _ErrorConditionEnum, typename = typename
  enable_if<is_error_condition_enum<_ErrorConditionEnum>::value>::type>
      error_condition(_ErrorConditionEnum __e) noexcept
      { *this = make_error_condition(__e); }

    void
    assign(int __v, const error_category& __cat) noexcept
    {
      _M_value = __v;
      _M_cat = &__cat;
    }


    template<typename _ErrorConditionEnum>
      typename enable_if<is_error_condition_enum
    <_ErrorConditionEnum>::value, error_condition&>::type
      operator=(_ErrorConditionEnum __e) noexcept
      { return *this = make_error_condition(__e); }

    void
    clear() noexcept
    { assign(0, generic_category()); }


    int
    value() const noexcept { return _M_value; }

    const error_category&
    category() const noexcept { return *_M_cat; }

    __attribute ((__abi_tag__ ("cxx11")))
    string
    message() const
    { return category().message(value()); }

    explicit operator bool() const noexcept
    { return _M_value != 0; }


  private:
    int _M_value;
    const error_category* _M_cat;
  };





  inline error_condition
  make_error_condition(errc __e) noexcept
  { return error_condition(static_cast<int>(__e), generic_category()); }




  inline bool
  operator==(const error_code& __lhs, const error_code& __rhs) noexcept
  { return (__lhs.category() == __rhs.category()
     && __lhs.value() == __rhs.value()); }



  inline bool
  operator==(const error_code& __lhs, const error_condition& __rhs) noexcept
  {
    return (__lhs.category().equivalent(__lhs.value(), __rhs)
     || __rhs.category().equivalent(__lhs, __rhs.value()));
  }


  inline bool
  operator==(const error_condition& __lhs,
      const error_condition& __rhs) noexcept
  {
    return (__lhs.category() == __rhs.category()
     && __lhs.value() == __rhs.value());
  }
# 378 "/usr/include/c++/10.2.0/system_error" 3
  inline bool
  operator<(const error_condition& __lhs,
     const error_condition& __rhs) noexcept
  {
    return (__lhs.category() < __rhs.category()
     || (__lhs.category() == __rhs.category()
  && __lhs.value() < __rhs.value()));
  }



  inline bool
  operator==(const error_condition& __lhs, const error_code& __rhs) noexcept
  {
    return (__rhs.category().equivalent(__rhs.value(), __lhs)
     || __lhs.category().equivalent(__rhs, __lhs.value()));
  }


  inline bool
  operator!=(const error_code& __lhs, const error_code& __rhs) noexcept
  { return !(__lhs == __rhs); }



  inline bool
  operator!=(const error_code& __lhs, const error_condition& __rhs) noexcept
  { return !(__lhs == __rhs); }



  inline bool
  operator!=(const error_condition& __lhs, const error_code& __rhs) noexcept
  { return !(__lhs == __rhs); }


  inline bool
  operator!=(const error_condition& __lhs,
      const error_condition& __rhs) noexcept
  { return !(__lhs == __rhs); }
# 428 "/usr/include/c++/10.2.0/system_error" 3
  class system_error : public std::runtime_error
  {
  private:
    error_code _M_code;

  public:
    system_error(error_code __ec = error_code())
    : runtime_error(__ec.message()), _M_code(__ec) { }

    system_error(error_code __ec, const string& __what)
    : runtime_error(__what + ": " + __ec.message()), _M_code(__ec) { }

    system_error(error_code __ec, const char* __what)
    : runtime_error(__what + (": " + __ec.message())), _M_code(__ec) { }

    system_error(int __v, const error_category& __ecat, const char* __what)
    : system_error(error_code(__v, __ecat), __what) { }

    system_error(int __v, const error_category& __ecat)
    : runtime_error(error_code(__v, __ecat).message()),
      _M_code(__v, __ecat) { }

    system_error(int __v, const error_category& __ecat, const string& __what)
    : runtime_error(__what + ": " + error_code(__v, __ecat).message()),
      _M_code(__v, __ecat) { }


    system_error (const system_error &) = default;
    system_error &operator= (const system_error &) = default;


    virtual ~system_error() noexcept;

    const error_code&
    code() const noexcept { return _M_code; }
  };


}



namespace std __attribute__ ((__visibility__ ("default")))
{






  template<>
    struct hash<error_code>
    : public __hash_base<size_t, error_code>
    {
      size_t
      operator()(const error_code& __e) const noexcept
      {
 const size_t __tmp = std::_Hash_impl::hash(__e.value());
 return std::_Hash_impl::__hash_combine(&__e.category(), __tmp);
      }
    };
# 508 "/usr/include/c++/10.2.0/system_error" 3

}
# 47 "/usr/include/c++/10.2.0/bits/ios_base.h" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{






  enum _Ios_Fmtflags
    {
      _S_boolalpha = 1L << 0,
      _S_dec = 1L << 1,
      _S_fixed = 1L << 2,
      _S_hex = 1L << 3,
      _S_internal = 1L << 4,
      _S_left = 1L << 5,
      _S_oct = 1L << 6,
      _S_right = 1L << 7,
      _S_scientific = 1L << 8,
      _S_showbase = 1L << 9,
      _S_showpoint = 1L << 10,
      _S_showpos = 1L << 11,
      _S_skipws = 1L << 12,
      _S_unitbuf = 1L << 13,
      _S_uppercase = 1L << 14,
      _S_adjustfield = _S_left | _S_right | _S_internal,
      _S_basefield = _S_dec | _S_oct | _S_hex,
      _S_floatfield = _S_scientific | _S_fixed,
      _S_ios_fmtflags_end = 1L << 16,
      _S_ios_fmtflags_max = 0x7fffffff,
      _S_ios_fmtflags_min = ~0x7fffffff
    };

  inline constexpr _Ios_Fmtflags
  operator&(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline constexpr _Ios_Fmtflags
  operator|(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline constexpr _Ios_Fmtflags
  operator^(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline constexpr _Ios_Fmtflags
  operator~(_Ios_Fmtflags __a)
  { return _Ios_Fmtflags(~static_cast<int>(__a)); }

  inline const _Ios_Fmtflags&
  operator|=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a | __b; }

  inline const _Ios_Fmtflags&
  operator&=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a & __b; }

  inline const _Ios_Fmtflags&
  operator^=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a ^ __b; }


  enum _Ios_Openmode
    {
      _S_app = 1L << 0,
      _S_ate = 1L << 1,
      _S_bin = 1L << 2,
      _S_in = 1L << 3,
      _S_out = 1L << 4,
      _S_trunc = 1L << 5,
      _S_ios_openmode_end = 1L << 16,
      _S_ios_openmode_max = 0x7fffffff,
      _S_ios_openmode_min = ~0x7fffffff
    };

  inline constexpr _Ios_Openmode
  operator&(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline constexpr _Ios_Openmode
  operator|(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline constexpr _Ios_Openmode
  operator^(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline constexpr _Ios_Openmode
  operator~(_Ios_Openmode __a)
  { return _Ios_Openmode(~static_cast<int>(__a)); }

  inline const _Ios_Openmode&
  operator|=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a | __b; }

  inline const _Ios_Openmode&
  operator&=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a & __b; }

  inline const _Ios_Openmode&
  operator^=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a ^ __b; }


  enum _Ios_Iostate
    {
      _S_goodbit = 0,
      _S_badbit = 1L << 0,
      _S_eofbit = 1L << 1,
      _S_failbit = 1L << 2,
      _S_ios_iostate_end = 1L << 16,
      _S_ios_iostate_max = 0x7fffffff,
      _S_ios_iostate_min = ~0x7fffffff
    };

  inline constexpr _Ios_Iostate
  operator&(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline constexpr _Ios_Iostate
  operator|(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline constexpr _Ios_Iostate
  operator^(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline constexpr _Ios_Iostate
  operator~(_Ios_Iostate __a)
  { return _Ios_Iostate(~static_cast<int>(__a)); }

  inline const _Ios_Iostate&
  operator|=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a | __b; }

  inline const _Ios_Iostate&
  operator&=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a & __b; }

  inline const _Ios_Iostate&
  operator^=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a ^ __b; }


  enum _Ios_Seekdir
    {
      _S_beg = 0,
      _S_cur = 1,
      _S_end = 2,
      _S_ios_seekdir_end = 1L << 16
    };



  enum class io_errc { stream = 1 };

  template <> struct is_error_code_enum<io_errc> : public true_type { };

  const error_category& iostream_category() noexcept;

  inline error_code
  make_error_code(io_errc __e) noexcept
  { return error_code(static_cast<int>(__e), iostream_category()); }

  inline error_condition
  make_error_condition(io_errc __e) noexcept
  { return error_condition(static_cast<int>(__e), iostream_category()); }
# 228 "/usr/include/c++/10.2.0/bits/ios_base.h" 3
  class ios_base
  {
# 246 "/usr/include/c++/10.2.0/bits/ios_base.h" 3
  public:
# 255 "/usr/include/c++/10.2.0/bits/ios_base.h" 3
    class __attribute ((__abi_tag__ ("cxx11"))) failure : public system_error
    {
    public:
      explicit
      failure(const string& __str);


      explicit
      failure(const string&, const error_code&);

      explicit
      failure(const char*, const error_code& = io_errc::stream);


      virtual
      ~failure() throw();

      virtual const char*
      what() const throw();
    };
# 323 "/usr/include/c++/10.2.0/bits/ios_base.h" 3
    typedef _Ios_Fmtflags fmtflags;


    static const fmtflags boolalpha = _S_boolalpha;


    static const fmtflags dec = _S_dec;


    static const fmtflags fixed = _S_fixed;


    static const fmtflags hex = _S_hex;




    static const fmtflags internal = _S_internal;



    static const fmtflags left = _S_left;


    static const fmtflags oct = _S_oct;



    static const fmtflags right = _S_right;


    static const fmtflags scientific = _S_scientific;



    static const fmtflags showbase = _S_showbase;



    static const fmtflags showpoint = _S_showpoint;


    static const fmtflags showpos = _S_showpos;


    static const fmtflags skipws = _S_skipws;


    static const fmtflags unitbuf = _S_unitbuf;



    static const fmtflags uppercase = _S_uppercase;


    static const fmtflags adjustfield = _S_adjustfield;


    static const fmtflags basefield = _S_basefield;


    static const fmtflags floatfield = _S_floatfield;
# 398 "/usr/include/c++/10.2.0/bits/ios_base.h" 3
    typedef _Ios_Iostate iostate;



    static const iostate badbit = _S_badbit;


    static const iostate eofbit = _S_eofbit;




    static const iostate failbit = _S_failbit;


    static const iostate goodbit = _S_goodbit;
# 429 "/usr/include/c++/10.2.0/bits/ios_base.h" 3
    typedef _Ios_Openmode openmode;


    static const openmode app = _S_app;


    static const openmode ate = _S_ate;




    static const openmode binary = _S_bin;


    static const openmode in = _S_in;


    static const openmode out = _S_out;


    static const openmode trunc = _S_trunc;
# 461 "/usr/include/c++/10.2.0/bits/ios_base.h" 3
    typedef _Ios_Seekdir seekdir;


    static const seekdir beg = _S_beg;


    static const seekdir cur = _S_cur;


    static const seekdir end = _S_end;



    typedef int io_state;
    typedef int open_mode;
    typedef int seek_dir;

    typedef std::streampos streampos;
    typedef std::streamoff streamoff;
# 489 "/usr/include/c++/10.2.0/bits/ios_base.h" 3
    enum event
    {
      erase_event,
      imbue_event,
      copyfmt_event
    };
# 506 "/usr/include/c++/10.2.0/bits/ios_base.h" 3
    typedef void (*event_callback) (event __e, ios_base& __b, int __i);
# 518 "/usr/include/c++/10.2.0/bits/ios_base.h" 3
    void
    register_callback(event_callback __fn, int __index);

  protected:
    streamsize _M_precision;
    streamsize _M_width;
    fmtflags _M_flags;
    iostate _M_exception;
    iostate _M_streambuf_state;



    struct _Callback_list
    {

      _Callback_list* _M_next;
      ios_base::event_callback _M_fn;
      int _M_index;
      _Atomic_word _M_refcount;

      _Callback_list(ios_base::event_callback __fn, int __index,
       _Callback_list* __cb)
      : _M_next(__cb), _M_fn(__fn), _M_index(__index), _M_refcount(0) { }

      void
      _M_add_reference() { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }


      int
      _M_remove_reference()
      {

        ;
        int __res = __gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1);
        if (__res == 0)
          {
            ;
          }
        return __res;
      }
    };

     _Callback_list* _M_callbacks;

    void
    _M_call_callbacks(event __ev) throw();

    void
    _M_dispose_callbacks(void) throw();


    struct _Words
    {
      void* _M_pword;
      long _M_iword;
      _Words() : _M_pword(0), _M_iword(0) { }
    };


    _Words _M_word_zero;



    enum { _S_local_word_size = 8 };
    _Words _M_local_word[_S_local_word_size];


    int _M_word_size;
    _Words* _M_word;

    _Words&
    _M_grow_words(int __index, bool __iword);


    locale _M_ios_locale;

    void
    _M_init() throw();

  public:





    class Init
    {
      friend class ios_base;
    public:
      Init();
      ~Init();


      Init(const Init&) = default;
      Init& operator=(const Init&) = default;


    private:
      static _Atomic_word _S_refcount;
      static bool _S_synced_with_stdio;
    };






    fmtflags
    flags() const
    { return _M_flags; }
# 636 "/usr/include/c++/10.2.0/bits/ios_base.h" 3
    fmtflags
    flags(fmtflags __fmtfl)
    {
      fmtflags __old = _M_flags;
      _M_flags = __fmtfl;
      return __old;
    }
# 652 "/usr/include/c++/10.2.0/bits/ios_base.h" 3
    fmtflags
    setf(fmtflags __fmtfl)
    {
      fmtflags __old = _M_flags;
      _M_flags |= __fmtfl;
      return __old;
    }
# 669 "/usr/include/c++/10.2.0/bits/ios_base.h" 3
    fmtflags
    setf(fmtflags __fmtfl, fmtflags __mask)
    {
      fmtflags __old = _M_flags;
      _M_flags &= ~__mask;
      _M_flags |= (__fmtfl & __mask);
      return __old;
    }







    void
    unsetf(fmtflags __mask)
    { _M_flags &= ~__mask; }
# 695 "/usr/include/c++/10.2.0/bits/ios_base.h" 3
    streamsize
    precision() const
    { return _M_precision; }






    streamsize
    precision(streamsize __prec)
    {
      streamsize __old = _M_precision;
      _M_precision = __prec;
      return __old;
    }







    streamsize
    width() const
    { return _M_width; }






    streamsize
    width(streamsize __wide)
    {
      streamsize __old = _M_width;
      _M_width = __wide;
      return __old;
    }
# 746 "/usr/include/c++/10.2.0/bits/ios_base.h" 3
    static bool
    sync_with_stdio(bool __sync = true);
# 758 "/usr/include/c++/10.2.0/bits/ios_base.h" 3
    locale
    imbue(const locale& __loc) throw();
# 769 "/usr/include/c++/10.2.0/bits/ios_base.h" 3
    locale
    getloc() const
    { return _M_ios_locale; }
# 780 "/usr/include/c++/10.2.0/bits/ios_base.h" 3
    const locale&
    _M_getloc() const
    { return _M_ios_locale; }
# 799 "/usr/include/c++/10.2.0/bits/ios_base.h" 3
    static int
    xalloc() throw();
# 815 "/usr/include/c++/10.2.0/bits/ios_base.h" 3
    long&
    iword(int __ix)
    {
      _Words& __word = ((unsigned)__ix < (unsigned)_M_word_size)
   ? _M_word[__ix] : _M_grow_words(__ix, true);
      return __word._M_iword;
    }
# 836 "/usr/include/c++/10.2.0/bits/ios_base.h" 3
    void*&
    pword(int __ix)
    {
      _Words& __word = ((unsigned)__ix < (unsigned)_M_word_size)
   ? _M_word[__ix] : _M_grow_words(__ix, false);
      return __word._M_pword;
    }
# 853 "/usr/include/c++/10.2.0/bits/ios_base.h" 3
    virtual ~ios_base();

  protected:
    ios_base() throw ();
# 867 "/usr/include/c++/10.2.0/bits/ios_base.h" 3
  public:
    ios_base(const ios_base&) = delete;

    ios_base&
    operator=(const ios_base&) = delete;

  protected:
    void
    _M_move(ios_base&) noexcept;

    void
    _M_swap(ios_base& __rhs) noexcept;

  };



  inline ios_base&
  boolalpha(ios_base& __base)
  {
    __base.setf(ios_base::boolalpha);
    return __base;
  }


  inline ios_base&
  noboolalpha(ios_base& __base)
  {
    __base.unsetf(ios_base::boolalpha);
    return __base;
  }


  inline ios_base&
  showbase(ios_base& __base)
  {
    __base.setf(ios_base::showbase);
    return __base;
  }


  inline ios_base&
  noshowbase(ios_base& __base)
  {
    __base.unsetf(ios_base::showbase);
    return __base;
  }


  inline ios_base&
  showpoint(ios_base& __base)
  {
    __base.setf(ios_base::showpoint);
    return __base;
  }


  inline ios_base&
  noshowpoint(ios_base& __base)
  {
    __base.unsetf(ios_base::showpoint);
    return __base;
  }


  inline ios_base&
  showpos(ios_base& __base)
  {
    __base.setf(ios_base::showpos);
    return __base;
  }


  inline ios_base&
  noshowpos(ios_base& __base)
  {
    __base.unsetf(ios_base::showpos);
    return __base;
  }


  inline ios_base&
  skipws(ios_base& __base)
  {
    __base.setf(ios_base::skipws);
    return __base;
  }


  inline ios_base&
  noskipws(ios_base& __base)
  {
    __base.unsetf(ios_base::skipws);
    return __base;
  }


  inline ios_base&
  uppercase(ios_base& __base)
  {
    __base.setf(ios_base::uppercase);
    return __base;
  }


  inline ios_base&
  nouppercase(ios_base& __base)
  {
    __base.unsetf(ios_base::uppercase);
    return __base;
  }


  inline ios_base&
  unitbuf(ios_base& __base)
  {
     __base.setf(ios_base::unitbuf);
     return __base;
  }


  inline ios_base&
  nounitbuf(ios_base& __base)
  {
     __base.unsetf(ios_base::unitbuf);
     return __base;
  }



  inline ios_base&
  internal(ios_base& __base)
  {
     __base.setf(ios_base::internal, ios_base::adjustfield);
     return __base;
  }


  inline ios_base&
  left(ios_base& __base)
  {
    __base.setf(ios_base::left, ios_base::adjustfield);
    return __base;
  }


  inline ios_base&
  right(ios_base& __base)
  {
    __base.setf(ios_base::right, ios_base::adjustfield);
    return __base;
  }



  inline ios_base&
  dec(ios_base& __base)
  {
    __base.setf(ios_base::dec, ios_base::basefield);
    return __base;
  }


  inline ios_base&
  hex(ios_base& __base)
  {
    __base.setf(ios_base::hex, ios_base::basefield);
    return __base;
  }


  inline ios_base&
  oct(ios_base& __base)
  {
    __base.setf(ios_base::oct, ios_base::basefield);
    return __base;
  }



  inline ios_base&
  fixed(ios_base& __base)
  {
    __base.setf(ios_base::fixed, ios_base::floatfield);
    return __base;
  }


  inline ios_base&
  scientific(ios_base& __base)
  {
    __base.setf(ios_base::scientific, ios_base::floatfield);
    return __base;
  }






  inline ios_base&
  hexfloat(ios_base& __base)
  {
    __base.setf(ios_base::fixed | ios_base::scientific, ios_base::floatfield);
    return __base;
  }


  inline ios_base&
  defaultfloat(ios_base& __base)
  {
    __base.unsetf(ios_base::floatfield);
    return __base;
  }



}
# 43 "/usr/include/c++/10.2.0/ios" 2 3
# 1 "/usr/include/c++/10.2.0/streambuf" 1 3
# 36 "/usr/include/c++/10.2.0/streambuf" 3
       
# 37 "/usr/include/c++/10.2.0/streambuf" 3
# 45 "/usr/include/c++/10.2.0/streambuf" 3
namespace std __attribute__ ((__visibility__ ("default")))
{




  template<typename _CharT, typename _Traits>
    streamsize
    __copy_streambufs_eof(basic_streambuf<_CharT, _Traits>*,
     basic_streambuf<_CharT, _Traits>*, bool&);
# 121 "/usr/include/c++/10.2.0/streambuf" 3
  template<typename _CharT, typename _Traits>
    class basic_streambuf
    {
    public:






      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;




      typedef basic_streambuf<char_type, traits_type> __streambuf_type;


      friend class basic_ios<char_type, traits_type>;
      friend class basic_istream<char_type, traits_type>;
      friend class basic_ostream<char_type, traits_type>;
      friend class istreambuf_iterator<char_type, traits_type>;
      friend class ostreambuf_iterator<char_type, traits_type>;

      friend streamsize
      __copy_streambufs_eof<>(basic_streambuf*, basic_streambuf*, bool&);

      template<bool _IsMove, typename _CharT2>
        friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
            _CharT2*>::__type
        __copy_move_a2(istreambuf_iterator<_CharT2>,
         istreambuf_iterator<_CharT2>, _CharT2*);

      template<typename _CharT2>
        friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
      istreambuf_iterator<_CharT2> >::__type
        find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      const _CharT2&);

      template<typename _CharT2, typename _Distance>
        friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
            void>::__type
        advance(istreambuf_iterator<_CharT2>&, _Distance);

      template<typename _CharT2, typename _Traits2>
        friend basic_istream<_CharT2, _Traits2>&
        operator>>(basic_istream<_CharT2, _Traits2>&, _CharT2*);

      template<typename _CharT2, typename _Traits2, typename _Alloc>
        friend basic_istream<_CharT2, _Traits2>&
        operator>>(basic_istream<_CharT2, _Traits2>&,
     basic_string<_CharT2, _Traits2, _Alloc>&);

      template<typename _CharT2, typename _Traits2, typename _Alloc>
        friend basic_istream<_CharT2, _Traits2>&
        getline(basic_istream<_CharT2, _Traits2>&,
  basic_string<_CharT2, _Traits2, _Alloc>&, _CharT2);

    protected:







      char_type* _M_in_beg;
      char_type* _M_in_cur;
      char_type* _M_in_end;
      char_type* _M_out_beg;
      char_type* _M_out_cur;
      char_type* _M_out_end;


      locale _M_buf_locale;

  public:

      virtual
      ~basic_streambuf()
      { }
# 215 "/usr/include/c++/10.2.0/streambuf" 3
      locale
      pubimbue(const locale& __loc)
      {
 locale __tmp(this->getloc());
 this->imbue(__loc);
 _M_buf_locale = __loc;
 return __tmp;
      }
# 232 "/usr/include/c++/10.2.0/streambuf" 3
      locale
      getloc() const
      { return _M_buf_locale; }
# 245 "/usr/include/c++/10.2.0/streambuf" 3
      basic_streambuf*
      pubsetbuf(char_type* __s, streamsize __n)
      { return this->setbuf(__s, __n); }
# 257 "/usr/include/c++/10.2.0/streambuf" 3
      pos_type
      pubseekoff(off_type __off, ios_base::seekdir __way,
   ios_base::openmode __mode = ios_base::in | ios_base::out)
      { return this->seekoff(__off, __way, __mode); }
# 269 "/usr/include/c++/10.2.0/streambuf" 3
      pos_type
      pubseekpos(pos_type __sp,
   ios_base::openmode __mode = ios_base::in | ios_base::out)
      { return this->seekpos(__sp, __mode); }




      int
      pubsync() { return this->sync(); }
# 290 "/usr/include/c++/10.2.0/streambuf" 3
      streamsize
      in_avail()
      {
 const streamsize __ret = this->egptr() - this->gptr();
 return __ret ? __ret : this->showmanyc();
      }
# 304 "/usr/include/c++/10.2.0/streambuf" 3
      int_type
      snextc()
      {
 int_type __ret = traits_type::eof();
 if (__builtin_expect(!traits_type::eq_int_type(this->sbumpc(),
             __ret), true))
   __ret = this->sgetc();
 return __ret;
      }
# 322 "/usr/include/c++/10.2.0/streambuf" 3
      int_type
      sbumpc()
      {
 int_type __ret;
 if (__builtin_expect(this->gptr() < this->egptr(), true))
   {
     __ret = traits_type::to_int_type(*this->gptr());
     this->gbump(1);
   }
 else
   __ret = this->uflow();
 return __ret;
      }
# 344 "/usr/include/c++/10.2.0/streambuf" 3
      int_type
      sgetc()
      {
 int_type __ret;
 if (__builtin_expect(this->gptr() < this->egptr(), true))
   __ret = traits_type::to_int_type(*this->gptr());
 else
   __ret = this->underflow();
 return __ret;
      }
# 363 "/usr/include/c++/10.2.0/streambuf" 3
      streamsize
      sgetn(char_type* __s, streamsize __n)
      { return this->xsgetn(__s, __n); }
# 378 "/usr/include/c++/10.2.0/streambuf" 3
      int_type
      sputbackc(char_type __c)
      {
 int_type __ret;
 const bool __testpos = this->eback() < this->gptr();
 if (__builtin_expect(!__testpos ||
        !traits_type::eq(__c, this->gptr()[-1]), false))
   __ret = this->pbackfail(traits_type::to_int_type(__c));
 else
   {
     this->gbump(-1);
     __ret = traits_type::to_int_type(*this->gptr());
   }
 return __ret;
      }
# 403 "/usr/include/c++/10.2.0/streambuf" 3
      int_type
      sungetc()
      {
 int_type __ret;
 if (__builtin_expect(this->eback() < this->gptr(), true))
   {
     this->gbump(-1);
     __ret = traits_type::to_int_type(*this->gptr());
   }
 else
   __ret = this->pbackfail();
 return __ret;
      }
# 430 "/usr/include/c++/10.2.0/streambuf" 3
      int_type
      sputc(char_type __c)
      {
 int_type __ret;
 if (__builtin_expect(this->pptr() < this->epptr(), true))
   {
     *this->pptr() = __c;
     this->pbump(1);
     __ret = traits_type::to_int_type(__c);
   }
 else
   __ret = this->overflow(traits_type::to_int_type(__c));
 return __ret;
      }
# 456 "/usr/include/c++/10.2.0/streambuf" 3
      streamsize
      sputn(const char_type* __s, streamsize __n)
      { return this->xsputn(__s, __n); }

    protected:
# 470 "/usr/include/c++/10.2.0/streambuf" 3
      basic_streambuf()
      : _M_in_beg(0), _M_in_cur(0), _M_in_end(0),
      _M_out_beg(0), _M_out_cur(0), _M_out_end(0),
      _M_buf_locale(locale())
      { }
# 488 "/usr/include/c++/10.2.0/streambuf" 3
      char_type*
      eback() const { return _M_in_beg; }

      char_type*
      gptr() const { return _M_in_cur; }

      char_type*
      egptr() const { return _M_in_end; }
# 504 "/usr/include/c++/10.2.0/streambuf" 3
      void
      gbump(int __n) { _M_in_cur += __n; }
# 515 "/usr/include/c++/10.2.0/streambuf" 3
      void
      setg(char_type* __gbeg, char_type* __gnext, char_type* __gend)
      {
 _M_in_beg = __gbeg;
 _M_in_cur = __gnext;
 _M_in_end = __gend;
      }
# 535 "/usr/include/c++/10.2.0/streambuf" 3
      char_type*
      pbase() const { return _M_out_beg; }

      char_type*
      pptr() const { return _M_out_cur; }

      char_type*
      epptr() const { return _M_out_end; }
# 551 "/usr/include/c++/10.2.0/streambuf" 3
      void
      pbump(int __n) { _M_out_cur += __n; }
# 561 "/usr/include/c++/10.2.0/streambuf" 3
      void
      setp(char_type* __pbeg, char_type* __pend)
      {
 _M_out_beg = _M_out_cur = __pbeg;
 _M_out_end = __pend;
      }
# 582 "/usr/include/c++/10.2.0/streambuf" 3
      virtual void
      imbue(const locale& __loc __attribute__ ((__unused__)))
      { }
# 597 "/usr/include/c++/10.2.0/streambuf" 3
      virtual basic_streambuf<char_type,_Traits>*
      setbuf(char_type*, streamsize)
      { return this; }
# 608 "/usr/include/c++/10.2.0/streambuf" 3
      virtual pos_type
      seekoff(off_type, ios_base::seekdir,
       ios_base::openmode = ios_base::in | ios_base::out)
      { return pos_type(off_type(-1)); }
# 620 "/usr/include/c++/10.2.0/streambuf" 3
      virtual pos_type
      seekpos(pos_type,
       ios_base::openmode = ios_base::in | ios_base::out)
      { return pos_type(off_type(-1)); }
# 633 "/usr/include/c++/10.2.0/streambuf" 3
      virtual int
      sync() { return 0; }
# 655 "/usr/include/c++/10.2.0/streambuf" 3
      virtual streamsize
      showmanyc() { return 0; }
# 671 "/usr/include/c++/10.2.0/streambuf" 3
      virtual streamsize
      xsgetn(char_type* __s, streamsize __n);
# 693 "/usr/include/c++/10.2.0/streambuf" 3
      virtual int_type
      underflow()
      { return traits_type::eof(); }
# 706 "/usr/include/c++/10.2.0/streambuf" 3
      virtual int_type
      uflow()
      {
 int_type __ret = traits_type::eof();
 const bool __testeof = traits_type::eq_int_type(this->underflow(),
       __ret);
 if (!__testeof)
   {
     __ret = traits_type::to_int_type(*this->gptr());
     this->gbump(1);
   }
 return __ret;
      }
# 730 "/usr/include/c++/10.2.0/streambuf" 3
      virtual int_type
      pbackfail(int_type __c __attribute__ ((__unused__)) = traits_type::eof())
      { return traits_type::eof(); }
# 748 "/usr/include/c++/10.2.0/streambuf" 3
      virtual streamsize
      xsputn(const char_type* __s, streamsize __n);
# 774 "/usr/include/c++/10.2.0/streambuf" 3
      virtual int_type
      overflow(int_type __c __attribute__ ((__unused__)) = traits_type::eof())
      { return traits_type::eof(); }



    public:
# 790 "/usr/include/c++/10.2.0/streambuf" 3
      [[__deprecated__("stossc is deprecated, use sbumpc instead")]]

      void
      stossc()
      {
 if (this->gptr() < this->egptr())
   this->gbump(1);
 else
   this->uflow();
      }



      void
      __safe_gbump(streamsize __n) { _M_in_cur += __n; }

      void
      __safe_pbump(streamsize __n) { _M_out_cur += __n; }




    protected:

      basic_streambuf(const basic_streambuf&);

      basic_streambuf&
      operator=(const basic_streambuf&);


      void
      swap(basic_streambuf& __sb)
      {
 std::swap(_M_in_beg, __sb._M_in_beg);
 std::swap(_M_in_cur, __sb._M_in_cur);
 std::swap(_M_in_end, __sb._M_in_end);
 std::swap(_M_out_beg, __sb._M_out_beg);
 std::swap(_M_out_cur, __sb._M_out_cur);
 std::swap(_M_out_end, __sb._M_out_end);
 std::swap(_M_buf_locale, __sb._M_buf_locale);
      }

    };


  template<typename _CharT, typename _Traits>
    std::basic_streambuf<_CharT, _Traits>::
    basic_streambuf(const basic_streambuf&) = default;

  template<typename _CharT, typename _Traits>
    std::basic_streambuf<_CharT, _Traits>&
    std::basic_streambuf<_CharT, _Traits>::
    operator=(const basic_streambuf&) = default;



  template<>
    streamsize
    __copy_streambufs_eof(basic_streambuf<char>* __sbin,
     basic_streambuf<char>* __sbout, bool& __ineof);

  template<>
    streamsize
    __copy_streambufs_eof(basic_streambuf<wchar_t>* __sbin,
     basic_streambuf<wchar_t>* __sbout, bool& __ineof);





}

# 1 "/usr/include/c++/10.2.0/bits/streambuf.tcc" 1 3
# 37 "/usr/include/c++/10.2.0/bits/streambuf.tcc" 3
       
# 38 "/usr/include/c++/10.2.0/bits/streambuf.tcc" 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    streamsize
    basic_streambuf<_CharT, _Traits>::
    xsgetn(char_type* __s, streamsize __n)
    {
      streamsize __ret = 0;
      while (__ret < __n)
 {
   const streamsize __buf_len = this->egptr() - this->gptr();
   if (__buf_len)
     {
       const streamsize __remaining = __n - __ret;
       const streamsize __len = std::min(__buf_len, __remaining);
       traits_type::copy(__s, this->gptr(), __len);
       __ret += __len;
       __s += __len;
       this->__safe_gbump(__len);
     }

   if (__ret < __n)
     {
       const int_type __c = this->uflow();
       if (!traits_type::eq_int_type(__c, traits_type::eof()))
  {
    traits_type::assign(*__s++, traits_type::to_char_type(__c));
    ++__ret;
  }
       else
  break;
     }
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_streambuf<_CharT, _Traits>::
    xsputn(const char_type* __s, streamsize __n)
    {
      streamsize __ret = 0;
      while (__ret < __n)
 {
   const streamsize __buf_len = this->epptr() - this->pptr();
   if (__buf_len)
     {
       const streamsize __remaining = __n - __ret;
       const streamsize __len = std::min(__buf_len, __remaining);
       traits_type::copy(this->pptr(), __s, __len);
       __ret += __len;
       __s += __len;
       this->__safe_pbump(__len);
     }

   if (__ret < __n)
     {
       int_type __c = this->overflow(traits_type::to_int_type(*__s));
       if (!traits_type::eq_int_type(__c, traits_type::eof()))
  {
    ++__ret;
    ++__s;
  }
       else
  break;
     }
 }
      return __ret;
    }




  template<typename _CharT, typename _Traits>
    streamsize
    __copy_streambufs_eof(basic_streambuf<_CharT, _Traits>* __sbin,
     basic_streambuf<_CharT, _Traits>* __sbout,
     bool& __ineof)
    {
      streamsize __ret = 0;
      __ineof = true;
      typename _Traits::int_type __c = __sbin->sgetc();
      while (!_Traits::eq_int_type(__c, _Traits::eof()))
 {
   __c = __sbout->sputc(_Traits::to_char_type(__c));
   if (_Traits::eq_int_type(__c, _Traits::eof()))
     {
       __ineof = false;
       break;
     }
   ++__ret;
   __c = __sbin->snextc();
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    inline streamsize
    __copy_streambufs(basic_streambuf<_CharT, _Traits>* __sbin,
        basic_streambuf<_CharT, _Traits>* __sbout)
    {
      bool __ineof;
      return __copy_streambufs_eof(__sbin, __sbout, __ineof);
    }




  extern template class basic_streambuf<char>;
  extern template
    streamsize
    __copy_streambufs(basic_streambuf<char>*,
        basic_streambuf<char>*);
  extern template
    streamsize
    __copy_streambufs_eof(basic_streambuf<char>*,
     basic_streambuf<char>*, bool&);


  extern template class basic_streambuf<wchar_t>;
  extern template
    streamsize
    __copy_streambufs(basic_streambuf<wchar_t>*,
        basic_streambuf<wchar_t>*);
  extern template
    streamsize
    __copy_streambufs_eof(basic_streambuf<wchar_t>*,
     basic_streambuf<wchar_t>*, bool&);




}
# 863 "/usr/include/c++/10.2.0/streambuf" 2 3
# 44 "/usr/include/c++/10.2.0/ios" 2 3
# 1 "/usr/include/c++/10.2.0/bits/basic_ios.h" 1 3
# 33 "/usr/include/c++/10.2.0/bits/basic_ios.h" 3
       
# 34 "/usr/include/c++/10.2.0/bits/basic_ios.h" 3



# 1 "/usr/include/c++/10.2.0/bits/locale_facets.h" 1 3
# 37 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
       
# 38 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3

# 1 "/usr/include/c++/10.2.0/cwctype" 1 3
# 39 "/usr/include/c++/10.2.0/cwctype" 3
       
# 40 "/usr/include/c++/10.2.0/cwctype" 3
# 50 "/usr/include/c++/10.2.0/cwctype" 3
# 1 "/usr/include/wctype.h" 1 3 4
# 38 "/usr/include/wctype.h" 3 4
# 1 "/usr/include/bits/wctype-wchar.h" 1 3 4
# 38 "/usr/include/bits/wctype-wchar.h" 3 4
typedef unsigned long int wctype_t;
# 56 "/usr/include/bits/wctype-wchar.h" 3 4
enum
{
  __ISwupper = 0,
  __ISwlower = 1,
  __ISwalpha = 2,
  __ISwdigit = 3,
  __ISwxdigit = 4,
  __ISwspace = 5,
  __ISwprint = 6,
  __ISwgraph = 7,
  __ISwblank = 8,
  __ISwcntrl = 9,
  __ISwpunct = 10,
  __ISwalnum = 11,

  _ISwupper = ((__ISwupper) < 8 ? (int) ((1UL << (__ISwupper)) << 24) : ((__ISwupper) < 16 ? (int) ((1UL << (__ISwupper)) << 8) : ((__ISwupper) < 24 ? (int) ((1UL << (__ISwupper)) >> 8) : (int) ((1UL << (__ISwupper)) >> 24)))),
  _ISwlower = ((__ISwlower) < 8 ? (int) ((1UL << (__ISwlower)) << 24) : ((__ISwlower) < 16 ? (int) ((1UL << (__ISwlower)) << 8) : ((__ISwlower) < 24 ? (int) ((1UL << (__ISwlower)) >> 8) : (int) ((1UL << (__ISwlower)) >> 24)))),
  _ISwalpha = ((__ISwalpha) < 8 ? (int) ((1UL << (__ISwalpha)) << 24) : ((__ISwalpha) < 16 ? (int) ((1UL << (__ISwalpha)) << 8) : ((__ISwalpha) < 24 ? (int) ((1UL << (__ISwalpha)) >> 8) : (int) ((1UL << (__ISwalpha)) >> 24)))),
  _ISwdigit = ((__ISwdigit) < 8 ? (int) ((1UL << (__ISwdigit)) << 24) : ((__ISwdigit) < 16 ? (int) ((1UL << (__ISwdigit)) << 8) : ((__ISwdigit) < 24 ? (int) ((1UL << (__ISwdigit)) >> 8) : (int) ((1UL << (__ISwdigit)) >> 24)))),
  _ISwxdigit = ((__ISwxdigit) < 8 ? (int) ((1UL << (__ISwxdigit)) << 24) : ((__ISwxdigit) < 16 ? (int) ((1UL << (__ISwxdigit)) << 8) : ((__ISwxdigit) < 24 ? (int) ((1UL << (__ISwxdigit)) >> 8) : (int) ((1UL << (__ISwxdigit)) >> 24)))),
  _ISwspace = ((__ISwspace) < 8 ? (int) ((1UL << (__ISwspace)) << 24) : ((__ISwspace) < 16 ? (int) ((1UL << (__ISwspace)) << 8) : ((__ISwspace) < 24 ? (int) ((1UL << (__ISwspace)) >> 8) : (int) ((1UL << (__ISwspace)) >> 24)))),
  _ISwprint = ((__ISwprint) < 8 ? (int) ((1UL << (__ISwprint)) << 24) : ((__ISwprint) < 16 ? (int) ((1UL << (__ISwprint)) << 8) : ((__ISwprint) < 24 ? (int) ((1UL << (__ISwprint)) >> 8) : (int) ((1UL << (__ISwprint)) >> 24)))),
  _ISwgraph = ((__ISwgraph) < 8 ? (int) ((1UL << (__ISwgraph)) << 24) : ((__ISwgraph) < 16 ? (int) ((1UL << (__ISwgraph)) << 8) : ((__ISwgraph) < 24 ? (int) ((1UL << (__ISwgraph)) >> 8) : (int) ((1UL << (__ISwgraph)) >> 24)))),
  _ISwblank = ((__ISwblank) < 8 ? (int) ((1UL << (__ISwblank)) << 24) : ((__ISwblank) < 16 ? (int) ((1UL << (__ISwblank)) << 8) : ((__ISwblank) < 24 ? (int) ((1UL << (__ISwblank)) >> 8) : (int) ((1UL << (__ISwblank)) >> 24)))),
  _ISwcntrl = ((__ISwcntrl) < 8 ? (int) ((1UL << (__ISwcntrl)) << 24) : ((__ISwcntrl) < 16 ? (int) ((1UL << (__ISwcntrl)) << 8) : ((__ISwcntrl) < 24 ? (int) ((1UL << (__ISwcntrl)) >> 8) : (int) ((1UL << (__ISwcntrl)) >> 24)))),
  _ISwpunct = ((__ISwpunct) < 8 ? (int) ((1UL << (__ISwpunct)) << 24) : ((__ISwpunct) < 16 ? (int) ((1UL << (__ISwpunct)) << 8) : ((__ISwpunct) < 24 ? (int) ((1UL << (__ISwpunct)) >> 8) : (int) ((1UL << (__ISwpunct)) >> 24)))),
  _ISwalnum = ((__ISwalnum) < 8 ? (int) ((1UL << (__ISwalnum)) << 24) : ((__ISwalnum) < 16 ? (int) ((1UL << (__ISwalnum)) << 8) : ((__ISwalnum) < 24 ? (int) ((1UL << (__ISwalnum)) >> 8) : (int) ((1UL << (__ISwalnum)) >> 24))))
};



extern "C" {







extern int iswalnum (wint_t __wc) noexcept (true);





extern int iswalpha (wint_t __wc) noexcept (true);


extern int iswcntrl (wint_t __wc) noexcept (true);



extern int iswdigit (wint_t __wc) noexcept (true);



extern int iswgraph (wint_t __wc) noexcept (true);




extern int iswlower (wint_t __wc) noexcept (true);


extern int iswprint (wint_t __wc) noexcept (true);




extern int iswpunct (wint_t __wc) noexcept (true);




extern int iswspace (wint_t __wc) noexcept (true);




extern int iswupper (wint_t __wc) noexcept (true);




extern int iswxdigit (wint_t __wc) noexcept (true);





extern int iswblank (wint_t __wc) noexcept (true);
# 155 "/usr/include/bits/wctype-wchar.h" 3 4
extern wctype_t wctype (const char *__property) noexcept (true);



extern int iswctype (wint_t __wc, wctype_t __desc) noexcept (true);






extern wint_t towlower (wint_t __wc) noexcept (true);


extern wint_t towupper (wint_t __wc) noexcept (true);

}
# 39 "/usr/include/wctype.h" 2 3 4





extern "C" {



typedef const __int32_t *wctrans_t;



extern wctrans_t wctrans (const char *__property) noexcept (true);


extern wint_t towctrans (wint_t __wc, wctrans_t __desc) noexcept (true);







extern int iswalnum_l (wint_t __wc, locale_t __locale) noexcept (true);





extern int iswalpha_l (wint_t __wc, locale_t __locale) noexcept (true);


extern int iswcntrl_l (wint_t __wc, locale_t __locale) noexcept (true);



extern int iswdigit_l (wint_t __wc, locale_t __locale) noexcept (true);



extern int iswgraph_l (wint_t __wc, locale_t __locale) noexcept (true);




extern int iswlower_l (wint_t __wc, locale_t __locale) noexcept (true);


extern int iswprint_l (wint_t __wc, locale_t __locale) noexcept (true);




extern int iswpunct_l (wint_t __wc, locale_t __locale) noexcept (true);




extern int iswspace_l (wint_t __wc, locale_t __locale) noexcept (true);




extern int iswupper_l (wint_t __wc, locale_t __locale) noexcept (true);




extern int iswxdigit_l (wint_t __wc, locale_t __locale) noexcept (true);




extern int iswblank_l (wint_t __wc, locale_t __locale) noexcept (true);



extern wctype_t wctype_l (const char *__property, locale_t __locale)
     noexcept (true);



extern int iswctype_l (wint_t __wc, wctype_t __desc, locale_t __locale)
     noexcept (true);






extern wint_t towlower_l (wint_t __wc, locale_t __locale) noexcept (true);


extern wint_t towupper_l (wint_t __wc, locale_t __locale) noexcept (true);



extern wctrans_t wctrans_l (const char *__property, locale_t __locale)
     noexcept (true);


extern wint_t towctrans_l (wint_t __wc, wctrans_t __desc,
      locale_t __locale) noexcept (true);



}
# 51 "/usr/include/c++/10.2.0/cwctype" 2 3
# 80 "/usr/include/c++/10.2.0/cwctype" 3
namespace std
{
  using ::wctrans_t;
  using ::wctype_t;
  using ::wint_t;

  using ::iswalnum;
  using ::iswalpha;

  using ::iswblank;

  using ::iswcntrl;
  using ::iswctype;
  using ::iswdigit;
  using ::iswgraph;
  using ::iswlower;
  using ::iswprint;
  using ::iswpunct;
  using ::iswspace;
  using ::iswupper;
  using ::iswxdigit;
  using ::towctrans;
  using ::towlower;
  using ::towupper;
  using ::wctrans;
  using ::wctype;
}
# 40 "/usr/include/c++/10.2.0/bits/locale_facets.h" 2 3
# 1 "/usr/include/c++/10.2.0/cctype" 1 3
# 39 "/usr/include/c++/10.2.0/cctype" 3
       
# 40 "/usr/include/c++/10.2.0/cctype" 3
# 41 "/usr/include/c++/10.2.0/bits/locale_facets.h" 2 3
# 1 "/usr/include/c++/10.2.0/x86_64-pc-linux-gnu/bits/ctype_base.h" 1 3
# 36 "/usr/include/c++/10.2.0/x86_64-pc-linux-gnu/bits/ctype_base.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  struct ctype_base
  {

    typedef const int* __to_type;



    typedef unsigned short mask;
    static const mask upper = _ISupper;
    static const mask lower = _ISlower;
    static const mask alpha = _ISalpha;
    static const mask digit = _ISdigit;
    static const mask xdigit = _ISxdigit;
    static const mask space = _ISspace;
    static const mask print = _ISprint;
    static const mask graph = _ISalpha | _ISdigit | _ISpunct;
    static const mask cntrl = _IScntrl;
    static const mask punct = _ISpunct;
    static const mask alnum = _ISalpha | _ISdigit;

    static const mask blank = _ISblank;

  };


}
# 42 "/usr/include/c++/10.2.0/bits/locale_facets.h" 2 3






# 1 "/usr/include/c++/10.2.0/bits/streambuf_iterator.h" 1 3
# 33 "/usr/include/c++/10.2.0/bits/streambuf_iterator.h" 3
       
# 34 "/usr/include/c++/10.2.0/bits/streambuf_iterator.h" 3




namespace std __attribute__ ((__visibility__ ("default")))
{

# 49 "/usr/include/c++/10.2.0/bits/streambuf_iterator.h" 3
  template<typename _CharT, typename _Traits>
    class istreambuf_iterator
    : public iterator<input_iterator_tag, _CharT, typename _Traits::off_type,
        _CharT*, _CharT>
    {
    public:
# 66 "/usr/include/c++/10.2.0/bits/streambuf_iterator.h" 3
      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename _Traits::int_type int_type;
      typedef basic_streambuf<_CharT, _Traits> streambuf_type;
      typedef basic_istream<_CharT, _Traits> istream_type;


      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
        ostreambuf_iterator<_CharT2> >::__type
 copy(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      ostreambuf_iterator<_CharT2>);

      template<bool _IsMove, typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
            _CharT2*>::__type
 __copy_move_a2(istreambuf_iterator<_CharT2>,
         istreambuf_iterator<_CharT2>, _CharT2*);


      template<typename _CharT2, typename _Size>
 friend __enable_if_t<__is_char<_CharT2>::__value, _CharT2*>
 __copy_n_a(istreambuf_iterator<_CharT2>, _Size, _CharT2*);


      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
        istreambuf_iterator<_CharT2> >::__type
 find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      const _CharT2&);

      template<typename _CharT2, typename _Distance>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
            void>::__type
 advance(istreambuf_iterator<_CharT2>&, _Distance);

    private:







      mutable streambuf_type* _M_sbuf;
      int_type _M_c;

    public:

      constexpr istreambuf_iterator() noexcept
      : _M_sbuf(0), _M_c(traits_type::eof()) { }







      istreambuf_iterator(const istreambuf_iterator&) noexcept = default;

      ~istreambuf_iterator() = default;



      istreambuf_iterator(istream_type& __s) noexcept
      : _M_sbuf(__s.rdbuf()), _M_c(traits_type::eof()) { }


      istreambuf_iterator(streambuf_type* __s) noexcept
      : _M_sbuf(__s), _M_c(traits_type::eof()) { }


      istreambuf_iterator&
      operator=(const istreambuf_iterator&) noexcept = default;





      char_type
      operator*() const
      {
 int_type __c = _M_get();
# 157 "/usr/include/c++/10.2.0/bits/streambuf_iterator.h" 3
 return traits_type::to_char_type(__c);
      }


      istreambuf_iterator&
      operator++()
      {



                        ;

 _M_sbuf->sbumpc();
 _M_c = traits_type::eof();
 return *this;
      }


      istreambuf_iterator
      operator++(int)
      {



                        ;

 istreambuf_iterator __old = *this;
 __old._M_c = _M_sbuf->sbumpc();
 _M_c = traits_type::eof();
 return __old;
      }





      bool
      equal(const istreambuf_iterator& __b) const
      { return _M_at_eof() == __b._M_at_eof(); }

    private:
      int_type
      _M_get() const
      {
 int_type __ret = _M_c;
 if (_M_sbuf && _S_is_eof(__ret) && _S_is_eof(__ret = _M_sbuf->sgetc()))
   _M_sbuf = 0;
 return __ret;
      }

      bool
      _M_at_eof() const
      { return _S_is_eof(_M_get()); }

      static bool
      _S_is_eof(int_type __c)
      {
 const int_type __eof = traits_type::eof();
 return traits_type::eq_int_type(__c, __eof);
      }






    };

  template<typename _CharT, typename _Traits>
    inline bool
    operator==(const istreambuf_iterator<_CharT, _Traits>& __a,
        const istreambuf_iterator<_CharT, _Traits>& __b)
    { return __a.equal(__b); }

  template<typename _CharT, typename _Traits>
    inline bool
    operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
        const istreambuf_iterator<_CharT, _Traits>& __b)
    { return !__a.equal(__b); }


  template<typename _CharT, typename _Traits>
    class ostreambuf_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    public:






      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef basic_streambuf<_CharT, _Traits> streambuf_type;
      typedef basic_ostream<_CharT, _Traits> ostream_type;


      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
        ostreambuf_iterator<_CharT2> >::__type
 copy(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      ostreambuf_iterator<_CharT2>);

    private:
      streambuf_type* _M_sbuf;
      bool _M_failed;

    public:
# 274 "/usr/include/c++/10.2.0/bits/streambuf_iterator.h" 3
      ostreambuf_iterator(ostream_type& __s) noexcept
      : _M_sbuf(__s.rdbuf()), _M_failed(!_M_sbuf) { }


      ostreambuf_iterator(streambuf_type* __s) noexcept
      : _M_sbuf(__s), _M_failed(!_M_sbuf) { }


      ostreambuf_iterator&
      operator=(_CharT __c)
      {
 if (!_M_failed &&
     _Traits::eq_int_type(_M_sbuf->sputc(__c), _Traits::eof()))
   _M_failed = true;
 return *this;
      }


      ostreambuf_iterator&
      operator*()
      { return *this; }


      ostreambuf_iterator&
      operator++(int)
      { return *this; }


      ostreambuf_iterator&
      operator++()
      { return *this; }


      bool
      failed() const noexcept
      { return _M_failed; }

      ostreambuf_iterator&
      _M_put(const _CharT* __ws, streamsize __len)
      {
 if (__builtin_expect(!_M_failed, true)
     && __builtin_expect(this->_M_sbuf->sputn(__ws, __len) != __len,
    false))
   _M_failed = true;
 return *this;
      }
    };


  template<typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        ostreambuf_iterator<_CharT> >::__type
    copy(istreambuf_iterator<_CharT> __first,
  istreambuf_iterator<_CharT> __last,
  ostreambuf_iterator<_CharT> __result)
    {
      if (__first._M_sbuf && !__last._M_sbuf && !__result._M_failed)
 {
   bool __ineof;
   __copy_streambufs_eof(__first._M_sbuf, __result._M_sbuf, __ineof);
   if (!__ineof)
     __result._M_failed = true;
 }
      return __result;
    }

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        ostreambuf_iterator<_CharT> >::__type
    __copy_move_a2(_CharT* __first, _CharT* __last,
     ostreambuf_iterator<_CharT> __result)
    {
      const streamsize __num = __last - __first;
      if (__num > 0)
 __result._M_put(__first, __num);
      return __result;
    }

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        ostreambuf_iterator<_CharT> >::__type
    __copy_move_a2(const _CharT* __first, const _CharT* __last,
     ostreambuf_iterator<_CharT> __result)
    {
      const streamsize __num = __last - __first;
      if (__num > 0)
 __result._M_put(__first, __num);
      return __result;
    }

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        _CharT*>::__type
    __copy_move_a2(istreambuf_iterator<_CharT> __first,
     istreambuf_iterator<_CharT> __last, _CharT* __result)
    {
      typedef istreambuf_iterator<_CharT> __is_iterator_type;
      typedef typename __is_iterator_type::traits_type traits_type;
      typedef typename __is_iterator_type::streambuf_type streambuf_type;
      typedef typename traits_type::int_type int_type;

      if (__first._M_sbuf && !__last._M_sbuf)
 {
   streambuf_type* __sb = __first._M_sbuf;
   int_type __c = __sb->sgetc();
   while (!traits_type::eq_int_type(__c, traits_type::eof()))
     {
       const streamsize __n = __sb->egptr() - __sb->gptr();
       if (__n > 1)
  {
    traits_type::copy(__result, __sb->gptr(), __n);
    __sb->__safe_gbump(__n);
    __result += __n;
    __c = __sb->underflow();
  }
       else
  {
    *__result++ = traits_type::to_char_type(__c);
    __c = __sb->snextc();
  }
     }
 }
      return __result;
    }


  template<typename _CharT, typename _Size>
    __enable_if_t<__is_char<_CharT>::__value, _CharT*>
    __copy_n_a(istreambuf_iterator<_CharT> __it, _Size __n, _CharT* __result)
    {
      if (__n == 0)
 return __result;

     

                            ;
      _CharT* __beg = __result;
      __result += __it._M_sbuf->sgetn(__beg, __n);
     

                            ;
      return __result;
    }


  template<typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
          istreambuf_iterator<_CharT> >::__type
    find(istreambuf_iterator<_CharT> __first,
  istreambuf_iterator<_CharT> __last, const _CharT& __val)
    {
      typedef istreambuf_iterator<_CharT> __is_iterator_type;
      typedef typename __is_iterator_type::traits_type traits_type;
      typedef typename __is_iterator_type::streambuf_type streambuf_type;
      typedef typename traits_type::int_type int_type;
      const int_type __eof = traits_type::eof();

      if (__first._M_sbuf && !__last._M_sbuf)
 {
   const int_type __ival = traits_type::to_int_type(__val);
   streambuf_type* __sb = __first._M_sbuf;
   int_type __c = __sb->sgetc();
   while (!traits_type::eq_int_type(__c, __eof)
   && !traits_type::eq_int_type(__c, __ival))
     {
       streamsize __n = __sb->egptr() - __sb->gptr();
       if (__n > 1)
  {
    const _CharT* __p = traits_type::find(__sb->gptr(),
       __n, __val);
    if (__p)
      __n = __p - __sb->gptr();
    __sb->__safe_gbump(__n);
    __c = __sb->sgetc();
  }
       else
  __c = __sb->snextc();
     }

   __first._M_c = __eof;
 }

      return __first;
    }

  template<typename _CharT, typename _Distance>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        void>::__type
    advance(istreambuf_iterator<_CharT>& __i, _Distance __n)
    {
      if (__n == 0)
 return;

      ;
     

                           ;

      typedef istreambuf_iterator<_CharT> __is_iterator_type;
      typedef typename __is_iterator_type::traits_type traits_type;
      typedef typename __is_iterator_type::streambuf_type streambuf_type;
      typedef typename traits_type::int_type int_type;
      const int_type __eof = traits_type::eof();

      streambuf_type* __sb = __i._M_sbuf;
      while (__n > 0)
 {
   streamsize __size = __sb->egptr() - __sb->gptr();
   if (__size > __n)
     {
       __sb->__safe_gbump(__n);
       break;
     }

   __sb->__safe_gbump(__size);
   __n -= __size;
   if (traits_type::eq_int_type(__sb->underflow(), __eof))
     {
      

                      ;
       break;
     }
 }

      __i._M_c = __eof;
    }




}
# 49 "/usr/include/c++/10.2.0/bits/locale_facets.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 71 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
  template<typename _Tp>
    void
    __convert_to_v(const char*, _Tp&, ios_base::iostate&,
     const __c_locale&) throw();


  template<>
    void
    __convert_to_v(const char*, float&, ios_base::iostate&,
     const __c_locale&) throw();

  template<>
    void
    __convert_to_v(const char*, double&, ios_base::iostate&,
     const __c_locale&) throw();

  template<>
    void
    __convert_to_v(const char*, long double&, ios_base::iostate&,
     const __c_locale&) throw();



  template<typename _CharT, typename _Traits>
    struct __pad
    {
      static void
      _S_pad(ios_base& __io, _CharT __fill, _CharT* __news,
      const _CharT* __olds, streamsize __newlen, streamsize __oldlen);
    };






  template<typename _CharT>
    _CharT*
    __add_grouping(_CharT* __s, _CharT __sep,
     const char* __gbeg, size_t __gsize,
     const _CharT* __first, const _CharT* __last);




  template<typename _CharT>
    inline
    ostreambuf_iterator<_CharT>
    __write(ostreambuf_iterator<_CharT> __s, const _CharT* __ws, int __len)
    {
      __s._M_put(__ws, __len);
      return __s;
    }


  template<typename _CharT, typename _OutIter>
    inline
    _OutIter
    __write(_OutIter __s, const _CharT* __ws, int __len)
    {
      for (int __j = 0; __j < __len; __j++, ++__s)
 *__s = __ws[__j];
      return __s;
    }
# 149 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
  template<typename _CharT>
    class __ctype_abstract_base : public locale::facet, public ctype_base
    {
    public:


      typedef _CharT char_type;
# 168 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      bool
      is(mask __m, char_type __c) const
      { return this->do_is(__m, __c); }
# 185 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      const char_type*
      is(const char_type *__lo, const char_type *__hi, mask *__vec) const
      { return this->do_is(__lo, __hi, __vec); }
# 201 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      const char_type*
      scan_is(mask __m, const char_type* __lo, const char_type* __hi) const
      { return this->do_scan_is(__m, __lo, __hi); }
# 217 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      const char_type*
      scan_not(mask __m, const char_type* __lo, const char_type* __hi) const
      { return this->do_scan_not(__m, __lo, __hi); }
# 231 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      char_type
      toupper(char_type __c) const
      { return this->do_toupper(__c); }
# 246 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      const char_type*
      toupper(char_type *__lo, const char_type* __hi) const
      { return this->do_toupper(__lo, __hi); }
# 260 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      char_type
      tolower(char_type __c) const
      { return this->do_tolower(__c); }
# 275 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      const char_type*
      tolower(char_type* __lo, const char_type* __hi) const
      { return this->do_tolower(__lo, __hi); }
# 292 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      char_type
      widen(char __c) const
      { return this->do_widen(__c); }
# 311 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      const char*
      widen(const char* __lo, const char* __hi, char_type* __to) const
      { return this->do_widen(__lo, __hi, __to); }
# 330 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      char
      narrow(char_type __c, char __dfault) const
      { return this->do_narrow(__c, __dfault); }
# 352 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      const char_type*
      narrow(const char_type* __lo, const char_type* __hi,
       char __dfault, char* __to) const
      { return this->do_narrow(__lo, __hi, __dfault, __to); }

    protected:
      explicit
      __ctype_abstract_base(size_t __refs = 0): facet(__refs) { }

      virtual
      ~__ctype_abstract_base() { }
# 377 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      virtual bool
      do_is(mask __m, char_type __c) const = 0;
# 396 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi,
     mask* __vec) const = 0;
# 415 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo,
   const char_type* __hi) const = 0;
# 434 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const = 0;
# 452 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      virtual char_type
      do_toupper(char_type __c) const = 0;
# 469 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const = 0;
# 485 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      virtual char_type
      do_tolower(char_type __c) const = 0;
# 502 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const = 0;
# 521 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      virtual char_type
      do_widen(char __c) const = 0;
# 542 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __to) const = 0;
# 563 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      virtual char
      do_narrow(char_type __c, char __dfault) const = 0;
# 588 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __to) const = 0;
    };
# 611 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
  template<typename _CharT>
    class ctype : public __ctype_abstract_base<_CharT>
    {
    public:

      typedef _CharT char_type;
      typedef typename __ctype_abstract_base<_CharT>::mask mask;


      static locale::id id;

      explicit
      ctype(size_t __refs = 0) : __ctype_abstract_base<_CharT>(__refs) { }

   protected:
      virtual
      ~ctype();

      virtual bool
      do_is(mask __m, char_type __c) const;

      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi, mask* __vec) const;

      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo, const char_type* __hi) const;

      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const;

      virtual char_type
      do_toupper(char_type __c) const;

      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;

      virtual char_type
      do_tolower(char_type __c) const;

      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;

      virtual char_type
      do_widen(char __c) const;

      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __dest) const;

      virtual char
      do_narrow(char_type, char __dfault) const;

      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __to) const;
    };

  template<typename _CharT>
    locale::id ctype<_CharT>::id;
# 680 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
  template<>
    class ctype<char> : public locale::facet, public ctype_base
    {
    public:


      typedef char char_type;

    protected:

      __c_locale _M_c_locale_ctype;
      bool _M_del;
      __to_type _M_toupper;
      __to_type _M_tolower;
      const mask* _M_table;
      mutable char _M_widen_ok;
      mutable char _M_widen[1 + static_cast<unsigned char>(-1)];
      mutable char _M_narrow[1 + static_cast<unsigned char>(-1)];
      mutable char _M_narrow_ok;


    public:

      static locale::id id;

      static const size_t table_size = 1 + static_cast<unsigned char>(-1);
# 717 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      explicit
      ctype(const mask* __table = 0, bool __del = false, size_t __refs = 0);
# 730 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      explicit
      ctype(__c_locale __cloc, const mask* __table = 0, bool __del = false,
     size_t __refs = 0);
# 743 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      inline bool
      is(mask __m, char __c) const;
# 758 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      inline const char*
      is(const char* __lo, const char* __hi, mask* __vec) const;
# 772 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      inline const char*
      scan_is(mask __m, const char* __lo, const char* __hi) const;
# 786 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      inline const char*
      scan_not(mask __m, const char* __lo, const char* __hi) const;
# 801 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      char_type
      toupper(char_type __c) const
      { return this->do_toupper(__c); }
# 818 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      const char_type*
      toupper(char_type *__lo, const char_type* __hi) const
      { return this->do_toupper(__lo, __hi); }
# 834 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      char_type
      tolower(char_type __c) const
      { return this->do_tolower(__c); }
# 851 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      const char_type*
      tolower(char_type* __lo, const char_type* __hi) const
      { return this->do_tolower(__lo, __hi); }
# 871 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      char_type
      widen(char __c) const
      {
 if (_M_widen_ok)
   return _M_widen[static_cast<unsigned char>(__c)];
 this->_M_widen_init();
 return this->do_widen(__c);
      }
# 898 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      const char*
      widen(const char* __lo, const char* __hi, char_type* __to) const
      {
 if (_M_widen_ok == 1)
   {
     if (__builtin_expect(__hi != __lo, true))
       __builtin_memcpy(__to, __lo, __hi - __lo);
     return __hi;
   }
 if (!_M_widen_ok)
   _M_widen_init();
 return this->do_widen(__lo, __hi, __to);
      }
# 930 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      char
      narrow(char_type __c, char __dfault) const
      {
 if (_M_narrow[static_cast<unsigned char>(__c)])
   return _M_narrow[static_cast<unsigned char>(__c)];
 const char __t = do_narrow(__c, __dfault);
 if (__t != __dfault)
   _M_narrow[static_cast<unsigned char>(__c)] = __t;
 return __t;
      }
# 963 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      const char_type*
      narrow(const char_type* __lo, const char_type* __hi,
      char __dfault, char* __to) const
      {
 if (__builtin_expect(_M_narrow_ok == 1, true))
   {
     if (__builtin_expect(__hi != __lo, true))
       __builtin_memcpy(__to, __lo, __hi - __lo);
     return __hi;
   }
 if (!_M_narrow_ok)
   _M_narrow_init();
 return this->do_narrow(__lo, __hi, __dfault, __to);
      }





      const mask*
      table() const throw()
      { return _M_table; }


      static const mask*
      classic_table() throw();
    protected:







      virtual
      ~ctype();
# 1013 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      virtual char_type
      do_toupper(char_type __c) const;
# 1030 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;
# 1046 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      virtual char_type
      do_tolower(char_type __c) const;
# 1063 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;
# 1083 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      virtual char_type
      do_widen(char __c) const
      { return __c; }
# 1106 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __to) const
      {
 if (__builtin_expect(__hi != __lo, true))
   __builtin_memcpy(__to, __lo, __hi - __lo);
 return __hi;
      }
# 1133 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      virtual char
      do_narrow(char_type __c, char __dfault __attribute__((__unused__))) const
      { return __c; }
# 1159 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault __attribute__((__unused__)), char* __to) const
      {
 if (__builtin_expect(__hi != __lo, true))
   __builtin_memcpy(__to, __lo, __hi - __lo);
 return __hi;
      }

    private:
      void _M_narrow_init() const;
      void _M_widen_init() const;
    };
# 1185 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
  template<>
    class ctype<wchar_t> : public __ctype_abstract_base<wchar_t>
    {
    public:


      typedef wchar_t char_type;
      typedef wctype_t __wmask_type;

    protected:
      __c_locale _M_c_locale_ctype;


      bool _M_narrow_ok;
      char _M_narrow[128];
      wint_t _M_widen[1 + static_cast<unsigned char>(-1)];


      mask _M_bit[16];
      __wmask_type _M_wmask[16];

    public:


      static locale::id id;
# 1218 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      explicit
      ctype(size_t __refs = 0);
# 1229 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      explicit
      ctype(__c_locale __cloc, size_t __refs = 0);

    protected:
      __wmask_type
      _M_convert_to_wmask(const mask __m) const throw();


      virtual
      ~ctype();
# 1253 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      virtual bool
      do_is(mask __m, char_type __c) const;
# 1272 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi, mask* __vec) const;
# 1290 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo, const char_type* __hi) const;
# 1308 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const;
# 1325 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      virtual char_type
      do_toupper(char_type __c) const;
# 1342 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;
# 1358 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      virtual char_type
      do_tolower(char_type __c) const;
# 1375 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;
# 1395 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      virtual char_type
      do_widen(char __c) const;
# 1417 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __to) const;
# 1440 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      virtual char
      do_narrow(char_type __c, char __dfault) const;
# 1466 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __to) const;


      void
      _M_initialize_ctype() throw();
    };



  template<typename _CharT>
    class ctype_byname : public ctype<_CharT>
    {
    public:
      typedef typename ctype<_CharT>::mask mask;

      explicit
      ctype_byname(const char* __s, size_t __refs = 0);


      explicit
      ctype_byname(const string& __s, size_t __refs = 0)
      : ctype_byname(__s.c_str(), __refs) { }


    protected:
      virtual
      ~ctype_byname() { }
    };


  template<>
    class ctype_byname<char> : public ctype<char>
    {
    public:
      explicit
      ctype_byname(const char* __s, size_t __refs = 0);


      explicit
      ctype_byname(const string& __s, size_t __refs = 0);


    protected:
      virtual
      ~ctype_byname();
    };


  template<>
    class ctype_byname<wchar_t> : public ctype<wchar_t>
    {
    public:
      explicit
      ctype_byname(const char* __s, size_t __refs = 0);


      explicit
      ctype_byname(const string& __s, size_t __refs = 0);


    protected:
      virtual
      ~ctype_byname();
    };



}


# 1 "/usr/include/c++/10.2.0/x86_64-pc-linux-gnu/bits/ctype_inline.h" 1 3
# 37 "/usr/include/c++/10.2.0/x86_64-pc-linux-gnu/bits/ctype_inline.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  bool
  ctype<char>::
  is(mask __m, char __c) const
  { return _M_table[static_cast<unsigned char>(__c)] & __m; }

  const char*
  ctype<char>::
  is(const char* __low, const char* __high, mask* __vec) const
  {
    while (__low < __high)
      *__vec++ = _M_table[static_cast<unsigned char>(*__low++)];
    return __high;
  }

  const char*
  ctype<char>::
  scan_is(mask __m, const char* __low, const char* __high) const
  {
    while (__low < __high
    && !(_M_table[static_cast<unsigned char>(*__low)] & __m))
      ++__low;
    return __low;
  }

  const char*
  ctype<char>::
  scan_not(mask __m, const char* __low, const char* __high) const
  {
    while (__low < __high
    && (_M_table[static_cast<unsigned char>(*__low)] & __m) != 0)
      ++__low;
    return __low;
  }


}
# 1539 "/usr/include/c++/10.2.0/bits/locale_facets.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{



  class __num_base
  {
  public:


    enum
      {
 _S_ominus,
 _S_oplus,
 _S_ox,
 _S_oX,
 _S_odigits,
 _S_odigits_end = _S_odigits + 16,
 _S_oudigits = _S_odigits_end,
 _S_oudigits_end = _S_oudigits + 16,
 _S_oe = _S_odigits + 14,
 _S_oE = _S_oudigits + 14,
 _S_oend = _S_oudigits_end
      };






    static const char* _S_atoms_out;



    static const char* _S_atoms_in;

    enum
    {
      _S_iminus,
      _S_iplus,
      _S_ix,
      _S_iX,
      _S_izero,
      _S_ie = _S_izero + 14,
      _S_iE = _S_izero + 20,
      _S_iend = 26
    };



    static void
    _S_format_float(const ios_base& __io, char* __fptr, char __mod) throw();
  };

  template<typename _CharT>
    struct __numpunct_cache : public locale::facet
    {
      const char* _M_grouping;
      size_t _M_grouping_size;
      bool _M_use_grouping;
      const _CharT* _M_truename;
      size_t _M_truename_size;
      const _CharT* _M_falsename;
      size_t _M_falsename_size;
      _CharT _M_decimal_point;
      _CharT _M_thousands_sep;





      _CharT _M_atoms_out[__num_base::_S_oend];





      _CharT _M_atoms_in[__num_base::_S_iend];

      bool _M_allocated;

      __numpunct_cache(size_t __refs = 0)
      : facet(__refs), _M_grouping(0), _M_grouping_size(0),
 _M_use_grouping(false),
 _M_truename(0), _M_truename_size(0), _M_falsename(0),
 _M_falsename_size(0), _M_decimal_point(_CharT()),
 _M_thousands_sep(_CharT()), _M_allocated(false)
 { }

      ~__numpunct_cache();

      void
      _M_cache(const locale& __loc);

    private:
      __numpunct_cache&
      operator=(const __numpunct_cache&);

      explicit
      __numpunct_cache(const __numpunct_cache&);
    };

  template<typename _CharT>
    __numpunct_cache<_CharT>::~__numpunct_cache()
    {
      if (_M_allocated)
 {
   delete [] _M_grouping;
   delete [] _M_truename;
   delete [] _M_falsename;
 }
    }

namespace __cxx11 {
# 1669 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
  template<typename _CharT>
    class numpunct : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      typedef __numpunct_cache<_CharT> __cache_type;

    protected:
      __cache_type* _M_data;

    public:

      static locale::id id;






      explicit
      numpunct(size_t __refs = 0)
      : facet(__refs), _M_data(0)
      { _M_initialize_numpunct(); }
# 1707 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      explicit
      numpunct(__cache_type* __cache, size_t __refs = 0)
      : facet(__refs), _M_data(__cache)
      { _M_initialize_numpunct(); }
# 1721 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      explicit
      numpunct(__c_locale __cloc, size_t __refs = 0)
      : facet(__refs), _M_data(0)
      { _M_initialize_numpunct(__cloc); }
# 1735 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      char_type
      decimal_point() const
      { return this->do_decimal_point(); }
# 1748 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      char_type
      thousands_sep() const
      { return this->do_thousands_sep(); }
# 1779 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      string
      grouping() const
      { return this->do_grouping(); }
# 1792 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      string_type
      truename() const
      { return this->do_truename(); }
# 1805 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      string_type
      falsename() const
      { return this->do_falsename(); }

    protected:

      virtual
      ~numpunct();
# 1822 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      virtual char_type
      do_decimal_point() const
      { return _M_data->_M_decimal_point; }
# 1834 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      virtual char_type
      do_thousands_sep() const
      { return _M_data->_M_thousands_sep; }
# 1847 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      virtual string
      do_grouping() const
      { return _M_data->_M_grouping; }
# 1860 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      virtual string_type
      do_truename() const
      { return _M_data->_M_truename; }
# 1873 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      virtual string_type
      do_falsename() const
      { return _M_data->_M_falsename; }


      void
      _M_initialize_numpunct(__c_locale __cloc = 0);
    };

  template<typename _CharT>
    locale::id numpunct<_CharT>::id;

  template<>
    numpunct<char>::~numpunct();

  template<>
    void
    numpunct<char>::_M_initialize_numpunct(__c_locale __cloc);


  template<>
    numpunct<wchar_t>::~numpunct();

  template<>
    void
    numpunct<wchar_t>::_M_initialize_numpunct(__c_locale __cloc);



  template<typename _CharT>
    class numpunct_byname : public numpunct<_CharT>
    {
    public:
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      explicit
      numpunct_byname(const char* __s, size_t __refs = 0)
      : numpunct<_CharT>(__refs)
      {
 if (__builtin_strcmp(__s, "C") != 0
     && __builtin_strcmp(__s, "POSIX") != 0)
   {
     __c_locale __tmp;
     this->_S_create_c_locale(__tmp, __s);
     this->_M_initialize_numpunct(__tmp);
     this->_S_destroy_c_locale(__tmp);
   }
      }


      explicit
      numpunct_byname(const string& __s, size_t __refs = 0)
      : numpunct_byname(__s.c_str(), __refs) { }


    protected:
      virtual
      ~numpunct_byname() { }
    };

}


# 1951 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
  template<typename _CharT, typename _InIter>
    class num_get : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef _InIter iter_type;



      static locale::id id;
# 1972 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      explicit
      num_get(size_t __refs = 0) : facet(__refs) { }
# 1998 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, bool& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
# 2035 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned short& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned int& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }


      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned long long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
# 2095 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, float& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, double& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long double& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
# 2138 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, void*& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

    protected:

      virtual ~num_get() { }

      __attribute ((__abi_tag__ ("cxx11")))
      iter_type
      _M_extract_float(iter_type, iter_type, ios_base&, ios_base::iostate&,
         string&) const;

      template<typename _ValueT>
 __attribute ((__abi_tag__ ("cxx11")))
 iter_type
 _M_extract_int(iter_type, iter_type, ios_base&, ios_base::iostate&,
         _ValueT&) const;

      template<typename _CharT2>
      typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, int>::__type
 _M_find(const _CharT2*, size_t __len, _CharT2 __c) const
 {
   int __ret = -1;
   if (__len <= 10)
     {
       if (__c >= _CharT2('0') && __c < _CharT2(_CharT2('0') + __len))
  __ret = __c - _CharT2('0');
     }
   else
     {
       if (__c >= _CharT2('0') && __c <= _CharT2('9'))
  __ret = __c - _CharT2('0');
       else if (__c >= _CharT2('a') && __c <= _CharT2('f'))
  __ret = 10 + (__c - _CharT2('a'));
       else if (__c >= _CharT2('A') && __c <= _CharT2('F'))
  __ret = 10 + (__c - _CharT2('A'));
     }
   return __ret;
 }

      template<typename _CharT2>
      typename __gnu_cxx::__enable_if<!__is_char<_CharT2>::__value,
          int>::__type
 _M_find(const _CharT2* __zero, size_t __len, _CharT2 __c) const
 {
   int __ret = -1;
   const char_type* __q = char_traits<_CharT2>::find(__zero, __len, __c);
   if (__q)
     {
       __ret = __q - __zero;
       if (__ret > 15)
  __ret -= 6;
     }
   return __ret;
 }
# 2211 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, bool&) const;

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned short& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned int& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }


      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, long long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned long long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }


      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, float&) const;

      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&,
      double&) const;







      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&,
      long double&) const;


      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, void*&) const;
# 2274 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
    };

  template<typename _CharT, typename _InIter>
    locale::id num_get<_CharT, _InIter>::id;
# 2292 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
  template<typename _CharT, typename _OutIter>
    class num_put : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef _OutIter iter_type;



      static locale::id id;
# 2313 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      explicit
      num_put(size_t __refs = 0) : facet(__refs) { }
# 2331 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill, bool __v) const
      { return this->do_put(__s, __io, __fill, __v); }
# 2373 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill, long __v) const
      { return this->do_put(__s, __io, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill,
   unsigned long __v) const
      { return this->do_put(__s, __io, __fill, __v); }


      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill, long long __v) const
      { return this->do_put(__s, __io, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill,
   unsigned long long __v) const
      { return this->do_put(__s, __io, __fill, __v); }
# 2436 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill, double __v) const
      { return this->do_put(__s, __io, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill,
   long double __v) const
      { return this->do_put(__s, __io, __fill, __v); }
# 2461 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill,
   const void* __v) const
      { return this->do_put(__s, __io, __fill, __v); }

    protected:
      template<typename _ValueT>
 iter_type
 _M_insert_float(iter_type, ios_base& __io, char_type __fill,
   char __mod, _ValueT __v) const;

      void
      _M_group_float(const char* __grouping, size_t __grouping_size,
       char_type __sep, const char_type* __p, char_type* __new,
       char_type* __cs, int& __len) const;

      template<typename _ValueT>
 iter_type
 _M_insert_int(iter_type, ios_base& __io, char_type __fill,
        _ValueT __v) const;

      void
      _M_group_int(const char* __grouping, size_t __grouping_size,
     char_type __sep, ios_base& __io, char_type* __new,
     char_type* __cs, int& __len) const;

      void
      _M_pad(char_type __fill, streamsize __w, ios_base& __io,
      char_type* __new, const char_type* __cs, int& __len) const;


      virtual
      ~num_put() { }
# 2509 "/usr/include/c++/10.2.0/bits/locale_facets.h" 3
      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill, bool __v) const;

      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill, long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }

      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill,
      unsigned long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }


      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill,
      long long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }

      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill,
      unsigned long long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }


      virtual iter_type
      do_put(iter_type, ios_base&, char_type, double) const;






      virtual iter_type
      do_put(iter_type, ios_base&, char_type, long double) const;


      virtual iter_type
      do_put(iter_type, ios_base&, char_type, const void*) const;







    };

  template <typename _CharT, typename _OutIter>
    locale::id num_put<_CharT, _OutIter>::id;









  template<typename _CharT>
    inline bool
    isspace(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::space, __c); }


  template<typename _CharT>
    inline bool
    isprint(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::print, __c); }


  template<typename _CharT>
    inline bool
    iscntrl(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::cntrl, __c); }


  template<typename _CharT>
    inline bool
    isupper(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::upper, __c); }


  template<typename _CharT>
    inline bool
    islower(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::lower, __c); }


  template<typename _CharT>
    inline bool
    isalpha(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alpha, __c); }


  template<typename _CharT>
    inline bool
    isdigit(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::digit, __c); }


  template<typename _CharT>
    inline bool
    ispunct(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::punct, __c); }


  template<typename _CharT>
    inline bool
    isxdigit(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::xdigit, __c); }


  template<typename _CharT>
    inline bool
    isalnum(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alnum, __c); }


  template<typename _CharT>
    inline bool
    isgraph(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::graph, __c); }



  template<typename _CharT>
    inline bool
    isblank(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::blank, __c); }



  template<typename _CharT>
    inline _CharT
    toupper(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).toupper(__c); }


  template<typename _CharT>
    inline _CharT
    tolower(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).tolower(__c); }


}

# 1 "/usr/include/c++/10.2.0/bits/locale_facets.tcc" 1 3
# 33 "/usr/include/c++/10.2.0/bits/locale_facets.tcc" 3
       
# 34 "/usr/include/c++/10.2.0/bits/locale_facets.tcc" 3

namespace std __attribute__ ((__visibility__ ("default")))
{




  template<typename _Facet>
    struct __use_cache
    {
      const _Facet*
      operator() (const locale& __loc) const;
    };


  template<typename _CharT>
    struct __use_cache<__numpunct_cache<_CharT> >
    {
      const __numpunct_cache<_CharT>*
      operator() (const locale& __loc) const
      {
 const size_t __i = numpunct<_CharT>::id._M_id();
 const locale::facet** __caches = __loc._M_impl->_M_caches;
 if (!__caches[__i])
   {
     __numpunct_cache<_CharT>* __tmp = 0;
     try
       {
  __tmp = new __numpunct_cache<_CharT>;
  __tmp->_M_cache(__loc);
       }
     catch(...)
       {
  delete __tmp;
  throw;
       }
     __loc._M_impl->_M_install_cache(__tmp, __i);
   }
 return static_cast<const __numpunct_cache<_CharT>*>(__caches[__i]);
      }
    };

  template<typename _CharT>
    void
    __numpunct_cache<_CharT>::_M_cache(const locale& __loc)
    {
      const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);

      char* __grouping = 0;
      _CharT* __truename = 0;
      _CharT* __falsename = 0;
      try
 {
   const string& __g = __np.grouping();
   _M_grouping_size = __g.size();
   __grouping = new char[_M_grouping_size];
   __g.copy(__grouping, _M_grouping_size);
   _M_use_grouping = (_M_grouping_size
        && static_cast<signed char>(__grouping[0]) > 0
        && (__grouping[0]
     != __gnu_cxx::__numeric_traits<char>::__max));

   const basic_string<_CharT>& __tn = __np.truename();
   _M_truename_size = __tn.size();
   __truename = new _CharT[_M_truename_size];
   __tn.copy(__truename, _M_truename_size);

   const basic_string<_CharT>& __fn = __np.falsename();
   _M_falsename_size = __fn.size();
   __falsename = new _CharT[_M_falsename_size];
   __fn.copy(__falsename, _M_falsename_size);

   _M_decimal_point = __np.decimal_point();
   _M_thousands_sep = __np.thousands_sep();

   const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__loc);
   __ct.widen(__num_base::_S_atoms_out,
       __num_base::_S_atoms_out
       + __num_base::_S_oend, _M_atoms_out);
   __ct.widen(__num_base::_S_atoms_in,
       __num_base::_S_atoms_in
       + __num_base::_S_iend, _M_atoms_in);

   _M_grouping = __grouping;
   _M_truename = __truename;
   _M_falsename = __falsename;
   _M_allocated = true;
 }
      catch(...)
 {
   delete [] __grouping;
   delete [] __truename;
   delete [] __falsename;
   throw;
 }
    }
# 139 "/usr/include/c++/10.2.0/bits/locale_facets.tcc" 3
  __attribute__ ((__pure__)) bool
  __verify_grouping(const char* __grouping, size_t __grouping_size,
      const string& __grouping_tmp) throw ();



  template<typename _CharT, typename _InIter>
    __attribute ((__abi_tag__ ("cxx11")))
    _InIter
    num_get<_CharT, _InIter>::
    _M_extract_float(_InIter __beg, _InIter __end, ios_base& __io,
       ios_base::iostate& __err, string& __xtrc) const
    {
      typedef char_traits<_CharT> __traits_type;
      typedef __numpunct_cache<_CharT> __cache_type;
      __use_cache<__cache_type> __uc;
      const locale& __loc = __io._M_getloc();
      const __cache_type* __lc = __uc(__loc);
      const _CharT* __lit = __lc->_M_atoms_in;
      char_type __c = char_type();


      bool __testeof = __beg == __end;


      if (!__testeof)
 {
   __c = *__beg;
   const bool __plus = __c == __lit[__num_base::_S_iplus];
   if ((__plus || __c == __lit[__num_base::_S_iminus])
       && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       && !(__c == __lc->_M_decimal_point))
     {
       __xtrc += __plus ? '+' : '-';
       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
 }


      bool __found_mantissa = false;
      int __sep_pos = 0;
      while (!__testeof)
 {
   if ((__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       || __c == __lc->_M_decimal_point)
     break;
   else if (__c == __lit[__num_base::_S_izero])
     {
       if (!__found_mantissa)
  {
    __xtrc += '0';
    __found_mantissa = true;
  }
       ++__sep_pos;

       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
   else
     break;
 }


      bool __found_dec = false;
      bool __found_sci = false;
      string __found_grouping;
      if (__lc->_M_use_grouping)
 __found_grouping.reserve(32);
      const char_type* __lit_zero = __lit + __num_base::_S_izero;

      if (!__lc->_M_allocated)

 while (!__testeof)
   {
     const int __digit = _M_find(__lit_zero, 10, __c);
     if (__digit != -1)
       {
  __xtrc += '0' + __digit;
  __found_mantissa = true;
       }
     else if (__c == __lc->_M_decimal_point
       && !__found_dec && !__found_sci)
       {
  __xtrc += '.';
  __found_dec = true;
       }
     else if ((__c == __lit[__num_base::_S_ie]
        || __c == __lit[__num_base::_S_iE])
       && !__found_sci && __found_mantissa)
       {

  __xtrc += 'e';
  __found_sci = true;


  if (++__beg != __end)
    {
      __c = *__beg;
      const bool __plus = __c == __lit[__num_base::_S_iplus];
      if (__plus || __c == __lit[__num_base::_S_iminus])
        __xtrc += __plus ? '+' : '-';
      else
        continue;
    }
  else
    {
      __testeof = true;
      break;
    }
       }
     else
       break;

     if (++__beg != __end)
       __c = *__beg;
     else
       __testeof = true;
   }
      else
 while (!__testeof)
   {


     if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       {
  if (!__found_dec && !__found_sci)
    {


      if (__sep_pos)
        {
   __found_grouping += static_cast<char>(__sep_pos);
   __sep_pos = 0;
        }
      else
        {


   __xtrc.clear();
   break;
        }
    }
  else
    break;
       }
     else if (__c == __lc->_M_decimal_point)
       {
  if (!__found_dec && !__found_sci)
    {



      if (__found_grouping.size())
        __found_grouping += static_cast<char>(__sep_pos);
      __xtrc += '.';
      __found_dec = true;
    }
  else
    break;
       }
     else
       {
  const char_type* __q =
    __traits_type::find(__lit_zero, 10, __c);
  if (__q)
    {
      __xtrc += '0' + (__q - __lit_zero);
      __found_mantissa = true;
      ++__sep_pos;
    }
  else if ((__c == __lit[__num_base::_S_ie]
     || __c == __lit[__num_base::_S_iE])
    && !__found_sci && __found_mantissa)
    {

      if (__found_grouping.size() && !__found_dec)
        __found_grouping += static_cast<char>(__sep_pos);
      __xtrc += 'e';
      __found_sci = true;


      if (++__beg != __end)
        {
   __c = *__beg;
   const bool __plus = __c == __lit[__num_base::_S_iplus];
   if ((__plus || __c == __lit[__num_base::_S_iminus])
       && !(__lc->_M_use_grouping
     && __c == __lc->_M_thousands_sep)
       && !(__c == __lc->_M_decimal_point))
        __xtrc += __plus ? '+' : '-';
   else
     continue;
        }
      else
        {
   __testeof = true;
   break;
        }
    }
  else
    break;
       }

     if (++__beg != __end)
       __c = *__beg;
     else
       __testeof = true;
   }



      if (__found_grouping.size())
        {

   if (!__found_dec && !__found_sci)
     __found_grouping += static_cast<char>(__sep_pos);

          if (!std::__verify_grouping(__lc->_M_grouping,
          __lc->_M_grouping_size,
          __found_grouping))
     __err = ios_base::failbit;
        }

      return __beg;
    }

  template<typename _CharT, typename _InIter>
    template<typename _ValueT>
      __attribute ((__abi_tag__ ("cxx11")))
      _InIter
      num_get<_CharT, _InIter>::
      _M_extract_int(_InIter __beg, _InIter __end, ios_base& __io,
       ios_base::iostate& __err, _ValueT& __v) const
      {
        typedef char_traits<_CharT> __traits_type;
 using __gnu_cxx::__add_unsigned;
 typedef typename __add_unsigned<_ValueT>::__type __unsigned_type;
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);
 const _CharT* __lit = __lc->_M_atoms_in;
 char_type __c = char_type();


 const ios_base::fmtflags __basefield = __io.flags()
                                        & ios_base::basefield;
 const bool __oct = __basefield == ios_base::oct;
 int __base = __oct ? 8 : (__basefield == ios_base::hex ? 16 : 10);


 bool __testeof = __beg == __end;


 bool __negative = false;
 if (!__testeof)
   {
     __c = *__beg;
     __negative = __c == __lit[__num_base::_S_iminus];
     if ((__negative || __c == __lit[__num_base::_S_iplus])
  && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  && !(__c == __lc->_M_decimal_point))
       {
  if (++__beg != __end)
    __c = *__beg;
  else
    __testeof = true;
       }
   }



 bool __found_zero = false;
 int __sep_pos = 0;
 while (!__testeof)
   {
     if ((__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  || __c == __lc->_M_decimal_point)
       break;
     else if (__c == __lit[__num_base::_S_izero]
       && (!__found_zero || __base == 10))
       {
  __found_zero = true;
  ++__sep_pos;
  if (__basefield == 0)
    __base = 8;
  if (__base == 8)
    __sep_pos = 0;
       }
     else if (__found_zero
       && (__c == __lit[__num_base::_S_ix]
    || __c == __lit[__num_base::_S_iX]))
       {
  if (__basefield == 0)
    __base = 16;
  if (__base == 16)
    {
      __found_zero = false;
      __sep_pos = 0;
    }
  else
    break;
       }
     else
       break;

     if (++__beg != __end)
       {
  __c = *__beg;
  if (!__found_zero)
    break;
       }
     else
       __testeof = true;
   }



 const size_t __len = (__base == 16 ? __num_base::_S_iend
         - __num_base::_S_izero : __base);


 typedef __gnu_cxx::__numeric_traits<_ValueT> __num_traits;
 string __found_grouping;
 if (__lc->_M_use_grouping)
   __found_grouping.reserve(32);
 bool __testfail = false;
 bool __testoverflow = false;
 const __unsigned_type __max =
   (__negative && __num_traits::__is_signed)
   ? -static_cast<__unsigned_type>(__num_traits::__min)
   : __num_traits::__max;
 const __unsigned_type __smax = __max / __base;
 __unsigned_type __result = 0;
 int __digit = 0;
 const char_type* __lit_zero = __lit + __num_base::_S_izero;

 if (!__lc->_M_allocated)

   while (!__testeof)
     {
       __digit = _M_find(__lit_zero, __len, __c);
       if (__digit == -1)
  break;

       if (__result > __smax)
  __testoverflow = true;
       else
  {
    __result *= __base;
    __testoverflow |= __result > __max - __digit;
    __result += __digit;
    ++__sep_pos;
  }

       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
 else
   while (!__testeof)
     {


       if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  {


    if (__sep_pos)
      {
        __found_grouping += static_cast<char>(__sep_pos);
        __sep_pos = 0;
      }
    else
      {
        __testfail = true;
        break;
      }
  }
       else if (__c == __lc->_M_decimal_point)
  break;
       else
  {
    const char_type* __q =
      __traits_type::find(__lit_zero, __len, __c);
    if (!__q)
      break;

    __digit = __q - __lit_zero;
    if (__digit > 15)
      __digit -= 6;
    if (__result > __smax)
      __testoverflow = true;
    else
      {
        __result *= __base;
        __testoverflow |= __result > __max - __digit;
        __result += __digit;
        ++__sep_pos;
      }
  }

       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }



 if (__found_grouping.size())
   {

     __found_grouping += static_cast<char>(__sep_pos);

     if (!std::__verify_grouping(__lc->_M_grouping,
     __lc->_M_grouping_size,
     __found_grouping))
       __err = ios_base::failbit;
   }



 if ((!__sep_pos && !__found_zero && !__found_grouping.size())
     || __testfail)
   {
     __v = 0;
     __err = ios_base::failbit;
   }
 else if (__testoverflow)
   {
     if (__negative && __num_traits::__is_signed)
       __v = __num_traits::__min;
     else
       __v = __num_traits::__max;
     __err = ios_base::failbit;
   }
 else
   __v = __negative ? -__result : __result;

 if (__testeof)
   __err |= ios_base::eofbit;
 return __beg;
      }



  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, bool& __v) const
    {
      if (!(__io.flags() & ios_base::boolalpha))
        {



   long __l = -1;
          __beg = _M_extract_int(__beg, __end, __io, __err, __l);
   if (__l == 0 || __l == 1)
     __v = bool(__l);
   else
     {


       __v = true;
       __err = ios_base::failbit;
       if (__beg == __end)
  __err |= ios_base::eofbit;
     }
        }
      else
        {

   typedef __numpunct_cache<_CharT> __cache_type;
   __use_cache<__cache_type> __uc;
   const locale& __loc = __io._M_getloc();
   const __cache_type* __lc = __uc(__loc);

   bool __testf = true;
   bool __testt = true;
   bool __donef = __lc->_M_falsename_size == 0;
   bool __donet = __lc->_M_truename_size == 0;
   bool __testeof = false;
   size_t __n = 0;
   while (!__donef || !__donet)
     {
       if (__beg == __end)
  {
    __testeof = true;
    break;
  }

       const char_type __c = *__beg;

       if (!__donef)
  __testf = __c == __lc->_M_falsename[__n];

       if (!__testf && __donet)
  break;

       if (!__donet)
  __testt = __c == __lc->_M_truename[__n];

       if (!__testt && __donef)
  break;

       if (!__testt && !__testf)
  break;

       ++__n;
       ++__beg;

       __donef = !__testf || __n >= __lc->_M_falsename_size;
       __donet = !__testt || __n >= __lc->_M_truename_size;
     }
   if (__testf && __n == __lc->_M_falsename_size && __n)
     {
       __v = false;
       if (__testt && __n == __lc->_M_truename_size)
  __err = ios_base::failbit;
       else
  __err = __testeof ? ios_base::eofbit : ios_base::goodbit;
     }
   else if (__testt && __n == __lc->_M_truename_size && __n)
     {
       __v = true;
       __err = __testeof ? ios_base::eofbit : ios_base::goodbit;
     }
   else
     {


       __v = false;
       __err = ios_base::failbit;
       if (__testeof)
  __err |= ios_base::eofbit;
     }
 }
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, float& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, double& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }
# 735 "/usr/include/c++/10.2.0/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, long double& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, void*& __v) const
    {

      typedef ios_base::fmtflags fmtflags;
      const fmtflags __fmt = __io.flags();
      __io.flags((__fmt & ~ios_base::basefield) | ios_base::hex);

      typedef __gnu_cxx::__conditional_type<(sizeof(void*)
          <= sizeof(unsigned long)),
 unsigned long, unsigned long long>::__type _UIntPtrType;

      _UIntPtrType __ul;
      __beg = _M_extract_int(__beg, __end, __io, __err, __ul);


      __io.flags(__fmt);

      __v = reinterpret_cast<void*>(__ul);
      return __beg;
    }



  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_pad(_CharT __fill, streamsize __w, ios_base& __io,
    _CharT* __new, const _CharT* __cs, int& __len) const
    {


      __pad<_CharT, char_traits<_CharT> >::_S_pad(__io, __fill, __new,
        __cs, __w, __len);
      __len = static_cast<int>(__w);
    }



  template<typename _CharT, typename _ValueT>
    int
    __int_to_char(_CharT* __bufend, _ValueT __v, const _CharT* __lit,
    ios_base::fmtflags __flags, bool __dec)
    {
      _CharT* __buf = __bufend;
      if (__builtin_expect(__dec, true))
 {

   do
     {
       *--__buf = __lit[(__v % 10) + __num_base::_S_odigits];
       __v /= 10;
     }
   while (__v != 0);
 }
      else if ((__flags & ios_base::basefield) == ios_base::oct)
 {

   do
     {
       *--__buf = __lit[(__v & 0x7) + __num_base::_S_odigits];
       __v >>= 3;
     }
   while (__v != 0);
 }
      else
 {

   const bool __uppercase = __flags & ios_base::uppercase;
   const int __case_offset = __uppercase ? __num_base::_S_oudigits
                                         : __num_base::_S_odigits;
   do
     {
       *--__buf = __lit[(__v & 0xf) + __case_offset];
       __v >>= 4;
     }
   while (__v != 0);
 }
      return __bufend - __buf;
    }



  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_group_int(const char* __grouping, size_t __grouping_size, _CharT __sep,
   ios_base&, _CharT* __new, _CharT* __cs, int& __len) const
    {
      _CharT* __p = std::__add_grouping(__new, __sep, __grouping,
     __grouping_size, __cs, __cs + __len);
      __len = __p - __new;
    }

  template<typename _CharT, typename _OutIter>
    template<typename _ValueT>
      _OutIter
      num_put<_CharT, _OutIter>::
      _M_insert_int(_OutIter __s, ios_base& __io, _CharT __fill,
      _ValueT __v) const
      {
 using __gnu_cxx::__add_unsigned;
 typedef typename __add_unsigned<_ValueT>::__type __unsigned_type;
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);
 const _CharT* __lit = __lc->_M_atoms_out;
 const ios_base::fmtflags __flags = __io.flags();


 const int __ilen = 5 * sizeof(_ValueT);
 _CharT* __cs = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
            * __ilen));



 const ios_base::fmtflags __basefield = __flags & ios_base::basefield;
 const bool __dec = (__basefield != ios_base::oct
       && __basefield != ios_base::hex);
 const __unsigned_type __u = ((__v > 0 || !__dec)
         ? __unsigned_type(__v)
         : -__unsigned_type(__v));
  int __len = __int_to_char(__cs + __ilen, __u, __lit, __flags, __dec);
 __cs += __ilen - __len;


 if (__lc->_M_use_grouping)
   {


     _CharT* __cs2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * (__len + 1)
          * 2));
     _M_group_int(__lc->_M_grouping, __lc->_M_grouping_size,
    __lc->_M_thousands_sep, __io, __cs2 + 2, __cs, __len);
     __cs = __cs2 + 2;
   }


 if (__builtin_expect(__dec, true))
   {

     if (__v >= 0)
       {
  if (bool(__flags & ios_base::showpos)
      && __gnu_cxx::__numeric_traits<_ValueT>::__is_signed)
    *--__cs = __lit[__num_base::_S_oplus], ++__len;
       }
     else
       *--__cs = __lit[__num_base::_S_ominus], ++__len;
   }
 else if (bool(__flags & ios_base::showbase) && __v)
   {
     if (__basefield == ios_base::oct)
       *--__cs = __lit[__num_base::_S_odigits], ++__len;
     else
       {

  const bool __uppercase = __flags & ios_base::uppercase;
  *--__cs = __lit[__num_base::_S_ox + __uppercase];

  *--__cs = __lit[__num_base::_S_odigits];
  __len += 2;
       }
   }


 const streamsize __w = __io.width();
 if (__w > static_cast<streamsize>(__len))
   {
     _CharT* __cs3 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __w));
     _M_pad(__fill, __w, __io, __cs3, __cs, __len);
     __cs = __cs3;
   }
 __io.width(0);



 return std::__write(__s, __cs, __len);
      }

  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_group_float(const char* __grouping, size_t __grouping_size,
     _CharT __sep, const _CharT* __p, _CharT* __new,
     _CharT* __cs, int& __len) const
    {



      const int __declen = __p ? __p - __cs : __len;
      _CharT* __p2 = std::__add_grouping(__new, __sep, __grouping,
      __grouping_size,
      __cs, __cs + __declen);


      int __newlen = __p2 - __new;
      if (__p)
 {
   char_traits<_CharT>::copy(__p2, __p, __len - __declen);
   __newlen += __len - __declen;
 }
      __len = __newlen;
    }
# 971 "/usr/include/c++/10.2.0/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _OutIter>
    template<typename _ValueT>
      _OutIter
      num_put<_CharT, _OutIter>::
      _M_insert_float(_OutIter __s, ios_base& __io, _CharT __fill, char __mod,
         _ValueT __v) const
      {
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);


 const streamsize __prec = __io.precision() < 0 ? 6 : __io.precision();

 const int __max_digits =
   __gnu_cxx::__numeric_traits<_ValueT>::__digits10;


 int __len;

 char __fbuf[16];
 __num_base::_S_format_float(__io, __fbuf, __mod);



 const bool __use_prec =
   (__io.flags() & ios_base::floatfield) != ios_base::floatfield;



 int __cs_size = __max_digits * 3;
 char* __cs = static_cast<char*>(__builtin_alloca(__cs_size));
 if (__use_prec)
   __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
     __fbuf, __prec, __v);
 else
   __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
     __fbuf, __v);


 if (__len >= __cs_size)
   {
     __cs_size = __len + 1;
     __cs = static_cast<char*>(__builtin_alloca(__cs_size));
     if (__use_prec)
       __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
         __fbuf, __prec, __v);
     else
       __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
         __fbuf, __v);
   }
# 1044 "/usr/include/c++/10.2.0/bits/locale_facets.tcc" 3
 const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

 _CharT* __ws = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
            * __len));
 __ctype.widen(__cs, __cs + __len, __ws);


 _CharT* __wp = 0;
 const char* __p = char_traits<char>::find(__cs, __len, '.');
 if (__p)
   {
     __wp = __ws + (__p - __cs);
     *__wp = __lc->_M_decimal_point;
   }




 if (__lc->_M_use_grouping
     && (__wp || __len < 3 || (__cs[1] <= '9' && __cs[2] <= '9'
          && __cs[1] >= '0' && __cs[2] >= '0')))
   {


     _CharT* __ws2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __len * 2));

     streamsize __off = 0;
     if (__cs[0] == '-' || __cs[0] == '+')
       {
  __off = 1;
  __ws2[0] = __ws[0];
  __len -= 1;
       }

     _M_group_float(__lc->_M_grouping, __lc->_M_grouping_size,
      __lc->_M_thousands_sep, __wp, __ws2 + __off,
      __ws + __off, __len);
     __len += __off;

     __ws = __ws2;
   }


 const streamsize __w = __io.width();
 if (__w > static_cast<streamsize>(__len))
   {
     _CharT* __ws3 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __w));
     _M_pad(__fill, __w, __io, __ws3, __ws, __len);
     __ws = __ws3;
   }
 __io.width(0);



 return std::__write(__s, __ws, __len);
      }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill, bool __v) const
    {
      const ios_base::fmtflags __flags = __io.flags();
      if ((__flags & ios_base::boolalpha) == 0)
        {
          const long __l = __v;
          __s = _M_insert_int(__s, __io, __fill, __l);
        }
      else
        {
   typedef __numpunct_cache<_CharT> __cache_type;
   __use_cache<__cache_type> __uc;
   const locale& __loc = __io._M_getloc();
   const __cache_type* __lc = __uc(__loc);

   const _CharT* __name = __v ? __lc->_M_truename
                              : __lc->_M_falsename;
   int __len = __v ? __lc->_M_truename_size
                   : __lc->_M_falsename_size;

   const streamsize __w = __io.width();
   if (__w > static_cast<streamsize>(__len))
     {
       const streamsize __plen = __w - __len;
       _CharT* __ps
  = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
       * __plen));

       char_traits<_CharT>::assign(__ps, __plen, __fill);
       __io.width(0);

       if ((__flags & ios_base::adjustfield) == ios_base::left)
  {
    __s = std::__write(__s, __name, __len);
    __s = std::__write(__s, __ps, __plen);
  }
       else
  {
    __s = std::__write(__s, __ps, __plen);
    __s = std::__write(__s, __name, __len);
  }
       return __s;
     }
   __io.width(0);
   __s = std::__write(__s, __name, __len);
 }
      return __s;
    }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill, double __v) const
    { return _M_insert_float(__s, __io, __fill, char(), __v); }
# 1169 "/usr/include/c++/10.2.0/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
    long double __v) const
    { return _M_insert_float(__s, __io, __fill, 'L', __v); }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
           const void* __v) const
    {
      const ios_base::fmtflags __flags = __io.flags();
      const ios_base::fmtflags __fmt = ~(ios_base::basefield
      | ios_base::uppercase);
      __io.flags((__flags & __fmt) | (ios_base::hex | ios_base::showbase));

      typedef __gnu_cxx::__conditional_type<(sizeof(const void*)
          <= sizeof(unsigned long)),
 unsigned long, unsigned long long>::__type _UIntPtrType;

      __s = _M_insert_int(__s, __io, __fill,
     reinterpret_cast<_UIntPtrType>(__v));
      __io.flags(__flags);
      return __s;
    }


# 1206 "/usr/include/c++/10.2.0/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _Traits>
    void
    __pad<_CharT, _Traits>::_S_pad(ios_base& __io, _CharT __fill,
       _CharT* __news, const _CharT* __olds,
       streamsize __newlen, streamsize __oldlen)
    {
      const size_t __plen = static_cast<size_t>(__newlen - __oldlen);
      const ios_base::fmtflags __adjust = __io.flags() & ios_base::adjustfield;


      if (__adjust == ios_base::left)
 {
   _Traits::copy(__news, __olds, __oldlen);
   _Traits::assign(__news + __oldlen, __plen, __fill);
   return;
 }

      size_t __mod = 0;
      if (__adjust == ios_base::internal)
 {



          const locale& __loc = __io._M_getloc();
   const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

   if (__ctype.widen('-') == __olds[0]
       || __ctype.widen('+') == __olds[0])
     {
       __news[0] = __olds[0];
       __mod = 1;
       ++__news;
     }
   else if (__ctype.widen('0') == __olds[0]
     && __oldlen > 1
     && (__ctype.widen('x') == __olds[1]
         || __ctype.widen('X') == __olds[1]))
     {
       __news[0] = __olds[0];
       __news[1] = __olds[1];
       __mod = 2;
       __news += 2;
     }

 }
      _Traits::assign(__news, __plen, __fill);
      _Traits::copy(__news + __plen, __olds + __mod, __oldlen - __mod);
    }

  template<typename _CharT>
    _CharT*
    __add_grouping(_CharT* __s, _CharT __sep,
     const char* __gbeg, size_t __gsize,
     const _CharT* __first, const _CharT* __last)
    {
      size_t __idx = 0;
      size_t __ctr = 0;

      while (__last - __first > __gbeg[__idx]
      && static_cast<signed char>(__gbeg[__idx]) > 0
      && __gbeg[__idx] != __gnu_cxx::__numeric_traits<char>::__max)
 {
   __last -= __gbeg[__idx];
   __idx < __gsize - 1 ? ++__idx : ++__ctr;
 }

      while (__first != __last)
 *__s++ = *__first++;

      while (__ctr--)
 {
   *__s++ = __sep;
   for (char __i = __gbeg[__idx]; __i > 0; --__i)
     *__s++ = *__first++;
 }

      while (__idx--)
 {
   *__s++ = __sep;
   for (char __i = __gbeg[__idx]; __i > 0; --__i)
     *__s++ = *__first++;
 }

      return __s;
    }




  extern template class __cxx11:: numpunct<char>;
  extern template class __cxx11:: numpunct_byname<char>;
  extern template class num_get<char>;
  extern template class num_put<char>;
  extern template class ctype_byname<char>;

  extern template
    const ctype<char>&
    use_facet<ctype<char> >(const locale&);

  extern template
    const numpunct<char>&
    use_facet<numpunct<char> >(const locale&);

  extern template
    const num_put<char>&
    use_facet<num_put<char> >(const locale&);

  extern template
    const num_get<char>&
    use_facet<num_get<char> >(const locale&);

  extern template
    bool
    has_facet<ctype<char> >(const locale&);

  extern template
    bool
    has_facet<numpunct<char> >(const locale&);

  extern template
    bool
    has_facet<num_put<char> >(const locale&);

  extern template
    bool
    has_facet<num_get<char> >(const locale&);


  extern template class __cxx11:: numpunct<wchar_t>;
  extern template class __cxx11:: numpunct_byname<wchar_t>;
  extern template class num_get<wchar_t>;
  extern template class num_put<wchar_t>;
  extern template class ctype_byname<wchar_t>;

  extern template
    const ctype<wchar_t>&
    use_facet<ctype<wchar_t> >(const locale&);

  extern template
    const numpunct<wchar_t>&
    use_facet<numpunct<wchar_t> >(const locale&);

  extern template
    const num_put<wchar_t>&
    use_facet<num_put<wchar_t> >(const locale&);

  extern template
    const num_get<wchar_t>&
    use_facet<num_get<wchar_t> >(const locale&);

 extern template
    bool
    has_facet<ctype<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<numpunct<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<num_put<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<num_get<wchar_t> >(const locale&);




}
# 2656 "/usr/include/c++/10.2.0/bits/locale_facets.h" 2 3
# 38 "/usr/include/c++/10.2.0/bits/basic_ios.h" 2 3



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Facet>
    inline const _Facet&
    __check_facet(const _Facet* __f)
    {
      if (!__f)
 __throw_bad_cast();
      return *__f;
    }
# 66 "/usr/include/c++/10.2.0/bits/basic_ios.h" 3
  template<typename _CharT, typename _Traits>
    class basic_ios : public ios_base
    {
    public:






      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;






      typedef ctype<_CharT> __ctype_type;
      typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits> >
           __num_put_type;
      typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits> >
           __num_get_type;



    protected:
      basic_ostream<_CharT, _Traits>* _M_tie;
      mutable char_type _M_fill;
      mutable bool _M_fill_init;
      basic_streambuf<_CharT, _Traits>* _M_streambuf;


      const __ctype_type* _M_ctype;

      const __num_put_type* _M_num_put;

      const __num_get_type* _M_num_get;

    public:
# 117 "/usr/include/c++/10.2.0/bits/basic_ios.h" 3
      explicit operator bool() const
      { return !this->fail(); }





      bool
      operator!() const
      { return this->fail(); }
# 136 "/usr/include/c++/10.2.0/bits/basic_ios.h" 3
      iostate
      rdstate() const
      { return _M_streambuf_state; }
# 147 "/usr/include/c++/10.2.0/bits/basic_ios.h" 3
      void
      clear(iostate __state = goodbit);







      void
      setstate(iostate __state)
      { this->clear(this->rdstate() | __state); }




      void
      _M_setstate(iostate __state)
      {


 _M_streambuf_state |= __state;
 if (this->exceptions() & __state)
   throw;
      }







      bool
      good() const
      { return this->rdstate() == 0; }







      bool
      eof() const
      { return (this->rdstate() & eofbit) != 0; }
# 200 "/usr/include/c++/10.2.0/bits/basic_ios.h" 3
      bool
      fail() const
      { return (this->rdstate() & (badbit | failbit)) != 0; }







      bool
      bad() const
      { return (this->rdstate() & badbit) != 0; }
# 221 "/usr/include/c++/10.2.0/bits/basic_ios.h" 3
      iostate
      exceptions() const
      { return _M_exception; }
# 256 "/usr/include/c++/10.2.0/bits/basic_ios.h" 3
      void
      exceptions(iostate __except)
      {
        _M_exception = __except;
        this->clear(_M_streambuf_state);
      }







      explicit
      basic_ios(basic_streambuf<_CharT, _Traits>* __sb)
      : ios_base(), _M_tie(0), _M_fill(), _M_fill_init(false), _M_streambuf(0),
 _M_ctype(0), _M_num_put(0), _M_num_get(0)
      { this->init(__sb); }







      virtual
      ~basic_ios() { }
# 294 "/usr/include/c++/10.2.0/bits/basic_ios.h" 3
      basic_ostream<_CharT, _Traits>*
      tie() const
      { return _M_tie; }
# 306 "/usr/include/c++/10.2.0/bits/basic_ios.h" 3
      basic_ostream<_CharT, _Traits>*
      tie(basic_ostream<_CharT, _Traits>* __tiestr)
      {
        basic_ostream<_CharT, _Traits>* __old = _M_tie;
        _M_tie = __tiestr;
        return __old;
      }







      basic_streambuf<_CharT, _Traits>*
      rdbuf() const
      { return _M_streambuf; }
# 346 "/usr/include/c++/10.2.0/bits/basic_ios.h" 3
      basic_streambuf<_CharT, _Traits>*
      rdbuf(basic_streambuf<_CharT, _Traits>* __sb);
# 360 "/usr/include/c++/10.2.0/bits/basic_ios.h" 3
      basic_ios&
      copyfmt(const basic_ios& __rhs);







      char_type
      fill() const
      {
 if (!_M_fill_init)
   {
     _M_fill = this->widen(' ');
     _M_fill_init = true;
   }
 return _M_fill;
      }
# 389 "/usr/include/c++/10.2.0/bits/basic_ios.h" 3
      char_type
      fill(char_type __ch)
      {
 char_type __old = this->fill();
 _M_fill = __ch;
 return __old;
      }
# 409 "/usr/include/c++/10.2.0/bits/basic_ios.h" 3
      locale
      imbue(const locale& __loc);
# 429 "/usr/include/c++/10.2.0/bits/basic_ios.h" 3
      char
      narrow(char_type __c, char __dfault) const
      { return __check_facet(_M_ctype).narrow(__c, __dfault); }
# 448 "/usr/include/c++/10.2.0/bits/basic_ios.h" 3
      char_type
      widen(char __c) const
      { return __check_facet(_M_ctype).widen(__c); }

    protected:







      basic_ios()
      : ios_base(), _M_tie(0), _M_fill(char_type()), _M_fill_init(false),
 _M_streambuf(0), _M_ctype(0), _M_num_put(0), _M_num_get(0)
      { }







      void
      init(basic_streambuf<_CharT, _Traits>* __sb);


      basic_ios(const basic_ios&) = delete;
      basic_ios& operator=(const basic_ios&) = delete;

      void
      move(basic_ios& __rhs)
      {
 ios_base::_M_move(__rhs);
 _M_cache_locale(_M_ios_locale);
 this->tie(__rhs.tie(nullptr));
 _M_fill = __rhs._M_fill;
 _M_fill_init = __rhs._M_fill_init;
 _M_streambuf = nullptr;
      }

      void
      move(basic_ios&& __rhs)
      { this->move(__rhs); }

      void
      swap(basic_ios& __rhs) noexcept
      {
 ios_base::_M_swap(__rhs);
 _M_cache_locale(_M_ios_locale);
 __rhs._M_cache_locale(__rhs._M_ios_locale);
 std::swap(_M_tie, __rhs._M_tie);
 std::swap(_M_fill, __rhs._M_fill);
 std::swap(_M_fill_init, __rhs._M_fill_init);
      }

      void
      set_rdbuf(basic_streambuf<_CharT, _Traits>* __sb)
      { _M_streambuf = __sb; }


      void
      _M_cache_locale(const locale& __loc);
    };


}

# 1 "/usr/include/c++/10.2.0/bits/basic_ios.tcc" 1 3
# 33 "/usr/include/c++/10.2.0/bits/basic_ios.tcc" 3
       
# 34 "/usr/include/c++/10.2.0/bits/basic_ios.tcc" 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::clear(iostate __state)
    {
      if (this->rdbuf())
 _M_streambuf_state = __state;
      else
   _M_streambuf_state = __state | badbit;
      if (this->exceptions() & this->rdstate())
 __throw_ios_failure(("basic_ios::clear"));
    }

  template<typename _CharT, typename _Traits>
    basic_streambuf<_CharT, _Traits>*
    basic_ios<_CharT, _Traits>::rdbuf(basic_streambuf<_CharT, _Traits>* __sb)
    {
      basic_streambuf<_CharT, _Traits>* __old = _M_streambuf;
      _M_streambuf = __sb;
      this->clear();
      return __old;
    }

  template<typename _CharT, typename _Traits>
    basic_ios<_CharT, _Traits>&
    basic_ios<_CharT, _Traits>::copyfmt(const basic_ios& __rhs)
    {


      if (this != &__rhs)
 {




   _Words* __words = (__rhs._M_word_size <= _S_local_word_size) ?
                      _M_local_word : new _Words[__rhs._M_word_size];


   _Callback_list* __cb = __rhs._M_callbacks;
   if (__cb)
     __cb->_M_add_reference();
   _M_call_callbacks(erase_event);
   if (_M_word != _M_local_word)
     {
       delete [] _M_word;
       _M_word = 0;
     }
   _M_dispose_callbacks();


   _M_callbacks = __cb;
   for (int __i = 0; __i < __rhs._M_word_size; ++__i)
     __words[__i] = __rhs._M_word[__i];
   _M_word = __words;
   _M_word_size = __rhs._M_word_size;

   this->flags(__rhs.flags());
   this->width(__rhs.width());
   this->precision(__rhs.precision());
   this->tie(__rhs.tie());
   this->fill(__rhs.fill());
   _M_ios_locale = __rhs.getloc();
   _M_cache_locale(_M_ios_locale);

   _M_call_callbacks(copyfmt_event);


   this->exceptions(__rhs.exceptions());
 }
      return *this;
    }


  template<typename _CharT, typename _Traits>
    locale
    basic_ios<_CharT, _Traits>::imbue(const locale& __loc)
    {
      locale __old(this->getloc());
      ios_base::imbue(__loc);
      _M_cache_locale(__loc);
      if (this->rdbuf() != 0)
 this->rdbuf()->pubimbue(__loc);
      return __old;
    }

  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::init(basic_streambuf<_CharT, _Traits>* __sb)
    {

      ios_base::_M_init();


      _M_cache_locale(_M_ios_locale);
# 146 "/usr/include/c++/10.2.0/bits/basic_ios.tcc" 3
      _M_fill = _CharT();
      _M_fill_init = false;

      _M_tie = 0;
      _M_exception = goodbit;
      _M_streambuf = __sb;
      _M_streambuf_state = __sb ? goodbit : badbit;
    }

  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::_M_cache_locale(const locale& __loc)
    {
      if (__builtin_expect(has_facet<__ctype_type>(__loc), true))
 _M_ctype = std::__addressof(use_facet<__ctype_type>(__loc));
      else
 _M_ctype = 0;

      if (__builtin_expect(has_facet<__num_put_type>(__loc), true))
 _M_num_put = std::__addressof(use_facet<__num_put_type>(__loc));
      else
 _M_num_put = 0;

      if (__builtin_expect(has_facet<__num_get_type>(__loc), true))
 _M_num_get = std::__addressof(use_facet<__num_get_type>(__loc));
      else
 _M_num_get = 0;
    }




  extern template class basic_ios<char>;


  extern template class basic_ios<wchar_t>;




}
# 517 "/usr/include/c++/10.2.0/bits/basic_ios.h" 2 3
# 45 "/usr/include/c++/10.2.0/ios" 2 3
# 39 "/usr/include/c++/10.2.0/ostream" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{

# 57 "/usr/include/c++/10.2.0/ostream" 3
  template<typename _CharT, typename _Traits>
    class basic_ostream : virtual public basic_ios<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_ios<_CharT, _Traits> __ios_type;
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits> >
             __num_put_type;
      typedef ctype<_CharT> __ctype_type;
# 83 "/usr/include/c++/10.2.0/ostream" 3
      explicit
      basic_ostream(__streambuf_type* __sb)
      { this->init(__sb); }






      virtual
      ~basic_ostream() { }


      class sentry;
      friend class sentry;
# 107 "/usr/include/c++/10.2.0/ostream" 3
      __ostream_type&
      operator<<(__ostream_type& (*__pf)(__ostream_type&))
      {



 return __pf(*this);
      }

      __ostream_type&
      operator<<(__ios_type& (*__pf)(__ios_type&))
      {



 __pf(*this);
 return *this;
      }

      __ostream_type&
      operator<<(ios_base& (*__pf) (ios_base&))
      {



 __pf(*this);
 return *this;
      }
# 165 "/usr/include/c++/10.2.0/ostream" 3
      __ostream_type&
      operator<<(long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(unsigned long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(bool __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(short __n);

      __ostream_type&
      operator<<(unsigned short __n)
      {


 return _M_insert(static_cast<unsigned long>(__n));
      }

      __ostream_type&
      operator<<(int __n);

      __ostream_type&
      operator<<(unsigned int __n)
      {


 return _M_insert(static_cast<unsigned long>(__n));
      }


      __ostream_type&
      operator<<(long long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(unsigned long long __n)
      { return _M_insert(__n); }
# 219 "/usr/include/c++/10.2.0/ostream" 3
      __ostream_type&
      operator<<(double __f)
      { return _M_insert(__f); }

      __ostream_type&
      operator<<(float __f)
      {


 return _M_insert(static_cast<double>(__f));
      }

      __ostream_type&
      operator<<(long double __f)
      { return _M_insert(__f); }
# 244 "/usr/include/c++/10.2.0/ostream" 3
      __ostream_type&
      operator<<(const void* __p)
      { return _M_insert(__p); }
# 275 "/usr/include/c++/10.2.0/ostream" 3
      __ostream_type&
      operator<<(__streambuf_type* __sb);
# 308 "/usr/include/c++/10.2.0/ostream" 3
      __ostream_type&
      put(char_type __c);






      void
      _M_write(const char_type* __s, streamsize __n)
      {
 const streamsize __put = this->rdbuf()->sputn(__s, __n);
 if (__put != __n)
   this->setstate(ios_base::badbit);
      }
# 340 "/usr/include/c++/10.2.0/ostream" 3
      __ostream_type&
      write(const char_type* __s, streamsize __n);
# 353 "/usr/include/c++/10.2.0/ostream" 3
      __ostream_type&
      flush();
# 363 "/usr/include/c++/10.2.0/ostream" 3
      pos_type
      tellp();
# 374 "/usr/include/c++/10.2.0/ostream" 3
      __ostream_type&
      seekp(pos_type);
# 386 "/usr/include/c++/10.2.0/ostream" 3
       __ostream_type&
      seekp(off_type, ios_base::seekdir);

    protected:
      basic_ostream()
      { this->init(0); }



      basic_ostream(basic_iostream<_CharT, _Traits>&) { }

      basic_ostream(const basic_ostream&) = delete;

      basic_ostream(basic_ostream&& __rhs)
      : __ios_type()
      { __ios_type::move(__rhs); }



      basic_ostream& operator=(const basic_ostream&) = delete;

      basic_ostream&
      operator=(basic_ostream&& __rhs)
      {
 swap(__rhs);
 return *this;
      }

      void
      swap(basic_ostream& __rhs)
      { __ios_type::swap(__rhs); }


      template<typename _ValueT>
 __ostream_type&
 _M_insert(_ValueT __v);
    };
# 431 "/usr/include/c++/10.2.0/ostream" 3
  template <typename _CharT, typename _Traits>
    class basic_ostream<_CharT, _Traits>::sentry
    {

      bool _M_ok;
      basic_ostream<_CharT, _Traits>& _M_os;

    public:
# 450 "/usr/include/c++/10.2.0/ostream" 3
      explicit
      sentry(basic_ostream<_CharT, _Traits>& __os);

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"







      ~sentry()
      {

 if (bool(_M_os.flags() & ios_base::unitbuf) && !uncaught_exception())
   {

     if (_M_os.rdbuf() && _M_os.rdbuf()->pubsync() == -1)
       _M_os.setstate(ios_base::badbit);
   }
      }
#pragma GCC diagnostic pop
# 482 "/usr/include/c++/10.2.0/ostream" 3
      explicit

      operator bool() const
      { return _M_ok; }
    };
# 504 "/usr/include/c++/10.2.0/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, _CharT __c)
    { return __ostream_insert(__out, &__c, 1); }

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, char __c)
    { return (__out << __out.widen(__c)); }


  template<typename _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, char __c)
    { return __ostream_insert(__out, &__c, 1); }


  template<typename _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, signed char __c)
    { return (__out << static_cast<char>(__c)); }

  template<typename _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, unsigned char __c)
    { return (__out << static_cast<char>(__c)); }
# 587 "/usr/include/c++/10.2.0/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, const _CharT* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 __ostream_insert(__out, __s,
    static_cast<streamsize>(_Traits::length(__s)));
      return __out;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits> &
    operator<<(basic_ostream<_CharT, _Traits>& __out, const char* __s);


  template<typename _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, const char* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 __ostream_insert(__out, __s,
    static_cast<streamsize>(_Traits::length(__s)));
      return __out;
    }


  template<typename _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, const signed char* __s)
    { return (__out << reinterpret_cast<const char*>(__s)); }

  template<typename _Traits>
    inline basic_ostream<char, _Traits> &
    operator<<(basic_ostream<char, _Traits>& __out, const unsigned char* __s)
    { return (__out << reinterpret_cast<const char*>(__s)); }
# 679 "/usr/include/c++/10.2.0/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    endl(basic_ostream<_CharT, _Traits>& __os)
    { return flush(__os.put(__os.widen('\n'))); }
# 691 "/usr/include/c++/10.2.0/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    ends(basic_ostream<_CharT, _Traits>& __os)
    { return __os.put(_CharT()); }






  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    flush(basic_ostream<_CharT, _Traits>& __os)
    { return __os.flush(); }


  template<typename _Ch, typename _Up>
    basic_ostream<_Ch, _Up>&
    __is_convertible_to_basic_ostream_test(basic_ostream<_Ch, _Up>*);

  template<typename _Tp, typename = void>
    struct __is_convertible_to_basic_ostream_impl
    {
      using __ostream_type = void;
    };

  template<typename _Tp>
    using __do_is_convertible_to_basic_ostream_impl =
    decltype(__is_convertible_to_basic_ostream_test
      (declval<typename remove_reference<_Tp>::type*>()));

  template<typename _Tp>
    struct __is_convertible_to_basic_ostream_impl
    <_Tp,
     __void_t<__do_is_convertible_to_basic_ostream_impl<_Tp>>>
    {
      using __ostream_type =
 __do_is_convertible_to_basic_ostream_impl<_Tp>;
    };

  template<typename _Tp>
    struct __is_convertible_to_basic_ostream
    : __is_convertible_to_basic_ostream_impl<_Tp>
    {
    public:
      using type = __not_<is_void<
        typename __is_convertible_to_basic_ostream_impl<_Tp>::__ostream_type>>;
      constexpr static bool value = type::value;
    };

  template<typename _Ostream, typename _Tp, typename = void>
    struct __is_insertable : false_type {};

  template<typename _Ostream, typename _Tp>
    struct __is_insertable<_Ostream, _Tp,
      __void_t<decltype(declval<_Ostream&>()
          << declval<const _Tp&>())>>
        : true_type {};

  template<typename _Ostream>
    using __rvalue_ostream_type =
      typename __is_convertible_to_basic_ostream<
 _Ostream>::__ostream_type;
# 765 "/usr/include/c++/10.2.0/ostream" 3
  template<typename _Ostream, typename _Tp>
    inline
    typename enable_if<__and_<__not_<is_lvalue_reference<_Ostream>>,
         __is_convertible_to_basic_ostream<_Ostream>,
         __is_insertable<
    __rvalue_ostream_type<_Ostream>,
    const _Tp&>>::value,
         __rvalue_ostream_type<_Ostream>>::type
    operator<<(_Ostream&& __os, const _Tp& __x)
    {
      __rvalue_ostream_type<_Ostream> __ret_os = __os;
      __ret_os << __x;
      return __ret_os;
    }



}

# 1 "/usr/include/c++/10.2.0/bits/ostream.tcc" 1 3
# 37 "/usr/include/c++/10.2.0/bits/ostream.tcc" 3
       
# 38 "/usr/include/c++/10.2.0/bits/ostream.tcc" 3



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>::sentry::
    sentry(basic_ostream<_CharT, _Traits>& __os)
    : _M_ok(false), _M_os(__os)
    {

      if (__os.tie() && __os.good())
 __os.tie()->flush();

      if (__os.good())
 _M_ok = true;
      else
 __os.setstate(ios_base::failbit);
    }

  template<typename _CharT, typename _Traits>
    template<typename _ValueT>
      basic_ostream<_CharT, _Traits>&
      basic_ostream<_CharT, _Traits>::
      _M_insert(_ValueT __v)
      {
 sentry __cerb(*this);
 if (__cerb)
   {
     ios_base::iostate __err = ios_base::goodbit;
     try
       {
  const __num_put_type& __np = __check_facet(this->_M_num_put);
  if (__np.put(*this, *this, this->fill(), __v).failed())
    __err |= ios_base::badbit;
       }
     catch(__cxxabiv1::__forced_unwind&)
       {
  this->_M_setstate(ios_base::badbit);
  throw;
       }
     catch(...)
       { this->_M_setstate(ios_base::badbit); }
     if (__err)
       this->setstate(__err);
   }
 return *this;
      }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(short __n)
    {


      const ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
      if (__fmt == ios_base::oct || __fmt == ios_base::hex)
 return _M_insert(static_cast<long>(static_cast<unsigned short>(__n)));
      else
 return _M_insert(static_cast<long>(__n));
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(int __n)
    {


      const ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
      if (__fmt == ios_base::oct || __fmt == ios_base::hex)
 return _M_insert(static_cast<long>(static_cast<unsigned int>(__n)));
      else
 return _M_insert(static_cast<long>(__n));
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(__streambuf_type* __sbin)
    {
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this);
      if (__cerb && __sbin)
 {
   try
     {
       if (!__copy_streambufs(__sbin, this->rdbuf()))
  __err |= ios_base::failbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::failbit); }
 }
      else if (!__sbin)
 __err |= ios_base::badbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    put(char_type __c)
    {






      sentry __cerb(*this);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const int_type __put = this->rdbuf()->sputc(__c);
       if (traits_type::eq_int_type(__put, traits_type::eof()))
  __err |= ios_base::badbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    write(const _CharT* __s, streamsize __n)
    {







      sentry __cerb(*this);
      if (__cerb)
 {
   try
     { _M_write(__s, __n); }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    flush()
    {



      ios_base::iostate __err = ios_base::goodbit;
      try
 {
   if (this->rdbuf() && this->rdbuf()->pubsync() == -1)
     __err |= ios_base::badbit;
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_ostream<_CharT, _Traits>::pos_type
    basic_ostream<_CharT, _Traits>::
    tellp()
    {
      pos_type __ret = pos_type(-1);
      try
 {
   if (!this->fail())
     __ret = this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::out);
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    seekp(pos_type __pos)
    {
      ios_base::iostate __err = ios_base::goodbit;
      try
 {
   if (!this->fail())
     {


       const pos_type __p = this->rdbuf()->pubseekpos(__pos,
            ios_base::out);


       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    seekp(off_type __off, ios_base::seekdir __dir)
    {
      ios_base::iostate __err = ios_base::goodbit;
      try
 {
   if (!this->fail())
     {


       const pos_type __p = this->rdbuf()->pubseekoff(__off, __dir,
            ios_base::out);


       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, const char* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 {


   const size_t __clen = char_traits<char>::length(__s);
   try
     {
       struct __ptr_guard
       {
  _CharT *__p;
  __ptr_guard (_CharT *__ip): __p(__ip) { }
  ~__ptr_guard() { delete[] __p; }
  _CharT* __get() { return __p; }
       } __pg (new _CharT[__clen]);

       _CharT *__ws = __pg.__get();
       for (size_t __i = 0; __i < __clen; ++__i)
  __ws[__i] = __out.widen(__s[__i]);
       __ostream_insert(__out, __ws, __clen);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __out._M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { __out._M_setstate(ios_base::badbit); }
 }
      return __out;
    }




  extern template class basic_ostream<char>;
  extern template ostream& endl(ostream&);
  extern template ostream& ends(ostream&);
  extern template ostream& flush(ostream&);
  extern template ostream& operator<<(ostream&, char);
  extern template ostream& operator<<(ostream&, unsigned char);
  extern template ostream& operator<<(ostream&, signed char);
  extern template ostream& operator<<(ostream&, const char*);
  extern template ostream& operator<<(ostream&, const unsigned char*);
  extern template ostream& operator<<(ostream&, const signed char*);

  extern template ostream& ostream::_M_insert(long);
  extern template ostream& ostream::_M_insert(unsigned long);
  extern template ostream& ostream::_M_insert(bool);

  extern template ostream& ostream::_M_insert(long long);
  extern template ostream& ostream::_M_insert(unsigned long long);

  extern template ostream& ostream::_M_insert(double);
  extern template ostream& ostream::_M_insert(long double);
  extern template ostream& ostream::_M_insert(const void*);


  extern template class basic_ostream<wchar_t>;
  extern template wostream& endl(wostream&);
  extern template wostream& ends(wostream&);
  extern template wostream& flush(wostream&);
  extern template wostream& operator<<(wostream&, wchar_t);
  extern template wostream& operator<<(wostream&, char);
  extern template wostream& operator<<(wostream&, const wchar_t*);
  extern template wostream& operator<<(wostream&, const char*);

  extern template wostream& wostream::_M_insert(long);
  extern template wostream& wostream::_M_insert(unsigned long);
  extern template wostream& wostream::_M_insert(bool);

  extern template wostream& wostream::_M_insert(long long);
  extern template wostream& wostream::_M_insert(unsigned long long);

  extern template wostream& wostream::_M_insert(double);
  extern template wostream& wostream::_M_insert(long double);
  extern template wostream& wostream::_M_insert(const void*);




}
# 785 "/usr/include/c++/10.2.0/ostream" 2 3
# 40 "/usr/include/c++/10.2.0/iostream" 2 3
# 1 "/usr/include/c++/10.2.0/istream" 1 3
# 36 "/usr/include/c++/10.2.0/istream" 3
       
# 37 "/usr/include/c++/10.2.0/istream" 3




namespace std __attribute__ ((__visibility__ ("default")))
{

# 57 "/usr/include/c++/10.2.0/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_istream : virtual public basic_ios<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_ios<_CharT, _Traits> __ios_type;
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits> >
        __num_get_type;
      typedef ctype<_CharT> __ctype_type;

    protected:





      streamsize _M_gcount;

    public:







      explicit
      basic_istream(__streambuf_type* __sb)
      : _M_gcount(streamsize(0))
      { this->init(__sb); }






      virtual
      ~basic_istream()
      { _M_gcount = streamsize(0); }


      class sentry;
      friend class sentry;
# 119 "/usr/include/c++/10.2.0/istream" 3
      __istream_type&
      operator>>(__istream_type& (*__pf)(__istream_type&))
      { return __pf(*this); }

      __istream_type&
      operator>>(__ios_type& (*__pf)(__ios_type&))
      {
 __pf(*this);
 return *this;
      }

      __istream_type&
      operator>>(ios_base& (*__pf)(ios_base&))
      {
 __pf(*this);
 return *this;
      }
# 167 "/usr/include/c++/10.2.0/istream" 3
      __istream_type&
      operator>>(bool& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(short& __n);

      __istream_type&
      operator>>(unsigned short& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(int& __n);

      __istream_type&
      operator>>(unsigned int& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(long& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(unsigned long& __n)
      { return _M_extract(__n); }


      __istream_type&
      operator>>(long long& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(unsigned long long& __n)
      { return _M_extract(__n); }
# 213 "/usr/include/c++/10.2.0/istream" 3
      __istream_type&
      operator>>(float& __f)
      { return _M_extract(__f); }

      __istream_type&
      operator>>(double& __f)
      { return _M_extract(__f); }

      __istream_type&
      operator>>(long double& __f)
      { return _M_extract(__f); }
# 234 "/usr/include/c++/10.2.0/istream" 3
      __istream_type&
      operator>>(void*& __p)
      { return _M_extract(__p); }
# 258 "/usr/include/c++/10.2.0/istream" 3
      __istream_type&
      operator>>(__streambuf_type* __sb);
# 268 "/usr/include/c++/10.2.0/istream" 3
      streamsize
      gcount() const
      { return _M_gcount; }
# 301 "/usr/include/c++/10.2.0/istream" 3
      int_type
      get();
# 315 "/usr/include/c++/10.2.0/istream" 3
      __istream_type&
      get(char_type& __c);
# 342 "/usr/include/c++/10.2.0/istream" 3
      __istream_type&
      get(char_type* __s, streamsize __n, char_type __delim);
# 353 "/usr/include/c++/10.2.0/istream" 3
      __istream_type&
      get(char_type* __s, streamsize __n)
      { return this->get(__s, __n, this->widen('\n')); }
# 376 "/usr/include/c++/10.2.0/istream" 3
      __istream_type&
      get(__streambuf_type& __sb, char_type __delim);
# 386 "/usr/include/c++/10.2.0/istream" 3
      __istream_type&
      get(__streambuf_type& __sb)
      { return this->get(__sb, this->widen('\n')); }
# 415 "/usr/include/c++/10.2.0/istream" 3
      __istream_type&
      getline(char_type* __s, streamsize __n, char_type __delim);
# 426 "/usr/include/c++/10.2.0/istream" 3
      __istream_type&
      getline(char_type* __s, streamsize __n)
      { return this->getline(__s, __n, this->widen('\n')); }
# 450 "/usr/include/c++/10.2.0/istream" 3
      __istream_type&
      ignore(streamsize __n, int_type __delim);

      __istream_type&
      ignore(streamsize __n);

      __istream_type&
      ignore();
# 467 "/usr/include/c++/10.2.0/istream" 3
      int_type
      peek();
# 485 "/usr/include/c++/10.2.0/istream" 3
      __istream_type&
      read(char_type* __s, streamsize __n);
# 504 "/usr/include/c++/10.2.0/istream" 3
      streamsize
      readsome(char_type* __s, streamsize __n);
# 521 "/usr/include/c++/10.2.0/istream" 3
      __istream_type&
      putback(char_type __c);
# 537 "/usr/include/c++/10.2.0/istream" 3
      __istream_type&
      unget();
# 555 "/usr/include/c++/10.2.0/istream" 3
      int
      sync();
# 570 "/usr/include/c++/10.2.0/istream" 3
      pos_type
      tellg();
# 585 "/usr/include/c++/10.2.0/istream" 3
      __istream_type&
      seekg(pos_type);
# 601 "/usr/include/c++/10.2.0/istream" 3
      __istream_type&
      seekg(off_type, ios_base::seekdir);


    protected:
      basic_istream()
      : _M_gcount(streamsize(0))
      { this->init(0); }


      basic_istream(const basic_istream&) = delete;

      basic_istream(basic_istream&& __rhs)
      : __ios_type(), _M_gcount(__rhs._M_gcount)
      {
 __ios_type::move(__rhs);
 __rhs._M_gcount = 0;
      }



      basic_istream& operator=(const basic_istream&) = delete;

      basic_istream&
      operator=(basic_istream&& __rhs)
      {
 swap(__rhs);
 return *this;
      }

      void
      swap(basic_istream& __rhs)
      {
 __ios_type::swap(__rhs);
 std::swap(_M_gcount, __rhs._M_gcount);
      }


      template<typename _ValueT>
 __istream_type&
 _M_extract(_ValueT& __v);
    };


  template<>
    basic_istream<char>&
    basic_istream<char>::
    getline(char_type* __s, streamsize __n, char_type __delim);

  template<>
    basic_istream<char>&
    basic_istream<char>::
    ignore(streamsize __n);

  template<>
    basic_istream<char>&
    basic_istream<char>::
    ignore(streamsize __n, int_type __delim);


  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    getline(char_type* __s, streamsize __n, char_type __delim);

  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    ignore(streamsize __n);

  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    ignore(streamsize __n, int_type __delim);
# 685 "/usr/include/c++/10.2.0/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_istream<_CharT, _Traits>::sentry
    {

      bool _M_ok;

    public:

      typedef _Traits traits_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::__ctype_type __ctype_type;
      typedef typename _Traits::int_type __int_type;
# 721 "/usr/include/c++/10.2.0/istream" 3
      explicit
      sentry(basic_istream<_CharT, _Traits>& __is, bool __noskipws = false);
# 732 "/usr/include/c++/10.2.0/istream" 3
      explicit

      operator bool() const
      { return _M_ok; }
    };
# 750 "/usr/include/c++/10.2.0/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT& __c);

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, unsigned char& __c)
    { return (__in >> reinterpret_cast<char&>(__c)); }

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, signed char& __c)
    { return (__in >> reinterpret_cast<char&>(__c)); }
# 792 "/usr/include/c++/10.2.0/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT* __s);


  template<>
    basic_istream<char>&
    operator>>(basic_istream<char>& __in, char* __s);

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, unsigned char* __s)
    { return (__in >> reinterpret_cast<char*>(__s)); }

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, signed char* __s)
    { return (__in >> reinterpret_cast<char*>(__s)); }
# 823 "/usr/include/c++/10.2.0/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_iostream
    : public basic_istream<_CharT, _Traits>,
      public basic_ostream<_CharT, _Traits>
    {
    public:



      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_ostream<_CharT, _Traits> __ostream_type;







      explicit
      basic_iostream(basic_streambuf<_CharT, _Traits>* __sb)
      : __istream_type(__sb), __ostream_type(__sb) { }




      virtual
      ~basic_iostream() { }

    protected:
      basic_iostream()
      : __istream_type(), __ostream_type() { }


      basic_iostream(const basic_iostream&) = delete;

      basic_iostream(basic_iostream&& __rhs)
      : __istream_type(std::move(__rhs)), __ostream_type(*this)
      { }



      basic_iostream& operator=(const basic_iostream&) = delete;

      basic_iostream&
      operator=(basic_iostream&& __rhs)
      {
 swap(__rhs);
 return *this;
      }

      void
      swap(basic_iostream& __rhs)
      { __istream_type::swap(__rhs); }

    };
# 906 "/usr/include/c++/10.2.0/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    ws(basic_istream<_CharT, _Traits>& __is);


  template<typename _Ch, typename _Up>
    basic_istream<_Ch, _Up>&
    __is_convertible_to_basic_istream_test(basic_istream<_Ch, _Up>*);

  template<typename _Tp, typename = void>
    struct __is_convertible_to_basic_istream_impl
    {
      using __istream_type = void;
    };

  template<typename _Tp>
    using __do_is_convertible_to_basic_istream_impl =
    decltype(__is_convertible_to_basic_istream_test
      (declval<typename remove_reference<_Tp>::type*>()));

  template<typename _Tp>
    struct __is_convertible_to_basic_istream_impl
    <_Tp,
     __void_t<__do_is_convertible_to_basic_istream_impl<_Tp>>>
    {
      using __istream_type =
 __do_is_convertible_to_basic_istream_impl<_Tp>;
    };

  template<typename _Tp>
    struct __is_convertible_to_basic_istream
    : __is_convertible_to_basic_istream_impl<_Tp>
    {
    public:
      using type = __not_<is_void<
        typename __is_convertible_to_basic_istream_impl<_Tp>::__istream_type>>;
      constexpr static bool value = type::value;
    };

  template<typename _Istream, typename _Tp, typename = void>
    struct __is_extractable : false_type {};

  template<typename _Istream, typename _Tp>
    struct __is_extractable<_Istream, _Tp,
       __void_t<decltype(declval<_Istream&>()
           >> declval<_Tp>())>>
    : true_type {};

  template<typename _Istream>
    using __rvalue_istream_type =
      typename __is_convertible_to_basic_istream<
 _Istream>::__istream_type;
# 972 "/usr/include/c++/10.2.0/istream" 3
  template<typename _Istream, typename _Tp>
    inline
    typename enable_if<__and_<__not_<is_lvalue_reference<_Istream>>,
         __is_convertible_to_basic_istream<_Istream>,
         __is_extractable<
    __rvalue_istream_type<_Istream>,
    _Tp&&>>::value,
         __rvalue_istream_type<_Istream>>::type
    operator>>(_Istream&& __is, _Tp&& __x)
    {
      __rvalue_istream_type<_Istream> __ret_is = __is;
      __ret_is >> std::forward<_Tp>(__x);
      return __ret_is;
    }



}

# 1 "/usr/include/c++/10.2.0/bits/istream.tcc" 1 3
# 37 "/usr/include/c++/10.2.0/bits/istream.tcc" 3
       
# 38 "/usr/include/c++/10.2.0/bits/istream.tcc" 3



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>::sentry::
    sentry(basic_istream<_CharT, _Traits>& __in, bool __noskip) : _M_ok(false)
    {
      ios_base::iostate __err = ios_base::goodbit;
      if (__in.good())
 try
   {
     if (__in.tie())
       __in.tie()->flush();
     if (!__noskip && bool(__in.flags() & ios_base::skipws))
       {
  const __int_type __eof = traits_type::eof();
  __streambuf_type* __sb = __in.rdbuf();
  __int_type __c = __sb->sgetc();

  const __ctype_type& __ct = __check_facet(__in._M_ctype);
  while (!traits_type::eq_int_type(__c, __eof)
         && __ct.is(ctype_base::space,
      traits_type::to_char_type(__c)))
    __c = __sb->snextc();




  if (traits_type::eq_int_type(__c, __eof))
    __err |= ios_base::eofbit;
       }
   }
 catch(__cxxabiv1::__forced_unwind&)
   {
     __in._M_setstate(ios_base::badbit);
     throw;
   }
 catch(...)
   { __in._M_setstate(ios_base::badbit); }

      if (__in.good() && __err == ios_base::goodbit)
 _M_ok = true;
      else
 {
   __err |= ios_base::failbit;
   __in.setstate(__err);
 }
    }

  template<typename _CharT, typename _Traits>
    template<typename _ValueT>
      basic_istream<_CharT, _Traits>&
      basic_istream<_CharT, _Traits>::
      _M_extract(_ValueT& __v)
      {
 sentry __cerb(*this, false);
 if (__cerb)
   {
     ios_base::iostate __err = ios_base::goodbit;
     try
       {
  const __num_get_type& __ng = __check_facet(this->_M_num_get);
  __ng.get(*this, 0, *this, __err, __v);
       }
     catch(__cxxabiv1::__forced_unwind&)
       {
  this->_M_setstate(ios_base::badbit);
  throw;
       }
     catch(...)
       { this->_M_setstate(ios_base::badbit); }
     if (__err)
       this->setstate(__err);
   }
 return *this;
      }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(short& __n)
    {


      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       long __l;
       const __num_get_type& __ng = __check_facet(this->_M_num_get);
       __ng.get(*this, 0, *this, __err, __l);



       if (__l < __gnu_cxx::__numeric_traits<short>::__min)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<short>::__min;
  }
       else if (__l > __gnu_cxx::__numeric_traits<short>::__max)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<short>::__max;
  }
       else
  __n = short(__l);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(int& __n)
    {


      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       long __l;
       const __num_get_type& __ng = __check_facet(this->_M_num_get);
       __ng.get(*this, 0, *this, __err, __l);



       if (__l < __gnu_cxx::__numeric_traits<int>::__min)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<int>::__min;
  }
       else if (__l > __gnu_cxx::__numeric_traits<int>::__max)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<int>::__max;
  }
       else
  __n = int(__l);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(__streambuf_type* __sbout)
    {
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, false);
      if (__cerb && __sbout)
 {
   try
     {
       bool __ineof;
       if (!__copy_streambufs_eof(this->rdbuf(), __sbout, __ineof))
  __err |= ios_base::failbit;
       if (__ineof)
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::failbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::failbit); }
 }
      else if (!__sbout)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::int_type
    basic_istream<_CharT, _Traits>::
    get(void)
    {
      const int_type __eof = traits_type::eof();
      int_type __c = __eof;
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       __c = this->rdbuf()->sbumpc();

       if (!traits_type::eq_int_type(__c, __eof))
  _M_gcount = 1;
       else
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return __c;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(char_type& __c)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       const int_type __cb = this->rdbuf()->sbumpc();

       if (!traits_type::eq_int_type(__cb, traits_type::eof()))
  {
    _M_gcount = 1;
    __c = traits_type::to_char_type(__cb);
  }
       else
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(char_type* __s, streamsize __n, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       const int_type __idelim = traits_type::to_int_type(__delim);
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       int_type __c = __sb->sgetc();

       while (_M_gcount + 1 < __n
       && !traits_type::eq_int_type(__c, __eof)
       && !traits_type::eq_int_type(__c, __idelim))
  {
    *__s++ = traits_type::to_char_type(__c);
    ++_M_gcount;
    __c = __sb->snextc();
  }
       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }


      if (__n > 0)
 *__s = char_type();
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(__streambuf_type& __sb, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       const int_type __idelim = traits_type::to_int_type(__delim);
       const int_type __eof = traits_type::eof();
       __streambuf_type* __this_sb = this->rdbuf();
       int_type __c = __this_sb->sgetc();
       char_type __c2 = traits_type::to_char_type(__c);

       while (!traits_type::eq_int_type(__c, __eof)
       && !traits_type::eq_int_type(__c, __idelim)
       && !traits_type::eq_int_type(__sb.sputc(__c2), __eof))
  {
    ++_M_gcount;
    __c = __this_sb->snextc();
    __c2 = traits_type::to_char_type(__c);
  }
       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    getline(char_type* __s, streamsize __n, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
        {
          try
            {
              const int_type __idelim = traits_type::to_int_type(__delim);
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();

              while (_M_gcount + 1 < __n
                     && !traits_type::eq_int_type(__c, __eof)
                     && !traits_type::eq_int_type(__c, __idelim))
                {
                  *__s++ = traits_type::to_char_type(__c);
                  __c = __sb->snextc();
                  ++_M_gcount;
                }
              if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
              else
                {
                  if (traits_type::eq_int_type(__c, __idelim))
                    {
                      __sb->sbumpc();
                      ++_M_gcount;
                    }
                  else
                    __err |= ios_base::failbit;
                }
            }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
          catch(...)
            { this->_M_setstate(ios_base::badbit); }
        }


      if (__n > 0)
 *__s = char_type();
      if (!_M_gcount)
        __err |= ios_base::failbit;
      if (__err)
        this->setstate(__err);
      return *this;
    }




  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(void)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();

       if (traits_type::eq_int_type(__sb->sbumpc(), __eof))
  __err |= ios_base::eofbit;
       else
  _M_gcount = 1;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb && __n > 0)
        {
          ios_base::iostate __err = ios_base::goodbit;
          try
            {
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();
# 521 "/usr/include/c++/10.2.0/bits/istream.tcc" 3
       bool __large_ignore = false;
       while (true)
  {
    while (_M_gcount < __n
    && !traits_type::eq_int_type(__c, __eof))
      {
        ++_M_gcount;
        __c = __sb->snextc();
      }
    if (__n == __gnu_cxx::__numeric_traits<streamsize>::__max
        && !traits_type::eq_int_type(__c, __eof))
      {
        _M_gcount =
   __gnu_cxx::__numeric_traits<streamsize>::__min;
        __large_ignore = true;
      }
    else
      break;
  }

       if (__large_ignore)
  _M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__max;

       if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
            }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
          catch(...)
            { this->_M_setstate(ios_base::badbit); }
          if (__err)
            this->setstate(__err);
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(streamsize __n, int_type __delim)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb && __n > 0)
        {
          ios_base::iostate __err = ios_base::goodbit;
          try
            {
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();


       bool __large_ignore = false;
       while (true)
  {
    while (_M_gcount < __n
    && !traits_type::eq_int_type(__c, __eof)
    && !traits_type::eq_int_type(__c, __delim))
      {
        ++_M_gcount;
        __c = __sb->snextc();
      }
    if (__n == __gnu_cxx::__numeric_traits<streamsize>::__max
        && !traits_type::eq_int_type(__c, __eof)
        && !traits_type::eq_int_type(__c, __delim))
      {
        _M_gcount =
   __gnu_cxx::__numeric_traits<streamsize>::__min;
        __large_ignore = true;
      }
    else
      break;
  }

       if (__large_ignore)
  _M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__max;

              if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
       else if (traits_type::eq_int_type(__c, __delim))
  {
    if (_M_gcount
        < __gnu_cxx::__numeric_traits<streamsize>::__max)
      ++_M_gcount;
    __sb->sbumpc();
  }
            }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
          catch(...)
            { this->_M_setstate(ios_base::badbit); }
          if (__err)
            this->setstate(__err);
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::int_type
    basic_istream<_CharT, _Traits>::
    peek(void)
    {
      int_type __c = traits_type::eof();
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       __c = this->rdbuf()->sgetc();
       if (traits_type::eq_int_type(__c, traits_type::eof()))
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return __c;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    read(char_type* __s, streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       _M_gcount = this->rdbuf()->sgetn(__s, __n);
       if (_M_gcount != __n)
  __err |= (ios_base::eofbit | ios_base::failbit);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_istream<_CharT, _Traits>::
    readsome(char_type* __s, streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {

       const streamsize __num = this->rdbuf()->in_avail();
       if (__num > 0)
  _M_gcount = this->rdbuf()->sgetn(__s, std::min(__num, __n));
       else if (__num == -1)
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return _M_gcount;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    putback(char_type __c)
    {


      _M_gcount = 0;

      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       if (!__sb
    || traits_type::eq_int_type(__sb->sputbackc(__c), __eof))
  __err |= ios_base::badbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    unget(void)
    {


      _M_gcount = 0;

      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       if (!__sb
    || traits_type::eq_int_type(__sb->sungetc(), __eof))
  __err |= ios_base::badbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    int
    basic_istream<_CharT, _Traits>::
    sync(void)
    {


      int __ret = -1;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       __streambuf_type* __sb = this->rdbuf();
       if (__sb)
  {
    if (__sb->pubsync() == -1)
      __err |= ios_base::badbit;
    else
      __ret = 0;
  }
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::pos_type
    basic_istream<_CharT, _Traits>::
    tellg(void)
    {


      pos_type __ret = pos_type(-1);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       if (!this->fail())
  __ret = this->rdbuf()->pubseekoff(0, ios_base::cur,
        ios_base::in);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    seekg(pos_type __pos)
    {



      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       if (!this->fail())
  {

    const pos_type __p = this->rdbuf()->pubseekpos(__pos,
         ios_base::in);


    if (__p == pos_type(off_type(-1)))
      __err |= ios_base::failbit;
  }
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    seekg(off_type __off, ios_base::seekdir __dir)
    {



      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       if (!this->fail())
  {

    const pos_type __p = this->rdbuf()->pubseekoff(__off, __dir,
         ios_base::in);


    if (__p == pos_type(off_type(-1)))
      __err |= ios_base::failbit;
  }
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT& __c)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::int_type __int_type;

      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const __int_type __cb = __in.rdbuf()->sbumpc();
       if (!_Traits::eq_int_type(__cb, _Traits::eof()))
  __c = _Traits::to_char_type(__cb);
       else
  __err |= (ios_base::eofbit | ios_base::failbit);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { __in._M_setstate(ios_base::badbit); }
   if (__err)
     __in.setstate(__err);
 }
      return __in;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT* __s)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef typename _Traits::int_type int_type;
      typedef _CharT char_type;
      typedef ctype<_CharT> __ctype_type;

      streamsize __extracted = 0;
      ios_base::iostate __err = ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   try
     {

       streamsize __num = __in.width();
       if (__num <= 0)
  __num = __gnu_cxx::__numeric_traits<streamsize>::__max;

       const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());

       const int_type __eof = _Traits::eof();
       __streambuf_type* __sb = __in.rdbuf();
       int_type __c = __sb->sgetc();

       while (__extracted < __num - 1
       && !_Traits::eq_int_type(__c, __eof)
       && !__ct.is(ctype_base::space,
     _Traits::to_char_type(__c)))
  {
    *__s++ = _Traits::to_char_type(__c);
    ++__extracted;
    __c = __sb->snextc();
  }
       if (_Traits::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;



       *__s = char_type();
       __in.width(0);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { __in._M_setstate(ios_base::badbit); }
 }
      if (!__extracted)
 __err |= ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    ws(basic_istream<_CharT, _Traits>& __in)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef typename __istream_type::int_type __int_type;
      typedef ctype<_CharT> __ctype_type;

      const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());
      const __int_type __eof = _Traits::eof();
      __streambuf_type* __sb = __in.rdbuf();
      __int_type __c = __sb->sgetc();

      while (!_Traits::eq_int_type(__c, __eof)
      && __ct.is(ctype_base::space, _Traits::to_char_type(__c)))
 __c = __sb->snextc();

       if (_Traits::eq_int_type(__c, __eof))
  __in.setstate(ios_base::eofbit);
      return __in;
    }




  extern template class basic_istream<char>;
  extern template istream& ws(istream&);
  extern template istream& operator>>(istream&, char&);
  extern template istream& operator>>(istream&, char*);
  extern template istream& operator>>(istream&, unsigned char&);
  extern template istream& operator>>(istream&, signed char&);
  extern template istream& operator>>(istream&, unsigned char*);
  extern template istream& operator>>(istream&, signed char*);

  extern template istream& istream::_M_extract(unsigned short&);
  extern template istream& istream::_M_extract(unsigned int&);
  extern template istream& istream::_M_extract(long&);
  extern template istream& istream::_M_extract(unsigned long&);
  extern template istream& istream::_M_extract(bool&);

  extern template istream& istream::_M_extract(long long&);
  extern template istream& istream::_M_extract(unsigned long long&);

  extern template istream& istream::_M_extract(float&);
  extern template istream& istream::_M_extract(double&);
  extern template istream& istream::_M_extract(long double&);
  extern template istream& istream::_M_extract(void*&);

  extern template class basic_iostream<char>;


  extern template class basic_istream<wchar_t>;
  extern template wistream& ws(wistream&);
  extern template wistream& operator>>(wistream&, wchar_t&);
  extern template wistream& operator>>(wistream&, wchar_t*);

  extern template wistream& wistream::_M_extract(unsigned short&);
  extern template wistream& wistream::_M_extract(unsigned int&);
  extern template wistream& wistream::_M_extract(long&);
  extern template wistream& wistream::_M_extract(unsigned long&);
  extern template wistream& wistream::_M_extract(bool&);

  extern template wistream& wistream::_M_extract(long long&);
  extern template wistream& wistream::_M_extract(unsigned long long&);

  extern template wistream& wistream::_M_extract(float&);
  extern template wistream& wistream::_M_extract(double&);
  extern template wistream& wistream::_M_extract(long double&);
  extern template wistream& wistream::_M_extract(void*&);

  extern template class basic_iostream<wchar_t>;




}
# 992 "/usr/include/c++/10.2.0/istream" 2 3
# 41 "/usr/include/c++/10.2.0/iostream" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 60 "/usr/include/c++/10.2.0/iostream" 3
  extern istream cin;
  extern ostream cout;
  extern ostream cerr;
  extern ostream clog;


  extern wistream wcin;
  extern wostream wcout;
  extern wostream wcerr;
  extern wostream wclog;




  static ios_base::Init __ioinit;


}
# 21 "/usr/include/opencascade/Standard_Stream.hxx" 2
# 1 "/usr/include/c++/10.2.0/iomanip" 1 3
# 36 "/usr/include/c++/10.2.0/iomanip" 3
       
# 37 "/usr/include/c++/10.2.0/iomanip" 3






# 1 "/usr/include/c++/10.2.0/locale" 1 3
# 36 "/usr/include/c++/10.2.0/locale" 3
       
# 37 "/usr/include/c++/10.2.0/locale" 3




# 1 "/usr/include/c++/10.2.0/bits/locale_facets_nonio.h" 1 3
# 37 "/usr/include/c++/10.2.0/bits/locale_facets_nonio.h" 3
       
# 38 "/usr/include/c++/10.2.0/bits/locale_facets_nonio.h" 3

# 1 "/usr/include/c++/10.2.0/ctime" 1 3
# 39 "/usr/include/c++/10.2.0/ctime" 3
       
# 40 "/usr/include/c++/10.2.0/ctime" 3
# 40 "/usr/include/c++/10.2.0/bits/locale_facets_nonio.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 52 "/usr/include/c++/10.2.0/bits/locale_facets_nonio.h" 3
  class time_base
  {
  public:
    enum dateorder { no_order, dmy, mdy, ymd, ydm };
  };

  template<typename _CharT>
    struct __timepunct_cache : public locale::facet
    {

      static const _CharT* _S_timezones[14];

      const _CharT* _M_date_format;
      const _CharT* _M_date_era_format;
      const _CharT* _M_time_format;
      const _CharT* _M_time_era_format;
      const _CharT* _M_date_time_format;
      const _CharT* _M_date_time_era_format;
      const _CharT* _M_am;
      const _CharT* _M_pm;
      const _CharT* _M_am_pm_format;


      const _CharT* _M_day1;
      const _CharT* _M_day2;
      const _CharT* _M_day3;
      const _CharT* _M_day4;
      const _CharT* _M_day5;
      const _CharT* _M_day6;
      const _CharT* _M_day7;


      const _CharT* _M_aday1;
      const _CharT* _M_aday2;
      const _CharT* _M_aday3;
      const _CharT* _M_aday4;
      const _CharT* _M_aday5;
      const _CharT* _M_aday6;
      const _CharT* _M_aday7;


      const _CharT* _M_month01;
      const _CharT* _M_month02;
      const _CharT* _M_month03;
      const _CharT* _M_month04;
      const _CharT* _M_month05;
      const _CharT* _M_month06;
      const _CharT* _M_month07;
      const _CharT* _M_month08;
      const _CharT* _M_month09;
      const _CharT* _M_month10;
      const _CharT* _M_month11;
      const _CharT* _M_month12;


      const _CharT* _M_amonth01;
      const _CharT* _M_amonth02;
      const _CharT* _M_amonth03;
      const _CharT* _M_amonth04;
      const _CharT* _M_amonth05;
      const _CharT* _M_amonth06;
      const _CharT* _M_amonth07;
      const _CharT* _M_amonth08;
      const _CharT* _M_amonth09;
      const _CharT* _M_amonth10;
      const _CharT* _M_amonth11;
      const _CharT* _M_amonth12;

      bool _M_allocated;

      __timepunct_cache(size_t __refs = 0) : facet(__refs),
      _M_date_format(0), _M_date_era_format(0), _M_time_format(0),
      _M_time_era_format(0), _M_date_time_format(0),
      _M_date_time_era_format(0), _M_am(0), _M_pm(0),
      _M_am_pm_format(0), _M_day1(0), _M_day2(0), _M_day3(0),
      _M_day4(0), _M_day5(0), _M_day6(0), _M_day7(0),
      _M_aday1(0), _M_aday2(0), _M_aday3(0), _M_aday4(0),
      _M_aday5(0), _M_aday6(0), _M_aday7(0), _M_month01(0),
      _M_month02(0), _M_month03(0), _M_month04(0), _M_month05(0),
      _M_month06(0), _M_month07(0), _M_month08(0), _M_month09(0),
      _M_month10(0), _M_month11(0), _M_month12(0), _M_amonth01(0),
      _M_amonth02(0), _M_amonth03(0), _M_amonth04(0),
      _M_amonth05(0), _M_amonth06(0), _M_amonth07(0),
      _M_amonth08(0), _M_amonth09(0), _M_amonth10(0),
      _M_amonth11(0), _M_amonth12(0), _M_allocated(false)
      { }

      ~__timepunct_cache();

    private:
      __timepunct_cache&
      operator=(const __timepunct_cache&);

      explicit
      __timepunct_cache(const __timepunct_cache&);
    };

  template<typename _CharT>
    __timepunct_cache<_CharT>::~__timepunct_cache()
    {
      if (_M_allocated)
 {

 }
    }


  template<>
    const char*
    __timepunct_cache<char>::_S_timezones[14];


  template<>
    const wchar_t*
    __timepunct_cache<wchar_t>::_S_timezones[14];



  template<typename _CharT>
    const _CharT* __timepunct_cache<_CharT>::_S_timezones[14];

  template<typename _CharT>
    class __timepunct : public locale::facet
    {
    public:

      typedef _CharT __char_type;
      typedef __timepunct_cache<_CharT> __cache_type;

    protected:
      __cache_type* _M_data;
      __c_locale _M_c_locale_timepunct;
      const char* _M_name_timepunct;

    public:

      static locale::id id;

      explicit
      __timepunct(size_t __refs = 0);

      explicit
      __timepunct(__cache_type* __cache, size_t __refs = 0);
# 206 "/usr/include/c++/10.2.0/bits/locale_facets_nonio.h" 3
      explicit
      __timepunct(__c_locale __cloc, const char* __s, size_t __refs = 0);



      void
      _M_put(_CharT* __s, size_t __maxlen, const _CharT* __format,
      const tm* __tm) const throw ();

      void
      _M_date_formats(const _CharT** __date) const
      {

 __date[0] = _M_data->_M_date_format;
 __date[1] = _M_data->_M_date_era_format;
      }

      void
      _M_time_formats(const _CharT** __time) const
      {

 __time[0] = _M_data->_M_time_format;
 __time[1] = _M_data->_M_time_era_format;
      }

      void
      _M_date_time_formats(const _CharT** __dt) const
      {

 __dt[0] = _M_data->_M_date_time_format;
 __dt[1] = _M_data->_M_date_time_era_format;
      }


      void
      _M_am_pm_format(const _CharT*) const
      { }


      void
      _M_am_pm(const _CharT** __ampm) const
      {
 __ampm[0] = _M_data->_M_am;
 __ampm[1] = _M_data->_M_pm;
      }

      void
      _M_days(const _CharT** __days) const
      {
 __days[0] = _M_data->_M_day1;
 __days[1] = _M_data->_M_day2;
 __days[2] = _M_data->_M_day3;
 __days[3] = _M_data->_M_day4;
 __days[4] = _M_data->_M_day5;
 __days[5] = _M_data->_M_day6;
 __days[6] = _M_data->_M_day7;
      }

      void
      _M_days_abbreviated(const _CharT** __days) const
      {
 __days[0] = _M_data->_M_aday1;
 __days[1] = _M_data->_M_aday2;
 __days[2] = _M_data->_M_aday3;
 __days[3] = _M_data->_M_aday4;
 __days[4] = _M_data->_M_aday5;
 __days[5] = _M_data->_M_aday6;
 __days[6] = _M_data->_M_aday7;
      }

      void
      _M_months(const _CharT** __months) const
      {
 __months[0] = _M_data->_M_month01;
 __months[1] = _M_data->_M_month02;
 __months[2] = _M_data->_M_month03;
 __months[3] = _M_data->_M_month04;
 __months[4] = _M_data->_M_month05;
 __months[5] = _M_data->_M_month06;
 __months[6] = _M_data->_M_month07;
 __months[7] = _M_data->_M_month08;
 __months[8] = _M_data->_M_month09;
 __months[9] = _M_data->_M_month10;
 __months[10] = _M_data->_M_month11;
 __months[11] = _M_data->_M_month12;
      }

      void
      _M_months_abbreviated(const _CharT** __months) const
      {
 __months[0] = _M_data->_M_amonth01;
 __months[1] = _M_data->_M_amonth02;
 __months[2] = _M_data->_M_amonth03;
 __months[3] = _M_data->_M_amonth04;
 __months[4] = _M_data->_M_amonth05;
 __months[5] = _M_data->_M_amonth06;
 __months[6] = _M_data->_M_amonth07;
 __months[7] = _M_data->_M_amonth08;
 __months[8] = _M_data->_M_amonth09;
 __months[9] = _M_data->_M_amonth10;
 __months[10] = _M_data->_M_amonth11;
 __months[11] = _M_data->_M_amonth12;
      }

    protected:
      virtual
      ~__timepunct();


      void
      _M_initialize_timepunct(__c_locale __cloc = 0);
    };

  template<typename _CharT>
    locale::id __timepunct<_CharT>::id;


  template<>
    void
    __timepunct<char>::_M_initialize_timepunct(__c_locale __cloc);

  template<>
    void
    __timepunct<char>::_M_put(char*, size_t, const char*, const tm*) const throw ();


  template<>
    void
    __timepunct<wchar_t>::_M_initialize_timepunct(__c_locale __cloc);

  template<>
    void
    __timepunct<wchar_t>::_M_put(wchar_t*, size_t, const wchar_t*,
     const tm*) const throw ();



}


# 1 "/usr/include/c++/10.2.0/x86_64-pc-linux-gnu/bits/time_members.h" 1 3
# 37 "/usr/include/c++/10.2.0/x86_64-pc-linux-gnu/bits/time_members.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT>
    __timepunct<_CharT>::__timepunct(size_t __refs)
    : facet(__refs), _M_data(0), _M_c_locale_timepunct(0),
      _M_name_timepunct(_S_get_c_name())
    { _M_initialize_timepunct(); }

  template<typename _CharT>
    __timepunct<_CharT>::__timepunct(__cache_type* __cache, size_t __refs)
    : facet(__refs), _M_data(__cache), _M_c_locale_timepunct(0),
      _M_name_timepunct(_S_get_c_name())
    { _M_initialize_timepunct(); }

  template<typename _CharT>
    __timepunct<_CharT>::__timepunct(__c_locale __cloc, const char* __s,
         size_t __refs)
    : facet(__refs), _M_data(0), _M_c_locale_timepunct(0),
      _M_name_timepunct(0)
    {
      if (__builtin_strcmp(__s, _S_get_c_name()) != 0)
 {
   const size_t __len = __builtin_strlen(__s) + 1;
   char* __tmp = new char[__len];
   __builtin_memcpy(__tmp, __s, __len);
   _M_name_timepunct = __tmp;
 }
      else
 _M_name_timepunct = _S_get_c_name();

      try
 { _M_initialize_timepunct(__cloc); }
      catch(...)
 {
   if (_M_name_timepunct != _S_get_c_name())
     delete [] _M_name_timepunct;
   throw;
 }
    }

  template<typename _CharT>
    __timepunct<_CharT>::~__timepunct()
    {
      if (_M_name_timepunct != _S_get_c_name())
 delete [] _M_name_timepunct;
      delete _M_data;
      _S_destroy_c_locale(_M_c_locale_timepunct);
    }


}
# 347 "/usr/include/c++/10.2.0/bits/locale_facets_nonio.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{


namespace __cxx11 {
# 367 "/usr/include/c++/10.2.0/bits/locale_facets_nonio.h" 3
  template<typename _CharT, typename _InIter>
    class time_get : public locale::facet, public time_base
    {
    public:



      typedef _CharT char_type;
      typedef _InIter iter_type;



      static locale::id id;
# 388 "/usr/include/c++/10.2.0/bits/locale_facets_nonio.h" 3
      explicit
      time_get(size_t __refs = 0)
      : facet (__refs) { }
# 405 "/usr/include/c++/10.2.0/bits/locale_facets_nonio.h" 3
      dateorder
      date_order() const
      { return this->do_date_order(); }
# 429 "/usr/include/c++/10.2.0/bits/locale_facets_nonio.h" 3
      iter_type
      get_time(iter_type __beg, iter_type __end, ios_base& __io,
        ios_base::iostate& __err, tm* __tm) const
      { return this->do_get_time(__beg, __end, __io, __err, __tm); }
# 454 "/usr/include/c++/10.2.0/bits/locale_facets_nonio.h" 3
      iter_type
      get_date(iter_type __beg, iter_type __end, ios_base& __io,
        ios_base::iostate& __err, tm* __tm) const
      { return this->do_get_date(__beg, __end, __io, __err, __tm); }
# 482 "/usr/include/c++/10.2.0/bits/locale_facets_nonio.h" 3
      iter_type
      get_weekday(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, tm* __tm) const
      { return this->do_get_weekday(__beg, __end, __io, __err, __tm); }
# 511 "/usr/include/c++/10.2.0/bits/locale_facets_nonio.h" 3
      iter_type
      get_monthname(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, tm* __tm) const
      { return this->do_get_monthname(__beg, __end, __io, __err, __tm); }
# 537 "/usr/include/c++/10.2.0/bits/locale_facets_nonio.h" 3
      iter_type
      get_year(iter_type __beg, iter_type __end, ios_base& __io,
        ios_base::iostate& __err, tm* __tm) const
      { return this->do_get_year(__beg, __end, __io, __err, __tm); }
# 558 "/usr/include/c++/10.2.0/bits/locale_facets_nonio.h" 3
      inline
      iter_type get(iter_type __s, iter_type __end, ios_base& __io,
                    ios_base::iostate& __err, tm* __tm, char __format,
                    char __modifier = 0) const
      {
        return this->do_get(__s, __end, __io, __err, __tm, __format,
                            __modifier);
      }
# 585 "/usr/include/c++/10.2.0/bits/locale_facets_nonio.h" 3
      iter_type get(iter_type __s, iter_type __end, ios_base& __io,
                    ios_base::iostate& __err, tm* __tm, const char_type* __fmt,
                    const char_type* __fmtend) const;


    protected:

      virtual
      ~time_get() { }
# 605 "/usr/include/c++/10.2.0/bits/locale_facets_nonio.h" 3
      virtual dateorder
      do_date_order() const;
# 623 "/usr/include/c++/10.2.0/bits/locale_facets_nonio.h" 3
      virtual iter_type
      do_get_time(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, tm* __tm) const;
# 642 "/usr/include/c++/10.2.0/bits/locale_facets_nonio.h" 3
      virtual iter_type
      do_get_date(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, tm* __tm) const;
# 661 "/usr/include/c++/10.2.0/bits/locale_facets_nonio.h" 3
      virtual iter_type
      do_get_weekday(iter_type __beg, iter_type __end, ios_base&,
       ios_base::iostate& __err, tm* __tm) const;
# 680 "/usr/include/c++/10.2.0/bits/locale_facets_nonio.h" 3
      virtual iter_type
      do_get_monthname(iter_type __beg, iter_type __end, ios_base&,
         ios_base::iostate& __err, tm* __tm) const;
# 699 "/usr/include/c++/10.2.0/bits/locale_facets_nonio.h" 3
      virtual iter_type
      do_get_year(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, tm* __tm) const;
# 722 "/usr/include/c++/10.2.0/bits/locale_facets_nonio.h" 3
      virtual

      iter_type
      do_get(iter_type __s, iter_type __end, ios_base& __f,
             ios_base::iostate& __err, tm* __tm,
             char __format, char __modifier) const;



      iter_type
      _M_extract_num(iter_type __beg, iter_type __end, int& __member,
       int __min, int __max, size_t __len,
       ios_base& __io, ios_base::iostate& __err) const;


      iter_type
      _M_extract_name(iter_type __beg, iter_type __end, int& __member,
        const _CharT** __names, size_t __indexlen,
        ios_base& __io, ios_base::iostate& __err) const;


      iter_type
      _M_extract_wday_or_month(iter_type __beg, iter_type __end, int& __member,
          const _CharT** __names, size_t __indexlen,
          ios_base& __io, ios_base::iostate& __err) const;


      iter_type
      _M_extract_via_format(iter_type __beg, iter_type __end, ios_base& __io,
       ios_base::iostate& __err, tm* __tm,
       const _CharT* __format) const;
    };

  template<typename _CharT, typename _InIter>
    locale::id time_get<_CharT, _InIter>::id;


  template<typename _CharT, typename _InIter>
    class time_get_byname : public time_get<_CharT, _InIter>
    {
    public:

      typedef _CharT char_type;
      typedef _InIter iter_type;

      explicit
      time_get_byname(const char*, size_t __refs = 0)
      : time_get<_CharT, _InIter>(__refs) { }


      explicit
      time_get_byname(const string& __s, size_t __refs = 0)
      : time_get_byname(__s.c_str(), __refs) { }


    protected:
      virtual
      ~time_get_byname() { }
    };

}
# 796 "/usr/include/c++/10.2.0/bits/locale_facets_nonio.h" 3
  template<typename _CharT, typename _OutIter>
    class time_put : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef _OutIter iter_type;



      static locale::id id;
# 817 "/usr/include/c++/10.2.0/bits/locale_facets_nonio.h" 3
      explicit
      time_put(size_t __refs = 0)
      : facet(__refs) { }
# 836 "/usr/include/c++/10.2.0/bits/locale_facets_nonio.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill, const tm* __tm,
   const _CharT* __beg, const _CharT* __end) const;
# 856 "/usr/include/c++/10.2.0/bits/locale_facets_nonio.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill,
   const tm* __tm, char __format, char __mod = 0) const
      { return this->do_put(__s, __io, __fill, __tm, __format, __mod); }

    protected:

      virtual
      ~time_put()
      { }
# 883 "/usr/include/c++/10.2.0/bits/locale_facets_nonio.h" 3
      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill, const tm* __tm,
      char __format, char __mod) const;
    };

  template<typename _CharT, typename _OutIter>
    locale::id time_put<_CharT, _OutIter>::id;


  template<typename _CharT, typename _OutIter>
    class time_put_byname : public time_put<_CharT, _OutIter>
    {
    public:

      typedef _CharT char_type;
      typedef _OutIter iter_type;

      explicit
      time_put_byname(const char*, size_t __refs = 0)
      : time_put<_CharT, _OutIter>(__refs)
      { }


      explicit
      time_put_byname(const string& __s, size_t __refs = 0)
      : time_put_byname(__s.c_str(), __refs) { }


    protected:
      virtual
      ~time_put_byname() { }
    };
# 928 "/usr/include/c++/10.2.0/bits/locale_facets_nonio.h" 3
  class money_base
  {
  public:
    enum part { none, space, symbol, sign, value };
    struct pattern { char field[4]; };

    static const pattern _S_default_pattern;

    enum
    {
      _S_minus,
      _S_zero,
      _S_end = 11
    };



    static const char* _S_atoms;



    __attribute__ ((__const__)) static pattern
    _S_construct_pattern(char __precedes, char __space, char __posn) throw ();
  };

  template<typename _CharT, bool _Intl>
    struct __moneypunct_cache : public locale::facet
    {
      const char* _M_grouping;
      size_t _M_grouping_size;
      bool _M_use_grouping;
      _CharT _M_decimal_point;
      _CharT _M_thousands_sep;
      const _CharT* _M_curr_symbol;
      size_t _M_curr_symbol_size;
      const _CharT* _M_positive_sign;
      size_t _M_positive_sign_size;
      const _CharT* _M_negative_sign;
      size_t _M_negative_sign_size;
      int _M_frac_digits;
      money_base::pattern _M_pos_format;
      money_base::pattern _M_neg_format;




      _CharT _M_atoms[money_base::_S_end];

      bool _M_allocated;

      __moneypunct_cache(size_t __refs = 0) : facet(__refs),
      _M_grouping(0), _M_grouping_size(0), _M_use_grouping(false),
      _M_decimal_point(_CharT()), _M_thousands_sep(_CharT()),
      _M_curr_symbol(0), _M_curr_symbol_size(0),
      _M_positive_sign(0), _M_positive_sign_size(0),
      _M_negative_sign(0), _M_negative_sign_size(0),
      _M_frac_digits(0),
      _M_pos_format(money_base::pattern()),
      _M_neg_format(money_base::pattern()), _M_allocated(false)
      { }

      ~__moneypunct_cache();

      void
      _M_cache(const locale& __loc);

    private:
      __moneypunct_cache&
      operator=(const __moneypunct_cache&);

      explicit
      __moneypunct_cache(const __moneypunct_cache&);
    };

  template<typename _CharT, bool _Intl>
    __moneypunct_cache<_CharT, _Intl>::~__moneypunct_cache()
    {
      if (_M_allocated)
 {
   delete [] _M_grouping;
   delete [] _M_curr_symbol;
   delete [] _M_positive_sign;
   delete [] _M_negative_sign;
 }
    }

namespace __cxx11 {
# 1023 "/usr/include/c++/10.2.0/bits/locale_facets_nonio.h" 3
  template<typename _CharT, bool _Intl>
    class moneypunct : public locale::facet, public money_base
    {
    public:



      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      typedef __moneypunct_cache<_CharT, _Intl> __cache_type;

    private:
      __cache_type* _M_data;

    public:


      static const bool intl = _Intl;

      static locale::id id;
# 1052 "/usr/include/c++/10.2.0/bits/locale_facets_nonio.h" 3
      explicit
      moneypunct(size_t __refs = 0)
      : facet(__refs), _M_data(0)
      { _M_initialize_moneypunct(); }
# 1065 "/usr/include/c++/10.2.0/bits/locale_facets_nonio.h" 3
      explicit
      moneypunct(__cache_type* __cache, size_t __refs = 0)
      : facet(__refs), _M_data(__cache)
      { _M_initialize_moneypunct(); }
# 1080 "/usr/include/c++/10.2.0/bits/locale_facets_nonio.h" 3
      explicit
      moneypunct(__c_locale __cloc, const char* __s, size_t __refs = 0)
      : facet(__refs), _M_data(0)
      { _M_initialize_moneypunct(__cloc, __s); }
# 1094 "/usr/include/c++/10.2.0/bits/locale_facets_nonio.h" 3
      char_type
      decimal_point() const
      { return this->do_decimal_point(); }
# 1107 "/usr/include/c++/10.2.0/bits/locale_facets_nonio.h" 3
      char_type
      thousands_sep() const
      { return this->do_thousands_sep(); }
# 1137 "/usr/include/c++/10.2.0/bits/locale_facets_nonio.h" 3
      string
      grouping() const
      { return this->do_grouping(); }
# 1150 "/usr/include/c++/10.2.0/bits/locale_facets_nonio.h" 3
      string_type
      curr_symbol() const
      { return this->do_curr_symbol(); }
# 1167 "/usr/include/c++/10.2.0/bits/locale_facets_nonio.h" 3
      string_type
      positive_sign() const
      { return this->do_positive_sign(); }
# 1184 "/usr/include/c++/10.2.0/bits/locale_facets_nonio.h" 3
      string_type
      negative_sign() const
      { return this->do_negative_sign(); }
# 1200 "/usr/include/c++/10.2.0/bits/locale_facets_nonio.h" 3
      int
      frac_digits() const
      { return this->do_frac_digits(); }
# 1236 "/usr/include/c++/10.2.0/bits/locale_facets_nonio.h" 3
      pattern
      pos_format() const
      { return this->do_pos_format(); }

      pattern
      neg_format() const
      { return this->do_neg_format(); }


    protected:

      virtual
      ~moneypunct();
# 1258 "/usr/include/c++/10.2.0/bits/locale_facets_nonio.h" 3
      virtual char_type
      do_decimal_point() const
      { return _M_data->_M_decimal_point; }
# 1270 "/usr/include/c++/10.2.0/bits/locale_facets_nonio.h" 3
      virtual char_type
      do_thousands_sep() const
      { return _M_data->_M_thousands_sep; }
# 1283 "/usr/include/c++/10.2.0/bits/locale_facets_nonio.h" 3
      virtual string
      do_grouping() const
      { return _M_data->_M_grouping; }
# 1296 "/usr/include/c++/10.2.0/bits/locale_facets_nonio.h" 3
      virtual string_type
      do_curr_symbol() const
      { return _M_data->_M_curr_symbol; }
# 1309 "/usr/include/c++/10.2.0/bits/locale_facets_nonio.h" 3
      virtual string_type
      do_positive_sign() const
      { return _M_data->_M_positive_sign; }
# 1322 "/usr/include/c++/10.2.0/bits/locale_facets_nonio.h" 3
      virtual string_type
      do_negative_sign() const
      { return _M_data->_M_negative_sign; }
# 1336 "/usr/include/c++/10.2.0/bits/locale_facets_nonio.h" 3
      virtual int
      do_frac_digits() const
      { return _M_data->_M_frac_digits; }
# 1350 "/usr/include/c++/10.2.0/bits/locale_facets_nonio.h" 3
      virtual pattern
      do_pos_format() const
      { return _M_data->_M_pos_format; }
# 1364 "/usr/include/c++/10.2.0/bits/locale_facets_nonio.h" 3
      virtual pattern
      do_neg_format() const
      { return _M_data->_M_neg_format; }


       void
       _M_initialize_moneypunct(__c_locale __cloc = 0,
    const char* __name = 0);
    };

  template<typename _CharT, bool _Intl>
    locale::id moneypunct<_CharT, _Intl>::id;

  template<typename _CharT, bool _Intl>
    const bool moneypunct<_CharT, _Intl>::intl;

  template<>
    moneypunct<char, true>::~moneypunct();

  template<>
    moneypunct<char, false>::~moneypunct();

  template<>
    void
    moneypunct<char, true>::_M_initialize_moneypunct(__c_locale, const char*);

  template<>
    void
    moneypunct<char, false>::_M_initialize_moneypunct(__c_locale, const char*);


  template<>
    moneypunct<wchar_t, true>::~moneypunct();

  template<>
    moneypunct<wchar_t, false>::~moneypunct();

  template<>
    void
    moneypunct<wchar_t, true>::_M_initialize_moneypunct(__c_locale,
       const char*);

  template<>
    void
    moneypunct<wchar_t, false>::_M_initialize_moneypunct(__c_locale,
        const char*);



  template<typename _CharT, bool _Intl>
    class moneypunct_byname : public moneypunct<_CharT, _Intl>
    {
    public:
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      static const bool intl = _Intl;

      explicit
      moneypunct_byname(const char* __s, size_t __refs = 0)
      : moneypunct<_CharT, _Intl>(__refs)
      {
 if (__builtin_strcmp(__s, "C") != 0
     && __builtin_strcmp(__s, "POSIX") != 0)
   {
     __c_locale __tmp;
     this->_S_create_c_locale(__tmp, __s);
     this->_M_initialize_moneypunct(__tmp);
     this->_S_destroy_c_locale(__tmp);
   }
      }


      explicit
      moneypunct_byname(const string& __s, size_t __refs = 0)
      : moneypunct_byname(__s.c_str(), __refs) { }


    protected:
      virtual
      ~moneypunct_byname() { }
    };

  template<typename _CharT, bool _Intl>
    const bool moneypunct_byname<_CharT, _Intl>::intl;

}

namespace __cxx11 {
# 1467 "/usr/include/c++/10.2.0/bits/locale_facets_nonio.h" 3
  template<typename _CharT, typename _InIter>
    class money_get : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef _InIter iter_type;
      typedef basic_string<_CharT> string_type;



      static locale::id id;
# 1489 "/usr/include/c++/10.2.0/bits/locale_facets_nonio.h" 3
      explicit
      money_get(size_t __refs = 0) : facet(__refs) { }
# 1519 "/usr/include/c++/10.2.0/bits/locale_facets_nonio.h" 3
      iter_type
      get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,
   ios_base::iostate& __err, long double& __units) const
      { return this->do_get(__s, __end, __intl, __io, __err, __units); }
# 1550 "/usr/include/c++/10.2.0/bits/locale_facets_nonio.h" 3
      iter_type
      get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,
   ios_base::iostate& __err, string_type& __digits) const
      { return this->do_get(__s, __end, __intl, __io, __err, __digits); }

    protected:

      virtual
      ~money_get() { }
# 1574 "/usr/include/c++/10.2.0/bits/locale_facets_nonio.h" 3
      virtual iter_type
      do_get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,
      ios_base::iostate& __err, long double& __units) const;
# 1586 "/usr/include/c++/10.2.0/bits/locale_facets_nonio.h" 3
      virtual iter_type
      do_get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,
      ios_base::iostate& __err, string_type& __digits) const;
# 1598 "/usr/include/c++/10.2.0/bits/locale_facets_nonio.h" 3
      template<bool _Intl>
        iter_type
        _M_extract(iter_type __s, iter_type __end, ios_base& __io,
     ios_base::iostate& __err, string& __digits) const;
    };

  template<typename _CharT, typename _InIter>
    locale::id money_get<_CharT, _InIter>::id;
# 1620 "/usr/include/c++/10.2.0/bits/locale_facets_nonio.h" 3
  template<typename _CharT, typename _OutIter>
    class money_put : public locale::facet
    {
    public:


      typedef _CharT char_type;
      typedef _OutIter iter_type;
      typedef basic_string<_CharT> string_type;



      static locale::id id;
# 1641 "/usr/include/c++/10.2.0/bits/locale_facets_nonio.h" 3
      explicit
      money_put(size_t __refs = 0) : facet(__refs) { }
# 1661 "/usr/include/c++/10.2.0/bits/locale_facets_nonio.h" 3
      iter_type
      put(iter_type __s, bool __intl, ios_base& __io,
   char_type __fill, long double __units) const
      { return this->do_put(__s, __intl, __io, __fill, __units); }
# 1684 "/usr/include/c++/10.2.0/bits/locale_facets_nonio.h" 3
      iter_type
      put(iter_type __s, bool __intl, ios_base& __io,
   char_type __fill, const string_type& __digits) const
      { return this->do_put(__s, __intl, __io, __fill, __digits); }

    protected:

      virtual
      ~money_put() { }
# 1719 "/usr/include/c++/10.2.0/bits/locale_facets_nonio.h" 3
      virtual iter_type
      do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,
      long double __units) const;
# 1743 "/usr/include/c++/10.2.0/bits/locale_facets_nonio.h" 3
      virtual iter_type
      do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,
      const string_type& __digits) const;
# 1755 "/usr/include/c++/10.2.0/bits/locale_facets_nonio.h" 3
      template<bool _Intl>
        iter_type
        _M_insert(iter_type __s, ios_base& __io, char_type __fill,
    const string_type& __digits) const;
    };

  template<typename _CharT, typename _OutIter>
    locale::id money_put<_CharT, _OutIter>::id;

}





  struct messages_base
  {
    typedef int catalog;
  };

namespace __cxx11 {
# 1798 "/usr/include/c++/10.2.0/bits/locale_facets_nonio.h" 3
  template<typename _CharT>
    class messages : public locale::facet, public messages_base
    {
    public:



      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;


    protected:


      __c_locale _M_c_locale_messages;
      const char* _M_name_messages;

    public:

      static locale::id id;
# 1826 "/usr/include/c++/10.2.0/bits/locale_facets_nonio.h" 3
      explicit
      messages(size_t __refs = 0);
# 1840 "/usr/include/c++/10.2.0/bits/locale_facets_nonio.h" 3
      explicit
      messages(__c_locale __cloc, const char* __s, size_t __refs = 0);
# 1853 "/usr/include/c++/10.2.0/bits/locale_facets_nonio.h" 3
      catalog
      open(const basic_string<char>& __s, const locale& __loc) const
      { return this->do_open(__s, __loc); }
# 1871 "/usr/include/c++/10.2.0/bits/locale_facets_nonio.h" 3
      catalog
      open(const basic_string<char>&, const locale&, const char*) const;
# 1889 "/usr/include/c++/10.2.0/bits/locale_facets_nonio.h" 3
      string_type
      get(catalog __c, int __set, int __msgid, const string_type& __s) const
      { return this->do_get(__c, __set, __msgid, __s); }
# 1900 "/usr/include/c++/10.2.0/bits/locale_facets_nonio.h" 3
      void
      close(catalog __c) const
      { return this->do_close(__c); }

    protected:

      virtual
      ~messages();
# 1920 "/usr/include/c++/10.2.0/bits/locale_facets_nonio.h" 3
      virtual catalog
      do_open(const basic_string<char>&, const locale&) const;
# 1939 "/usr/include/c++/10.2.0/bits/locale_facets_nonio.h" 3
      virtual string_type
      do_get(catalog, int, int, const string_type& __dfault) const;






      virtual void
      do_close(catalog) const;


      char*
      _M_convert_to_char(const string_type& __msg) const
      {

 return reinterpret_cast<char*>(const_cast<_CharT*>(__msg.c_str()));
      }


      string_type
      _M_convert_from_char(char*) const
      {

 return string_type();
      }
     };

  template<typename _CharT>
    locale::id messages<_CharT>::id;


  template<>
    string
    messages<char>::do_get(catalog, int, int, const string&) const;


  template<>
    wstring
    messages<wchar_t>::do_get(catalog, int, int, const wstring&) const;



   template<typename _CharT>
    class messages_byname : public messages<_CharT>
    {
    public:
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      explicit
      messages_byname(const char* __s, size_t __refs = 0);


      explicit
      messages_byname(const string& __s, size_t __refs = 0)
      : messages_byname(__s.c_str(), __refs) { }


    protected:
      virtual
      ~messages_byname()
      { }
    };

}


}


# 1 "/usr/include/c++/10.2.0/x86_64-pc-linux-gnu/bits/messages_members.h" 1 3
# 36 "/usr/include/c++/10.2.0/x86_64-pc-linux-gnu/bits/messages_members.h" 3
# 1 "/usr/include/libintl.h" 1 3 4
# 34 "/usr/include/libintl.h" 3 4
extern "C" {




extern char *gettext (const char *__msgid)
     noexcept (true) __attribute__ ((__format_arg__ (1)));



extern char *dgettext (const char *__domainname, const char *__msgid)
     noexcept (true) __attribute__ ((__format_arg__ (2)));
extern char *__dgettext (const char *__domainname, const char *__msgid)
     noexcept (true) __attribute__ ((__format_arg__ (2)));



extern char *dcgettext (const char *__domainname,
   const char *__msgid, int __category)
     noexcept (true) __attribute__ ((__format_arg__ (2)));
extern char *__dcgettext (const char *__domainname,
     const char *__msgid, int __category)
     noexcept (true) __attribute__ ((__format_arg__ (2)));




extern char *ngettext (const char *__msgid1, const char *__msgid2,
         unsigned long int __n)
     noexcept (true) __attribute__ ((__format_arg__ (1))) __attribute__ ((__format_arg__ (2)));



extern char *dngettext (const char *__domainname, const char *__msgid1,
   const char *__msgid2, unsigned long int __n)
     noexcept (true) __attribute__ ((__format_arg__ (2))) __attribute__ ((__format_arg__ (3)));



extern char *dcngettext (const char *__domainname, const char *__msgid1,
    const char *__msgid2, unsigned long int __n,
    int __category)
     noexcept (true) __attribute__ ((__format_arg__ (2))) __attribute__ ((__format_arg__ (3)));





extern char *textdomain (const char *__domainname) noexcept (true);



extern char *bindtextdomain (const char *__domainname,
        const char *__dirname) noexcept (true);



extern char *bind_textdomain_codeset (const char *__domainname,
          const char *__codeset) noexcept (true);
# 121 "/usr/include/libintl.h" 3 4
}
# 37 "/usr/include/c++/10.2.0/x86_64-pc-linux-gnu/bits/messages_members.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{



  template<typename _CharT>
    messages<_CharT>::messages(size_t __refs)
    : facet(__refs), _M_c_locale_messages(_S_get_c_locale()),
      _M_name_messages(_S_get_c_name())
    { }

  template<typename _CharT>
    messages<_CharT>::messages(__c_locale __cloc, const char* __s,
          size_t __refs)
    : facet(__refs), _M_c_locale_messages(0), _M_name_messages(0)
    {
      if (__builtin_strcmp(__s, _S_get_c_name()) != 0)
 {
   const size_t __len = __builtin_strlen(__s) + 1;
   char* __tmp = new char[__len];
   __builtin_memcpy(__tmp, __s, __len);
   _M_name_messages = __tmp;
 }
      else
 _M_name_messages = _S_get_c_name();


      _M_c_locale_messages = _S_clone_c_locale(__cloc);
    }

  template<typename _CharT>
    typename messages<_CharT>::catalog
    messages<_CharT>::open(const basic_string<char>& __s, const locale& __loc,
      const char* __dir) const
    {
      bindtextdomain(__s.c_str(), __dir);
      return this->do_open(__s, __loc);
    }


  template<typename _CharT>
    messages<_CharT>::~messages()
    {
      if (_M_name_messages != _S_get_c_name())
 delete [] _M_name_messages;
      _S_destroy_c_locale(_M_c_locale_messages);
    }

  template<typename _CharT>
    typename messages<_CharT>::catalog
    messages<_CharT>::do_open(const basic_string<char>& __s,
         const locale&) const
    {


      textdomain(__s.c_str());
      return 0;
    }

  template<typename _CharT>
    void
    messages<_CharT>::do_close(catalog) const
    { }


  template<typename _CharT>
    messages_byname<_CharT>::messages_byname(const char* __s, size_t __refs)
    : messages<_CharT>(__refs)
    {
      if (this->_M_name_messages != locale::facet::_S_get_c_name())
 {
   delete [] this->_M_name_messages;
   if (__builtin_strcmp(__s, locale::facet::_S_get_c_name()) != 0)
     {
       const size_t __len = __builtin_strlen(__s) + 1;
       char* __tmp = new char[__len];
       __builtin_memcpy(__tmp, __s, __len);
       this->_M_name_messages = __tmp;
     }
   else
     this->_M_name_messages = locale::facet::_S_get_c_name();
 }

      if (__builtin_strcmp(__s, "C") != 0
   && __builtin_strcmp(__s, "POSIX") != 0)
 {
   this->_S_destroy_c_locale(this->_M_c_locale_messages);
   this->_S_create_c_locale(this->_M_c_locale_messages, __s);
 }
    }


  template<>
    typename messages<char>::catalog
    messages<char>::do_open(const basic_string<char>&,
       const locale&) const;

  template<>
    void
    messages<char>::do_close(catalog) const;


  template<>
    typename messages<wchar_t>::catalog
    messages<wchar_t>::do_open(const basic_string<char>&,
          const locale&) const;

  template<>
    void
    messages<wchar_t>::do_close(catalog) const;



}
# 2011 "/usr/include/c++/10.2.0/bits/locale_facets_nonio.h" 2 3


# 1 "/usr/include/c++/10.2.0/bits/codecvt.h" 1 3
# 39 "/usr/include/c++/10.2.0/bits/codecvt.h" 3
       
# 40 "/usr/include/c++/10.2.0/bits/codecvt.h" 3

namespace std __attribute__ ((__visibility__ ("default")))
{



  class codecvt_base
  {
  public:
    enum result
    {
      ok,
      partial,
      error,
      noconv
    };
  };
# 67 "/usr/include/c++/10.2.0/bits/codecvt.h" 3
  template<typename _InternT, typename _ExternT, typename _StateT>
    class __codecvt_abstract_base
    : public locale::facet, public codecvt_base
    {
    public:

      typedef codecvt_base::result result;
      typedef _InternT intern_type;
      typedef _ExternT extern_type;
      typedef _StateT state_type;
# 115 "/usr/include/c++/10.2.0/bits/codecvt.h" 3
      result
      out(state_type& __state, const intern_type* __from,
   const intern_type* __from_end, const intern_type*& __from_next,
   extern_type* __to, extern_type* __to_end,
   extern_type*& __to_next) const
      {
 return this->do_out(__state, __from, __from_end, __from_next,
       __to, __to_end, __to_next);
      }
# 154 "/usr/include/c++/10.2.0/bits/codecvt.h" 3
      result
      unshift(state_type& __state, extern_type* __to, extern_type* __to_end,
       extern_type*& __to_next) const
      { return this->do_unshift(__state, __to,__to_end,__to_next); }
# 195 "/usr/include/c++/10.2.0/bits/codecvt.h" 3
      result
      in(state_type& __state, const extern_type* __from,
  const extern_type* __from_end, const extern_type*& __from_next,
  intern_type* __to, intern_type* __to_end,
  intern_type*& __to_next) const
      {
 return this->do_in(__state, __from, __from_end, __from_next,
      __to, __to_end, __to_next);
      }

      int
      encoding() const throw()
      { return this->do_encoding(); }

      bool
      always_noconv() const throw()
      { return this->do_always_noconv(); }

      int
      length(state_type& __state, const extern_type* __from,
      const extern_type* __end, size_t __max) const
      { return this->do_length(__state, __from, __end, __max); }

      int
      max_length() const throw()
      { return this->do_max_length(); }

    protected:
      explicit
      __codecvt_abstract_base(size_t __refs = 0) : locale::facet(__refs) { }

      virtual
      ~__codecvt_abstract_base() { }
# 236 "/usr/include/c++/10.2.0/bits/codecvt.h" 3
      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const = 0;

      virtual result
      do_unshift(state_type& __state, extern_type* __to,
   extern_type* __to_end, extern_type*& __to_next) const = 0;

      virtual result
      do_in(state_type& __state, const extern_type* __from,
     const extern_type* __from_end, const extern_type*& __from_next,
     intern_type* __to, intern_type* __to_end,
     intern_type*& __to_next) const = 0;

      virtual int
      do_encoding() const throw() = 0;

      virtual bool
      do_always_noconv() const throw() = 0;

      virtual int
      do_length(state_type&, const extern_type* __from,
  const extern_type* __end, size_t __max) const = 0;

      virtual int
      do_max_length() const throw() = 0;
    };
# 273 "/usr/include/c++/10.2.0/bits/codecvt.h" 3
   template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt
    : public __codecvt_abstract_base<_InternT, _ExternT, _StateT>
    {
    public:

      typedef codecvt_base::result result;
      typedef _InternT intern_type;
      typedef _ExternT extern_type;
      typedef _StateT state_type;

    protected:
      __c_locale _M_c_locale_codecvt;

    public:
      static locale::id id;

      explicit
      codecvt(size_t __refs = 0)
      : __codecvt_abstract_base<_InternT, _ExternT, _StateT> (__refs),
 _M_c_locale_codecvt(0)
      { }

      explicit
      codecvt(__c_locale __cloc, size_t __refs = 0);

    protected:
      virtual
      ~codecvt() { }

      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const;

      virtual result
      do_unshift(state_type& __state, extern_type* __to,
   extern_type* __to_end, extern_type*& __to_next) const;

      virtual result
      do_in(state_type& __state, const extern_type* __from,
     const extern_type* __from_end, const extern_type*& __from_next,
     intern_type* __to, intern_type* __to_end,
     intern_type*& __to_next) const;

      virtual int
      do_encoding() const throw();

      virtual bool
      do_always_noconv() const throw();

      virtual int
      do_length(state_type&, const extern_type* __from,
  const extern_type* __end, size_t __max) const;

      virtual int
      do_max_length() const throw();
    };

  template<typename _InternT, typename _ExternT, typename _StateT>
    locale::id codecvt<_InternT, _ExternT, _StateT>::id;


  template<>
    class codecvt<char, char, mbstate_t>
    : public __codecvt_abstract_base<char, char, mbstate_t>
    {
      friend class messages<char>;

    public:

      typedef char intern_type;
      typedef char extern_type;
      typedef mbstate_t state_type;

    protected:
      __c_locale _M_c_locale_codecvt;

    public:
      static locale::id id;

      explicit
      codecvt(size_t __refs = 0);

      explicit
      codecvt(__c_locale __cloc, size_t __refs = 0);

    protected:
      virtual
      ~codecvt();

      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const;

      virtual result
      do_unshift(state_type& __state, extern_type* __to,
   extern_type* __to_end, extern_type*& __to_next) const;

      virtual result
      do_in(state_type& __state, const extern_type* __from,
     const extern_type* __from_end, const extern_type*& __from_next,
     intern_type* __to, intern_type* __to_end,
     intern_type*& __to_next) const;

      virtual int
      do_encoding() const throw();

      virtual bool
      do_always_noconv() const throw();

      virtual int
      do_length(state_type&, const extern_type* __from,
  const extern_type* __end, size_t __max) const;

      virtual int
      do_max_length() const throw();
  };






  template<>
    class codecvt<wchar_t, char, mbstate_t>
    : public __codecvt_abstract_base<wchar_t, char, mbstate_t>
    {
      friend class messages<wchar_t>;

    public:

      typedef wchar_t intern_type;
      typedef char extern_type;
      typedef mbstate_t state_type;

    protected:
      __c_locale _M_c_locale_codecvt;

    public:
      static locale::id id;

      explicit
      codecvt(size_t __refs = 0);

      explicit
      codecvt(__c_locale __cloc, size_t __refs = 0);

    protected:
      virtual
      ~codecvt();

      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const;

      virtual result
      do_unshift(state_type& __state,
   extern_type* __to, extern_type* __to_end,
   extern_type*& __to_next) const;

      virtual result
      do_in(state_type& __state,
      const extern_type* __from, const extern_type* __from_end,
      const extern_type*& __from_next,
      intern_type* __to, intern_type* __to_end,
      intern_type*& __to_next) const;

      virtual
      int do_encoding() const throw();

      virtual
      bool do_always_noconv() const throw();

      virtual
      int do_length(state_type&, const extern_type* __from,
      const extern_type* __end, size_t __max) const;

      virtual int
      do_max_length() const throw();
    };







  template<>
    class codecvt<char16_t, char, mbstate_t>
    : public __codecvt_abstract_base<char16_t, char, mbstate_t>
    {
    public:

      typedef char16_t intern_type;
      typedef char extern_type;
      typedef mbstate_t state_type;

    public:
      static locale::id id;

      explicit
      codecvt(size_t __refs = 0)
      : __codecvt_abstract_base<char16_t, char, mbstate_t>(__refs) { }

    protected:
      virtual
      ~codecvt();

      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const;

      virtual result
      do_unshift(state_type& __state,
   extern_type* __to, extern_type* __to_end,
   extern_type*& __to_next) const;

      virtual result
      do_in(state_type& __state,
      const extern_type* __from, const extern_type* __from_end,
      const extern_type*& __from_next,
      intern_type* __to, intern_type* __to_end,
      intern_type*& __to_next) const;

      virtual
      int do_encoding() const throw();

      virtual
      bool do_always_noconv() const throw();

      virtual
      int do_length(state_type&, const extern_type* __from,
      const extern_type* __end, size_t __max) const;

      virtual int
      do_max_length() const throw();
    };





  template<>
    class codecvt<char32_t, char, mbstate_t>
    : public __codecvt_abstract_base<char32_t, char, mbstate_t>
    {
    public:

      typedef char32_t intern_type;
      typedef char extern_type;
      typedef mbstate_t state_type;

    public:
      static locale::id id;

      explicit
      codecvt(size_t __refs = 0)
      : __codecvt_abstract_base<char32_t, char, mbstate_t>(__refs) { }

    protected:
      virtual
      ~codecvt();

      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const;

      virtual result
      do_unshift(state_type& __state,
   extern_type* __to, extern_type* __to_end,
   extern_type*& __to_next) const;

      virtual result
      do_in(state_type& __state,
      const extern_type* __from, const extern_type* __from_end,
      const extern_type*& __from_next,
      intern_type* __to, intern_type* __to_end,
      intern_type*& __to_next) const;

      virtual
      int do_encoding() const throw();

      virtual
      bool do_always_noconv() const throw();

      virtual
      int do_length(state_type&, const extern_type* __from,
      const extern_type* __end, size_t __max) const;

      virtual int
      do_max_length() const throw();
    };
# 695 "/usr/include/c++/10.2.0/bits/codecvt.h" 3
  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt_byname : public codecvt<_InternT, _ExternT, _StateT>
    {
    public:
      explicit
      codecvt_byname(const char* __s, size_t __refs = 0)
      : codecvt<_InternT, _ExternT, _StateT>(__refs)
      {
 if (__builtin_strcmp(__s, "C") != 0
     && __builtin_strcmp(__s, "POSIX") != 0)
   {
     this->_S_destroy_c_locale(this->_M_c_locale_codecvt);
     this->_S_create_c_locale(this->_M_c_locale_codecvt, __s);
   }
      }


      explicit
      codecvt_byname(const string& __s, size_t __refs = 0)
      : codecvt_byname(__s.c_str(), __refs) { }


    protected:
      virtual
      ~codecvt_byname() { }
    };


  template<>
    class codecvt_byname<char16_t, char, mbstate_t>
    : public codecvt<char16_t, char, mbstate_t>
    {
    public:
      explicit
      codecvt_byname(const char*, size_t __refs = 0)
      : codecvt<char16_t, char, mbstate_t>(__refs) { }

      explicit
      codecvt_byname(const string& __s, size_t __refs = 0)
      : codecvt_byname(__s.c_str(), __refs) { }

    protected:
      virtual
      ~codecvt_byname() { }
    };

  template<>
    class codecvt_byname<char32_t, char, mbstate_t>
    : public codecvt<char32_t, char, mbstate_t>
    {
    public:
      explicit
      codecvt_byname(const char*, size_t __refs = 0)
      : codecvt<char32_t, char, mbstate_t>(__refs) { }

      explicit
      codecvt_byname(const string& __s, size_t __refs = 0)
      : codecvt_byname(__s.c_str(), __refs) { }

    protected:
      virtual
      ~codecvt_byname() { }
    };
# 802 "/usr/include/c++/10.2.0/bits/codecvt.h" 3
  extern template class codecvt_byname<char, char, mbstate_t>;

  extern template
    const codecvt<char, char, mbstate_t>&
    use_facet<codecvt<char, char, mbstate_t> >(const locale&);

  extern template
    bool
    has_facet<codecvt<char, char, mbstate_t> >(const locale&);


  extern template class codecvt_byname<wchar_t, char, mbstate_t>;

  extern template
    const codecvt<wchar_t, char, mbstate_t>&
    use_facet<codecvt<wchar_t, char, mbstate_t> >(const locale&);

  extern template
    bool
    has_facet<codecvt<wchar_t, char, mbstate_t> >(const locale&);



  extern template class codecvt_byname<char16_t, char, mbstate_t>;
  extern template class codecvt_byname<char32_t, char, mbstate_t>;
# 837 "/usr/include/c++/10.2.0/bits/codecvt.h" 3

}
# 2014 "/usr/include/c++/10.2.0/bits/locale_facets_nonio.h" 2 3

# 1 "/usr/include/c++/10.2.0/bits/locale_facets_nonio.tcc" 1 3
# 33 "/usr/include/c++/10.2.0/bits/locale_facets_nonio.tcc" 3
       
# 34 "/usr/include/c++/10.2.0/bits/locale_facets_nonio.tcc" 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, bool _Intl>
    struct __use_cache<__moneypunct_cache<_CharT, _Intl> >
    {
      const __moneypunct_cache<_CharT, _Intl>*
      operator() (const locale& __loc) const
      {
 const size_t __i = moneypunct<_CharT, _Intl>::id._M_id();
 const locale::facet** __caches = __loc._M_impl->_M_caches;
 if (!__caches[__i])
   {
     __moneypunct_cache<_CharT, _Intl>* __tmp = 0;
     try
       {
  __tmp = new __moneypunct_cache<_CharT, _Intl>;
  __tmp->_M_cache(__loc);
       }
     catch(...)
       {
  delete __tmp;
  throw;
       }
     __loc._M_impl->_M_install_cache(__tmp, __i);
   }
 return static_cast<
   const __moneypunct_cache<_CharT, _Intl>*>(__caches[__i]);
      }
    };

  template<typename _CharT, bool _Intl>
    void
    __moneypunct_cache<_CharT, _Intl>::_M_cache(const locale& __loc)
    {
      const moneypunct<_CharT, _Intl>& __mp =
 use_facet<moneypunct<_CharT, _Intl> >(__loc);

      _M_decimal_point = __mp.decimal_point();
      _M_thousands_sep = __mp.thousands_sep();
      _M_frac_digits = __mp.frac_digits();

      char* __grouping = 0;
      _CharT* __curr_symbol = 0;
      _CharT* __positive_sign = 0;
      _CharT* __negative_sign = 0;
      try
 {
   const string& __g = __mp.grouping();
   _M_grouping_size = __g.size();
   __grouping = new char[_M_grouping_size];
   __g.copy(__grouping, _M_grouping_size);
   _M_use_grouping = (_M_grouping_size
        && static_cast<signed char>(__grouping[0]) > 0
        && (__grouping[0]
     != __gnu_cxx::__numeric_traits<char>::__max));

   const basic_string<_CharT>& __cs = __mp.curr_symbol();
   _M_curr_symbol_size = __cs.size();
   __curr_symbol = new _CharT[_M_curr_symbol_size];
   __cs.copy(__curr_symbol, _M_curr_symbol_size);

   const basic_string<_CharT>& __ps = __mp.positive_sign();
   _M_positive_sign_size = __ps.size();
   __positive_sign = new _CharT[_M_positive_sign_size];
   __ps.copy(__positive_sign, _M_positive_sign_size);

   const basic_string<_CharT>& __ns = __mp.negative_sign();
   _M_negative_sign_size = __ns.size();
   __negative_sign = new _CharT[_M_negative_sign_size];
   __ns.copy(__negative_sign, _M_negative_sign_size);

   _M_pos_format = __mp.pos_format();
   _M_neg_format = __mp.neg_format();

   const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__loc);
   __ct.widen(money_base::_S_atoms,
       money_base::_S_atoms + money_base::_S_end, _M_atoms);

   _M_grouping = __grouping;
   _M_curr_symbol = __curr_symbol;
   _M_positive_sign = __positive_sign;
   _M_negative_sign = __negative_sign;
   _M_allocated = true;
 }
      catch(...)
 {
   delete [] __grouping;
   delete [] __curr_symbol;
   delete [] __positive_sign;
   delete [] __negative_sign;
   throw;
 }
    }

namespace __cxx11 {

  template<typename _CharT, typename _InIter>
    template<bool _Intl>
      _InIter
      money_get<_CharT, _InIter>::
      _M_extract(iter_type __beg, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, string& __units) const
      {
 typedef char_traits<_CharT> __traits_type;
 typedef typename string_type::size_type size_type;
 typedef money_base::part part;
 typedef __moneypunct_cache<_CharT, _Intl> __cache_type;

 const locale& __loc = __io._M_getloc();
 const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

 __use_cache<__cache_type> __uc;
 const __cache_type* __lc = __uc(__loc);
 const char_type* __lit = __lc->_M_atoms;


 bool __negative = false;

 size_type __sign_size = 0;

 const bool __mandatory_sign = (__lc->_M_positive_sign_size
           && __lc->_M_negative_sign_size);

 string __grouping_tmp;
 if (__lc->_M_use_grouping)
   __grouping_tmp.reserve(32);

 int __last_pos = 0;

 int __n = 0;

 bool __testvalid = true;

 bool __testdecfound = false;


 string __res;
 __res.reserve(32);

 const char_type* __lit_zero = __lit + money_base::_S_zero;
 const money_base::pattern __p = __lc->_M_neg_format;
 for (int __i = 0; __i < 4 && __testvalid; ++__i)
   {
     const part __which = static_cast<part>(__p.field[__i]);
     switch (__which)
       {
       case money_base::symbol:




  if (__io.flags() & ios_base::showbase || __sign_size > 1
      || __i == 0
      || (__i == 1 && (__mandatory_sign
         || (static_cast<part>(__p.field[0])
      == money_base::sign)
         || (static_cast<part>(__p.field[2])
      == money_base::space)))
      || (__i == 2 && ((static_cast<part>(__p.field[3])
          == money_base::value)
         || (__mandatory_sign
      && (static_cast<part>(__p.field[3])
          == money_base::sign)))))
    {
      const size_type __len = __lc->_M_curr_symbol_size;
      size_type __j = 0;
      for (; __beg != __end && __j < __len
      && *__beg == __lc->_M_curr_symbol[__j];
    ++__beg, (void)++__j);
      if (__j != __len
   && (__j || __io.flags() & ios_base::showbase))
        __testvalid = false;
    }
  break;
       case money_base::sign:

  if (__lc->_M_positive_sign_size && __beg != __end
      && *__beg == __lc->_M_positive_sign[0])
    {
      __sign_size = __lc->_M_positive_sign_size;
      ++__beg;
    }
  else if (__lc->_M_negative_sign_size && __beg != __end
    && *__beg == __lc->_M_negative_sign[0])
    {
      __negative = true;
      __sign_size = __lc->_M_negative_sign_size;
      ++__beg;
    }
  else if (__lc->_M_positive_sign_size
    && !__lc->_M_negative_sign_size)


    __negative = true;
  else if (__mandatory_sign)
    __testvalid = false;
  break;
       case money_base::value:


  for (; __beg != __end; ++__beg)
    {
      const char_type __c = *__beg;
      const char_type* __q = __traits_type::find(__lit_zero,
              10, __c);
      if (__q != 0)
        {
   __res += money_base::_S_atoms[__q - __lit];
   ++__n;
        }
      else if (__c == __lc->_M_decimal_point
        && !__testdecfound)
        {
   if (__lc->_M_frac_digits <= 0)
     break;

   __last_pos = __n;
   __n = 0;
   __testdecfound = true;
        }
      else if (__lc->_M_use_grouping
        && __c == __lc->_M_thousands_sep
        && !__testdecfound)
        {
   if (__n)
     {

       __grouping_tmp += static_cast<char>(__n);
       __n = 0;
     }
   else
     {
       __testvalid = false;
       break;
     }
        }
      else
        break;
    }
  if (__res.empty())
    __testvalid = false;
  break;
       case money_base::space:

  if (__beg != __end && __ctype.is(ctype_base::space, *__beg))
    ++__beg;
  else
    __testvalid = false;

       case money_base::none:

  if (__i != 3)
    for (; __beg != __end
    && __ctype.is(ctype_base::space, *__beg); ++__beg);
  break;
       }
   }


 if (__sign_size > 1 && __testvalid)
   {
     const char_type* __sign = __negative ? __lc->_M_negative_sign
                                          : __lc->_M_positive_sign;
     size_type __i = 1;
     for (; __beg != __end && __i < __sign_size
     && *__beg == __sign[__i]; ++__beg, (void)++__i);

     if (__i != __sign_size)
       __testvalid = false;
   }

 if (__testvalid)
   {

     if (__res.size() > 1)
       {
  const size_type __first = __res.find_first_not_of('0');
  const bool __only_zeros = __first == string::npos;
  if (__first)
    __res.erase(0, __only_zeros ? __res.size() - 1 : __first);
       }


     if (__negative && __res[0] != '0')
       __res.insert(__res.begin(), '-');


     if (__grouping_tmp.size())
       {

  __grouping_tmp += static_cast<char>(__testdecfound ? __last_pos
                         : __n);
  if (!std::__verify_grouping(__lc->_M_grouping,
         __lc->_M_grouping_size,
         __grouping_tmp))
    __err |= ios_base::failbit;
       }


     if (__testdecfound && __n != __lc->_M_frac_digits)
       __testvalid = false;
   }


 if (!__testvalid)
   __err |= ios_base::failbit;
 else
   __units.swap(__res);


 if (__beg == __end)
   __err |= ios_base::eofbit;
 return __beg;
      }
# 368 "/usr/include/c++/10.2.0/bits/locale_facets_nonio.tcc" 3
  template<typename _CharT, typename _InIter>
    _InIter
    money_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, bool __intl, ios_base& __io,
    ios_base::iostate& __err, long double& __units) const
    {
      string __str;
      __beg = __intl ? _M_extract<true>(__beg, __end, __io, __err, __str)
              : _M_extract<false>(__beg, __end, __io, __err, __str);
      std::__convert_to_v(__str.c_str(), __units, __err, _S_get_c_locale());
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    money_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, bool __intl, ios_base& __io,
    ios_base::iostate& __err, string_type& __digits) const
    {
      typedef typename string::size_type size_type;

      const locale& __loc = __io._M_getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

      string __str;
      __beg = __intl ? _M_extract<true>(__beg, __end, __io, __err, __str)
              : _M_extract<false>(__beg, __end, __io, __err, __str);
      const size_type __len = __str.size();
      if (__len)
 {
   __digits.resize(__len);
   __ctype.widen(__str.data(), __str.data() + __len, &__digits[0]);
 }
      return __beg;
    }

  template<typename _CharT, typename _OutIter>
    template<bool _Intl>
      _OutIter
      money_put<_CharT, _OutIter>::
      _M_insert(iter_type __s, ios_base& __io, char_type __fill,
  const string_type& __digits) const
      {
 typedef typename string_type::size_type size_type;
 typedef money_base::part part;
 typedef __moneypunct_cache<_CharT, _Intl> __cache_type;

 const locale& __loc = __io._M_getloc();
 const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

 __use_cache<__cache_type> __uc;
 const __cache_type* __lc = __uc(__loc);
 const char_type* __lit = __lc->_M_atoms;



 const char_type* __beg = __digits.data();

 money_base::pattern __p;
 const char_type* __sign;
 size_type __sign_size;
 if (!(*__beg == __lit[money_base::_S_minus]))
   {
     __p = __lc->_M_pos_format;
     __sign = __lc->_M_positive_sign;
     __sign_size = __lc->_M_positive_sign_size;
   }
 else
   {
     __p = __lc->_M_neg_format;
     __sign = __lc->_M_negative_sign;
     __sign_size = __lc->_M_negative_sign_size;
     if (__digits.size())
       ++__beg;
   }


 size_type __len = __ctype.scan_not(ctype_base::digit, __beg,
        __beg + __digits.size()) - __beg;
 if (__len)
   {



     string_type __value;
     __value.reserve(2 * __len);



     long __paddec = __len - __lc->_M_frac_digits;
     if (__paddec > 0)
         {
  if (__lc->_M_frac_digits < 0)
    __paddec = __len;
    if (__lc->_M_grouping_size)
      {
      __value.assign(2 * __paddec, char_type());
       _CharT* __vend =
        std::__add_grouping(&__value[0], __lc->_M_thousands_sep,
       __lc->_M_grouping,
       __lc->_M_grouping_size,
       __beg, __beg + __paddec);
      __value.erase(__vend - &__value[0]);
      }
    else
    __value.assign(__beg, __paddec);
       }


     if (__lc->_M_frac_digits > 0)
       {
  __value += __lc->_M_decimal_point;
  if (__paddec >= 0)
    __value.append(__beg + __paddec, __lc->_M_frac_digits);
  else
    {

      __value.append(-__paddec, __lit[money_base::_S_zero]);
      __value.append(__beg, __len);
    }
         }


     const ios_base::fmtflags __f = __io.flags()
                                    & ios_base::adjustfield;
     __len = __value.size() + __sign_size;
     __len += ((__io.flags() & ios_base::showbase)
        ? __lc->_M_curr_symbol_size : 0);

     string_type __res;
     __res.reserve(2 * __len);

     const size_type __width = static_cast<size_type>(__io.width());
     const bool __testipad = (__f == ios_base::internal
         && __len < __width);

     for (int __i = 0; __i < 4; ++__i)
       {
  const part __which = static_cast<part>(__p.field[__i]);
  switch (__which)
    {
    case money_base::symbol:
      if (__io.flags() & ios_base::showbase)
        __res.append(__lc->_M_curr_symbol,
       __lc->_M_curr_symbol_size);
      break;
    case money_base::sign:



      if (__sign_size)
        __res += __sign[0];
      break;
    case money_base::value:
      __res += __value;
      break;
    case money_base::space:



      if (__testipad)
        __res.append(__width - __len, __fill);
      else
        __res += __fill;
      break;
    case money_base::none:
      if (__testipad)
        __res.append(__width - __len, __fill);
      break;
    }
       }


     if (__sign_size > 1)
       __res.append(__sign + 1, __sign_size - 1);


     __len = __res.size();
     if (__width > __len)
       {
  if (__f == ios_base::left)

    __res.append(__width - __len, __fill);
  else

    __res.insert(0, __width - __len, __fill);
  __len = __width;
       }


     __s = std::__write(__s, __res.data(), __len);
   }
 __io.width(0);
 return __s;
      }
# 574 "/usr/include/c++/10.2.0/bits/locale_facets_nonio.tcc" 3
  template<typename _CharT, typename _OutIter>
    _OutIter
    money_put<_CharT, _OutIter>::
    do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,
    long double __units) const
    {
      const locale __loc = __io.getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);


      int __cs_size = 64;
      char* __cs = static_cast<char*>(__builtin_alloca(__cs_size));


      int __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
     "%.*Lf", 0, __units);

      if (__len >= __cs_size)
 {
   __cs_size = __len + 1;
   __cs = static_cast<char*>(__builtin_alloca(__cs_size));
   __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
     "%.*Lf", 0, __units);
 }
# 606 "/usr/include/c++/10.2.0/bits/locale_facets_nonio.tcc" 3
      string_type __digits(__len, char_type());
      __ctype.widen(__cs, __cs + __len, &__digits[0]);
      return __intl ? _M_insert<true>(__s, __io, __fill, __digits)
             : _M_insert<false>(__s, __io, __fill, __digits);
    }

  template<typename _CharT, typename _OutIter>
    _OutIter
    money_put<_CharT, _OutIter>::
    do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,
    const string_type& __digits) const
    { return __intl ? _M_insert<true>(__s, __io, __fill, __digits)
             : _M_insert<false>(__s, __io, __fill, __digits); }

}




  template<typename _CharT, typename _InIter>
    time_base::dateorder
    time_get<_CharT, _InIter>::do_date_order() const
    { return time_base::no_order; }



  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    _M_extract_via_format(iter_type __beg, iter_type __end, ios_base& __io,
     ios_base::iostate& __err, tm* __tm,
     const _CharT* __format) const
    {
      const locale& __loc = __io._M_getloc();
      const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
      const size_t __len = char_traits<_CharT>::length(__format);

      ios_base::iostate __tmperr = ios_base::goodbit;
      size_t __i = 0;
      for (; __beg != __end && __i < __len && !__tmperr; ++__i)
 {
   if (__ctype.narrow(__format[__i], 0) == '%')
     {

       char __c = __ctype.narrow(__format[++__i], 0);
       int __mem = 0;
       if (__c == 'E' || __c == 'O')
  __c = __ctype.narrow(__format[++__i], 0);
       switch (__c)
  {
    const char* __cs;
    _CharT __wcs[10];
  case 'a':

    const char_type* __days1[7];
    __tp._M_days_abbreviated(__days1);
    __beg = _M_extract_name(__beg, __end, __mem, __days1,
       7, __io, __tmperr);
    if (!__tmperr)
      __tm->tm_wday = __mem;
    break;
  case 'A':

    const char_type* __days2[7];
    __tp._M_days(__days2);
    __beg = _M_extract_name(__beg, __end, __mem, __days2,
       7, __io, __tmperr);
    if (!__tmperr)
      __tm->tm_wday = __mem;
    break;
  case 'h':
  case 'b':

    const char_type* __months1[12];
    __tp._M_months_abbreviated(__months1);
    __beg = _M_extract_name(__beg, __end, __mem,
       __months1, 12, __io, __tmperr);
    if (!__tmperr)
      __tm->tm_mon = __mem;
    break;
  case 'B':

    const char_type* __months2[12];
    __tp._M_months(__months2);
    __beg = _M_extract_name(__beg, __end, __mem,
       __months2, 12, __io, __tmperr);
    if (!__tmperr)
      __tm->tm_mon = __mem;
    break;
  case 'c':

    const char_type* __dt[2];
    __tp._M_date_time_formats(__dt);
    __beg = _M_extract_via_format(__beg, __end, __io, __tmperr,
      __tm, __dt[0]);
    break;
  case 'd':

    __beg = _M_extract_num(__beg, __end, __mem, 1, 31, 2,
      __io, __tmperr);
    if (!__tmperr)
      __tm->tm_mday = __mem;
    break;
  case 'e':


    if (__ctype.is(ctype_base::space, *__beg))
      __beg = _M_extract_num(++__beg, __end, __mem, 1, 9,
        1, __io, __tmperr);
    else
      __beg = _M_extract_num(__beg, __end, __mem, 10, 31,
        2, __io, __tmperr);
    if (!__tmperr)
      __tm->tm_mday = __mem;
    break;
  case 'D':

    __cs = "%m/%d/%y";
    __ctype.widen(__cs, __cs + 9, __wcs);
    __beg = _M_extract_via_format(__beg, __end, __io, __tmperr,
      __tm, __wcs);
    break;
  case 'H':

    __beg = _M_extract_num(__beg, __end, __mem, 0, 23, 2,
      __io, __tmperr);
    if (!__tmperr)
      __tm->tm_hour = __mem;
    break;
  case 'I':

    __beg = _M_extract_num(__beg, __end, __mem, 1, 12, 2,
      __io, __tmperr);
    if (!__tmperr)
      __tm->tm_hour = __mem;
    break;
  case 'm':

    __beg = _M_extract_num(__beg, __end, __mem, 1, 12, 2,
      __io, __tmperr);
    if (!__tmperr)
      __tm->tm_mon = __mem - 1;
    break;
  case 'M':

    __beg = _M_extract_num(__beg, __end, __mem, 0, 59, 2,
      __io, __tmperr);
    if (!__tmperr)
      __tm->tm_min = __mem;
    break;
  case 'n':
    if (__ctype.narrow(*__beg, 0) == '\n')
      ++__beg;
    else
      __tmperr |= ios_base::failbit;
    break;
  case 'R':

    __cs = "%H:%M";
    __ctype.widen(__cs, __cs + 6, __wcs);
    __beg = _M_extract_via_format(__beg, __end, __io, __tmperr,
      __tm, __wcs);
    break;
  case 'S':



    __beg = _M_extract_num(__beg, __end, __mem, 0, 60, 2,



      __io, __tmperr);
    if (!__tmperr)
    __tm->tm_sec = __mem;
    break;
  case 't':
    if (__ctype.narrow(*__beg, 0) == '\t')
      ++__beg;
    else
      __tmperr |= ios_base::failbit;
    break;
  case 'T':

    __cs = "%H:%M:%S";
    __ctype.widen(__cs, __cs + 9, __wcs);
    __beg = _M_extract_via_format(__beg, __end, __io, __tmperr,
      __tm, __wcs);
    break;
  case 'x':

    const char_type* __dates[2];
    __tp._M_date_formats(__dates);
    __beg = _M_extract_via_format(__beg, __end, __io, __tmperr,
      __tm, __dates[0]);
    break;
  case 'X':

    const char_type* __times[2];
    __tp._M_time_formats(__times);
    __beg = _M_extract_via_format(__beg, __end, __io, __tmperr,
      __tm, __times[0]);
    break;
  case 'y':
  case 'C':

  case 'Y':




    __beg = _M_extract_num(__beg, __end, __mem, 0, 9999, 4,
      __io, __tmperr);
    if (!__tmperr)
      __tm->tm_year = __mem < 0 ? __mem + 100 : __mem - 1900;
    break;
  case 'Z':

    if (__ctype.is(ctype_base::upper, *__beg))
      {
        int __tmp;
        __beg = _M_extract_name(__beg, __end, __tmp,
           __timepunct_cache<_CharT>::_S_timezones,
           14, __io, __tmperr);


        if (__beg != __end && !__tmperr && __tmp == 0
     && (*__beg == __ctype.widen('-')
         || *__beg == __ctype.widen('+')))
   {
     __beg = _M_extract_num(__beg, __end, __tmp, 0, 23, 2,
       __io, __tmperr);
     __beg = _M_extract_num(__beg, __end, __tmp, 0, 59, 2,
       __io, __tmperr);
   }
      }
    else
      __tmperr |= ios_base::failbit;
    break;
  default:

    __tmperr |= ios_base::failbit;
  }
     }
   else
     {

       if (__format[__i] == *__beg)
  ++__beg;
       else
  __tmperr |= ios_base::failbit;
     }
 }

      if (__tmperr || __i != __len)
 __err |= ios_base::failbit;

      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    _M_extract_num(iter_type __beg, iter_type __end, int& __member,
     int __min, int __max, size_t __len,
     ios_base& __io, ios_base::iostate& __err) const
    {
      const locale& __loc = __io._M_getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);


      int __mult = __len == 2 ? 10 : (__len == 4 ? 1000 : 1);

      ++__min;
      size_t __i = 0;
      int __value = 0;
      for (; __beg != __end && __i < __len; ++__beg, (void)++__i)
 {
   const char __c = __ctype.narrow(*__beg, '*');
   if (__c >= '0' && __c <= '9')
     {
       __value = __value * 10 + (__c - '0');
       const int __valuec = __value * __mult;
       if (__valuec > __max || __valuec + __mult < __min)
  break;
       __mult /= 10;
     }
   else
     break;
 }
      if (__i == __len)
 __member = __value;

      else if (__len == 4 && __i == 2)
 __member = __value - 100;
      else
 __err |= ios_base::failbit;

      return __beg;
    }



  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    _M_extract_name(iter_type __beg, iter_type __end, int& __member,
      const _CharT** __names, size_t __indexlen,
      ios_base& __io, ios_base::iostate& __err) const
    {
      typedef char_traits<_CharT> __traits_type;
      const locale& __loc = __io._M_getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

      int* __matches = static_cast<int*>(__builtin_alloca(sizeof(int)
         * __indexlen));
      size_t __nmatches = 0;
      size_t __pos = 0;
      bool __testvalid = true;
      const char_type* __name;





      if (__beg != __end)
 {
   const char_type __c = *__beg;
   for (size_t __i1 = 0; __i1 < __indexlen; ++__i1)
     if (__c == __names[__i1][0]
  || __c == __ctype.toupper(__names[__i1][0]))
       __matches[__nmatches++] = __i1;
 }

      while (__nmatches > 1)
 {

   size_t __minlen = __traits_type::length(__names[__matches[0]]);
   for (size_t __i2 = 1; __i2 < __nmatches; ++__i2)
     __minlen = std::min(__minlen,
         __traits_type::length(__names[__matches[__i2]]));
   ++__beg;
   ++__pos;
   if (__pos < __minlen && __beg != __end)
     for (size_t __i3 = 0; __i3 < __nmatches;)
       {
  __name = __names[__matches[__i3]];
  if (!(__name[__pos] == *__beg))
    __matches[__i3] = __matches[--__nmatches];
  else
    ++__i3;
       }
   else
     break;
 }

      if (__nmatches == 1)
 {

   ++__beg;
   ++__pos;
   __name = __names[__matches[0]];
   const size_t __len = __traits_type::length(__name);
   while (__pos < __len && __beg != __end && __name[__pos] == *__beg)
     ++__beg, (void)++__pos;

   if (__len == __pos)
     __member = __matches[0];
   else
     __testvalid = false;
 }
      else
 __testvalid = false;
      if (!__testvalid)
 __err |= ios_base::failbit;

      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    _M_extract_wday_or_month(iter_type __beg, iter_type __end, int& __member,
        const _CharT** __names, size_t __indexlen,
        ios_base& __io, ios_base::iostate& __err) const
    {
      typedef char_traits<_CharT> __traits_type;
      const locale& __loc = __io._M_getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

      int* __matches = static_cast<int*>(__builtin_alloca(2 * sizeof(int)
         * __indexlen));
      size_t __nmatches = 0;
      size_t* __matches_lengths = 0;
      size_t __pos = 0;

      if (__beg != __end)
 {
   const char_type __c = *__beg;
   for (size_t __i = 0; __i < 2 * __indexlen; ++__i)
     if (__c == __names[__i][0]
  || __c == __ctype.toupper(__names[__i][0]))
       __matches[__nmatches++] = __i;
 }

      if (__nmatches)
 {
   ++__beg;
   ++__pos;

   __matches_lengths
     = static_cast<size_t*>(__builtin_alloca(sizeof(size_t)
          * __nmatches));
   for (size_t __i = 0; __i < __nmatches; ++__i)
     __matches_lengths[__i]
       = __traits_type::length(__names[__matches[__i]]);
 }

      for (; __beg != __end; ++__beg, (void)++__pos)
 {
   size_t __nskipped = 0;
   const char_type __c = *__beg;
   for (size_t __i = 0; __i < __nmatches;)
     {
       const char_type* __name = __names[__matches[__i]];
       if (__pos >= __matches_lengths[__i])
  ++__nskipped, ++__i;
       else if (!(__name[__pos] == __c))
  {
    --__nmatches;
    __matches[__i] = __matches[__nmatches];
    __matches_lengths[__i] = __matches_lengths[__nmatches];
  }
       else
  ++__i;
     }
   if (__nskipped == __nmatches)
     break;
 }

      if ((__nmatches == 1 && __matches_lengths[0] == __pos)
   || (__nmatches == 2 && (__matches_lengths[0] == __pos
      || __matches_lengths[1] == __pos)))
 __member = (__matches[0] >= __indexlen
      ? __matches[0] - __indexlen : __matches[0]);
      else
 __err |= ios_base::failbit;

      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    do_get_time(iter_type __beg, iter_type __end, ios_base& __io,
  ios_base::iostate& __err, tm* __tm) const
    {
      const locale& __loc = __io._M_getloc();
      const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);
      const char_type* __times[2];
      __tp._M_time_formats(__times);
      __beg = _M_extract_via_format(__beg, __end, __io, __err,
        __tm, __times[0]);
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    do_get_date(iter_type __beg, iter_type __end, ios_base& __io,
  ios_base::iostate& __err, tm* __tm) const
    {
      const locale& __loc = __io._M_getloc();
      const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);
      const char_type* __dates[2];
      __tp._M_date_formats(__dates);
      __beg = _M_extract_via_format(__beg, __end, __io, __err,
        __tm, __dates[0]);
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    do_get_weekday(iter_type __beg, iter_type __end, ios_base& __io,
     ios_base::iostate& __err, tm* __tm) const
    {
      const locale& __loc = __io._M_getloc();
      const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);
      const char_type* __days[14];
      __tp._M_days_abbreviated(__days);
      __tp._M_days(__days + 7);
      int __tmpwday;
      ios_base::iostate __tmperr = ios_base::goodbit;

      __beg = _M_extract_wday_or_month(__beg, __end, __tmpwday, __days, 7,
           __io, __tmperr);
      if (!__tmperr)
 __tm->tm_wday = __tmpwday;
      else
 __err |= ios_base::failbit;

      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
     }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    do_get_monthname(iter_type __beg, iter_type __end,
                     ios_base& __io, ios_base::iostate& __err, tm* __tm) const
    {
      const locale& __loc = __io._M_getloc();
      const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);
      const char_type* __months[24];
      __tp._M_months_abbreviated(__months);
      __tp._M_months(__months + 12);
      int __tmpmon;
      ios_base::iostate __tmperr = ios_base::goodbit;

      __beg = _M_extract_wday_or_month(__beg, __end, __tmpmon, __months, 12,
           __io, __tmperr);
      if (!__tmperr)
 __tm->tm_mon = __tmpmon;
      else
 __err |= ios_base::failbit;

      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    do_get_year(iter_type __beg, iter_type __end, ios_base& __io,
  ios_base::iostate& __err, tm* __tm) const
    {
      int __tmpyear;
      ios_base::iostate __tmperr = ios_base::goodbit;

      __beg = _M_extract_num(__beg, __end, __tmpyear, 0, 9999, 4,
        __io, __tmperr);
      if (!__tmperr)
 __tm->tm_year = __tmpyear < 0 ? __tmpyear + 100 : __tmpyear - 1900;
      else
 __err |= ios_base::failbit;

      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }


  template<typename _CharT, typename _InIter>
    inline
    _InIter
    time_get<_CharT, _InIter>::
    get(iter_type __s, iter_type __end, ios_base& __io,
        ios_base::iostate& __err, tm* __tm, const char_type* __fmt,
        const char_type* __fmtend) const
    {
      const locale& __loc = __io._M_getloc();
      ctype<_CharT> const& __ctype = use_facet<ctype<_CharT> >(__loc);
      __err = ios_base::goodbit;
      while (__fmt != __fmtend &&
             __err == ios_base::goodbit)
        {
          if (__s == __end)
            {
              __err = ios_base::eofbit | ios_base::failbit;
              break;
            }
          else if (__ctype.narrow(*__fmt, 0) == '%')
            {
              char __format;
              char __mod = 0;
              if (++__fmt == __fmtend)
                {
                  __err = ios_base::failbit;
                  break;
                }
              const char __c = __ctype.narrow(*__fmt, 0);
              if (__c != 'E' && __c != 'O')
                __format = __c;
              else if (++__fmt != __fmtend)
                {
                  __mod = __c;
                  __format = __ctype.narrow(*__fmt, 0);
                }
              else
                {
                  __err = ios_base::failbit;
                  break;
                }
              __s = this->do_get(__s, __end, __io, __err, __tm, __format,
     __mod);
              ++__fmt;
            }
          else if (__ctype.is(ctype_base::space, *__fmt))
            {
              ++__fmt;
              while (__fmt != __fmtend &&
                     __ctype.is(ctype_base::space, *__fmt))
                ++__fmt;

              while (__s != __end &&
                     __ctype.is(ctype_base::space, *__s))
                ++__s;
            }

          else if (__ctype.tolower(*__s) == __ctype.tolower(*__fmt) ||
                   __ctype.toupper(*__s) == __ctype.toupper(*__fmt))
            {
              ++__s;
              ++__fmt;
            }
          else
            {
              __err = ios_base::failbit;
              break;
            }
        }
      return __s;
    }

  template<typename _CharT, typename _InIter>
    inline
    _InIter
    time_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, tm* __tm,
           char __format, char __mod) const
    {
      const locale& __loc = __io._M_getloc();
      ctype<_CharT> const& __ctype = use_facet<ctype<_CharT> >(__loc);
      __err = ios_base::goodbit;

      char_type __fmt[4];
      __fmt[0] = __ctype.widen('%');
      if (!__mod)
        {
          __fmt[1] = __format;
          __fmt[2] = char_type();
        }
      else
        {
          __fmt[1] = __mod;
          __fmt[2] = __format;
          __fmt[3] = char_type();
        }

      __beg = _M_extract_via_format(__beg, __end, __io, __err, __tm, __fmt);
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }



  template<typename _CharT, typename _OutIter>
    _OutIter
    time_put<_CharT, _OutIter>::
    put(iter_type __s, ios_base& __io, char_type __fill, const tm* __tm,
 const _CharT* __beg, const _CharT* __end) const
    {
      const locale& __loc = __io._M_getloc();
      ctype<_CharT> const& __ctype = use_facet<ctype<_CharT> >(__loc);
      for (; __beg != __end; ++__beg)
 if (__ctype.narrow(*__beg, 0) != '%')
   {
     *__s = *__beg;
     ++__s;
   }
 else if (++__beg != __end)
   {
     char __format;
     char __mod = 0;
     const char __c = __ctype.narrow(*__beg, 0);
     if (__c != 'E' && __c != 'O')
       __format = __c;
     else if (++__beg != __end)
       {
  __mod = __c;
  __format = __ctype.narrow(*__beg, 0);
       }
     else
       break;
     __s = this->do_put(__s, __io, __fill, __tm, __format, __mod);
   }
 else
   break;
      return __s;
    }

  template<typename _CharT, typename _OutIter>
    _OutIter
    time_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type, const tm* __tm,
    char __format, char __mod) const
    {
      const locale& __loc = __io._M_getloc();
      ctype<_CharT> const& __ctype = use_facet<ctype<_CharT> >(__loc);
      __timepunct<_CharT> const& __tp = use_facet<__timepunct<_CharT> >(__loc);



      const size_t __maxlen = 128;
      char_type __res[__maxlen];






      char_type __fmt[4];
      __fmt[0] = __ctype.widen('%');
      if (!__mod)
 {
   __fmt[1] = __format;
   __fmt[2] = char_type();
 }
      else
 {
   __fmt[1] = __mod;
   __fmt[2] = __format;
   __fmt[3] = char_type();
 }

      __tp._M_put(__res, __maxlen, __fmt, __tm);


      return std::__write(__s, __res, char_traits<char_type>::length(__res));
    }





  extern template class moneypunct<char, false>;
  extern template class moneypunct<char, true>;
  extern template class moneypunct_byname<char, false>;
  extern template class moneypunct_byname<char, true>;
  extern template class __cxx11:: money_get<char>;
  extern template class __cxx11:: money_put<char>;
  extern template class __timepunct<char>;
  extern template class time_put<char>;
  extern template class time_put_byname<char>;
  extern template class time_get<char>;
  extern template class time_get_byname<char>;
  extern template class messages<char>;
  extern template class messages_byname<char>;

  extern template
    const moneypunct<char, true>&
    use_facet<moneypunct<char, true> >(const locale&);

  extern template
    const moneypunct<char, false>&
    use_facet<moneypunct<char, false> >(const locale&);

  extern template
    const money_put<char>&
    use_facet<money_put<char> >(const locale&);

  extern template
    const money_get<char>&
    use_facet<money_get<char> >(const locale&);

  extern template
    const __timepunct<char>&
    use_facet<__timepunct<char> >(const locale&);

  extern template
    const time_put<char>&
    use_facet<time_put<char> >(const locale&);

  extern template
    const time_get<char>&
    use_facet<time_get<char> >(const locale&);

  extern template
    const messages<char>&
    use_facet<messages<char> >(const locale&);

  extern template
    bool
    has_facet<moneypunct<char> >(const locale&);

  extern template
    bool
    has_facet<money_put<char> >(const locale&);

  extern template
    bool
    has_facet<money_get<char> >(const locale&);

  extern template
    bool
    has_facet<__timepunct<char> >(const locale&);

  extern template
    bool
    has_facet<time_put<char> >(const locale&);

  extern template
    bool
    has_facet<time_get<char> >(const locale&);

  extern template
    bool
    has_facet<messages<char> >(const locale&);


  extern template class moneypunct<wchar_t, false>;
  extern template class moneypunct<wchar_t, true>;
  extern template class moneypunct_byname<wchar_t, false>;
  extern template class moneypunct_byname<wchar_t, true>;
  extern template class __cxx11:: money_get<wchar_t>;
  extern template class __cxx11:: money_put<wchar_t>;
  extern template class __timepunct<wchar_t>;
  extern template class time_put<wchar_t>;
  extern template class time_put_byname<wchar_t>;
  extern template class time_get<wchar_t>;
  extern template class time_get_byname<wchar_t>;
  extern template class messages<wchar_t>;
  extern template class messages_byname<wchar_t>;

  extern template
    const moneypunct<wchar_t, true>&
    use_facet<moneypunct<wchar_t, true> >(const locale&);

  extern template
    const moneypunct<wchar_t, false>&
    use_facet<moneypunct<wchar_t, false> >(const locale&);

  extern template
    const money_put<wchar_t>&
    use_facet<money_put<wchar_t> >(const locale&);

  extern template
    const money_get<wchar_t>&
    use_facet<money_get<wchar_t> >(const locale&);

  extern template
    const __timepunct<wchar_t>&
    use_facet<__timepunct<wchar_t> >(const locale&);

  extern template
    const time_put<wchar_t>&
    use_facet<time_put<wchar_t> >(const locale&);

  extern template
    const time_get<wchar_t>&
    use_facet<time_get<wchar_t> >(const locale&);

  extern template
    const messages<wchar_t>&
    use_facet<messages<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<moneypunct<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<money_put<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<money_get<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<__timepunct<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<time_put<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<time_get<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<messages<wchar_t> >(const locale&);




}
# 2016 "/usr/include/c++/10.2.0/bits/locale_facets_nonio.h" 2 3
# 42 "/usr/include/c++/10.2.0/locale" 2 3

# 1 "/usr/include/c++/10.2.0/bits/locale_conv.h" 1 3
# 41 "/usr/include/c++/10.2.0/bits/locale_conv.h" 3
# 1 "/usr/include/c++/10.2.0/bits/unique_ptr.h" 1 3
# 36 "/usr/include/c++/10.2.0/bits/unique_ptr.h" 3
# 1 "/usr/include/c++/10.2.0/utility" 1 3
# 58 "/usr/include/c++/10.2.0/utility" 3
       
# 59 "/usr/include/c++/10.2.0/utility" 3
# 69 "/usr/include/c++/10.2.0/utility" 3
# 1 "/usr/include/c++/10.2.0/bits/stl_relops.h" 1 3
# 67 "/usr/include/c++/10.2.0/bits/stl_relops.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  namespace rel_ops
  {
# 85 "/usr/include/c++/10.2.0/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator!=(const _Tp& __x, const _Tp& __y)
      { return !(__x == __y); }
# 98 "/usr/include/c++/10.2.0/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator>(const _Tp& __x, const _Tp& __y)
      { return __y < __x; }
# 111 "/usr/include/c++/10.2.0/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator<=(const _Tp& __x, const _Tp& __y)
      { return !(__y < __x); }
# 124 "/usr/include/c++/10.2.0/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator>=(const _Tp& __x, const _Tp& __y)
      { return !(__x < __y); }
  }


}
# 70 "/usr/include/c++/10.2.0/utility" 2 3
# 82 "/usr/include/c++/10.2.0/utility" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  template<typename _Tp>
    struct tuple_size;





  template<typename _Tp,
    typename _Up = typename remove_cv<_Tp>::type,
    typename = typename enable_if<is_same<_Tp, _Up>::value>::type,
    size_t = tuple_size<_Tp>::value>
    using __enable_if_has_tuple_size = _Tp;

  template<typename _Tp>
    struct tuple_size<const __enable_if_has_tuple_size<_Tp>>
    : public tuple_size<_Tp> { };

  template<typename _Tp>
    struct tuple_size<volatile __enable_if_has_tuple_size<_Tp>>
    : public tuple_size<_Tp> { };

  template<typename _Tp>
    struct tuple_size<const volatile __enable_if_has_tuple_size<_Tp>>
    : public tuple_size<_Tp> { };


  template<std::size_t __i, typename _Tp>
    struct tuple_element;


  template<std::size_t __i, typename _Tp>
    using __tuple_element_t = typename tuple_element<__i, _Tp>::type;

  template<std::size_t __i, typename _Tp>
    struct tuple_element<__i, const _Tp>
    {
      typedef typename add_const<__tuple_element_t<__i, _Tp>>::type type;
    };

  template<std::size_t __i, typename _Tp>
    struct tuple_element<__i, volatile _Tp>
    {
      typedef typename add_volatile<__tuple_element_t<__i, _Tp>>::type type;
    };

  template<std::size_t __i, typename _Tp>
    struct tuple_element<__i, const volatile _Tp>
    {
      typedef typename add_cv<__tuple_element_t<__i, _Tp>>::type type;
    };







  template<std::size_t __i, typename _Tp>
    using tuple_element_t = typename tuple_element<__i, _Tp>::type;





  template<typename _T1, typename _T2>
    struct __is_tuple_like_impl<std::pair<_T1, _T2>> : true_type
    { };


  template<class _Tp1, class _Tp2>
    struct tuple_size<std::pair<_Tp1, _Tp2>>
    : public integral_constant<std::size_t, 2> { };


  template<class _Tp1, class _Tp2>
    struct tuple_element<0, std::pair<_Tp1, _Tp2>>
    { typedef _Tp1 type; };


  template<class _Tp1, class _Tp2>
    struct tuple_element<1, std::pair<_Tp1, _Tp2>>
    { typedef _Tp2 type; };

  template<std::size_t _Int>
    struct __pair_get;

  template<>
    struct __pair_get<0>
    {
      template<typename _Tp1, typename _Tp2>
        static constexpr _Tp1&
        __get(std::pair<_Tp1, _Tp2>& __pair) noexcept
        { return __pair.first; }

      template<typename _Tp1, typename _Tp2>
        static constexpr _Tp1&&
        __move_get(std::pair<_Tp1, _Tp2>&& __pair) noexcept
        { return std::forward<_Tp1>(__pair.first); }

      template<typename _Tp1, typename _Tp2>
        static constexpr const _Tp1&
        __const_get(const std::pair<_Tp1, _Tp2>& __pair) noexcept
        { return __pair.first; }

      template<typename _Tp1, typename _Tp2>
        static constexpr const _Tp1&&
        __const_move_get(const std::pair<_Tp1, _Tp2>&& __pair) noexcept
        { return std::forward<const _Tp1>(__pair.first); }
    };

  template<>
    struct __pair_get<1>
    {
      template<typename _Tp1, typename _Tp2>
        static constexpr _Tp2&
        __get(std::pair<_Tp1, _Tp2>& __pair) noexcept
        { return __pair.second; }

      template<typename _Tp1, typename _Tp2>
        static constexpr _Tp2&&
        __move_get(std::pair<_Tp1, _Tp2>&& __pair) noexcept
        { return std::forward<_Tp2>(__pair.second); }

      template<typename _Tp1, typename _Tp2>
        static constexpr const _Tp2&
        __const_get(const std::pair<_Tp1, _Tp2>& __pair) noexcept
        { return __pair.second; }

      template<typename _Tp1, typename _Tp2>
        static constexpr const _Tp2&&
        __const_move_get(const std::pair<_Tp1, _Tp2>&& __pair) noexcept
        { return std::forward<const _Tp2>(__pair.second); }
    };

  template<std::size_t _Int, class _Tp1, class _Tp2>
    constexpr typename tuple_element<_Int, std::pair<_Tp1, _Tp2>>::type&
    get(std::pair<_Tp1, _Tp2>& __in) noexcept
    { return __pair_get<_Int>::__get(__in); }

  template<std::size_t _Int, class _Tp1, class _Tp2>
    constexpr typename tuple_element<_Int, std::pair<_Tp1, _Tp2>>::type&&
    get(std::pair<_Tp1, _Tp2>&& __in) noexcept
    { return __pair_get<_Int>::__move_get(std::move(__in)); }

  template<std::size_t _Int, class _Tp1, class _Tp2>
    constexpr const typename tuple_element<_Int, std::pair<_Tp1, _Tp2>>::type&
    get(const std::pair<_Tp1, _Tp2>& __in) noexcept
    { return __pair_get<_Int>::__const_get(__in); }

  template<std::size_t _Int, class _Tp1, class _Tp2>
    constexpr const typename tuple_element<_Int, std::pair<_Tp1, _Tp2>>::type&&
    get(const std::pair<_Tp1, _Tp2>&& __in) noexcept
    { return __pair_get<_Int>::__const_move_get(std::move(__in)); }





  template <typename _Tp, typename _Up>
    constexpr _Tp&
    get(pair<_Tp, _Up>& __p) noexcept
    { return __p.first; }

  template <typename _Tp, typename _Up>
    constexpr const _Tp&
    get(const pair<_Tp, _Up>& __p) noexcept
    { return __p.first; }

  template <typename _Tp, typename _Up>
    constexpr _Tp&&
    get(pair<_Tp, _Up>&& __p) noexcept
    { return std::move(__p.first); }

  template <typename _Tp, typename _Up>
    constexpr const _Tp&&
    get(const pair<_Tp, _Up>&& __p) noexcept
    { return std::move(__p.first); }

  template <typename _Tp, typename _Up>
    constexpr _Tp&
    get(pair<_Up, _Tp>& __p) noexcept
    { return __p.second; }

  template <typename _Tp, typename _Up>
    constexpr const _Tp&
    get(const pair<_Up, _Tp>& __p) noexcept
    { return __p.second; }

  template <typename _Tp, typename _Up>
    constexpr _Tp&&
    get(pair<_Up, _Tp>&& __p) noexcept
    { return std::move(__p.second); }

  template <typename _Tp, typename _Up>
    constexpr const _Tp&&
    get(const pair<_Up, _Tp>&& __p) noexcept
    { return std::move(__p.second); }




  template <typename _Tp, typename _Up = _Tp>
   
    inline _Tp
    exchange(_Tp& __obj, _Up&& __new_val)
    { return std::__exchange(__obj, std::forward<_Up>(__new_val)); }





  template<size_t... _Indexes> struct _Index_tuple { };
# 307 "/usr/include/c++/10.2.0/utility" 3
  template<size_t _Num>
    struct _Build_index_tuple
    {






      using __type = _Index_tuple<__integer_pack(_Num)...>;

    };






  template<typename _Tp, _Tp... _Idx>
    struct integer_sequence
    {
      typedef _Tp value_type;
      static constexpr size_t size() noexcept { return sizeof...(_Idx); }
    };


  template<typename _Tp, _Tp _Num>
    using make_integer_sequence



      = integer_sequence<_Tp, __integer_pack(_Num)...>;





  template<size_t... _Idx>
    using index_sequence = integer_sequence<size_t, _Idx...>;


  template<size_t _Num>
    using make_index_sequence = make_integer_sequence<size_t, _Num>;


  template<typename... _Types>
    using index_sequence_for = make_index_sequence<sizeof...(_Types)>;
# 473 "/usr/include/c++/10.2.0/utility" 3

}
# 37 "/usr/include/c++/10.2.0/bits/unique_ptr.h" 2 3
# 1 "/usr/include/c++/10.2.0/tuple" 1 3
# 32 "/usr/include/c++/10.2.0/tuple" 3
       
# 33 "/usr/include/c++/10.2.0/tuple" 3






# 1 "/usr/include/c++/10.2.0/array" 1 3
# 32 "/usr/include/c++/10.2.0/array" 3
       
# 33 "/usr/include/c++/10.2.0/array" 3
# 43 "/usr/include/c++/10.2.0/array" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Tp, std::size_t _Nm>
    struct __array_traits
    {
      typedef _Tp _Type[_Nm];
      typedef __is_swappable<_Tp> _Is_swappable;
      typedef __is_nothrow_swappable<_Tp> _Is_nothrow_swappable;

      static constexpr _Tp&
      _S_ref(const _Type& __t, std::size_t __n) noexcept
      { return const_cast<_Tp&>(__t[__n]); }

      static constexpr _Tp*
      _S_ptr(const _Type& __t) noexcept
      { return const_cast<_Tp*>(__t); }
    };

 template<typename _Tp>
   struct __array_traits<_Tp, 0>
   {
     struct _Type { };
     typedef true_type _Is_swappable;
     typedef true_type _Is_nothrow_swappable;

     static constexpr _Tp&
     _S_ref(const _Type&, std::size_t) noexcept
     { return *static_cast<_Tp*>(nullptr); }

     static constexpr _Tp*
     _S_ptr(const _Type&) noexcept
     { return nullptr; }
   };
# 93 "/usr/include/c++/10.2.0/array" 3
  template<typename _Tp, std::size_t _Nm>
    struct array
    {
      typedef _Tp value_type;
      typedef value_type* pointer;
      typedef const value_type* const_pointer;
      typedef value_type& reference;
      typedef const value_type& const_reference;
      typedef value_type* iterator;
      typedef const value_type* const_iterator;
      typedef std::size_t size_type;
      typedef std::ptrdiff_t difference_type;
      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;


      typedef std::__array_traits<_Tp, _Nm> _AT_Type;
      typename _AT_Type::_Type _M_elems;




      void
      fill(const value_type& __u)
      { std::fill_n(begin(), size(), __u); }

      void
      swap(array& __other)
      noexcept(_AT_Type::_Is_nothrow_swappable::value)
      { std::swap_ranges(begin(), end(), __other.begin()); }


      iterator
      begin() noexcept
      { return iterator(data()); }

      const_iterator
      begin() const noexcept
      { return const_iterator(data()); }

      iterator
      end() noexcept
      { return iterator(data() + _Nm); }

      const_iterator
      end() const noexcept
      { return const_iterator(data() + _Nm); }

      reverse_iterator
      rbegin() noexcept
      { return reverse_iterator(end()); }

      const_reverse_iterator
      rbegin() const noexcept
      { return const_reverse_iterator(end()); }

      reverse_iterator
      rend() noexcept
      { return reverse_iterator(begin()); }

      const_reverse_iterator
      rend() const noexcept
      { return const_reverse_iterator(begin()); }

      const_iterator
      cbegin() const noexcept
      { return const_iterator(data()); }

      const_iterator
      cend() const noexcept
      { return const_iterator(data() + _Nm); }

      const_reverse_iterator
      crbegin() const noexcept
      { return const_reverse_iterator(end()); }

      const_reverse_iterator
      crend() const noexcept
      { return const_reverse_iterator(begin()); }


      constexpr size_type
      size() const noexcept { return _Nm; }

      constexpr size_type
      max_size() const noexcept { return _Nm; }

      constexpr bool
      empty() const noexcept { return size() == 0; }


      reference
      operator[](size_type __n) noexcept
      { return _AT_Type::_S_ref(_M_elems, __n); }

      constexpr const_reference
      operator[](size_type __n) const noexcept
      { return _AT_Type::_S_ref(_M_elems, __n); }

      reference
      at(size_type __n)
      {
 if (__n >= _Nm)
   std::__throw_out_of_range_fmt(("array::at: __n (which is %zu) " ">= _Nm (which is %zu)")
                                 ,
     __n, _Nm);
 return _AT_Type::_S_ref(_M_elems, __n);
      }

      constexpr const_reference
      at(size_type __n) const
      {


 return __n < _Nm ? _AT_Type::_S_ref(_M_elems, __n)
   : (std::__throw_out_of_range_fmt(("array::at: __n (which is %zu) " ">= _Nm (which is %zu)")
                                    ,
        __n, _Nm),
      _AT_Type::_S_ref(_M_elems, 0));
      }

      reference
      front() noexcept
      { return *begin(); }

      constexpr const_reference
      front() const noexcept
      { return _AT_Type::_S_ref(_M_elems, 0); }

      reference
      back() noexcept
      { return _Nm ? *(end() - 1) : *end(); }

      constexpr const_reference
      back() const noexcept
      {
 return _Nm ? _AT_Type::_S_ref(_M_elems, _Nm - 1)
             : _AT_Type::_S_ref(_M_elems, 0);
      }

      pointer
      data() noexcept
      { return _AT_Type::_S_ptr(_M_elems); }

      const_pointer
      data() const noexcept
      { return _AT_Type::_S_ptr(_M_elems); }
    };
# 250 "/usr/include/c++/10.2.0/array" 3
  template<typename _Tp, std::size_t _Nm>
   
    inline bool
    operator==(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
    { return std::equal(__one.begin(), __one.end(), __two.begin()); }
# 275 "/usr/include/c++/10.2.0/array" 3
  template<typename _Tp, std::size_t _Nm>
   
    inline bool
    operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
    { return !(__one == __two); }

  template<typename _Tp, std::size_t _Nm>
   
    inline bool
    operator<(const array<_Tp, _Nm>& __a, const array<_Tp, _Nm>& __b)
    {
      return std::lexicographical_compare(__a.begin(), __a.end(),
       __b.begin(), __b.end());
    }

  template<typename _Tp, std::size_t _Nm>
   
    inline bool
    operator>(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
    { return __two < __one; }

  template<typename _Tp, std::size_t _Nm>
   
    inline bool
    operator<=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
    { return !(__one > __two); }

  template<typename _Tp, std::size_t _Nm>
   
    inline bool
    operator>=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
    { return !(__one < __two); }



  template<typename _Tp, std::size_t _Nm>
   
    inline


    typename enable_if<
      std::__array_traits<_Tp, _Nm>::_Is_swappable::value
    >::type



    swap(array<_Tp, _Nm>& __one, array<_Tp, _Nm>& __two)
    noexcept(noexcept(__one.swap(__two)))
    { __one.swap(__two); }


  template<typename _Tp, std::size_t _Nm>
    typename enable_if<
      !std::__array_traits<_Tp, _Nm>::_Is_swappable::value>::type
    swap(array<_Tp, _Nm>&, array<_Tp, _Nm>&) = delete;


  template<std::size_t _Int, typename _Tp, std::size_t _Nm>
    constexpr _Tp&
    get(array<_Tp, _Nm>& __arr) noexcept
    {
      static_assert(_Int < _Nm, "array index is within bounds");
      return std::__array_traits<_Tp, _Nm>::
 _S_ref(__arr._M_elems, _Int);
    }

  template<std::size_t _Int, typename _Tp, std::size_t _Nm>
    constexpr _Tp&&
    get(array<_Tp, _Nm>&& __arr) noexcept
    {
      static_assert(_Int < _Nm, "array index is within bounds");
      return std::move(std::get<_Int>(__arr));
    }

  template<std::size_t _Int, typename _Tp, std::size_t _Nm>
    constexpr const _Tp&
    get(const array<_Tp, _Nm>& __arr) noexcept
    {
      static_assert(_Int < _Nm, "array index is within bounds");
      return std::__array_traits<_Tp, _Nm>::
 _S_ref(__arr._M_elems, _Int);
    }

  template<std::size_t _Int, typename _Tp, std::size_t _Nm>
    constexpr const _Tp&&
    get(const array<_Tp, _Nm>&& __arr) noexcept
    {
      static_assert(_Int < _Nm, "array index is within bounds");
      return std::move(std::get<_Int>(__arr));
    }
# 404 "/usr/include/c++/10.2.0/array" 3

}

namespace std __attribute__ ((__visibility__ ("default")))
{





  template<typename _Tp>
    struct tuple_size;


  template<typename _Tp, std::size_t _Nm>
    struct tuple_size<std::array<_Tp, _Nm>>
    : public integral_constant<std::size_t, _Nm> { };


  template<std::size_t _Int, typename _Tp>
    struct tuple_element;


  template<std::size_t _Int, typename _Tp, std::size_t _Nm>
    struct tuple_element<_Int, std::array<_Tp, _Nm>>
    {
      static_assert(_Int < _Nm, "index is out of bounds");
      typedef _Tp type;
    };

  template<typename _Tp, std::size_t _Nm>
    struct __is_tuple_like_impl<std::array<_Tp, _Nm>> : true_type
    { };


}
# 40 "/usr/include/c++/10.2.0/tuple" 2 3
# 1 "/usr/include/c++/10.2.0/bits/uses_allocator.h" 1 3
# 35 "/usr/include/c++/10.2.0/bits/uses_allocator.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  struct __erased_type { };




  template<typename _Alloc, typename _Tp>
    using __is_erased_or_convertible
      = __or_<is_convertible<_Alloc, _Tp>, is_same<_Tp, __erased_type>>;


  struct allocator_arg_t { explicit allocator_arg_t() = default; };

  constexpr allocator_arg_t allocator_arg =
    allocator_arg_t();

  template<typename _Tp, typename _Alloc, typename = __void_t<>>
    struct __uses_allocator_helper
    : false_type { };

  template<typename _Tp, typename _Alloc>
    struct __uses_allocator_helper<_Tp, _Alloc,
       __void_t<typename _Tp::allocator_type>>
    : __is_erased_or_convertible<_Alloc, typename _Tp::allocator_type>::type
    { };


  template<typename _Tp, typename _Alloc>
    struct uses_allocator
    : __uses_allocator_helper<_Tp, _Alloc>::type
    { };

  struct __uses_alloc_base { };

  struct __uses_alloc0 : __uses_alloc_base
  {
    struct _Sink { void operator=(const void*) { } } _M_a;
  };

  template<typename _Alloc>
    struct __uses_alloc1 : __uses_alloc_base { const _Alloc* _M_a; };

  template<typename _Alloc>
    struct __uses_alloc2 : __uses_alloc_base { const _Alloc* _M_a; };

  template<bool, typename _Tp, typename _Alloc, typename... _Args>
    struct __uses_alloc;

  template<typename _Tp, typename _Alloc, typename... _Args>
    struct __uses_alloc<true, _Tp, _Alloc, _Args...>
    : conditional<
        is_constructible<_Tp, allocator_arg_t, const _Alloc&, _Args...>::value,
        __uses_alloc1<_Alloc>,
        __uses_alloc2<_Alloc>>::type
    {


      static_assert(__or_<
   is_constructible<_Tp, allocator_arg_t, const _Alloc&, _Args...>,
   is_constructible<_Tp, _Args..., const _Alloc&>>::value,
   "construction with an allocator must be possible"
   " if uses_allocator is true");
    };

  template<typename _Tp, typename _Alloc, typename... _Args>
    struct __uses_alloc<false, _Tp, _Alloc, _Args...>
    : __uses_alloc0 { };

  template<typename _Tp, typename _Alloc, typename... _Args>
    using __uses_alloc_t =
      __uses_alloc<uses_allocator<_Tp, _Alloc>::value, _Tp, _Alloc, _Args...>;

  template<typename _Tp, typename _Alloc, typename... _Args>
   
    inline __uses_alloc_t<_Tp, _Alloc, _Args...>
    __use_alloc(const _Alloc& __a)
    {
      __uses_alloc_t<_Tp, _Alloc, _Args...> __ret;
      __ret._M_a = std::__addressof(__a);
      return __ret;
    }

  template<typename _Tp, typename _Alloc, typename... _Args>
    void
    __use_alloc(const _Alloc&&) = delete;







  template<template<typename...> class _Predicate,
    typename _Tp, typename _Alloc, typename... _Args>
    struct __is_uses_allocator_predicate
    : conditional<uses_allocator<_Tp, _Alloc>::value,
      __or_<_Predicate<_Tp, allocator_arg_t, _Alloc, _Args...>,
     _Predicate<_Tp, _Args..., _Alloc>>,
      _Predicate<_Tp, _Args...>>::type { };

  template<typename _Tp, typename _Alloc, typename... _Args>
    struct __is_uses_allocator_constructible
    : __is_uses_allocator_predicate<is_constructible, _Tp, _Alloc, _Args...>
    { };


  template<typename _Tp, typename _Alloc, typename... _Args>
    constexpr bool __is_uses_allocator_constructible_v =
      __is_uses_allocator_constructible<_Tp, _Alloc, _Args...>::value;


  template<typename _Tp, typename _Alloc, typename... _Args>
    struct __is_nothrow_uses_allocator_constructible
    : __is_uses_allocator_predicate<is_nothrow_constructible,
        _Tp, _Alloc, _Args...>
    { };



  template<typename _Tp, typename _Alloc, typename... _Args>
    constexpr bool
    __is_nothrow_uses_allocator_constructible_v =
      __is_nothrow_uses_allocator_constructible<_Tp, _Alloc, _Args...>::value;


  template<typename _Tp, typename... _Args>
    void __uses_allocator_construct_impl(__uses_alloc0 __a, _Tp* __ptr,
      _Args&&... __args)
    { ::new ((void*)__ptr) _Tp(std::forward<_Args>(__args)...); }

  template<typename _Tp, typename _Alloc, typename... _Args>
    void __uses_allocator_construct_impl(__uses_alloc1<_Alloc> __a, _Tp* __ptr,
      _Args&&... __args)
    {
      ::new ((void*)__ptr) _Tp(allocator_arg, *__a._M_a,
          std::forward<_Args>(__args)...);
    }

  template<typename _Tp, typename _Alloc, typename... _Args>
    void __uses_allocator_construct_impl(__uses_alloc2<_Alloc> __a, _Tp* __ptr,
      _Args&&... __args)
    { ::new ((void*)__ptr) _Tp(std::forward<_Args>(__args)..., *__a._M_a); }

  template<typename _Tp, typename _Alloc, typename... _Args>
    void __uses_allocator_construct(const _Alloc& __a, _Tp* __ptr,
        _Args&&... __args)
    {
      std::__uses_allocator_construct_impl(
   std::__use_alloc<_Tp, _Alloc, _Args...>(__a), __ptr,
   std::forward<_Args>(__args)...);
    }


}
# 41 "/usr/include/c++/10.2.0/tuple" 2 3
# 1 "/usr/include/c++/10.2.0/bits/invoke.h" 1 3
# 33 "/usr/include/c++/10.2.0/bits/invoke.h" 3
       
# 34 "/usr/include/c++/10.2.0/bits/invoke.h" 3







namespace std __attribute__ ((__visibility__ ("default")))
{

# 52 "/usr/include/c++/10.2.0/bits/invoke.h" 3
  template<typename _Tp, typename _Up = typename __inv_unwrap<_Tp>::type>
    constexpr _Up&&
    __invfwd(typename remove_reference<_Tp>::type& __t) noexcept
    { return static_cast<_Up&&>(__t); }

  template<typename _Res, typename _Fn, typename... _Args>
    constexpr _Res
    __invoke_impl(__invoke_other, _Fn&& __f, _Args&&... __args)
    { return std::forward<_Fn>(__f)(std::forward<_Args>(__args)...); }

  template<typename _Res, typename _MemFun, typename _Tp, typename... _Args>
    constexpr _Res
    __invoke_impl(__invoke_memfun_ref, _MemFun&& __f, _Tp&& __t,
    _Args&&... __args)
    { return (__invfwd<_Tp>(__t).*__f)(std::forward<_Args>(__args)...); }

  template<typename _Res, typename _MemFun, typename _Tp, typename... _Args>
    constexpr _Res
    __invoke_impl(__invoke_memfun_deref, _MemFun&& __f, _Tp&& __t,
    _Args&&... __args)
    {
      return ((*std::forward<_Tp>(__t)).*__f)(std::forward<_Args>(__args)...);
    }

  template<typename _Res, typename _MemPtr, typename _Tp>
    constexpr _Res
    __invoke_impl(__invoke_memobj_ref, _MemPtr&& __f, _Tp&& __t)
    { return __invfwd<_Tp>(__t).*__f; }

  template<typename _Res, typename _MemPtr, typename _Tp>
    constexpr _Res
    __invoke_impl(__invoke_memobj_deref, _MemPtr&& __f, _Tp&& __t)
    { return (*std::forward<_Tp>(__t)).*__f; }


  template<typename _Callable, typename... _Args>
    constexpr typename __invoke_result<_Callable, _Args...>::type
    __invoke(_Callable&& __fn, _Args&&... __args)
    noexcept(__is_nothrow_invocable<_Callable, _Args...>::value)
    {
      using __result = __invoke_result<_Callable, _Args...>;
      using __type = typename __result::type;
      using __tag = typename __result::__invoke_type;
      return std::__invoke_impl<__type>(__tag{}, std::forward<_Callable>(__fn),
     std::forward<_Args>(__args)...);
    }
# 118 "/usr/include/c++/10.2.0/bits/invoke.h" 3
  template<typename _Res, typename _Callable, typename... _Args>
    using __can_invoke_as_void = __enable_if_t<
      __and_<is_void<_Res>, __is_invocable<_Callable, _Args...>>::value,
      _Res
    >;

  template<typename _Res, typename _Callable, typename... _Args>
    using __can_invoke_as_nonvoid = __enable_if_t<
      __and_<__not_<is_void<_Res>>,
      is_convertible<typename __invoke_result<_Callable, _Args...>::type,
       _Res>
      >::value,
      _Res
    >;


  template<typename _Res, typename _Callable, typename... _Args>
    constexpr __can_invoke_as_nonvoid<_Res, _Callable, _Args...>
    __invoke_r(_Callable&& __fn, _Args&&... __args)
    {
      using __result = __invoke_result<_Callable, _Args...>;
      using __type = typename __result::type;
      using __tag = typename __result::__invoke_type;
      return std::__invoke_impl<__type>(__tag{}, std::forward<_Callable>(__fn),
     std::forward<_Args>(__args)...);
    }


  template<typename _Res, typename _Callable, typename... _Args>
    constexpr __can_invoke_as_void<_Res, _Callable, _Args...>
    __invoke_r(_Callable&& __fn, _Args&&... __args)
    {
      using __result = __invoke_result<_Callable, _Args...>;
      using __type = typename __result::type;
      using __tag = typename __result::__invoke_type;
      std::__invoke_impl<__type>(__tag{}, std::forward<_Callable>(__fn),
     std::forward<_Args>(__args)...);
    }



}
# 42 "/usr/include/c++/10.2.0/tuple" 2 3





namespace std __attribute__ ((__visibility__ ("default")))
{







  template<typename... _Elements>
    class tuple;

  template<typename _Tp>
    struct __is_empty_non_tuple : is_empty<_Tp> { };


  template<typename _El0, typename... _El>
    struct __is_empty_non_tuple<tuple<_El0, _El...>> : false_type { };


  template<typename _Tp>
    using __empty_not_final
    = typename conditional<__is_final(_Tp), false_type,
      __is_empty_non_tuple<_Tp>>::type;

  template<std::size_t _Idx, typename _Head,
    bool = __empty_not_final<_Head>::value>
    struct _Head_base;

  template<std::size_t _Idx, typename _Head>
    struct _Head_base<_Idx, _Head, true>
    : public _Head
    {
      constexpr _Head_base()
      : _Head() { }

      constexpr _Head_base(const _Head& __h)
      : _Head(__h) { }

      constexpr _Head_base(const _Head_base&) = default;
      constexpr _Head_base(_Head_base&&) = default;

      template<typename _UHead>
        constexpr _Head_base(_UHead&& __h)
 : _Head(std::forward<_UHead>(__h)) { }

      _Head_base(allocator_arg_t, __uses_alloc0)
      : _Head() { }

      template<typename _Alloc>
 _Head_base(allocator_arg_t, __uses_alloc1<_Alloc> __a)
 : _Head(allocator_arg, *__a._M_a) { }

      template<typename _Alloc>
 _Head_base(allocator_arg_t, __uses_alloc2<_Alloc> __a)
 : _Head(*__a._M_a) { }

      template<typename _UHead>
 _Head_base(__uses_alloc0, _UHead&& __uhead)
 : _Head(std::forward<_UHead>(__uhead)) { }

      template<typename _Alloc, typename _UHead>
 _Head_base(__uses_alloc1<_Alloc> __a, _UHead&& __uhead)
 : _Head(allocator_arg, *__a._M_a, std::forward<_UHead>(__uhead)) { }

      template<typename _Alloc, typename _UHead>
 _Head_base(__uses_alloc2<_Alloc> __a, _UHead&& __uhead)
 : _Head(std::forward<_UHead>(__uhead), *__a._M_a) { }

      static constexpr _Head&
      _M_head(_Head_base& __b) noexcept { return __b; }

      static constexpr const _Head&
      _M_head(const _Head_base& __b) noexcept { return __b; }
    };

  template<std::size_t _Idx, typename _Head>
    struct _Head_base<_Idx, _Head, false>
    {
      constexpr _Head_base()
      : _M_head_impl() { }

      constexpr _Head_base(const _Head& __h)
      : _M_head_impl(__h) { }

      constexpr _Head_base(const _Head_base&) = default;
      constexpr _Head_base(_Head_base&&) = default;

      template<typename _UHead>
        constexpr _Head_base(_UHead&& __h)
 : _M_head_impl(std::forward<_UHead>(__h)) { }

     
      _Head_base(allocator_arg_t, __uses_alloc0)
      : _M_head_impl() { }

      template<typename _Alloc>
 _Head_base(allocator_arg_t, __uses_alloc1<_Alloc> __a)
 : _M_head_impl(allocator_arg, *__a._M_a) { }

      template<typename _Alloc>
 _Head_base(allocator_arg_t, __uses_alloc2<_Alloc> __a)
 : _M_head_impl(*__a._M_a) { }

      template<typename _UHead>

 _Head_base(__uses_alloc0, _UHead&& __uhead)
 : _M_head_impl(std::forward<_UHead>(__uhead)) { }

      template<typename _Alloc, typename _UHead>
 _Head_base(__uses_alloc1<_Alloc> __a, _UHead&& __uhead)
 : _M_head_impl(allocator_arg, *__a._M_a, std::forward<_UHead>(__uhead))
 { }

      template<typename _Alloc, typename _UHead>
 _Head_base(__uses_alloc2<_Alloc> __a, _UHead&& __uhead)
 : _M_head_impl(std::forward<_UHead>(__uhead), *__a._M_a) { }

      static constexpr _Head&
      _M_head(_Head_base& __b) noexcept { return __b._M_head_impl; }

      static constexpr const _Head&
      _M_head(const _Head_base& __b) noexcept { return __b._M_head_impl; }

      _Head _M_head_impl;
    };
# 182 "/usr/include/c++/10.2.0/tuple" 3
  template<std::size_t _Idx, typename... _Elements>
    struct _Tuple_impl;






  template<std::size_t _Idx, typename _Head, typename... _Tail>
    struct _Tuple_impl<_Idx, _Head, _Tail...>
    : public _Tuple_impl<_Idx + 1, _Tail...>,
      private _Head_base<_Idx, _Head>
    {
      template<std::size_t, typename...> friend class _Tuple_impl;

      typedef _Tuple_impl<_Idx + 1, _Tail...> _Inherited;
      typedef _Head_base<_Idx, _Head> _Base;

      static constexpr _Head&
      _M_head(_Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }

      static constexpr const _Head&
      _M_head(const _Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }

      static constexpr _Inherited&
      _M_tail(_Tuple_impl& __t) noexcept { return __t; }

      static constexpr const _Inherited&
      _M_tail(const _Tuple_impl& __t) noexcept { return __t; }

      constexpr _Tuple_impl()
      : _Inherited(), _Base() { }

      explicit
      constexpr _Tuple_impl(const _Head& __head, const _Tail&... __tail)
      : _Inherited(__tail...), _Base(__head) { }

      template<typename _UHead, typename... _UTail, typename = typename
               enable_if<sizeof...(_Tail) == sizeof...(_UTail)>::type>
        explicit
        constexpr _Tuple_impl(_UHead&& __head, _UTail&&... __tail)
 : _Inherited(std::forward<_UTail>(__tail)...),
   _Base(std::forward<_UHead>(__head)) { }

      constexpr _Tuple_impl(const _Tuple_impl&) = default;



      _Tuple_impl& operator=(const _Tuple_impl&) = delete;

      constexpr
      _Tuple_impl(_Tuple_impl&& __in)
      noexcept(__and_<is_nothrow_move_constructible<_Head>,
               is_nothrow_move_constructible<_Inherited>>::value)
      : _Inherited(std::move(_M_tail(__in))),
 _Base(std::forward<_Head>(_M_head(__in))) { }

      template<typename... _UElements>
        constexpr _Tuple_impl(const _Tuple_impl<_Idx, _UElements...>& __in)
 : _Inherited(_Tuple_impl<_Idx, _UElements...>::_M_tail(__in)),
   _Base(_Tuple_impl<_Idx, _UElements...>::_M_head(__in)) { }

      template<typename _UHead, typename... _UTails>
        constexpr _Tuple_impl(_Tuple_impl<_Idx, _UHead, _UTails...>&& __in)
 : _Inherited(std::move
       (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in))),
   _Base(std::forward<_UHead>
  (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in))) { }

      template<typename _Alloc>

 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a)
 : _Inherited(__tag, __a),
          _Base(__tag, __use_alloc<_Head>(__a)) { }

      template<typename _Alloc>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
      const _Head& __head, const _Tail&... __tail)
 : _Inherited(__tag, __a, __tail...),
          _Base(__use_alloc<_Head, _Alloc, _Head>(__a), __head) { }

      template<typename _Alloc, typename _UHead, typename... _UTail,
               typename = typename enable_if<sizeof...(_Tail)
          == sizeof...(_UTail)>::type>

 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             _UHead&& __head, _UTail&&... __tail)
 : _Inherited(__tag, __a, std::forward<_UTail>(__tail)...),
          _Base(__use_alloc<_Head, _Alloc, _UHead>(__a),
         std::forward<_UHead>(__head)) { }

      template<typename _Alloc>

        _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             const _Tuple_impl& __in)
 : _Inherited(__tag, __a, _M_tail(__in)),
          _Base(__use_alloc<_Head, _Alloc, _Head>(__a), _M_head(__in)) { }

      template<typename _Alloc>

 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             _Tuple_impl&& __in)
 : _Inherited(__tag, __a, std::move(_M_tail(__in))),
   _Base(__use_alloc<_Head, _Alloc, _Head>(__a),
         std::forward<_Head>(_M_head(__in))) { }

      template<typename _Alloc, typename... _UElements>

 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             const _Tuple_impl<_Idx, _UElements...>& __in)
 : _Inherited(__tag, __a,
       _Tuple_impl<_Idx, _UElements...>::_M_tail(__in)),
   _Base(__use_alloc<_Head, _Alloc, _Head>(__a),
  _Tuple_impl<_Idx, _UElements...>::_M_head(__in)) { }

      template<typename _Alloc, typename _UHead, typename... _UTails>

 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             _Tuple_impl<_Idx, _UHead, _UTails...>&& __in)
 : _Inherited(__tag, __a, std::move
       (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in))),
   _Base(__use_alloc<_Head, _Alloc, _UHead>(__a),
                std::forward<_UHead>
  (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in))) { }

      template<typename... _UElements>

        void
        _M_assign(const _Tuple_impl<_Idx, _UElements...>& __in)
        {
   _M_head(*this) = _Tuple_impl<_Idx, _UElements...>::_M_head(__in);
   _M_tail(*this)._M_assign(
       _Tuple_impl<_Idx, _UElements...>::_M_tail(__in));
 }

      template<typename _UHead, typename... _UTails>

        void
        _M_assign(_Tuple_impl<_Idx, _UHead, _UTails...>&& __in)
        {
   _M_head(*this) = std::forward<_UHead>
     (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in));
   _M_tail(*this)._M_assign(
       std::move(_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in)));
 }

    protected:
     
      void
      _M_swap(_Tuple_impl& __in)
      {
 using std::swap;
 swap(_M_head(*this), _M_head(__in));
 _Inherited::_M_swap(_M_tail(__in));
      }
    };


  template<std::size_t _Idx, typename _Head>
    struct _Tuple_impl<_Idx, _Head>
    : private _Head_base<_Idx, _Head>
    {
      template<std::size_t, typename...> friend class _Tuple_impl;

      typedef _Head_base<_Idx, _Head> _Base;

      static constexpr _Head&
      _M_head(_Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }

      static constexpr const _Head&
      _M_head(const _Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }

      constexpr _Tuple_impl()
      : _Base() { }

      explicit
      constexpr _Tuple_impl(const _Head& __head)
      : _Base(__head) { }

      template<typename _UHead>
        explicit
        constexpr _Tuple_impl(_UHead&& __head)
 : _Base(std::forward<_UHead>(__head)) { }

      constexpr _Tuple_impl(const _Tuple_impl&) = default;



      _Tuple_impl& operator=(const _Tuple_impl&) = delete;

      constexpr
      _Tuple_impl(_Tuple_impl&& __in)
      noexcept(is_nothrow_move_constructible<_Head>::value)
      : _Base(std::forward<_Head>(_M_head(__in))) { }

      template<typename _UHead>
        constexpr _Tuple_impl(const _Tuple_impl<_Idx, _UHead>& __in)
 : _Base(_Tuple_impl<_Idx, _UHead>::_M_head(__in)) { }

      template<typename _UHead>
        constexpr _Tuple_impl(_Tuple_impl<_Idx, _UHead>&& __in)
 : _Base(std::forward<_UHead>(_Tuple_impl<_Idx, _UHead>::_M_head(__in)))
 { }

      template<typename _Alloc>

 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a)
 : _Base(__tag, __use_alloc<_Head>(__a)) { }

      template<typename _Alloc>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
      const _Head& __head)
 : _Base(__use_alloc<_Head, _Alloc, _Head>(__a), __head) { }

      template<typename _Alloc, typename _UHead>

 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             _UHead&& __head)
 : _Base(__use_alloc<_Head, _Alloc, _UHead>(__a),
         std::forward<_UHead>(__head)) { }

      template<typename _Alloc>

        _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             const _Tuple_impl& __in)
 : _Base(__use_alloc<_Head, _Alloc, _Head>(__a), _M_head(__in)) { }

      template<typename _Alloc>

 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             _Tuple_impl&& __in)
 : _Base(__use_alloc<_Head, _Alloc, _Head>(__a),
         std::forward<_Head>(_M_head(__in))) { }

      template<typename _Alloc, typename _UHead>

 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             const _Tuple_impl<_Idx, _UHead>& __in)
 : _Base(__use_alloc<_Head, _Alloc, _Head>(__a),
  _Tuple_impl<_Idx, _UHead>::_M_head(__in)) { }

      template<typename _Alloc, typename _UHead>

 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             _Tuple_impl<_Idx, _UHead>&& __in)
 : _Base(__use_alloc<_Head, _Alloc, _UHead>(__a),
                std::forward<_UHead>(_Tuple_impl<_Idx, _UHead>::_M_head(__in)))
 { }

      template<typename _UHead>

        void
        _M_assign(const _Tuple_impl<_Idx, _UHead>& __in)
        {
   _M_head(*this) = _Tuple_impl<_Idx, _UHead>::_M_head(__in);
 }

      template<typename _UHead>

        void
        _M_assign(_Tuple_impl<_Idx, _UHead>&& __in)
        {
   _M_head(*this)
     = std::forward<_UHead>(_Tuple_impl<_Idx, _UHead>::_M_head(__in));
 }

    protected:
     
      void
      _M_swap(_Tuple_impl& __in)
      {
 using std::swap;
 swap(_M_head(*this), _M_head(__in));
      }
    };



  template<bool, typename... _Types>
    struct _TupleConstraints
    {



      template<typename... _UTypes>
 static constexpr bool __is_implicitly_constructible()
 {
   return __and_<is_constructible<_Types, _UTypes>...,
   is_convertible<_UTypes, _Types>...
   >::value;
 }




      template<typename... _UTypes>
 static constexpr bool __is_explicitly_constructible()
 {
   return __and_<is_constructible<_Types, _UTypes>...,
   __not_<__and_<is_convertible<_UTypes, _Types>...>>
   >::value;
 }

      static constexpr bool __is_implicitly_default_constructible()
      {
 return __and_<std::__is_implicitly_default_constructible<_Types>...
        >::value;
      }

      static constexpr bool __is_explicitly_default_constructible()
      {
 return __and_<is_default_constructible<_Types>...,
        __not_<__and_<
   std::__is_implicitly_default_constructible<_Types>...>
        >>::value;
      }
    };



  template<typename... _Types>
    struct _TupleConstraints<false, _Types...>
    {
      template<typename... _UTypes>
 static constexpr bool __is_implicitly_constructible()
 { return false; }

      template<typename... _UTypes>
 static constexpr bool __is_explicitly_constructible()
 { return false; }
    };


  template<typename... _Elements>
    class tuple : public _Tuple_impl<0, _Elements...>
    {
      typedef _Tuple_impl<0, _Elements...> _Inherited;

      template<bool _Cond>
 using _TCC = _TupleConstraints<_Cond, _Elements...>;


      template<bool _Dummy>
 using _ImplicitDefaultCtor = __enable_if_t<
   _TCC<_Dummy>::__is_implicitly_default_constructible(),
   bool>;


      template<bool _Dummy>
 using _ExplicitDefaultCtor = __enable_if_t<
   _TCC<_Dummy>::__is_explicitly_default_constructible(),
   bool>;


      template<bool _Cond, typename... _Args>
 using _ImplicitCtor = __enable_if_t<
   _TCC<_Cond>::template __is_implicitly_constructible<_Args...>(),
   bool>;


      template<bool _Cond, typename... _Args>
 using _ExplicitCtor = __enable_if_t<
   _TCC<_Cond>::template __is_explicitly_constructible<_Args...>(),
   bool>;

      template<typename... _UElements>
 static constexpr
 __enable_if_t<sizeof...(_UElements) == sizeof...(_Elements), bool>
 __assignable()
 { return __and_<is_assignable<_Elements&, _UElements>...>::value; }


      template<typename... _UElements>
 static constexpr bool __nothrow_assignable()
 {
   return
     __and_<is_nothrow_assignable<_Elements&, _UElements>...>::value;
 }


      template<typename... _UElements>
 static constexpr bool __nothrow_constructible()
 {
   return
     __and_<is_nothrow_constructible<_Elements, _UElements>...>::value;
 }


      template<typename _Up>
 static constexpr bool __valid_args()
 {
   return sizeof...(_Elements) == 1
     && !is_same<tuple, __remove_cvref_t<_Up>>::value;
 }


      template<typename, typename, typename... _Tail>
 static constexpr bool __valid_args()
 { return (sizeof...(_Tail) + 2) == sizeof...(_Elements); }
# 591 "/usr/include/c++/10.2.0/tuple" 3
      template<typename _Tuple, typename = tuple,
        typename = __remove_cvref_t<_Tuple>>
 struct _UseOtherCtor
 : false_type
 { };


      template<typename _Tuple, typename _Tp, typename _Up>
 struct _UseOtherCtor<_Tuple, tuple<_Tp>, tuple<_Up>>
 : __or_<is_convertible<_Tuple, _Tp>, is_constructible<_Tp, _Tuple>>
 { };


      template<typename _Tuple, typename _Tp>
 struct _UseOtherCtor<_Tuple, tuple<_Tp>, tuple<_Tp>>
 : true_type
 { };




      template<typename _Tuple>
 static constexpr bool __use_other_ctor()
 { return _UseOtherCtor<_Tuple>::value; }

    public:
      template<typename _Dummy = void,
        _ImplicitDefaultCtor<is_void<_Dummy>::value> = true>
 constexpr
 tuple()
 noexcept(__and_<is_nothrow_default_constructible<_Elements>...>::value)
 : _Inherited() { }

      template<typename _Dummy = void,
        _ExplicitDefaultCtor<is_void<_Dummy>::value> = false>
 explicit constexpr
 tuple()
 noexcept(__and_<is_nothrow_default_constructible<_Elements>...>::value)
 : _Inherited() { }

      template<bool _NotEmpty = (sizeof...(_Elements) >= 1),
        _ImplicitCtor<_NotEmpty, const _Elements&...> = true>
 constexpr
 tuple(const _Elements&... __elements)
 noexcept(__nothrow_constructible<const _Elements&...>())
 : _Inherited(__elements...) { }

      template<bool _NotEmpty = (sizeof...(_Elements) >= 1),
        _ExplicitCtor<_NotEmpty, const _Elements&...> = false>
 explicit constexpr
 tuple(const _Elements&... __elements)
 noexcept(__nothrow_constructible<const _Elements&...>())
 : _Inherited(__elements...) { }

      template<typename... _UElements,
        bool _Valid = __valid_args<_UElements...>(),
        _ImplicitCtor<_Valid, _UElements...> = true>
 constexpr
 tuple(_UElements&&... __elements)
 noexcept(__nothrow_constructible<_UElements...>())
 : _Inherited(std::forward<_UElements>(__elements)...) { }

      template<typename... _UElements,
        bool _Valid = __valid_args<_UElements...>(),
        _ExplicitCtor<_Valid, _UElements...> = false>
 explicit constexpr
 tuple(_UElements&&... __elements)
 noexcept(__nothrow_constructible<_UElements...>())
 : _Inherited(std::forward<_UElements>(__elements)...) { }

      constexpr tuple(const tuple&) = default;

      constexpr tuple(tuple&&) = default;

      template<typename... _UElements,
        bool _Valid = (sizeof...(_Elements) == sizeof...(_UElements))
      && !__use_other_ctor<const tuple<_UElements...>&>(),
        _ImplicitCtor<_Valid, const _UElements&...> = true>
 constexpr
 tuple(const tuple<_UElements...>& __in)
 noexcept(__nothrow_constructible<const _UElements&...>())
 : _Inherited(static_cast<const _Tuple_impl<0, _UElements...>&>(__in))
 { }

      template<typename... _UElements,
        bool _Valid = (sizeof...(_Elements) == sizeof...(_UElements))
      && !__use_other_ctor<const tuple<_UElements...>&>(),
        _ExplicitCtor<_Valid, const _UElements&...> = false>
 explicit constexpr
 tuple(const tuple<_UElements...>& __in)
 noexcept(__nothrow_constructible<const _UElements&...>())
 : _Inherited(static_cast<const _Tuple_impl<0, _UElements...>&>(__in))
 { }

      template<typename... _UElements,
        bool _Valid = (sizeof...(_Elements) == sizeof...(_UElements))
        && !__use_other_ctor<tuple<_UElements...>&&>(),
        _ImplicitCtor<_Valid, _UElements...> = true>
 constexpr
 tuple(tuple<_UElements...>&& __in)
 noexcept(__nothrow_constructible<_UElements...>())
 : _Inherited(static_cast<_Tuple_impl<0, _UElements...>&&>(__in)) { }

      template<typename... _UElements,
        bool _Valid = (sizeof...(_Elements) == sizeof...(_UElements))
        && !__use_other_ctor<tuple<_UElements...>&&>(),
        _ExplicitCtor<_Valid, _UElements...> = false>
 explicit constexpr
 tuple(tuple<_UElements...>&& __in)
 noexcept(__nothrow_constructible<_UElements...>())
 : _Inherited(static_cast<_Tuple_impl<0, _UElements...>&&>(__in)) { }



      template<typename _Alloc,
        _ImplicitDefaultCtor<is_object<_Alloc>::value> = true>

 tuple(allocator_arg_t __tag, const _Alloc& __a)
 : _Inherited(__tag, __a) { }

      template<typename _Alloc, bool _NotEmpty = (sizeof...(_Elements) >= 1),
        _ImplicitCtor<_NotEmpty, const _Elements&...> = true>

 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const _Elements&... __elements)
 : _Inherited(__tag, __a, __elements...) { }

      template<typename _Alloc, bool _NotEmpty = (sizeof...(_Elements) >= 1),
        _ExplicitCtor<_NotEmpty, const _Elements&...> = false>

 explicit
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const _Elements&... __elements)
 : _Inherited(__tag, __a, __elements...) { }

      template<typename _Alloc, typename... _UElements,
        bool _Valid = __valid_args<_UElements...>(),
        _ImplicitCtor<_Valid, _UElements...> = true>

 tuple(allocator_arg_t __tag, const _Alloc& __a,
       _UElements&&... __elements)
 : _Inherited(__tag, __a, std::forward<_UElements>(__elements)...)
 { }

      template<typename _Alloc, typename... _UElements,
   bool _Valid = __valid_args<_UElements...>(),
        _ExplicitCtor<_Valid, _UElements...> = false>

 explicit
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       _UElements&&... __elements)
 : _Inherited(__tag, __a, std::forward<_UElements>(__elements)...)
 { }

      template<typename _Alloc>

 tuple(allocator_arg_t __tag, const _Alloc& __a, const tuple& __in)
 : _Inherited(__tag, __a, static_cast<const _Inherited&>(__in)) { }

      template<typename _Alloc>

 tuple(allocator_arg_t __tag, const _Alloc& __a, tuple&& __in)
 : _Inherited(__tag, __a, static_cast<_Inherited&&>(__in)) { }

      template<typename _Alloc, typename... _UElements,
        bool _Valid = (sizeof...(_Elements) == sizeof...(_UElements))
        && !__use_other_ctor<const tuple<_UElements...>&>(),
        _ImplicitCtor<_Valid, const _UElements&...> = true>

 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const tuple<_UElements...>& __in)
 : _Inherited(__tag, __a,
              static_cast<const _Tuple_impl<0, _UElements...>&>(__in))
 { }

      template<typename _Alloc, typename... _UElements,
        bool _Valid = (sizeof...(_Elements) == sizeof...(_UElements))
        && !__use_other_ctor<const tuple<_UElements...>&>(),
        _ExplicitCtor<_Valid, const _UElements&...> = false>

 explicit
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const tuple<_UElements...>& __in)
 : _Inherited(__tag, __a,
              static_cast<const _Tuple_impl<0, _UElements...>&>(__in))
 { }

      template<typename _Alloc, typename... _UElements,
        bool _Valid = (sizeof...(_Elements) == sizeof...(_UElements))
        && !__use_other_ctor<tuple<_UElements...>&&>(),
        _ImplicitCtor<_Valid, _UElements...> = true>

 tuple(allocator_arg_t __tag, const _Alloc& __a,
       tuple<_UElements...>&& __in)
 : _Inherited(__tag, __a,
              static_cast<_Tuple_impl<0, _UElements...>&&>(__in))
 { }

      template<typename _Alloc, typename... _UElements,
        bool _Valid = (sizeof...(_Elements) == sizeof...(_UElements))
        && !__use_other_ctor<tuple<_UElements...>&&>(),
        _ExplicitCtor<_Valid, _UElements...> = false>

 explicit
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       tuple<_UElements...>&& __in)
 : _Inherited(__tag, __a,
              static_cast<_Tuple_impl<0, _UElements...>&&>(__in))
 { }



     
      tuple&
      operator=(typename conditional<__assignable<const _Elements&...>(),
         const tuple&,
         const __nonesuch&>::type __in)
      noexcept(__nothrow_assignable<const _Elements&...>())
      {
 this->_M_assign(__in);
 return *this;
      }

     
      tuple&
      operator=(typename conditional<__assignable<_Elements...>(),
         tuple&&,
         __nonesuch&&>::type __in)
      noexcept(__nothrow_assignable<_Elements...>())
      {
 this->_M_assign(std::move(__in));
 return *this;
      }

      template<typename... _UElements>

 __enable_if_t<__assignable<const _UElements&...>(), tuple&>
 operator=(const tuple<_UElements...>& __in)
 noexcept(__nothrow_assignable<const _UElements&...>())
 {
   this->_M_assign(__in);
   return *this;
 }

      template<typename... _UElements>

 __enable_if_t<__assignable<_UElements...>(), tuple&>
 operator=(tuple<_UElements...>&& __in)
 noexcept(__nothrow_assignable<_UElements...>())
 {
   this->_M_assign(std::move(__in));
   return *this;
 }


     
      void
      swap(tuple& __in)
      noexcept(__and_<__is_nothrow_swappable<_Elements>...>::value)
      { _Inherited::_M_swap(__in); }
    };
# 867 "/usr/include/c++/10.2.0/tuple" 3
  template<>
    class tuple<>
    {
    public:
      void swap(tuple&) noexcept { }


      tuple() = default;

      template<typename _Alloc>

 tuple(allocator_arg_t, const _Alloc&) noexcept { }
      template<typename _Alloc>

 tuple(allocator_arg_t, const _Alloc&, const tuple&) noexcept { }
    };



  template<typename _T1, typename _T2>
    class tuple<_T1, _T2> : public _Tuple_impl<0, _T1, _T2>
    {
      typedef _Tuple_impl<0, _T1, _T2> _Inherited;


      template<bool _Dummy, typename _U1, typename _U2>
 using _ImplicitDefaultCtor = __enable_if_t<
   _TupleConstraints<_Dummy, _U1, _U2>::
     __is_implicitly_default_constructible(),
   bool>;


      template<bool _Dummy, typename _U1, typename _U2>
 using _ExplicitDefaultCtor = __enable_if_t<
   _TupleConstraints<_Dummy, _U1, _U2>::
     __is_explicitly_default_constructible(),
   bool>;

      template<bool _Dummy>
 using _TCC = _TupleConstraints<_Dummy, _T1, _T2>;


      template<bool _Cond, typename _U1, typename _U2>
 using _ImplicitCtor = __enable_if_t<
   _TCC<_Cond>::template __is_implicitly_constructible<_U1, _U2>(),
   bool>;


      template<bool _Cond, typename _U1, typename _U2>
 using _ExplicitCtor = __enable_if_t<
   _TCC<_Cond>::template __is_explicitly_constructible<_U1, _U2>(),
   bool>;

      template<typename _U1, typename _U2>
 static constexpr bool __assignable()
 {
   return __and_<is_assignable<_T1&, _U1>,
   is_assignable<_T2&, _U2>>::value;
 }

      template<typename _U1, typename _U2>
 static constexpr bool __nothrow_assignable()
 {
   return __and_<is_nothrow_assignable<_T1&, _U1>,
   is_nothrow_assignable<_T2&, _U2>>::value;
 }

      template<typename _U1, typename _U2>
 static constexpr bool __nothrow_constructible()
 {
   return __and_<is_nothrow_constructible<_T1, _U1>,
       is_nothrow_constructible<_T2, _U2>>::value;
 }

      static constexpr bool __nothrow_default_constructible()
      {
 return __and_<is_nothrow_default_constructible<_T1>,
        is_nothrow_default_constructible<_T2>>::value;
      }

      template<typename _U1>
 static constexpr bool __is_alloc_arg()
 { return is_same<__remove_cvref_t<_U1>, allocator_arg_t>::value; }

    public:
      template<bool _Dummy = true,
        _ImplicitDefaultCtor<_Dummy, _T1, _T2> = true>
 constexpr
 tuple()
 noexcept(__nothrow_default_constructible())
 : _Inherited() { }

      template<bool _Dummy = true,
        _ExplicitDefaultCtor<_Dummy, _T1, _T2> = false>
 explicit constexpr
 tuple()
 noexcept(__nothrow_default_constructible())
 : _Inherited() { }

      template<bool _Dummy = true,
        _ImplicitCtor<_Dummy, const _T1&, const _T2&> = true>
 constexpr
 tuple(const _T1& __a1, const _T2& __a2)
 noexcept(__nothrow_constructible<const _T1&, const _T2&>())
 : _Inherited(__a1, __a2) { }

      template<bool _Dummy = true,
        _ExplicitCtor<_Dummy, const _T1&, const _T2&> = false>
 explicit constexpr
 tuple(const _T1& __a1, const _T2& __a2)
 noexcept(__nothrow_constructible<const _T1&, const _T2&>())
 : _Inherited(__a1, __a2) { }

      template<typename _U1, typename _U2,
        _ImplicitCtor<!__is_alloc_arg<_U1>(), _U1, _U2> = true>
 constexpr
 tuple(_U1&& __a1, _U2&& __a2)
 noexcept(__nothrow_constructible<_U1, _U2>())
 : _Inherited(std::forward<_U1>(__a1), std::forward<_U2>(__a2)) { }

      template<typename _U1, typename _U2,
        _ExplicitCtor<!__is_alloc_arg<_U1>(), _U1, _U2> = false>
 explicit constexpr
 tuple(_U1&& __a1, _U2&& __a2)
 noexcept(__nothrow_constructible<_U1, _U2>())
 : _Inherited(std::forward<_U1>(__a1), std::forward<_U2>(__a2)) { }

      constexpr tuple(const tuple&) = default;

      constexpr tuple(tuple&&) = default;

      template<typename _U1, typename _U2,
        _ImplicitCtor<true, const _U1&, const _U2&> = true>
 constexpr
 tuple(const tuple<_U1, _U2>& __in)
 noexcept(__nothrow_constructible<const _U1&, const _U2&>())
 : _Inherited(static_cast<const _Tuple_impl<0, _U1, _U2>&>(__in)) { }

      template<typename _U1, typename _U2,
        _ExplicitCtor<true, const _U1&, const _U2&> = false>
 explicit constexpr
 tuple(const tuple<_U1, _U2>& __in)
 noexcept(__nothrow_constructible<const _U1&, const _U2&>())
 : _Inherited(static_cast<const _Tuple_impl<0, _U1, _U2>&>(__in)) { }

      template<typename _U1, typename _U2,
        _ImplicitCtor<true, _U1, _U2> = true>
 constexpr
 tuple(tuple<_U1, _U2>&& __in)
 noexcept(__nothrow_constructible<_U1, _U2>())
 : _Inherited(static_cast<_Tuple_impl<0, _U1, _U2>&&>(__in)) { }

      template<typename _U1, typename _U2,
        _ExplicitCtor<true, _U1, _U2> = false>
 explicit constexpr
 tuple(tuple<_U1, _U2>&& __in)
 noexcept(__nothrow_constructible<_U1, _U2>())
 : _Inherited(static_cast<_Tuple_impl<0, _U1, _U2>&&>(__in)) { }

      template<typename _U1, typename _U2,
        _ImplicitCtor<true, const _U1&, const _U2&> = true>
 constexpr
 tuple(const pair<_U1, _U2>& __in)
 noexcept(__nothrow_constructible<const _U1&, const _U2&>())
 : _Inherited(__in.first, __in.second) { }

      template<typename _U1, typename _U2,
        _ExplicitCtor<true, const _U1&, const _U2&> = false>
 explicit constexpr
 tuple(const pair<_U1, _U2>& __in)
 noexcept(__nothrow_constructible<const _U1&, const _U2&>())
 : _Inherited(__in.first, __in.second) { }

      template<typename _U1, typename _U2,
        _ImplicitCtor<true, _U1, _U2> = true>
 constexpr
 tuple(pair<_U1, _U2>&& __in)
 noexcept(__nothrow_constructible<_U1, _U2>())
 : _Inherited(std::forward<_U1>(__in.first),
       std::forward<_U2>(__in.second)) { }

      template<typename _U1, typename _U2,
        _ExplicitCtor<true, _U1, _U2> = false>
 explicit constexpr
 tuple(pair<_U1, _U2>&& __in)
 noexcept(__nothrow_constructible<_U1, _U2>())
 : _Inherited(std::forward<_U1>(__in.first),
       std::forward<_U2>(__in.second)) { }



      template<typename _Alloc,
        _ImplicitDefaultCtor<is_object<_Alloc>::value, _T1, _T2> = true>

 tuple(allocator_arg_t __tag, const _Alloc& __a)
 : _Inherited(__tag, __a) { }

      template<typename _Alloc, bool _Dummy = true,
        _ImplicitCtor<_Dummy, const _T1&, const _T2&> = true>

 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const _T1& __a1, const _T2& __a2)
 : _Inherited(__tag, __a, __a1, __a2) { }

      template<typename _Alloc, bool _Dummy = true,
        _ExplicitCtor<_Dummy, const _T1&, const _T2&> = false>
 explicit

 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const _T1& __a1, const _T2& __a2)
 : _Inherited(__tag, __a, __a1, __a2) { }

      template<typename _Alloc, typename _U1, typename _U2,
        _ImplicitCtor<true, _U1, _U2> = true>

 tuple(allocator_arg_t __tag, const _Alloc& __a, _U1&& __a1, _U2&& __a2)
 : _Inherited(__tag, __a, std::forward<_U1>(__a1),
              std::forward<_U2>(__a2)) { }

      template<typename _Alloc, typename _U1, typename _U2,
        _ExplicitCtor<true, _U1, _U2> = false>
 explicit

 tuple(allocator_arg_t __tag, const _Alloc& __a,
       _U1&& __a1, _U2&& __a2)
 : _Inherited(__tag, __a, std::forward<_U1>(__a1),
              std::forward<_U2>(__a2)) { }

      template<typename _Alloc>

 tuple(allocator_arg_t __tag, const _Alloc& __a, const tuple& __in)
 : _Inherited(__tag, __a, static_cast<const _Inherited&>(__in)) { }

      template<typename _Alloc>

 tuple(allocator_arg_t __tag, const _Alloc& __a, tuple&& __in)
 : _Inherited(__tag, __a, static_cast<_Inherited&&>(__in)) { }

      template<typename _Alloc, typename _U1, typename _U2,
        _ImplicitCtor<true, const _U1&, const _U2&> = true>

 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const tuple<_U1, _U2>& __in)
 : _Inherited(__tag, __a,
              static_cast<const _Tuple_impl<0, _U1, _U2>&>(__in))
 { }

      template<typename _Alloc, typename _U1, typename _U2,
        _ExplicitCtor<true, const _U1&, const _U2&> = false>
 explicit

 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const tuple<_U1, _U2>& __in)
 : _Inherited(__tag, __a,
              static_cast<const _Tuple_impl<0, _U1, _U2>&>(__in))
 { }

      template<typename _Alloc, typename _U1, typename _U2,
        _ImplicitCtor<true, _U1, _U2> = true>

 tuple(allocator_arg_t __tag, const _Alloc& __a, tuple<_U1, _U2>&& __in)
 : _Inherited(__tag, __a, static_cast<_Tuple_impl<0, _U1, _U2>&&>(__in))
 { }

      template<typename _Alloc, typename _U1, typename _U2,
        _ExplicitCtor<true, _U1, _U2> = false>
 explicit

 tuple(allocator_arg_t __tag, const _Alloc& __a, tuple<_U1, _U2>&& __in)
 : _Inherited(__tag, __a, static_cast<_Tuple_impl<0, _U1, _U2>&&>(__in))
 { }

      template<typename _Alloc, typename _U1, typename _U2,
        _ImplicitCtor<true, const _U1&, const _U2&> = true>

 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const pair<_U1, _U2>& __in)
 : _Inherited(__tag, __a, __in.first, __in.second) { }

      template<typename _Alloc, typename _U1, typename _U2,
        _ExplicitCtor<true, const _U1&, const _U2&> = false>
 explicit

 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const pair<_U1, _U2>& __in)
 : _Inherited(__tag, __a, __in.first, __in.second) { }

      template<typename _Alloc, typename _U1, typename _U2,
        _ImplicitCtor<true, _U1, _U2> = true>

 tuple(allocator_arg_t __tag, const _Alloc& __a, pair<_U1, _U2>&& __in)
 : _Inherited(__tag, __a, std::forward<_U1>(__in.first),
       std::forward<_U2>(__in.second)) { }

      template<typename _Alloc, typename _U1, typename _U2,
        _ExplicitCtor<true, _U1, _U2> = false>
 explicit

 tuple(allocator_arg_t __tag, const _Alloc& __a, pair<_U1, _U2>&& __in)
 : _Inherited(__tag, __a, std::forward<_U1>(__in.first),
       std::forward<_U2>(__in.second)) { }



     
      tuple&
      operator=(typename conditional<__assignable<const _T1&, const _T2&>(),
         const tuple&,
         const __nonesuch&>::type __in)
      noexcept(__nothrow_assignable<const _T1&, const _T2&>())
      {
 this->_M_assign(__in);
 return *this;
      }

     
      tuple&
      operator=(typename conditional<__assignable<_T1, _T2>(),
         tuple&&,
         __nonesuch&&>::type __in)
      noexcept(__nothrow_assignable<_T1, _T2>())
      {
 this->_M_assign(std::move(__in));
 return *this;
      }

      template<typename _U1, typename _U2>

 __enable_if_t<__assignable<const _U1&, const _U2&>(), tuple&>
 operator=(const tuple<_U1, _U2>& __in)
 noexcept(__nothrow_assignable<const _U1&, const _U2&>())
 {
   this->_M_assign(__in);
   return *this;
 }

      template<typename _U1, typename _U2>

 __enable_if_t<__assignable<_U1, _U2>(), tuple&>
 operator=(tuple<_U1, _U2>&& __in)
 noexcept(__nothrow_assignable<_U1, _U2>())
 {
   this->_M_assign(std::move(__in));
   return *this;
 }

      template<typename _U1, typename _U2>

 __enable_if_t<__assignable<const _U1&, const _U2&>(), tuple&>
 operator=(const pair<_U1, _U2>& __in)
 noexcept(__nothrow_assignable<const _U1&, const _U2&>())
 {
   this->_M_head(*this) = __in.first;
   this->_M_tail(*this)._M_head(*this) = __in.second;
   return *this;
 }

      template<typename _U1, typename _U2>

 __enable_if_t<__assignable<_U1, _U2>(), tuple&>
 operator=(pair<_U1, _U2>&& __in)
 noexcept(__nothrow_assignable<_U1, _U2>())
 {
   this->_M_head(*this) = std::forward<_U1>(__in.first);
   this->_M_tail(*this)._M_head(*this) = std::forward<_U2>(__in.second);
   return *this;
 }

     
      void
      swap(tuple& __in)
      noexcept(__and_<__is_nothrow_swappable<_T1>,
        __is_nothrow_swappable<_T2>>::value)
      { _Inherited::_M_swap(__in); }
    };



  template<typename... _Elements>
    struct tuple_size<tuple<_Elements...>>
    : public integral_constant<std::size_t, sizeof...(_Elements)> { };
# 1258 "/usr/include/c++/10.2.0/tuple" 3
  template<std::size_t __i, typename _Head, typename... _Tail>
    struct tuple_element<__i, tuple<_Head, _Tail...> >
    : tuple_element<__i - 1, tuple<_Tail...> > { };




  template<typename _Head, typename... _Tail>
    struct tuple_element<0, tuple<_Head, _Tail...> >
    {
      typedef _Head type;
    };




  template<size_t __i>
    struct tuple_element<__i, tuple<>>
    {
      static_assert(__i < tuple_size<tuple<>>::value,
   "tuple index is in range");
    };

  template<std::size_t __i, typename _Head, typename... _Tail>
    constexpr _Head&
    __get_helper(_Tuple_impl<__i, _Head, _Tail...>& __t) noexcept
    { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }

  template<std::size_t __i, typename _Head, typename... _Tail>
    constexpr const _Head&
    __get_helper(const _Tuple_impl<__i, _Head, _Tail...>& __t) noexcept
    { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }


  template<std::size_t __i, typename... _Elements>
    constexpr __tuple_element_t<__i, tuple<_Elements...>>&
    get(tuple<_Elements...>& __t) noexcept
    { return std::__get_helper<__i>(__t); }


  template<std::size_t __i, typename... _Elements>
    constexpr const __tuple_element_t<__i, tuple<_Elements...>>&
    get(const tuple<_Elements...>& __t) noexcept
    { return std::__get_helper<__i>(__t); }


  template<std::size_t __i, typename... _Elements>
    constexpr __tuple_element_t<__i, tuple<_Elements...>>&&
    get(tuple<_Elements...>&& __t) noexcept
    {
      typedef __tuple_element_t<__i, tuple<_Elements...>> __element_type;
      return std::forward<__element_type&&>(std::get<__i>(__t));
    }


  template<std::size_t __i, typename... _Elements>
    constexpr const __tuple_element_t<__i, tuple<_Elements...>>&&
    get(const tuple<_Elements...>&& __t) noexcept
    {
      typedef __tuple_element_t<__i, tuple<_Elements...>> __element_type;
      return std::forward<const __element_type&&>(std::get<__i>(__t));
    }





  template<typename _Head, size_t __i, typename... _Tail>
    constexpr _Head&
    __get_helper2(_Tuple_impl<__i, _Head, _Tail...>& __t) noexcept
    { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }

  template<typename _Head, size_t __i, typename... _Tail>
    constexpr const _Head&
    __get_helper2(const _Tuple_impl<__i, _Head, _Tail...>& __t) noexcept
    { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }


  template <typename _Tp, typename... _Types>
    constexpr _Tp&
    get(tuple<_Types...>& __t) noexcept
    { return std::__get_helper2<_Tp>(__t); }


  template <typename _Tp, typename... _Types>
    constexpr _Tp&&
    get(tuple<_Types...>&& __t) noexcept
    { return std::forward<_Tp&&>(std::__get_helper2<_Tp>(__t)); }


  template <typename _Tp, typename... _Types>
    constexpr const _Tp&
    get(const tuple<_Types...>& __t) noexcept
    { return std::__get_helper2<_Tp>(__t); }



  template <typename _Tp, typename... _Types>
    constexpr const _Tp&&
    get(const tuple<_Types...>&& __t) noexcept
    { return std::forward<const _Tp&&>(std::__get_helper2<_Tp>(__t)); }



  template<typename _Tp, typename _Up, size_t __i, size_t __size>
    struct __tuple_compare
    {
      static constexpr bool
      __eq(const _Tp& __t, const _Up& __u)
      {
 return bool(std::get<__i>(__t) == std::get<__i>(__u))
   && __tuple_compare<_Tp, _Up, __i + 1, __size>::__eq(__t, __u);
      }

      static constexpr bool
      __less(const _Tp& __t, const _Up& __u)
      {
 return bool(std::get<__i>(__t) < std::get<__i>(__u))
   || (!bool(std::get<__i>(__u) < std::get<__i>(__t))
       && __tuple_compare<_Tp, _Up, __i + 1, __size>::__less(__t, __u));
      }
    };

  template<typename _Tp, typename _Up, size_t __size>
    struct __tuple_compare<_Tp, _Up, __size, __size>
    {
      static constexpr bool
      __eq(const _Tp&, const _Up&) { return true; }

      static constexpr bool
      __less(const _Tp&, const _Up&) { return false; }
    };

  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator==(const tuple<_TElements...>& __t,
        const tuple<_UElements...>& __u)
    {
      static_assert(sizeof...(_TElements) == sizeof...(_UElements),
   "tuple objects can only be compared if they have equal sizes.");
      using __compare = __tuple_compare<tuple<_TElements...>,
     tuple<_UElements...>,
     0, sizeof...(_TElements)>;
      return __compare::__eq(__t, __u);
    }
# 1433 "/usr/include/c++/10.2.0/tuple" 3
  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator<(const tuple<_TElements...>& __t,
       const tuple<_UElements...>& __u)
    {
      static_assert(sizeof...(_TElements) == sizeof...(_UElements),
   "tuple objects can only be compared if they have equal sizes.");
      using __compare = __tuple_compare<tuple<_TElements...>,
     tuple<_UElements...>,
     0, sizeof...(_TElements)>;
      return __compare::__less(__t, __u);
    }

  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator!=(const tuple<_TElements...>& __t,
        const tuple<_UElements...>& __u)
    { return !(__t == __u); }

  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator>(const tuple<_TElements...>& __t,
       const tuple<_UElements...>& __u)
    { return __u < __t; }

  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator<=(const tuple<_TElements...>& __t,
        const tuple<_UElements...>& __u)
    { return !(__u < __t); }

  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator>=(const tuple<_TElements...>& __t,
        const tuple<_UElements...>& __u)
    { return !(__t < __u); }



  template<typename... _Elements>
    constexpr tuple<typename __decay_and_strip<_Elements>::__type...>
    make_tuple(_Elements&&... __args)
    {
      typedef tuple<typename __decay_and_strip<_Elements>::__type...>
 __result_type;
      return __result_type(std::forward<_Elements>(__args)...);
    }




  template<typename... _Elements>
    constexpr tuple<_Elements&&...>
    forward_as_tuple(_Elements&&... __args) noexcept
    { return tuple<_Elements&&...>(std::forward<_Elements>(__args)...); }

  template<size_t, typename, typename, size_t>
    struct __make_tuple_impl;

  template<size_t _Idx, typename _Tuple, typename... _Tp, size_t _Nm>
    struct __make_tuple_impl<_Idx, tuple<_Tp...>, _Tuple, _Nm>
    : __make_tuple_impl<_Idx + 1,
   tuple<_Tp..., __tuple_element_t<_Idx, _Tuple>>,
   _Tuple, _Nm>
    { };

  template<std::size_t _Nm, typename _Tuple, typename... _Tp>
    struct __make_tuple_impl<_Nm, tuple<_Tp...>, _Tuple, _Nm>
    {
      typedef tuple<_Tp...> __type;
    };

  template<typename _Tuple>
    struct __do_make_tuple
    : __make_tuple_impl<0, tuple<>, _Tuple, std::tuple_size<_Tuple>::value>
    { };


  template<typename _Tuple>
    struct __make_tuple
    : public __do_make_tuple<__remove_cvref_t<_Tuple>>
    { };


  template<typename...>
    struct __combine_tuples;

  template<>
    struct __combine_tuples<>
    {
      typedef tuple<> __type;
    };

  template<typename... _Ts>
    struct __combine_tuples<tuple<_Ts...>>
    {
      typedef tuple<_Ts...> __type;
    };

  template<typename... _T1s, typename... _T2s, typename... _Rem>
    struct __combine_tuples<tuple<_T1s...>, tuple<_T2s...>, _Rem...>
    {
      typedef typename __combine_tuples<tuple<_T1s..., _T2s...>,
     _Rem...>::__type __type;
    };


  template<typename... _Tpls>
    struct __tuple_cat_result
    {
      typedef typename __combine_tuples
        <typename __make_tuple<_Tpls>::__type...>::__type __type;
    };



  template<typename...>
    struct __make_1st_indices;

  template<>
    struct __make_1st_indices<>
    {
      typedef std::_Index_tuple<> __type;
    };

  template<typename _Tp, typename... _Tpls>
    struct __make_1st_indices<_Tp, _Tpls...>
    {
      typedef typename std::_Build_index_tuple<std::tuple_size<
 typename std::remove_reference<_Tp>::type>::value>::__type __type;
    };




  template<typename _Ret, typename _Indices, typename... _Tpls>
    struct __tuple_concater;

  template<typename _Ret, std::size_t... _Is, typename _Tp, typename... _Tpls>
    struct __tuple_concater<_Ret, std::_Index_tuple<_Is...>, _Tp, _Tpls...>
    {
      template<typename... _Us>
        static constexpr _Ret
        _S_do(_Tp&& __tp, _Tpls&&... __tps, _Us&&... __us)
        {
   typedef typename __make_1st_indices<_Tpls...>::__type __idx;
   typedef __tuple_concater<_Ret, __idx, _Tpls...> __next;
   return __next::_S_do(std::forward<_Tpls>(__tps)...,
          std::forward<_Us>(__us)...,
          std::get<_Is>(std::forward<_Tp>(__tp))...);
 }
    };

  template<typename _Ret>
    struct __tuple_concater<_Ret, std::_Index_tuple<>>
    {
      template<typename... _Us>
 static constexpr _Ret
 _S_do(_Us&&... __us)
        {
   return _Ret(std::forward<_Us>(__us)...);
 }
    };


  template<typename... _Tpls, typename = typename
           enable_if<__and_<__is_tuple_like<_Tpls>...>::value>::type>
    constexpr auto
    tuple_cat(_Tpls&&... __tpls)
    -> typename __tuple_cat_result<_Tpls...>::__type
    {
      typedef typename __tuple_cat_result<_Tpls...>::__type __ret;
      typedef typename __make_1st_indices<_Tpls...>::__type __idx;
      typedef __tuple_concater<__ret, __idx, _Tpls...> __concater;
      return __concater::_S_do(std::forward<_Tpls>(__tpls)...);
    }




  template<typename... _Elements>
    constexpr tuple<_Elements&...>
    tie(_Elements&... __args) noexcept
    { return tuple<_Elements&...>(__args...); }


  template<typename... _Elements>
   
    inline


    typename enable_if<__and_<__is_swappable<_Elements>...>::value
      >::type



    swap(tuple<_Elements...>& __x, tuple<_Elements...>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }


  template<typename... _Elements>
   
    typename enable_if<!__and_<__is_swappable<_Elements>...>::value>::type
    swap(tuple<_Elements...>&, tuple<_Elements...>&) = delete;






  struct _Swallow_assign
  {
    template<class _Tp>
      constexpr const _Swallow_assign&
      operator=(const _Tp&) const
      { return *this; }
  };



  constexpr _Swallow_assign ignore{};


  template<typename... _Types, typename _Alloc>
    struct uses_allocator<tuple<_Types...>, _Alloc> : true_type { };
# 1669 "/usr/include/c++/10.2.0/tuple" 3
  template<class _T1, class _T2>
    template<typename... _Args1, typename... _Args2>
     
      inline
      pair<_T1, _T2>::
      pair(piecewise_construct_t,
    tuple<_Args1...> __first, tuple<_Args2...> __second)
      : pair(__first, __second,
      typename _Build_index_tuple<sizeof...(_Args1)>::__type(),
      typename _Build_index_tuple<sizeof...(_Args2)>::__type())
      { }

  template<class _T1, class _T2>
    template<typename... _Args1, std::size_t... _Indexes1,
             typename... _Args2, std::size_t... _Indexes2>
      inline
      pair<_T1, _T2>::
      pair(tuple<_Args1...>& __tuple1, tuple<_Args2...>& __tuple2,
    _Index_tuple<_Indexes1...>, _Index_tuple<_Indexes2...>)
      : first(std::forward<_Args1>(std::get<_Indexes1>(__tuple1))...),
        second(std::forward<_Args2>(std::get<_Indexes2>(__tuple2))...)
      { }
# 1759 "/usr/include/c++/10.2.0/tuple" 3

}
# 38 "/usr/include/c++/10.2.0/bits/unique_ptr.h" 2 3







namespace std __attribute__ ((__visibility__ ("default")))
{








#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
  template<typename> class auto_ptr;
#pragma GCC diagnostic pop



  template<typename _Tp>
    struct default_delete
    {

      constexpr default_delete() noexcept = default;






      template<typename _Up,
        typename = _Require<is_convertible<_Up*, _Tp*>>>
        default_delete(const default_delete<_Up>&) noexcept { }


      void
      operator()(_Tp* __ptr) const
      {
 static_assert(!is_void<_Tp>::value,
        "can't delete pointer to incomplete type");
 static_assert(sizeof(_Tp)>0,
        "can't delete pointer to incomplete type");
 delete __ptr;
      }
    };





  template<typename _Tp>
    struct default_delete<_Tp[]>
    {
    public:

      constexpr default_delete() noexcept = default;
# 109 "/usr/include/c++/10.2.0/bits/unique_ptr.h" 3
      template<typename _Up,
        typename = _Require<is_convertible<_Up(*)[], _Tp(*)[]>>>
        default_delete(const default_delete<_Up[]>&) noexcept { }


      template<typename _Up>
 typename enable_if<is_convertible<_Up(*)[], _Tp(*)[]>::value>::type
 operator()(_Up* __ptr) const
 {
   static_assert(sizeof(_Tp)>0,
   "can't delete pointer to incomplete type");
   delete [] __ptr;
 }
    };




  template <typename _Tp, typename _Dp>
    class __uniq_ptr_impl
    {
      template <typename _Up, typename _Ep, typename = void>
 struct _Ptr
 {
   using type = _Up*;
 };

      template <typename _Up, typename _Ep>
 struct
 _Ptr<_Up, _Ep, __void_t<typename remove_reference<_Ep>::type::pointer>>
 {
   using type = typename remove_reference<_Ep>::type::pointer;
 };

    public:
      using _DeleterConstraint = enable_if<
        __and_<__not_<is_pointer<_Dp>>,
        is_default_constructible<_Dp>>::value>;

      using pointer = typename _Ptr<_Tp, _Dp>::type;

      static_assert( !is_rvalue_reference<_Dp>::value,
       "unique_ptr's deleter type must be a function object type"
       " or an lvalue reference type" );

      __uniq_ptr_impl() = default;
      __uniq_ptr_impl(pointer __p) : _M_t() { _M_ptr() = __p; }

      template<typename _Del>
      __uniq_ptr_impl(pointer __p, _Del&& __d)
 : _M_t(__p, std::forward<_Del>(__d)) { }

      __uniq_ptr_impl(__uniq_ptr_impl&& __u) noexcept
      : _M_t(std::move(__u._M_t))
      { __u._M_ptr() = nullptr; }

      __uniq_ptr_impl& operator=(__uniq_ptr_impl&& __u) noexcept
      {
 reset(__u.release());
 _M_deleter() = std::forward<_Dp>(__u._M_deleter());
 return *this;
      }

      pointer& _M_ptr() { return std::get<0>(_M_t); }
      pointer _M_ptr() const { return std::get<0>(_M_t); }
      _Dp& _M_deleter() { return std::get<1>(_M_t); }
      const _Dp& _M_deleter() const { return std::get<1>(_M_t); }

      void reset(pointer __p) noexcept
      {
 const pointer __old_p = _M_ptr();
 _M_ptr() = __p;
 if (__old_p)
   _M_deleter()(__old_p);
      }

      pointer release() noexcept
      {
 pointer __p = _M_ptr();
 _M_ptr() = nullptr;
 return __p;
      }

      void
      swap(__uniq_ptr_impl& __rhs) noexcept
      {
 using std::swap;
 swap(this->_M_ptr(), __rhs._M_ptr());
 swap(this->_M_deleter(), __rhs._M_deleter());
      }

    private:
      tuple<pointer, _Dp> _M_t;
    };


  template <typename _Tp, typename _Dp,
     bool = is_move_constructible<_Dp>::value,
     bool = is_move_assignable<_Dp>::value>
    struct __uniq_ptr_data : __uniq_ptr_impl<_Tp, _Dp>
    {
      using __uniq_ptr_impl<_Tp, _Dp>::__uniq_ptr_impl;
      __uniq_ptr_data(__uniq_ptr_data&&) = default;
      __uniq_ptr_data& operator=(__uniq_ptr_data&&) = default;
    };

  template <typename _Tp, typename _Dp>
    struct __uniq_ptr_data<_Tp, _Dp, true, false> : __uniq_ptr_impl<_Tp, _Dp>
    {
      using __uniq_ptr_impl<_Tp, _Dp>::__uniq_ptr_impl;
      __uniq_ptr_data(__uniq_ptr_data&&) = default;
      __uniq_ptr_data& operator=(__uniq_ptr_data&&) = delete;
    };

  template <typename _Tp, typename _Dp>
    struct __uniq_ptr_data<_Tp, _Dp, false, true> : __uniq_ptr_impl<_Tp, _Dp>
    {
      using __uniq_ptr_impl<_Tp, _Dp>::__uniq_ptr_impl;
      __uniq_ptr_data(__uniq_ptr_data&&) = delete;
      __uniq_ptr_data& operator=(__uniq_ptr_data&&) = default;
    };

  template <typename _Tp, typename _Dp>
    struct __uniq_ptr_data<_Tp, _Dp, false, false> : __uniq_ptr_impl<_Tp, _Dp>
    {
      using __uniq_ptr_impl<_Tp, _Dp>::__uniq_ptr_impl;
      __uniq_ptr_data(__uniq_ptr_data&&) = delete;
      __uniq_ptr_data& operator=(__uniq_ptr_data&&) = delete;
    };



  template <typename _Tp, typename _Dp = default_delete<_Tp>>
    class unique_ptr
    {
      template <typename _Up>
 using _DeleterConstraint =
   typename __uniq_ptr_impl<_Tp, _Up>::_DeleterConstraint::type;

      __uniq_ptr_data<_Tp, _Dp> _M_t;

    public:
      using pointer = typename __uniq_ptr_impl<_Tp, _Dp>::pointer;
      using element_type = _Tp;
      using deleter_type = _Dp;

    private:


      template<typename _Up, typename _Ep>
 using __safe_conversion_up = __and_<
   is_convertible<typename unique_ptr<_Up, _Ep>::pointer, pointer>,
   __not_<is_array<_Up>>
        >;

    public:



      template<typename _Del = _Dp, typename = _DeleterConstraint<_Del>>
 constexpr unique_ptr() noexcept
 : _M_t()
 { }







      template<typename _Del = _Dp, typename = _DeleterConstraint<_Del>>
 explicit
 unique_ptr(pointer __p) noexcept
 : _M_t(__p)
        { }
# 292 "/usr/include/c++/10.2.0/bits/unique_ptr.h" 3
      template<typename _Del = deleter_type,
        typename = _Require<is_copy_constructible<_Del>>>
 unique_ptr(pointer __p, const deleter_type& __d) noexcept
 : _M_t(__p, __d) { }
# 304 "/usr/include/c++/10.2.0/bits/unique_ptr.h" 3
      template<typename _Del = deleter_type,
        typename = _Require<is_move_constructible<_Del>>>
 unique_ptr(pointer __p,
     __enable_if_t<!is_lvalue_reference<_Del>::value,
     _Del&&> __d) noexcept
 : _M_t(__p, std::move(__d))
 { }

      template<typename _Del = deleter_type,
        typename _DelUnref = typename remove_reference<_Del>::type>
 unique_ptr(pointer,
     __enable_if_t<is_lvalue_reference<_Del>::value,
     _DelUnref&&>) = delete;


      template<typename _Del = _Dp, typename = _DeleterConstraint<_Del>>
 constexpr unique_ptr(nullptr_t) noexcept
 : _M_t()
 { }




      unique_ptr(unique_ptr&&) = default;







      template<typename _Up, typename _Ep, typename = _Require<
               __safe_conversion_up<_Up, _Ep>,
        typename conditional<is_reference<_Dp>::value,
        is_same<_Ep, _Dp>,
        is_convertible<_Ep, _Dp>>::type>>
 unique_ptr(unique_ptr<_Up, _Ep>&& __u) noexcept
 : _M_t(__u.release(), std::forward<_Ep>(__u.get_deleter()))
 { }


#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

      template<typename _Up, typename = _Require<
        is_convertible<_Up*, _Tp*>, is_same<_Dp, default_delete<_Tp>>>>
 unique_ptr(auto_ptr<_Up>&& __u) noexcept;
#pragma GCC diagnostic pop



      ~unique_ptr() noexcept
      {
 static_assert(__is_invocable<deleter_type&, pointer>::value,
        "unique_ptr's deleter must be invocable with a pointer");
 auto& __ptr = _M_t._M_ptr();
 if (__ptr != nullptr)
   get_deleter()(std::move(__ptr));
 __ptr = pointer();
      }







      unique_ptr& operator=(unique_ptr&&) = default;
# 380 "/usr/include/c++/10.2.0/bits/unique_ptr.h" 3
      template<typename _Up, typename _Ep>
        typename enable_if< __and_<
          __safe_conversion_up<_Up, _Ep>,
          is_assignable<deleter_type&, _Ep&&>
          >::value,
          unique_ptr&>::type
 operator=(unique_ptr<_Up, _Ep>&& __u) noexcept
 {
   reset(__u.release());
   get_deleter() = std::forward<_Ep>(__u.get_deleter());
   return *this;
 }


      unique_ptr&
      operator=(nullptr_t) noexcept
      {
 reset();
 return *this;
      }




      typename add_lvalue_reference<element_type>::type
      operator*() const
      {
 ;
 return *get();
      }


      pointer
      operator->() const noexcept
      {
 ;
 return get();
      }


      pointer
      get() const noexcept
      { return _M_t._M_ptr(); }


      deleter_type&
      get_deleter() noexcept
      { return _M_t._M_deleter(); }


      const deleter_type&
      get_deleter() const noexcept
      { return _M_t._M_deleter(); }


      explicit operator bool() const noexcept
      { return get() == pointer() ? false : true; }




      pointer
      release() noexcept
      { return _M_t.release(); }







      void
      reset(pointer __p = pointer()) noexcept
      {
 static_assert(__is_invocable<deleter_type&, pointer>::value,
        "unique_ptr's deleter must be invocable with a pointer");
 _M_t.reset(std::move(__p));
      }


      void
      swap(unique_ptr& __u) noexcept
      {
 static_assert(__is_swappable<_Dp>::value, "deleter must be swappable");
 _M_t.swap(__u._M_t);
      }


      unique_ptr(const unique_ptr&) = delete;
      unique_ptr& operator=(const unique_ptr&) = delete;
  };





  template<typename _Tp, typename _Dp>
    class unique_ptr<_Tp[], _Dp>
    {
      template <typename _Up>
      using _DeleterConstraint =
 typename __uniq_ptr_impl<_Tp, _Up>::_DeleterConstraint::type;

      __uniq_ptr_data<_Tp, _Dp> _M_t;

      template<typename _Up>
 using __remove_cv = typename remove_cv<_Up>::type;


      template<typename _Up>
 using __is_derived_Tp
   = __and_< is_base_of<_Tp, _Up>,
      __not_<is_same<__remove_cv<_Tp>, __remove_cv<_Up>>> >;

    public:
      using pointer = typename __uniq_ptr_impl<_Tp, _Dp>::pointer;
      using element_type = _Tp;
      using deleter_type = _Dp;



      template<typename _Up, typename _Ep,
               typename _UPtr = unique_ptr<_Up, _Ep>,
        typename _UP_pointer = typename _UPtr::pointer,
        typename _UP_element_type = typename _UPtr::element_type>
 using __safe_conversion_up = __and_<
          is_array<_Up>,
          is_same<pointer, element_type*>,
          is_same<_UP_pointer, _UP_element_type*>,
          is_convertible<_UP_element_type(*)[], element_type(*)[]>
        >;


      template<typename _Up>
        using __safe_conversion_raw = __and_<
          __or_<__or_<is_same<_Up, pointer>,
                      is_same<_Up, nullptr_t>>,
                __and_<is_pointer<_Up>,
                       is_same<pointer, element_type*>,
                       is_convertible<
                         typename remove_pointer<_Up>::type(*)[],
                         element_type(*)[]>
                >
          >
        >;




      template<typename _Del = _Dp, typename = _DeleterConstraint<_Del>>
 constexpr unique_ptr() noexcept
 : _M_t()
 { }
# 541 "/usr/include/c++/10.2.0/bits/unique_ptr.h" 3
      template<typename _Up,
        typename _Vp = _Dp,
        typename = _DeleterConstraint<_Vp>,
        typename = typename enable_if<
                 __safe_conversion_raw<_Up>::value, bool>::type>
 explicit
 unique_ptr(_Up __p) noexcept
 : _M_t(__p)
        { }
# 559 "/usr/include/c++/10.2.0/bits/unique_ptr.h" 3
      template<typename _Up, typename _Del = deleter_type,
        typename = _Require<__safe_conversion_raw<_Up>,
       is_copy_constructible<_Del>>>
      unique_ptr(_Up __p, const deleter_type& __d) noexcept
      : _M_t(__p, __d) { }
# 573 "/usr/include/c++/10.2.0/bits/unique_ptr.h" 3
      template<typename _Up, typename _Del = deleter_type,
        typename = _Require<__safe_conversion_raw<_Up>,
       is_move_constructible<_Del>>>
 unique_ptr(_Up __p,
     __enable_if_t<!is_lvalue_reference<_Del>::value,
     _Del&&> __d) noexcept
 : _M_t(std::move(__p), std::move(__d))
 { }

      template<typename _Up, typename _Del = deleter_type,
        typename _DelUnref = typename remove_reference<_Del>::type,
        typename = _Require<__safe_conversion_raw<_Up>>>
 unique_ptr(_Up,
     __enable_if_t<is_lvalue_reference<_Del>::value,
     _DelUnref&&>) = delete;


      unique_ptr(unique_ptr&&) = default;


      template<typename _Del = _Dp, typename = _DeleterConstraint<_Del>>
 constexpr unique_ptr(nullptr_t) noexcept
 : _M_t()
        { }

      template<typename _Up, typename _Ep, typename = _Require<
        __safe_conversion_up<_Up, _Ep>,
        typename conditional<is_reference<_Dp>::value,
        is_same<_Ep, _Dp>,
        is_convertible<_Ep, _Dp>>::type>>
 unique_ptr(unique_ptr<_Up, _Ep>&& __u) noexcept
 : _M_t(__u.release(), std::forward<_Ep>(__u.get_deleter()))
 { }


      ~unique_ptr()
      {
 auto& __ptr = _M_t._M_ptr();
 if (__ptr != nullptr)
   get_deleter()(__ptr);
 __ptr = pointer();
      }







      unique_ptr&
      operator=(unique_ptr&&) = default;
# 632 "/usr/include/c++/10.2.0/bits/unique_ptr.h" 3
      template<typename _Up, typename _Ep>
 typename
 enable_if<__and_<__safe_conversion_up<_Up, _Ep>,
                         is_assignable<deleter_type&, _Ep&&>
                  >::value,
                  unique_ptr&>::type
 operator=(unique_ptr<_Up, _Ep>&& __u) noexcept
 {
   reset(__u.release());
   get_deleter() = std::forward<_Ep>(__u.get_deleter());
   return *this;
 }


      unique_ptr&
      operator=(nullptr_t) noexcept
      {
 reset();
 return *this;
      }




      typename std::add_lvalue_reference<element_type>::type
      operator[](size_t __i) const
      {
 ;
 return get()[__i];
      }


      pointer
      get() const noexcept
      { return _M_t._M_ptr(); }


      deleter_type&
      get_deleter() noexcept
      { return _M_t._M_deleter(); }


      const deleter_type&
      get_deleter() const noexcept
      { return _M_t._M_deleter(); }


      explicit operator bool() const noexcept
      { return get() == pointer() ? false : true; }




      pointer
      release() noexcept
      { return _M_t.release(); }







      template <typename _Up,
                typename = _Require<
                  __or_<is_same<_Up, pointer>,
                        __and_<is_same<pointer, element_type*>,
                               is_pointer<_Up>,
                               is_convertible<
                                 typename remove_pointer<_Up>::type(*)[],
                                 element_type(*)[]
                               >
                        >
                  >
               >>
      void
      reset(_Up __p) noexcept
      { _M_t.reset(std::move(__p)); }

      void reset(nullptr_t = nullptr) noexcept
      { reset(pointer()); }


      void
      swap(unique_ptr& __u) noexcept
      {
 static_assert(__is_swappable<_Dp>::value, "deleter must be swappable");
 _M_t.swap(__u._M_t);
      }


      unique_ptr(const unique_ptr&) = delete;
      unique_ptr& operator=(const unique_ptr&) = delete;
    };




  template<typename _Tp, typename _Dp>
    inline


    typename enable_if<__is_swappable<_Dp>::value>::type



    swap(unique_ptr<_Tp, _Dp>& __x,
  unique_ptr<_Tp, _Dp>& __y) noexcept
    { __x.swap(__y); }


  template<typename _Tp, typename _Dp>
    typename enable_if<!__is_swappable<_Dp>::value>::type
    swap(unique_ptr<_Tp, _Dp>&,
  unique_ptr<_Tp, _Dp>&) = delete;



  template<typename _Tp, typename _Dp,
    typename _Up, typename _Ep>
    inline bool
    operator==(const unique_ptr<_Tp, _Dp>& __x,
        const unique_ptr<_Up, _Ep>& __y)
    { return __x.get() == __y.get(); }


  template<typename _Tp, typename _Dp>
    inline bool
    operator==(const unique_ptr<_Tp, _Dp>& __x, nullptr_t) noexcept
    { return !__x; }



  template<typename _Tp, typename _Dp>
    inline bool
    operator==(nullptr_t, const unique_ptr<_Tp, _Dp>& __x) noexcept
    { return !__x; }


  template<typename _Tp, typename _Dp,
    typename _Up, typename _Ep>
    inline bool
    operator!=(const unique_ptr<_Tp, _Dp>& __x,
        const unique_ptr<_Up, _Ep>& __y)
    { return __x.get() != __y.get(); }


  template<typename _Tp, typename _Dp>
    inline bool
    operator!=(const unique_ptr<_Tp, _Dp>& __x, nullptr_t) noexcept
    { return (bool)__x; }


  template<typename _Tp, typename _Dp>
    inline bool
    operator!=(nullptr_t, const unique_ptr<_Tp, _Dp>& __x) noexcept
    { return (bool)__x; }



  template<typename _Tp, typename _Dp,
    typename _Up, typename _Ep>
    inline bool
    operator<(const unique_ptr<_Tp, _Dp>& __x,
       const unique_ptr<_Up, _Ep>& __y)
    {
      typedef typename
 std::common_type<typename unique_ptr<_Tp, _Dp>::pointer,
                  typename unique_ptr<_Up, _Ep>::pointer>::type _CT;
      return std::less<_CT>()(__x.get(), __y.get());
    }


  template<typename _Tp, typename _Dp>
    inline bool
    operator<(const unique_ptr<_Tp, _Dp>& __x, nullptr_t)
    {
      return std::less<typename unique_ptr<_Tp, _Dp>::pointer>()(__x.get(),
         nullptr);
    }


  template<typename _Tp, typename _Dp>
    inline bool
    operator<(nullptr_t, const unique_ptr<_Tp, _Dp>& __x)
    {
      return std::less<typename unique_ptr<_Tp, _Dp>::pointer>()(nullptr,
         __x.get());
    }


  template<typename _Tp, typename _Dp,
    typename _Up, typename _Ep>
    inline bool
    operator<=(const unique_ptr<_Tp, _Dp>& __x,
        const unique_ptr<_Up, _Ep>& __y)
    { return !(__y < __x); }


  template<typename _Tp, typename _Dp>
    inline bool
    operator<=(const unique_ptr<_Tp, _Dp>& __x, nullptr_t)
    { return !(nullptr < __x); }


  template<typename _Tp, typename _Dp>
    inline bool
    operator<=(nullptr_t, const unique_ptr<_Tp, _Dp>& __x)
    { return !(__x < nullptr); }


  template<typename _Tp, typename _Dp,
    typename _Up, typename _Ep>
    inline bool
    operator>(const unique_ptr<_Tp, _Dp>& __x,
       const unique_ptr<_Up, _Ep>& __y)
    { return (__y < __x); }


  template<typename _Tp, typename _Dp>
    inline bool
    operator>(const unique_ptr<_Tp, _Dp>& __x, nullptr_t)
    {
      return std::less<typename unique_ptr<_Tp, _Dp>::pointer>()(nullptr,
         __x.get());
    }


  template<typename _Tp, typename _Dp>
    inline bool
    operator>(nullptr_t, const unique_ptr<_Tp, _Dp>& __x)
    {
      return std::less<typename unique_ptr<_Tp, _Dp>::pointer>()(__x.get(),
         nullptr);
    }


  template<typename _Tp, typename _Dp,
    typename _Up, typename _Ep>
    inline bool
    operator>=(const unique_ptr<_Tp, _Dp>& __x,
        const unique_ptr<_Up, _Ep>& __y)
    { return !(__x < __y); }


  template<typename _Tp, typename _Dp>
    inline bool
    operator>=(const unique_ptr<_Tp, _Dp>& __x, nullptr_t)
    { return !(__x < nullptr); }


  template<typename _Tp, typename _Dp>
    inline bool
    operator>=(nullptr_t, const unique_ptr<_Tp, _Dp>& __x)
    { return !(nullptr < __x); }
# 912 "/usr/include/c++/10.2.0/bits/unique_ptr.h" 3
  template<typename _Up, typename _Ptr = typename _Up::pointer,
    bool = __poison_hash<_Ptr>::__enable_hash_call>
    struct __uniq_ptr_hash

    : private __poison_hash<_Ptr>

    {
      size_t
      operator()(const _Up& __u) const
      noexcept(noexcept(std::declval<hash<_Ptr>>()(std::declval<_Ptr>())))
      { return hash<_Ptr>()(__u.get()); }
    };

  template<typename _Up, typename _Ptr>
    struct __uniq_ptr_hash<_Up, _Ptr, false>
    : private __poison_hash<_Ptr>
    { };



  template<typename _Tp, typename _Dp>
    struct hash<unique_ptr<_Tp, _Dp>>
    : public __hash_base<size_t, unique_ptr<_Tp, _Dp>>,
      public __uniq_ptr_hash<unique_ptr<_Tp, _Dp>>
    { };







  template<typename _Tp>
    struct _MakeUniq
    { typedef unique_ptr<_Tp> __single_object; };

  template<typename _Tp>
    struct _MakeUniq<_Tp[]>
    { typedef unique_ptr<_Tp[]> __array; };

  template<typename _Tp, size_t _Bound>
    struct _MakeUniq<_Tp[_Bound]>
    { struct __invalid_type { }; };




  template<typename _Tp, typename... _Args>
    inline typename _MakeUniq<_Tp>::__single_object
    make_unique(_Args&&... __args)
    { return unique_ptr<_Tp>(new _Tp(std::forward<_Args>(__args)...)); }


  template<typename _Tp>
    inline typename _MakeUniq<_Tp>::__array
    make_unique(size_t __num)
    { return unique_ptr<_Tp>(new remove_extent_t<_Tp>[__num]()); }


  template<typename _Tp, typename... _Args>
    inline typename _MakeUniq<_Tp>::__invalid_type
    make_unique(_Args&&...) = delete;
# 1008 "/usr/include/c++/10.2.0/bits/unique_ptr.h" 3

}
# 42 "/usr/include/c++/10.2.0/bits/locale_conv.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{







  template<typename _OutStr, typename _InChar, typename _Codecvt,
    typename _State, typename _Fn>
    bool
    __do_str_codecvt(const _InChar* __first, const _InChar* __last,
       _OutStr& __outstr, const _Codecvt& __cvt, _State& __state,
       size_t& __count, _Fn __fn)
    {
      if (__first == __last)
 {
   __outstr.clear();
   __count = 0;
   return true;
 }

      size_t __outchars = 0;
      auto __next = __first;
      const auto __maxlen = __cvt.max_length() + 1;

      codecvt_base::result __result;
      do
 {
   __outstr.resize(__outstr.size() + (__last - __next) * __maxlen);
   auto __outnext = &__outstr.front() + __outchars;
   auto const __outlast = &__outstr.back() + 1;
   __result = (__cvt.*__fn)(__state, __next, __last, __next,
     __outnext, __outlast, __outnext);
   __outchars = __outnext - &__outstr.front();
 }
      while (__result == codecvt_base::partial && __next != __last
      && (__outstr.size() - __outchars) < __maxlen);

      if (__result == codecvt_base::error)
 {
   __count = __next - __first;
   return false;
 }



      if (is_same<typename _Codecvt::intern_type,
           typename _Codecvt::extern_type>())
 if (__result == codecvt_base::noconv)
   {
     __outstr.assign(__first, __last);
     __count = __last - __first;
     return true;
   }

      __outstr.resize(__outchars);
      __count = __next - __first;
      return true;
    }


  template<typename _CharT, typename _Traits, typename _Alloc, typename _State>
    inline bool
    __str_codecvt_in(const char* __first, const char* __last,
       basic_string<_CharT, _Traits, _Alloc>& __outstr,
       const codecvt<_CharT, char, _State>& __cvt,
       _State& __state, size_t& __count)
    {
      using _Codecvt = codecvt<_CharT, char, _State>;
      using _ConvFn
 = codecvt_base::result
   (_Codecvt::*)(_State&, const char*, const char*, const char*&,
   _CharT*, _CharT*, _CharT*&) const;
      _ConvFn __fn = &codecvt<_CharT, char, _State>::in;
      return __do_str_codecvt(__first, __last, __outstr, __cvt, __state,
         __count, __fn);
    }


  template<typename _CharT, typename _Traits, typename _Alloc, typename _State>
    inline bool
    __str_codecvt_in(const char* __first, const char* __last,
       basic_string<_CharT, _Traits, _Alloc>& __outstr,
       const codecvt<_CharT, char, _State>& __cvt)
    {
      _State __state = {};
      size_t __n;
      return __str_codecvt_in(__first, __last, __outstr, __cvt, __state, __n);
    }


  template<typename _CharT, typename _Traits, typename _Alloc, typename _State>
    inline bool
    __str_codecvt_in_all(const char* __first, const char* __last,
    basic_string<_CharT, _Traits, _Alloc>& __outstr,
    const codecvt<_CharT, char, _State>& __cvt)
    {
      _State __state = {};
      size_t __n;
      return __str_codecvt_in(__first, __last, __outstr, __cvt, __state, __n)
 && (__n == (__last - __first));
    }


  template<typename _CharT, typename _Traits, typename _Alloc, typename _State>
    inline bool
    __str_codecvt_out(const _CharT* __first, const _CharT* __last,
        basic_string<char, _Traits, _Alloc>& __outstr,
        const codecvt<_CharT, char, _State>& __cvt,
        _State& __state, size_t& __count)
    {
      using _Codecvt = codecvt<_CharT, char, _State>;
      using _ConvFn
 = codecvt_base::result
   (_Codecvt::*)(_State&, const _CharT*, const _CharT*, const _CharT*&,
   char*, char*, char*&) const;
      _ConvFn __fn = &codecvt<_CharT, char, _State>::out;
      return __do_str_codecvt(__first, __last, __outstr, __cvt, __state,
         __count, __fn);
    }


  template<typename _CharT, typename _Traits, typename _Alloc, typename _State>
    inline bool
    __str_codecvt_out(const _CharT* __first, const _CharT* __last,
        basic_string<char, _Traits, _Alloc>& __outstr,
        const codecvt<_CharT, char, _State>& __cvt)
    {
      _State __state = {};
      size_t __n;
      return __str_codecvt_out(__first, __last, __outstr, __cvt, __state, __n);
    }


  template<typename _CharT, typename _Traits, typename _Alloc, typename _State>
    inline bool
    __str_codecvt_out_all(const _CharT* __first, const _CharT* __last,
     basic_string<char, _Traits, _Alloc>& __outstr,
     const codecvt<_CharT, char, _State>& __cvt)
    {
      _State __state = {};
      size_t __n;
      return __str_codecvt_out(__first, __last, __outstr, __cvt, __state, __n)
 && (__n == (__last - __first));
    }
# 226 "/usr/include/c++/10.2.0/bits/locale_conv.h" 3
namespace __cxx11 {


  template<typename _Codecvt, typename _Elem = wchar_t,
    typename _Wide_alloc = allocator<_Elem>,
    typename _Byte_alloc = allocator<char>>
    class wstring_convert
    {
    public:
      typedef basic_string<char, char_traits<char>, _Byte_alloc> byte_string;
      typedef basic_string<_Elem, char_traits<_Elem>, _Wide_alloc> wide_string;
      typedef typename _Codecvt::state_type state_type;
      typedef typename wide_string::traits_type::int_type int_type;


      wstring_convert() : _M_cvt(new _Codecvt()) { }







      explicit
      wstring_convert(_Codecvt* __pcvt) : _M_cvt(__pcvt)
      {
 if (!_M_cvt)
   __throw_logic_error("wstring_convert");
      }
# 264 "/usr/include/c++/10.2.0/bits/locale_conv.h" 3
      wstring_convert(_Codecvt* __pcvt, state_type __state)
      : _M_cvt(__pcvt), _M_state(__state), _M_with_cvtstate(true)
      {
 if (!_M_cvt)
   __throw_logic_error("wstring_convert");
      }






      explicit
      wstring_convert(const byte_string& __byte_err,
        const wide_string& __wide_err = wide_string())
      : _M_cvt(new _Codecvt),
 _M_byte_err_string(__byte_err), _M_wide_err_string(__wide_err),
 _M_with_strings(true)
      {
 if (!_M_cvt)
   __throw_logic_error("wstring_convert");
      }

      ~wstring_convert() = default;



      wstring_convert(const wstring_convert&) = delete;
      wstring_convert& operator=(const wstring_convert&) = delete;


      wide_string
      from_bytes(char __byte)
      {
 char __bytes[2] = { __byte };
 return from_bytes(__bytes, __bytes+1);
      }

      wide_string
      from_bytes(const char* __ptr)
      { return from_bytes(__ptr, __ptr+char_traits<char>::length(__ptr)); }

      wide_string
      from_bytes(const byte_string& __str)
      {
 auto __ptr = __str.data();
 return from_bytes(__ptr, __ptr + __str.size());
      }

      wide_string
      from_bytes(const char* __first, const char* __last)
      {
 if (!_M_with_cvtstate)
   _M_state = state_type();
 wide_string __out{ _M_wide_err_string.get_allocator() };
 if (__str_codecvt_in(__first, __last, __out, *_M_cvt, _M_state,
        _M_count))
   return __out;
 if (_M_with_strings)
   return _M_wide_err_string;
 __throw_range_error("wstring_convert::from_bytes");
      }



      byte_string
      to_bytes(_Elem __wchar)
      {
 _Elem __wchars[2] = { __wchar };
 return to_bytes(__wchars, __wchars+1);
      }

      byte_string
      to_bytes(const _Elem* __ptr)
      {
 return to_bytes(__ptr, __ptr+wide_string::traits_type::length(__ptr));
      }

      byte_string
      to_bytes(const wide_string& __wstr)
      {
 auto __ptr = __wstr.data();
 return to_bytes(__ptr, __ptr + __wstr.size());
      }

      byte_string
      to_bytes(const _Elem* __first, const _Elem* __last)
      {
 if (!_M_with_cvtstate)
   _M_state = state_type();
 byte_string __out{ _M_byte_err_string.get_allocator() };
 if (__str_codecvt_out(__first, __last, __out, *_M_cvt, _M_state,
         _M_count))
   return __out;
 if (_M_with_strings)
   return _M_byte_err_string;
 __throw_range_error("wstring_convert::to_bytes");
      }





      size_t converted() const noexcept { return _M_count; }


      state_type state() const { return _M_state; }

    private:
      unique_ptr<_Codecvt> _M_cvt;
      byte_string _M_byte_err_string;
      wide_string _M_wide_err_string;
      state_type _M_state = state_type();
      size_t _M_count = 0;
      bool _M_with_cvtstate = false;
      bool _M_with_strings = false;
    };

}


  template<typename _Codecvt, typename _Elem = wchar_t,
    typename _Tr = char_traits<_Elem>>
    class wbuffer_convert : public basic_streambuf<_Elem, _Tr>
    {
      typedef basic_streambuf<_Elem, _Tr> _Wide_streambuf;

    public:
      typedef typename _Codecvt::state_type state_type;


      wbuffer_convert() : wbuffer_convert(nullptr) { }
# 405 "/usr/include/c++/10.2.0/bits/locale_conv.h" 3
      explicit
      wbuffer_convert(streambuf* __bytebuf, _Codecvt* __pcvt = new _Codecvt,
        state_type __state = state_type())
      : _M_buf(__bytebuf), _M_cvt(__pcvt), _M_state(__state)
      {
 if (!_M_cvt)
   __throw_logic_error("wbuffer_convert");

 _M_always_noconv = _M_cvt->always_noconv();

 if (_M_buf)
   {
     this->setp(_M_put_area, _M_put_area + _S_buffer_length);
     this->setg(_M_get_area + _S_putback_length,
         _M_get_area + _S_putback_length,
         _M_get_area + _S_putback_length);
   }
      }

      ~wbuffer_convert() = default;



      wbuffer_convert(const wbuffer_convert&) = delete;
      wbuffer_convert& operator=(const wbuffer_convert&) = delete;

      streambuf* rdbuf() const noexcept { return _M_buf; }

      streambuf*
      rdbuf(streambuf *__bytebuf) noexcept
      {
 auto __prev = _M_buf;
 _M_buf = __bytebuf;
 return __prev;
      }


      state_type state() const noexcept { return _M_state; }

    protected:
      int
      sync()
      { return _M_buf && _M_conv_put() && !_M_buf->pubsync() ? 0 : -1; }

      typename _Wide_streambuf::int_type
      overflow(typename _Wide_streambuf::int_type __out)
      {
 if (!_M_buf || !_M_conv_put())
   return _Tr::eof();
 else if (!_Tr::eq_int_type(__out, _Tr::eof()))
   return this->sputc(__out);
 return _Tr::not_eof(__out);
      }

      typename _Wide_streambuf::int_type
      underflow()
      {
 if (!_M_buf)
   return _Tr::eof();

 if (this->gptr() < this->egptr() || (_M_buf && _M_conv_get()))
   return _Tr::to_int_type(*this->gptr());
 else
   return _Tr::eof();
      }

      streamsize
      xsputn(const typename _Wide_streambuf::char_type* __s, streamsize __n)
      {
 if (!_M_buf || __n == 0)
   return 0;
 streamsize __done = 0;
 do
 {
   auto __nn = std::min<streamsize>(this->epptr() - this->pptr(),
        __n - __done);
   _Tr::copy(this->pptr(), __s + __done, __nn);
   this->pbump(__nn);
   __done += __nn;
 } while (__done < __n && _M_conv_put());
 return __done;
      }

    private:

      bool
      _M_conv_get()
      {
 const streamsize __pb1 = this->gptr() - this->eback();
 const streamsize __pb2 = _S_putback_length;
 const streamsize __npb = std::min(__pb1, __pb2);

 _Tr::move(_M_get_area + _S_putback_length - __npb,
    this->gptr() - __npb, __npb);

 streamsize __nbytes = sizeof(_M_get_buf) - _M_unconv;
 __nbytes = std::min(__nbytes, _M_buf->in_avail());
 if (__nbytes < 1)
   __nbytes = 1;
 __nbytes = _M_buf->sgetn(_M_get_buf + _M_unconv, __nbytes);
 if (__nbytes < 1)
   return false;
 __nbytes += _M_unconv;



 _Elem* __outbuf = _M_get_area + _S_putback_length;
 _Elem* __outnext = __outbuf;
 const char* __bnext = _M_get_buf;

 codecvt_base::result __result;
 if (_M_always_noconv)
   __result = codecvt_base::noconv;
 else
   {
     _Elem* __outend = _M_get_area + _S_buffer_length;

     __result = _M_cvt->in(_M_state,
      __bnext, __bnext + __nbytes, __bnext,
      __outbuf, __outend, __outnext);
   }

 if (__result == codecvt_base::noconv)
   {

     auto __get_buf = reinterpret_cast<const _Elem*>(_M_get_buf);
     _Tr::copy(__outbuf, __get_buf, __nbytes);
     _M_unconv = 0;
     return true;
   }

 if ((_M_unconv = _M_get_buf + __nbytes - __bnext))
   char_traits<char>::move(_M_get_buf, __bnext, _M_unconv);

 this->setg(__outbuf, __outbuf, __outnext);

 return __result != codecvt_base::error;
      }


      bool
      _M_put(...)
      { return false; }

      bool
      _M_put(const char* __p, streamsize __n)
      {
 if (_M_buf->sputn(__p, __n) < __n)
   return false;
 return true;
      }


      bool
      _M_conv_put()
      {
 _Elem* const __first = this->pbase();
 const _Elem* const __last = this->pptr();
 const streamsize __pending = __last - __first;

 if (_M_always_noconv)
   return _M_put(__first, __pending);

 char __outbuf[2 * _S_buffer_length];

 const _Elem* __next = __first;
 const _Elem* __start;
 do
   {
     __start = __next;
     char* __outnext = __outbuf;
     char* const __outlast = __outbuf + sizeof(__outbuf);
     auto __result = _M_cvt->out(_M_state, __next, __last, __next,
     __outnext, __outlast, __outnext);
     if (__result == codecvt_base::error)
       return false;
     else if (__result == codecvt_base::noconv)
       return _M_put(__next, __pending);

     if (!_M_put(__outbuf, __outnext - __outbuf))
       return false;
   }
 while (__next != __last && __next != __start);

 if (__next != __last)
   _Tr::move(__first, __next, __last - __next);

 this->pbump(__first - __next);
 return __next != __first;
      }

      streambuf* _M_buf;
      unique_ptr<_Codecvt> _M_cvt;
      state_type _M_state;

      static const streamsize _S_buffer_length = 32;
      static const streamsize _S_putback_length = 3;
      _Elem _M_put_area[_S_buffer_length];
      _Elem _M_get_area[_S_buffer_length];
      streamsize _M_unconv = 0;
      char _M_get_buf[_S_buffer_length-_S_putback_length];
      bool _M_always_noconv;
    };






}
# 44 "/usr/include/c++/10.2.0/locale" 2 3
# 44 "/usr/include/c++/10.2.0/iomanip" 2 3

# 1 "/usr/include/c++/10.2.0/bits/quoted_string.h" 1 3
# 33 "/usr/include/c++/10.2.0/bits/quoted_string.h" 3
       
# 34 "/usr/include/c++/10.2.0/bits/quoted_string.h" 3




# 1 "/usr/include/c++/10.2.0/sstream" 1 3
# 36 "/usr/include/c++/10.2.0/sstream" 3
       
# 37 "/usr/include/c++/10.2.0/sstream" 3




namespace std __attribute__ ((__visibility__ ("default")))
{

namespace __cxx11 {
# 64 "/usr/include/c++/10.2.0/sstream" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_stringbuf : public basic_streambuf<_CharT, _Traits>
    {
      struct __xfer_bufptrs;
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;

      typedef basic_streambuf<char_type, traits_type> __streambuf_type;
      typedef basic_string<char_type, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;

    protected:

      ios_base::openmode _M_mode;


      __string_type _M_string;

    public:
# 99 "/usr/include/c++/10.2.0/sstream" 3
      basic_stringbuf()
      : __streambuf_type(), _M_mode(ios_base::in | ios_base::out), _M_string()
      { }
# 110 "/usr/include/c++/10.2.0/sstream" 3
      explicit
      basic_stringbuf(ios_base::openmode __mode)
      : __streambuf_type(), _M_mode(__mode), _M_string()
      { }
# 123 "/usr/include/c++/10.2.0/sstream" 3
      explicit
      basic_stringbuf(const __string_type& __str,
        ios_base::openmode __mode = ios_base::in | ios_base::out)
      : __streambuf_type(), _M_mode(),
 _M_string(__str.data(), __str.size(), __str.get_allocator())
      { _M_stringbuf_init(__mode); }


      basic_stringbuf(const basic_stringbuf&) = delete;

      basic_stringbuf(basic_stringbuf&& __rhs)
      : basic_stringbuf(std::move(__rhs), __xfer_bufptrs(__rhs, this))
      { __rhs._M_sync(const_cast<char_type*>(__rhs._M_string.data()), 0, 0); }



      basic_stringbuf&
      operator=(const basic_stringbuf&) = delete;

      basic_stringbuf&
      operator=(basic_stringbuf&& __rhs)
      {
 __xfer_bufptrs __st{__rhs, this};
 const __streambuf_type& __base = __rhs;
 __streambuf_type::operator=(__base);
 this->pubimbue(__rhs.getloc());
 _M_mode = __rhs._M_mode;
 _M_string = std::move(__rhs._M_string);
 __rhs._M_sync(const_cast<char_type*>(__rhs._M_string.data()), 0, 0);
 return *this;
      }

      void
      swap(basic_stringbuf& __rhs)
      {
 __xfer_bufptrs __l_st{*this, std::__addressof(__rhs)};
 __xfer_bufptrs __r_st{__rhs, this};
 __streambuf_type& __base = __rhs;
 __streambuf_type::swap(__base);
 __rhs.pubimbue(this->pubimbue(__rhs.getloc()));
 std::swap(_M_mode, __rhs._M_mode);
 std::swap(_M_string, __rhs._M_string);
      }
# 177 "/usr/include/c++/10.2.0/sstream" 3
      __string_type
      str() const
      {
 __string_type __ret(_M_string.get_allocator());
 if (this->pptr())
   {

     if (this->pptr() > this->egptr())
       __ret.assign(this->pbase(), this->pptr());
     else
       __ret.assign(this->pbase(), this->egptr());
   }
 else
   __ret = _M_string;
 return __ret;
      }
# 201 "/usr/include/c++/10.2.0/sstream" 3
      void
      str(const __string_type& __s)
      {


 _M_string.assign(__s.data(), __s.size());
 _M_stringbuf_init(_M_mode);
      }

    protected:

      void
      _M_stringbuf_init(ios_base::openmode __mode)
      {
 _M_mode = __mode;
 __size_type __len = 0;
 if (_M_mode & (ios_base::ate | ios_base::app))
   __len = _M_string.size();
 _M_sync(const_cast<char_type*>(_M_string.data()), 0, __len);
      }

      virtual streamsize
      showmanyc()
      {
 streamsize __ret = -1;
 if (_M_mode & ios_base::in)
   {
     _M_update_egptr();
     __ret = this->egptr() - this->gptr();
   }
 return __ret;
      }

      virtual int_type
      underflow();

      virtual int_type
      pbackfail(int_type __c = traits_type::eof());

      virtual int_type
      overflow(int_type __c = traits_type::eof());
# 254 "/usr/include/c++/10.2.0/sstream" 3
      virtual __streambuf_type*
      setbuf(char_type* __s, streamsize __n)
      {
 if (__s && __n >= 0)
   {






     _M_string.clear();


     _M_sync(__s, __n, 0);
   }
 return this;
      }

      virtual pos_type
      seekoff(off_type __off, ios_base::seekdir __way,
       ios_base::openmode __mode = ios_base::in | ios_base::out);

      virtual pos_type
      seekpos(pos_type __sp,
       ios_base::openmode __mode = ios_base::in | ios_base::out);




      void
      _M_sync(char_type* __base, __size_type __i, __size_type __o);



      void
      _M_update_egptr()
      {
 const bool __testin = _M_mode & ios_base::in;
 if (this->pptr() && this->pptr() > this->egptr())
   {
     if (__testin)
       this->setg(this->eback(), this->gptr(), this->pptr());
     else
       this->setg(this->pptr(), this->pptr(), this->pptr());
   }
      }



      void
      _M_pbump(char_type* __pbeg, char_type* __pend, off_type __off);

    private:




      struct __xfer_bufptrs
      {
 __xfer_bufptrs(const basic_stringbuf& __from, basic_stringbuf* __to)
 : _M_to{__to}, _M_goff{-1, -1, -1}, _M_poff{-1, -1, -1}
 {
   const _CharT* const __str = __from._M_string.data();
   const _CharT* __end = nullptr;
   if (__from.eback())
     {
       _M_goff[0] = __from.eback() - __str;
       _M_goff[1] = __from.gptr() - __str;
       _M_goff[2] = __from.egptr() - __str;
       __end = __from.egptr();
     }
   if (__from.pbase())
     {
       _M_poff[0] = __from.pbase() - __str;
       _M_poff[1] = __from.pptr() - __from.pbase();
       _M_poff[2] = __from.epptr() - __str;
       if (__from.pptr() > __end)
  __end = __from.pptr();
     }


   if (__end)
     {


       auto& __mut_from = const_cast<basic_stringbuf&>(__from);
       __mut_from._M_string._M_length(__end - __str);
     }
 }

 ~__xfer_bufptrs()
 {
   char_type* __str = const_cast<char_type*>(_M_to->_M_string.data());
   if (_M_goff[0] != -1)
     _M_to->setg(__str+_M_goff[0], __str+_M_goff[1], __str+_M_goff[2]);
   if (_M_poff[0] != -1)
     _M_to->_M_pbump(__str+_M_poff[0], __str+_M_poff[2], _M_poff[1]);
 }

 basic_stringbuf* _M_to;
 off_type _M_goff[3];
 off_type _M_poff[3];
      };
# 368 "/usr/include/c++/10.2.0/sstream" 3
      basic_stringbuf(basic_stringbuf&& __rhs, __xfer_bufptrs&&)
      : __streambuf_type(static_cast<const __streambuf_type&>(__rhs)),
      _M_mode(__rhs._M_mode), _M_string(std::move(__rhs._M_string))
      { }

    };
# 391 "/usr/include/c++/10.2.0/sstream" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_istringstream : public basic_istream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef basic_stringbuf<_CharT, _Traits, _Alloc> __stringbuf_type;
      typedef basic_istream<char_type, traits_type> __istream_type;

    private:
      __stringbuf_type _M_stringbuf;

    public:
# 425 "/usr/include/c++/10.2.0/sstream" 3
      basic_istringstream()
      : __istream_type(), _M_stringbuf(ios_base::in)
      { this->init(&_M_stringbuf); }
# 441 "/usr/include/c++/10.2.0/sstream" 3
      explicit
      basic_istringstream(ios_base::openmode __mode)
      : __istream_type(), _M_stringbuf(__mode | ios_base::in)
      { this->init(&_M_stringbuf); }
# 459 "/usr/include/c++/10.2.0/sstream" 3
      explicit
      basic_istringstream(const __string_type& __str,
     ios_base::openmode __mode = ios_base::in)
      : __istream_type(), _M_stringbuf(__str, __mode | ios_base::in)
      { this->init(&_M_stringbuf); }







      ~basic_istringstream()
      { }


      basic_istringstream(const basic_istringstream&) = delete;

      basic_istringstream(basic_istringstream&& __rhs)
      : __istream_type(std::move(__rhs)),
      _M_stringbuf(std::move(__rhs._M_stringbuf))
      { __istream_type::set_rdbuf(&_M_stringbuf); }



      basic_istringstream&
      operator=(const basic_istringstream&) = delete;

      basic_istringstream&
      operator=(basic_istringstream&& __rhs)
      {
 __istream_type::operator=(std::move(__rhs));
 _M_stringbuf = std::move(__rhs._M_stringbuf);
 return *this;
      }

      void
      swap(basic_istringstream& __rhs)
      {
 __istream_type::swap(__rhs);
 _M_stringbuf.swap(__rhs._M_stringbuf);
      }
# 510 "/usr/include/c++/10.2.0/sstream" 3
      __stringbuf_type*
      rdbuf() const
      { return const_cast<__stringbuf_type*>(&_M_stringbuf); }





      __string_type
      str() const
      { return _M_stringbuf.str(); }







      void
      str(const __string_type& __s)
      { _M_stringbuf.str(__s); }
    };
# 549 "/usr/include/c++/10.2.0/sstream" 3
  template <typename _CharT, typename _Traits, typename _Alloc>
    class basic_ostringstream : public basic_ostream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef basic_stringbuf<_CharT, _Traits, _Alloc> __stringbuf_type;
      typedef basic_ostream<char_type, traits_type> __ostream_type;

    private:
      __stringbuf_type _M_stringbuf;

    public:
# 583 "/usr/include/c++/10.2.0/sstream" 3
      basic_ostringstream()
      : __ostream_type(), _M_stringbuf(ios_base::out)
      { this->init(&_M_stringbuf); }
# 599 "/usr/include/c++/10.2.0/sstream" 3
      explicit
      basic_ostringstream(ios_base::openmode __mode)
      : __ostream_type(), _M_stringbuf(__mode | ios_base::out)
      { this->init(&_M_stringbuf); }
# 617 "/usr/include/c++/10.2.0/sstream" 3
      explicit
      basic_ostringstream(const __string_type& __str,
     ios_base::openmode __mode = ios_base::out)
      : __ostream_type(), _M_stringbuf(__str, __mode | ios_base::out)
      { this->init(&_M_stringbuf); }







      ~basic_ostringstream()
      { }


      basic_ostringstream(const basic_ostringstream&) = delete;

      basic_ostringstream(basic_ostringstream&& __rhs)
      : __ostream_type(std::move(__rhs)),
      _M_stringbuf(std::move(__rhs._M_stringbuf))
      { __ostream_type::set_rdbuf(&_M_stringbuf); }



      basic_ostringstream&
      operator=(const basic_ostringstream&) = delete;

      basic_ostringstream&
      operator=(basic_ostringstream&& __rhs)
      {
 __ostream_type::operator=(std::move(__rhs));
 _M_stringbuf = std::move(__rhs._M_stringbuf);
 return *this;
      }

      void
      swap(basic_ostringstream& __rhs)
      {
 __ostream_type::swap(__rhs);
 _M_stringbuf.swap(__rhs._M_stringbuf);
      }
# 668 "/usr/include/c++/10.2.0/sstream" 3
      __stringbuf_type*
      rdbuf() const
      { return const_cast<__stringbuf_type*>(&_M_stringbuf); }





      __string_type
      str() const
      { return _M_stringbuf.str(); }







      void
      str(const __string_type& __s)
      { _M_stringbuf.str(__s); }
    };
# 707 "/usr/include/c++/10.2.0/sstream" 3
  template <typename _CharT, typename _Traits, typename _Alloc>
    class basic_stringstream : public basic_iostream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef basic_stringbuf<_CharT, _Traits, _Alloc> __stringbuf_type;
      typedef basic_iostream<char_type, traits_type> __iostream_type;

    private:
      __stringbuf_type _M_stringbuf;

    public:
# 741 "/usr/include/c++/10.2.0/sstream" 3
      basic_stringstream()
      : __iostream_type(), _M_stringbuf(ios_base::out | ios_base::in)
      { this->init(&_M_stringbuf); }
# 755 "/usr/include/c++/10.2.0/sstream" 3
      explicit
      basic_stringstream(ios_base::openmode __m)
      : __iostream_type(), _M_stringbuf(__m)
      { this->init(&_M_stringbuf); }
# 771 "/usr/include/c++/10.2.0/sstream" 3
      explicit
      basic_stringstream(const __string_type& __str,
    ios_base::openmode __m = ios_base::out | ios_base::in)
      : __iostream_type(), _M_stringbuf(__str, __m)
      { this->init(&_M_stringbuf); }







      ~basic_stringstream()
      { }


      basic_stringstream(const basic_stringstream&) = delete;

      basic_stringstream(basic_stringstream&& __rhs)
      : __iostream_type(std::move(__rhs)),
      _M_stringbuf(std::move(__rhs._M_stringbuf))
      { __iostream_type::set_rdbuf(&_M_stringbuf); }



      basic_stringstream&
      operator=(const basic_stringstream&) = delete;

      basic_stringstream&
      operator=(basic_stringstream&& __rhs)
      {
 __iostream_type::operator=(std::move(__rhs));
 _M_stringbuf = std::move(__rhs._M_stringbuf);
 return *this;
      }

      void
      swap(basic_stringstream& __rhs)
      {
 __iostream_type::swap(__rhs);
 _M_stringbuf.swap(__rhs._M_stringbuf);
      }
# 822 "/usr/include/c++/10.2.0/sstream" 3
      __stringbuf_type*
      rdbuf() const
      { return const_cast<__stringbuf_type*>(&_M_stringbuf); }





      __string_type
      str() const
      { return _M_stringbuf.str(); }







      void
      str(const __string_type& __s)
      { _M_stringbuf.str(__s); }
    };



  template <class _CharT, class _Traits, class _Allocator>
    inline void
    swap(basic_stringbuf<_CharT, _Traits, _Allocator>& __x,
  basic_stringbuf<_CharT, _Traits, _Allocator>& __y)
    { __x.swap(__y); }


  template <class _CharT, class _Traits, class _Allocator>
    inline void
    swap(basic_istringstream<_CharT, _Traits, _Allocator>& __x,
  basic_istringstream<_CharT, _Traits, _Allocator>& __y)
    { __x.swap(__y); }


  template <class _CharT, class _Traits, class _Allocator>
    inline void
    swap(basic_ostringstream<_CharT, _Traits, _Allocator>& __x,
  basic_ostringstream<_CharT, _Traits, _Allocator>& __y)
    { __x.swap(__y); }


  template <class _CharT, class _Traits, class _Allocator>
    inline void
    swap(basic_stringstream<_CharT, _Traits, _Allocator>& __x,
  basic_stringstream<_CharT, _Traits, _Allocator>& __y)
    { __x.swap(__y); }


}

}

# 1 "/usr/include/c++/10.2.0/bits/sstream.tcc" 1 3
# 37 "/usr/include/c++/10.2.0/bits/sstream.tcc" 3
       
# 38 "/usr/include/c++/10.2.0/bits/sstream.tcc" 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::int_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    pbackfail(int_type __c)
    {
      int_type __ret = traits_type::eof();
      if (this->eback() < this->gptr())
 {


   const bool __testeof = traits_type::eq_int_type(__c, __ret);
   if (!__testeof)
     {
       const bool __testeq = traits_type::eq(traits_type::
          to_char_type(__c),
          this->gptr()[-1]);
       const bool __testout = this->_M_mode & ios_base::out;
       if (__testeq || __testout)
  {
    this->gbump(-1);
    if (!__testeq)
      *this->gptr() = traits_type::to_char_type(__c);
    __ret = __c;
  }
     }
   else
     {
       this->gbump(-1);
       __ret = traits_type::not_eof(__c);
     }
 }
      return __ret;
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::int_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    overflow(int_type __c)
    {
      const bool __testout = this->_M_mode & ios_base::out;
      if (__builtin_expect(!__testout, false))
 return traits_type::eof();

      const bool __testeof = traits_type::eq_int_type(__c, traits_type::eof());
      if (__builtin_expect(__testeof, false))
 return traits_type::not_eof(__c);

      const __size_type __capacity = _M_string.capacity();


      if ((this->epptr() - this->pbase()) < __capacity)
 {

   char_type* __base = const_cast<char_type*>(_M_string.data());
   _M_pbump(__base, __base + __capacity, this->pptr() - this->pbase());
   if (_M_mode & ios_base::in)
     {
       const __size_type __nget = this->gptr() - this->eback();
       const __size_type __eget = this->egptr() - this->eback();
       this->setg(__base, __base + __nget, __base + __eget + 1);
     }
   *this->pptr() = traits_type::to_char_type(__c);
   this->pbump(1);
   return __c;
 }


      const __size_type __max_size = _M_string.max_size();
      const bool __testput = this->pptr() < this->epptr();
      if (__builtin_expect(!__testput && __capacity == __max_size, false))
 return traits_type::eof();



      const char_type __conv = traits_type::to_char_type(__c);
      if (!__testput)
 {
# 129 "/usr/include/c++/10.2.0/bits/sstream.tcc" 3
   const __size_type __opt_len = std::max(__size_type(2 * __capacity),
       __size_type(512));
   const __size_type __len = std::min(__opt_len, __max_size);
   __string_type __tmp(_M_string.get_allocator());
   __tmp.reserve(__len);
   if (this->pbase())
     __tmp.assign(this->pbase(), this->epptr() - this->pbase());
   __tmp.push_back(__conv);
   _M_string.swap(__tmp);
   _M_sync(const_cast<char_type*>(_M_string.data()),
    this->gptr() - this->eback(), this->pptr() - this->pbase());
 }
      else
 *this->pptr() = __conv;
      this->pbump(1);
      return __c;
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::int_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    underflow()
    {
      int_type __ret = traits_type::eof();
      const bool __testin = this->_M_mode & ios_base::in;
      if (__testin)
 {

   _M_update_egptr();

   if (this->gptr() < this->egptr())
     __ret = traits_type::to_int_type(*this->gptr());
 }
      return __ret;
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::pos_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    seekoff(off_type __off, ios_base::seekdir __way, ios_base::openmode __mode)
    {
      pos_type __ret = pos_type(off_type(-1));
      bool __testin = (ios_base::in & this->_M_mode & __mode) != 0;
      bool __testout = (ios_base::out & this->_M_mode & __mode) != 0;
      const bool __testboth = __testin && __testout && __way != ios_base::cur;
      __testin &= !(__mode & ios_base::out);
      __testout &= !(__mode & ios_base::in);



      const char_type* __beg = __testin ? this->eback() : this->pbase();
      if ((__beg || !__off) && (__testin || __testout || __testboth))
 {
   _M_update_egptr();

   off_type __newoffi = __off;
   off_type __newoffo = __newoffi;
   if (__way == ios_base::cur)
     {
       __newoffi += this->gptr() - __beg;
       __newoffo += this->pptr() - __beg;
     }
   else if (__way == ios_base::end)
     __newoffo = __newoffi += this->egptr() - __beg;

   if ((__testin || __testboth)
       && __newoffi >= 0
       && this->egptr() - __beg >= __newoffi)
     {
       this->setg(this->eback(), this->eback() + __newoffi,
    this->egptr());
       __ret = pos_type(__newoffi);
     }
   if ((__testout || __testboth)
       && __newoffo >= 0
       && this->egptr() - __beg >= __newoffo)
     {
       _M_pbump(this->pbase(), this->epptr(), __newoffo);
       __ret = pos_type(__newoffo);
     }
 }
      return __ret;
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::pos_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    seekpos(pos_type __sp, ios_base::openmode __mode)
    {
      pos_type __ret = pos_type(off_type(-1));
      const bool __testin = (ios_base::in & this->_M_mode & __mode) != 0;
      const bool __testout = (ios_base::out & this->_M_mode & __mode) != 0;

      const char_type* __beg = __testin ? this->eback() : this->pbase();
      if ((__beg || !off_type(__sp)) && (__testin || __testout))
 {
   _M_update_egptr();

   const off_type __pos(__sp);
   const bool __testpos = (0 <= __pos
      && __pos <= this->egptr() - __beg);
   if (__testpos)
     {
       if (__testin)
  this->setg(this->eback(), this->eback() + __pos,
      this->egptr());
       if (__testout)
  _M_pbump(this->pbase(), this->epptr(), __pos);
       __ret = __sp;
     }
 }
      return __ret;
    }

  template <class _CharT, class _Traits, class _Alloc>
    void
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    _M_sync(char_type* __base, __size_type __i, __size_type __o)
    {
      const bool __testin = _M_mode & ios_base::in;
      const bool __testout = _M_mode & ios_base::out;
      char_type* __endg = __base + _M_string.size();
      char_type* __endp = __base + _M_string.capacity();

      if (__base != _M_string.data())
 {

   __endg += __i;
   __i = 0;
   __endp = __endg;
 }

      if (__testin)
 this->setg(__base, __base + __i, __endg);
      if (__testout)
 {
   _M_pbump(__base, __endp, __o);



   if (!__testin)
     this->setg(__endg, __endg, __endg);
 }
    }

  template <class _CharT, class _Traits, class _Alloc>
    void
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    _M_pbump(char_type* __pbeg, char_type* __pend, off_type __off)
    {
      this->setp(__pbeg, __pend);
      while (__off > __gnu_cxx::__numeric_traits<int>::__max)
 {
   this->pbump(__gnu_cxx::__numeric_traits<int>::__max);
   __off -= __gnu_cxx::__numeric_traits<int>::__max;
 }
      this->pbump(__off);
    }




  extern template class basic_stringbuf<char>;
  extern template class basic_istringstream<char>;
  extern template class basic_ostringstream<char>;
  extern template class basic_stringstream<char>;


  extern template class basic_stringbuf<wchar_t>;
  extern template class basic_istringstream<wchar_t>;
  extern template class basic_ostringstream<wchar_t>;
  extern template class basic_stringstream<wchar_t>;




}
# 880 "/usr/include/c++/10.2.0/sstream" 2 3
# 39 "/usr/include/c++/10.2.0/bits/quoted_string.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  namespace __detail {



    template<typename _String, typename _CharT>
      struct _Quoted_string
      {
 static_assert(is_reference<_String>::value
     || is_pointer<_String>::value,
        "String type must be pointer or reference");

 _Quoted_string(_String __str, _CharT __del, _CharT __esc)
 : _M_string(__str), _M_delim{__del}, _M_escape{__esc}
 { }

 _Quoted_string&
 operator=(_Quoted_string&) = delete;

 _String _M_string;
 _CharT _M_delim;
 _CharT _M_escape;
      };
# 91 "/usr/include/c++/10.2.0/bits/quoted_string.h" 3
    template<typename _CharT, typename _Traits>
      std::basic_ostream<_CharT, _Traits>&
      operator<<(std::basic_ostream<_CharT, _Traits>& __os,
   const _Quoted_string<const _CharT*, _CharT>& __str)
      {
 std::basic_ostringstream<_CharT, _Traits> __ostr;
 __ostr << __str._M_delim;
 for (const _CharT* __c = __str._M_string; *__c; ++__c)
   {
     if (*__c == __str._M_delim || *__c == __str._M_escape)
       __ostr << __str._M_escape;
     __ostr << *__c;
   }
 __ostr << __str._M_delim;

 return __os << __ostr.str();
      }







    template<typename _CharT, typename _Traits, typename _String>
      std::basic_ostream<_CharT, _Traits>&
      operator<<(std::basic_ostream<_CharT, _Traits>& __os,
   const _Quoted_string<_String, _CharT>& __str)
      {
 std::basic_ostringstream<_CharT, _Traits> __ostr;
 __ostr << __str._M_delim;
 for (auto __c : __str._M_string)
   {
     if (__c == __str._M_delim || __c == __str._M_escape)
       __ostr << __str._M_escape;
     __ostr << __c;
   }
 __ostr << __str._M_delim;

 return __os << __ostr.str();
      }





    template<typename _CharT, typename _Traits, typename _Alloc>
      std::basic_istream<_CharT, _Traits>&
      operator>>(std::basic_istream<_CharT, _Traits>& __is,
   const _Quoted_string<basic_string<_CharT, _Traits, _Alloc>&,
          _CharT>& __str)
      {
 _CharT __c;
 __is >> __c;
 if (!__is.good())
   return __is;
 if (__c != __str._M_delim)
   {
     __is.unget();
     __is >> __str._M_string;
     return __is;
   }
 __str._M_string.clear();
 std::ios_base::fmtflags __flags
   = __is.flags(__is.flags() & ~std::ios_base::skipws);
 do
   {
     __is >> __c;
     if (!__is.good())
       break;
     if (__c == __str._M_escape)
       {
  __is >> __c;
  if (!__is.good())
    break;
       }
     else if (__c == __str._M_delim)
       break;
     __str._M_string += __c;
   }
 while (true);
 __is.setf(__flags);

 return __is;
      }
  }


}
# 46 "/usr/include/c++/10.2.0/iomanip" 2 3



namespace std __attribute__ ((__visibility__ ("default")))
{





  struct _Resetiosflags { ios_base::fmtflags _M_mask; };
# 65 "/usr/include/c++/10.2.0/iomanip" 3
  inline _Resetiosflags
  resetiosflags(ios_base::fmtflags __mask)
  { return { __mask }; }

  template<typename _CharT, typename _Traits>
    inline basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, _Resetiosflags __f)
    {
      __is.setf(ios_base::fmtflags(0), __f._M_mask);
      return __is;
    }

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, _Resetiosflags __f)
    {
      __os.setf(ios_base::fmtflags(0), __f._M_mask);
      return __os;
    }


  struct _Setiosflags { ios_base::fmtflags _M_mask; };
# 95 "/usr/include/c++/10.2.0/iomanip" 3
  inline _Setiosflags
  setiosflags(ios_base::fmtflags __mask)
  { return { __mask }; }

  template<typename _CharT, typename _Traits>
    inline basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, _Setiosflags __f)
    {
      __is.setf(__f._M_mask);
      return __is;
    }

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, _Setiosflags __f)
    {
      __os.setf(__f._M_mask);
      return __os;
    }


  struct _Setbase { int _M_base; };
# 126 "/usr/include/c++/10.2.0/iomanip" 3
  inline _Setbase
  setbase(int __base)
  { return { __base }; }

  template<typename _CharT, typename _Traits>
    inline basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, _Setbase __f)
    {
      __is.setf(__f._M_base == 8 ? ios_base::oct :
  __f._M_base == 10 ? ios_base::dec :
  __f._M_base == 16 ? ios_base::hex :
  ios_base::fmtflags(0), ios_base::basefield);
      return __is;
    }

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, _Setbase __f)
    {
      __os.setf(__f._M_base == 8 ? ios_base::oct :
  __f._M_base == 10 ? ios_base::dec :
  __f._M_base == 16 ? ios_base::hex :
  ios_base::fmtflags(0), ios_base::basefield);
      return __os;
    }


  template<typename _CharT>
    struct _Setfill { _CharT _M_c; };
# 163 "/usr/include/c++/10.2.0/iomanip" 3
  template<typename _CharT>
    inline _Setfill<_CharT>
    setfill(_CharT __c)
    { return { __c }; }

  template<typename _CharT, typename _Traits>
    inline basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, _Setfill<_CharT> __f)
    {
      __is.fill(__f._M_c);
      return __is;
    }

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, _Setfill<_CharT> __f)
    {
      __os.fill(__f._M_c);
      return __os;
    }


  struct _Setprecision { int _M_n; };
# 194 "/usr/include/c++/10.2.0/iomanip" 3
  inline _Setprecision
  setprecision(int __n)
  { return { __n }; }

  template<typename _CharT, typename _Traits>
    inline basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, _Setprecision __f)
    {
      __is.precision(__f._M_n);
      return __is;
    }

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, _Setprecision __f)
    {
      __os.precision(__f._M_n);
      return __os;
    }


  struct _Setw { int _M_n; };
# 224 "/usr/include/c++/10.2.0/iomanip" 3
  inline _Setw
  setw(int __n)
  { return { __n }; }

  template<typename _CharT, typename _Traits>
    inline basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, _Setw __f)
    {
      __is.width(__f._M_n);
      return __is;
    }

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, _Setw __f)
    {
      __os.width(__f._M_n);
      return __os;
    }



  template<typename _MoneyT>
    struct _Get_money { _MoneyT& _M_mon; bool _M_intl; };
# 257 "/usr/include/c++/10.2.0/iomanip" 3
  template<typename _MoneyT>
    inline _Get_money<_MoneyT>
    get_money(_MoneyT& __mon, bool __intl = false)
    { return { __mon, __intl }; }

  template<typename _CharT, typename _Traits, typename _MoneyT>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, _Get_money<_MoneyT> __f)
    {
      typename basic_istream<_CharT, _Traits>::sentry __cerb(__is, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       typedef istreambuf_iterator<_CharT, _Traits> _Iter;
       typedef money_get<_CharT, _Iter> _MoneyGet;

       const _MoneyGet& __mg = use_facet<_MoneyGet>(__is.getloc());
       __mg.get(_Iter(__is.rdbuf()), _Iter(), __f._M_intl,
         __is, __err, __f._M_mon);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __is._M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { __is._M_setstate(ios_base::badbit); }
   if (__err)
     __is.setstate(__err);
 }
      return __is;
    }


  template<typename _MoneyT>
    struct _Put_money { const _MoneyT& _M_mon; bool _M_intl; };
# 304 "/usr/include/c++/10.2.0/iomanip" 3
  template<typename _MoneyT>
    inline _Put_money<_MoneyT>
    put_money(const _MoneyT& __mon, bool __intl = false)
    { return { __mon, __intl }; }

  template<typename _CharT, typename _Traits, typename _MoneyT>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, _Put_money<_MoneyT> __f)
    {
      typename basic_ostream<_CharT, _Traits>::sentry __cerb(__os);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       typedef ostreambuf_iterator<_CharT, _Traits> _Iter;
       typedef money_put<_CharT, _Iter> _MoneyPut;

       const _MoneyPut& __mp = use_facet<_MoneyPut>(__os.getloc());
       if (__mp.put(_Iter(__os.rdbuf()), __f._M_intl, __os,
      __os.fill(), __f._M_mon).failed())
  __err |= ios_base::badbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __os._M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { __os._M_setstate(ios_base::badbit); }
   if (__err)
     __os.setstate(__err);
 }
      return __os;
    }

  template<typename _CharT>
    struct _Put_time
    {
      const std::tm* _M_tmb;
      const _CharT* _M_fmt;
    };
# 356 "/usr/include/c++/10.2.0/iomanip" 3
  template<typename _CharT>
    inline _Put_time<_CharT>
    put_time(const std::tm* __tmb, const _CharT* __fmt)
    { return { __tmb, __fmt }; }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, _Put_time<_CharT> __f)
    {
      typename basic_ostream<_CharT, _Traits>::sentry __cerb(__os);
      if (__cerb)
        {
          ios_base::iostate __err = ios_base::goodbit;
          try
            {
              typedef ostreambuf_iterator<_CharT, _Traits> _Iter;
              typedef time_put<_CharT, _Iter> _TimePut;

              const _CharT* const __fmt_end = __f._M_fmt +
                _Traits::length(__f._M_fmt);

              const _TimePut& __mp = use_facet<_TimePut>(__os.getloc());
              if (__mp.put(_Iter(__os.rdbuf()), __os, __os.fill(),
                           __f._M_tmb, __f._M_fmt, __fmt_end).failed())
                __err |= ios_base::badbit;
            }
          catch(__cxxabiv1::__forced_unwind&)
            {
              __os._M_setstate(ios_base::badbit);
              throw;
            }
          catch(...)
            { __os._M_setstate(ios_base::badbit); }
          if (__err)
            __os.setstate(__err);
        }
      return __os;
    }

  template<typename _CharT>
    struct _Get_time
    {
      std::tm* _M_tmb;
      const _CharT* _M_fmt;
    };
# 411 "/usr/include/c++/10.2.0/iomanip" 3
  template<typename _CharT>
    inline _Get_time<_CharT>
    get_time(std::tm* __tmb, const _CharT* __fmt)
    { return { __tmb, __fmt }; }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, _Get_time<_CharT> __f)
    {
      typename basic_istream<_CharT, _Traits>::sentry __cerb(__is, false);
      if (__cerb)
        {
          ios_base::iostate __err = ios_base::goodbit;
          try
            {
              typedef istreambuf_iterator<_CharT, _Traits> _Iter;
              typedef time_get<_CharT, _Iter> _TimeGet;

              const _CharT* const __fmt_end = __f._M_fmt +
                _Traits::length(__f._M_fmt);

              const _TimeGet& __mg = use_facet<_TimeGet>(__is.getloc());
              __mg.get(_Iter(__is.rdbuf()), _Iter(), __is,
                       __err, __f._M_tmb, __f._M_fmt, __fmt_end);
            }
          catch(__cxxabiv1::__forced_unwind&)
            {
              __is._M_setstate(ios_base::badbit);
              throw;
            }
          catch(...)
            { __is._M_setstate(ios_base::badbit); }
          if (__err)
            __is.setstate(__err);
        }
      return __is;
    }
# 459 "/usr/include/c++/10.2.0/iomanip" 3
  template<typename _CharT>
    inline auto
    quoted(const _CharT* __string,
    _CharT __delim = _CharT('"'), _CharT __escape = _CharT('\\'))
    {
      return __detail::_Quoted_string<const _CharT*, _CharT>(__string, __delim,
            __escape);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline auto
    quoted(const basic_string<_CharT, _Traits, _Alloc>& __string,
    _CharT __delim = _CharT('"'), _CharT __escape = _CharT('\\'))
    {
      return __detail::_Quoted_string<
 const basic_string<_CharT, _Traits, _Alloc>&, _CharT>(
     __string, __delim, __escape);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline auto
    quoted(basic_string<_CharT, _Traits, _Alloc>& __string,
    _CharT __delim = _CharT('"'), _CharT __escape = _CharT('\\'))
    {
      return __detail::_Quoted_string<
 basic_string<_CharT, _Traits, _Alloc>&, _CharT>(
     __string, __delim, __escape);
    }
# 508 "/usr/include/c++/10.2.0/iomanip" 3
  extern template ostream& operator<<(ostream&, _Setfill<char>);
  extern template ostream& operator<<(ostream&, _Setiosflags);
  extern template ostream& operator<<(ostream&, _Resetiosflags);
  extern template ostream& operator<<(ostream&, _Setbase);
  extern template ostream& operator<<(ostream&, _Setprecision);
  extern template ostream& operator<<(ostream&, _Setw);
  extern template istream& operator>>(istream&, _Setfill<char>);
  extern template istream& operator>>(istream&, _Setiosflags);
  extern template istream& operator>>(istream&, _Resetiosflags);
  extern template istream& operator>>(istream&, _Setbase);
  extern template istream& operator>>(istream&, _Setprecision);
  extern template istream& operator>>(istream&, _Setw);


  extern template wostream& operator<<(wostream&, _Setfill<wchar_t>);
  extern template wostream& operator<<(wostream&, _Setiosflags);
  extern template wostream& operator<<(wostream&, _Resetiosflags);
  extern template wostream& operator<<(wostream&, _Setbase);
  extern template wostream& operator<<(wostream&, _Setprecision);
  extern template wostream& operator<<(wostream&, _Setw);
  extern template wistream& operator>>(wistream&, _Setfill<wchar_t>);
  extern template wistream& operator>>(wistream&, _Setiosflags);
  extern template wistream& operator>>(wistream&, _Resetiosflags);
  extern template wistream& operator>>(wistream&, _Setbase);
  extern template wistream& operator>>(wistream&, _Setprecision);
  extern template wistream& operator>>(wistream&, _Setw);




}
# 22 "/usr/include/opencascade/Standard_Stream.hxx" 2
# 1 "/usr/include/c++/10.2.0/fstream" 1 3
# 36 "/usr/include/c++/10.2.0/fstream" 3
       
# 37 "/usr/include/c++/10.2.0/fstream" 3




# 1 "/usr/include/c++/10.2.0/cstdio" 1 3
# 39 "/usr/include/c++/10.2.0/cstdio" 3
       
# 40 "/usr/include/c++/10.2.0/cstdio" 3
# 42 "/usr/include/c++/10.2.0/fstream" 2 3
# 1 "/usr/include/c++/10.2.0/x86_64-pc-linux-gnu/bits/basic_file.h" 1 3
# 37 "/usr/include/c++/10.2.0/x86_64-pc-linux-gnu/bits/basic_file.h" 3
       
# 38 "/usr/include/c++/10.2.0/x86_64-pc-linux-gnu/bits/basic_file.h" 3


# 1 "/usr/include/c++/10.2.0/x86_64-pc-linux-gnu/bits/c++io.h" 1 3
# 35 "/usr/include/c++/10.2.0/x86_64-pc-linux-gnu/bits/c++io.h" 3
# 1 "/usr/include/c++/10.2.0/cstdio" 1 3
# 39 "/usr/include/c++/10.2.0/cstdio" 3
       
# 40 "/usr/include/c++/10.2.0/cstdio" 3
# 36 "/usr/include/c++/10.2.0/x86_64-pc-linux-gnu/bits/c++io.h" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{


  typedef __gthread_mutex_t __c_lock;


  typedef FILE __c_file;


}
# 41 "/usr/include/c++/10.2.0/x86_64-pc-linux-gnu/bits/basic_file.h" 2 3



namespace std __attribute__ ((__visibility__ ("default")))
{



  template<typename _CharT>
    class __basic_file;


  template<>
    class __basic_file<char>
    {

      __c_file* _M_cfile;


      bool _M_cfile_created;

    public:
      __basic_file(__c_lock* __lock = 0) throw ();


      __basic_file(__basic_file&& __rv, __c_lock* = 0) noexcept
      : _M_cfile(__rv._M_cfile), _M_cfile_created(__rv._M_cfile_created)
      {
 __rv._M_cfile = nullptr;
 __rv._M_cfile_created = false;
      }

      __basic_file& operator=(const __basic_file&) = delete;
      __basic_file& operator=(__basic_file&&) = delete;

      void
      swap(__basic_file& __f) noexcept
      {
 std::swap(_M_cfile, __f._M_cfile);
 std::swap(_M_cfile_created, __f._M_cfile_created);
      }


      __basic_file*
      open(const char* __name, ios_base::openmode __mode, int __prot = 0664);






      __basic_file*
      sys_open(__c_file* __file, ios_base::openmode);

      __basic_file*
      sys_open(int __fd, ios_base::openmode __mode) throw ();

      __basic_file*
      close();

      __attribute__ ((__pure__)) bool
      is_open() const throw ();

      __attribute__ ((__pure__)) int
      fd() throw ();

      __attribute__ ((__pure__)) __c_file*
      file() throw ();

      ~__basic_file();

      streamsize
      xsputn(const char* __s, streamsize __n);

      streamsize
      xsputn_2(const char* __s1, streamsize __n1,
        const char* __s2, streamsize __n2);

      streamsize
      xsgetn(char* __s, streamsize __n);

      streamoff
      seekoff(streamoff __off, ios_base::seekdir __way) throw ();

      int
      sync();

      streamsize
      showmanyc();
    };


}
# 43 "/usr/include/c++/10.2.0/fstream" 2 3




namespace std __attribute__ ((__visibility__ ("default")))
{

# 79 "/usr/include/c++/10.2.0/fstream" 3
  template<typename _CharT, typename _Traits>
    class basic_filebuf : public basic_streambuf<_CharT, _Traits>
    {

      template<typename _Tp>
 using __chk_state = __and_<is_copy_assignable<_Tp>,
       is_copy_constructible<_Tp>,
       is_default_constructible<_Tp>>;

      static_assert(__chk_state<typename _Traits::state_type>::value,
      "state_type must be CopyAssignable, CopyConstructible"
      " and DefaultConstructible");

      static_assert(is_same<typename _Traits::pos_type,
       fpos<typename _Traits::state_type>>::value,
      "pos_type must be fpos<state_type>");

    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;

      typedef basic_streambuf<char_type, traits_type> __streambuf_type;
      typedef basic_filebuf<char_type, traits_type> __filebuf_type;
      typedef __basic_file<char> __file_type;
      typedef typename traits_type::state_type __state_type;
      typedef codecvt<char_type, char, __state_type> __codecvt_type;

      friend class ios_base;

    protected:


      __c_lock _M_lock;


      __file_type _M_file;


      ios_base::openmode _M_mode;


      __state_type _M_state_beg;




      __state_type _M_state_cur;



      __state_type _M_state_last;


      char_type* _M_buf;






      size_t _M_buf_size;


      bool _M_buf_allocated;
# 155 "/usr/include/c++/10.2.0/fstream" 3
      bool _M_reading;
      bool _M_writing;







      char_type _M_pback;
      char_type* _M_pback_cur_save;
      char_type* _M_pback_end_save;
      bool _M_pback_init;



      const __codecvt_type* _M_codecvt;






      char* _M_ext_buf;




      streamsize _M_ext_buf_size;






      const char* _M_ext_next;
      char* _M_ext_end;






      void
      _M_create_pback()
      {
 if (!_M_pback_init)
   {
     _M_pback_cur_save = this->gptr();
     _M_pback_end_save = this->egptr();
     this->setg(&_M_pback, &_M_pback, &_M_pback + 1);
     _M_pback_init = true;
   }
      }






      void
      _M_destroy_pback() throw()
      {
 if (_M_pback_init)
   {

     _M_pback_cur_save += this->gptr() != this->eback();
     this->setg(_M_buf, _M_pback_cur_save, _M_pback_end_save);
     _M_pback_init = false;
   }
      }

    public:







      basic_filebuf();


      basic_filebuf(const basic_filebuf&) = delete;
      basic_filebuf(basic_filebuf&&);





      virtual
      ~basic_filebuf()
      {
 try
   { this->close(); }
 catch(...)
   { }
      }


      basic_filebuf& operator=(const basic_filebuf&) = delete;
      basic_filebuf& operator=(basic_filebuf&&);
      void swap(basic_filebuf&);






      bool
      is_open() const throw()
      { return _M_file.is_open(); }
# 309 "/usr/include/c++/10.2.0/fstream" 3
      __filebuf_type*
      open(const char* __s, ios_base::openmode __mode);
# 330 "/usr/include/c++/10.2.0/fstream" 3
      __filebuf_type*
      open(const std::string& __s, ios_base::openmode __mode)
      { return open(__s.c_str(), __mode); }
# 360 "/usr/include/c++/10.2.0/fstream" 3
      __filebuf_type*
      close();

    protected:
      void
      _M_allocate_internal_buffer();

      void
      _M_destroy_internal_buffer() throw();


      virtual streamsize
      showmanyc();






      virtual int_type
      underflow();

      virtual int_type
      pbackfail(int_type __c = _Traits::eof());
# 392 "/usr/include/c++/10.2.0/fstream" 3
      virtual int_type
      overflow(int_type __c = _Traits::eof());



      bool
      _M_convert_to_external(char_type*, streamsize);
# 412 "/usr/include/c++/10.2.0/fstream" 3
      virtual __streambuf_type*
      setbuf(char_type* __s, streamsize __n);

      virtual pos_type
      seekoff(off_type __off, ios_base::seekdir __way,
       ios_base::openmode __mode = ios_base::in | ios_base::out);

      virtual pos_type
      seekpos(pos_type __pos,
       ios_base::openmode __mode = ios_base::in | ios_base::out);


      pos_type
      _M_seek(off_type __off, ios_base::seekdir __way, __state_type __state);

      int
      _M_get_ext_pos(__state_type &__state);

      virtual int
      sync();

      virtual void
      imbue(const locale& __loc);

      virtual streamsize
      xsgetn(char_type* __s, streamsize __n);

      virtual streamsize
      xsputn(const char_type* __s, streamsize __n);


      bool
      _M_terminate_output();
# 458 "/usr/include/c++/10.2.0/fstream" 3
      void
      _M_set_buffer(streamsize __off)
      {
 const bool __testin = _M_mode & ios_base::in;
 const bool __testout = (_M_mode & ios_base::out
    || _M_mode & ios_base::app);

 if (__testin && __off > 0)
   this->setg(_M_buf, _M_buf, _M_buf + __off);
 else
   this->setg(_M_buf, _M_buf, _M_buf);

 if (__testout && __off == 0 && _M_buf_size > 1 )
   this->setp(_M_buf, _M_buf + _M_buf_size - 1);
 else
   this->setp(0, 0);
      }
    };
# 491 "/usr/include/c++/10.2.0/fstream" 3
  template<typename _CharT, typename _Traits>
    class basic_ifstream : public basic_istream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_filebuf<char_type, traits_type> __filebuf_type;
      typedef basic_istream<char_type, traits_type> __istream_type;

    private:
      __filebuf_type _M_filebuf;

    public:
# 518 "/usr/include/c++/10.2.0/fstream" 3
      basic_ifstream() : __istream_type(), _M_filebuf()
      { this->init(&_M_filebuf); }
# 528 "/usr/include/c++/10.2.0/fstream" 3
      explicit
      basic_ifstream(const char* __s, ios_base::openmode __mode = ios_base::in)
      : __istream_type(), _M_filebuf()
      {
 this->init(&_M_filebuf);
 this->open(__s, __mode);
      }
# 561 "/usr/include/c++/10.2.0/fstream" 3
      explicit
      basic_ifstream(const std::string& __s,
       ios_base::openmode __mode = ios_base::in)
      : __istream_type(), _M_filebuf()
      {
 this->init(&_M_filebuf);
 this->open(__s, __mode);
      }
# 585 "/usr/include/c++/10.2.0/fstream" 3
      basic_ifstream(const basic_ifstream&) = delete;

      basic_ifstream(basic_ifstream&& __rhs)
      : __istream_type(std::move(__rhs)),
      _M_filebuf(std::move(__rhs._M_filebuf))
      { __istream_type::set_rdbuf(&_M_filebuf); }
# 599 "/usr/include/c++/10.2.0/fstream" 3
      ~basic_ifstream()
      { }




      basic_ifstream&
      operator=(const basic_ifstream&) = delete;

      basic_ifstream&
      operator=(basic_ifstream&& __rhs)
      {
 __istream_type::operator=(std::move(__rhs));
 _M_filebuf = std::move(__rhs._M_filebuf);
 return *this;
      }

      void
      swap(basic_ifstream& __rhs)
      {
 __istream_type::swap(__rhs);
 _M_filebuf.swap(__rhs._M_filebuf);
      }
# 631 "/usr/include/c++/10.2.0/fstream" 3
      __filebuf_type*
      rdbuf() const
      { return const_cast<__filebuf_type*>(&_M_filebuf); }





      bool
      is_open()
      { return _M_filebuf.is_open(); }



      bool
      is_open() const
      { return _M_filebuf.is_open(); }
# 657 "/usr/include/c++/10.2.0/fstream" 3
      void
      open(const char* __s, ios_base::openmode __mode = ios_base::in)
      {
 if (!_M_filebuf.open(__s, __mode | ios_base::in))
   this->setstate(ios_base::failbit);
 else


   this->clear();
      }
# 696 "/usr/include/c++/10.2.0/fstream" 3
      void
      open(const std::string& __s, ios_base::openmode __mode = ios_base::in)
      {
 if (!_M_filebuf.open(__s, __mode | ios_base::in))
   this->setstate(ios_base::failbit);
 else


   this->clear();
      }
# 729 "/usr/include/c++/10.2.0/fstream" 3
      void
      close()
      {
 if (!_M_filebuf.close())
   this->setstate(ios_base::failbit);
      }
    };
# 752 "/usr/include/c++/10.2.0/fstream" 3
  template<typename _CharT, typename _Traits>
    class basic_ofstream : public basic_ostream<_CharT,_Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_filebuf<char_type, traits_type> __filebuf_type;
      typedef basic_ostream<char_type, traits_type> __ostream_type;

    private:
      __filebuf_type _M_filebuf;

    public:
# 779 "/usr/include/c++/10.2.0/fstream" 3
      basic_ofstream(): __ostream_type(), _M_filebuf()
      { this->init(&_M_filebuf); }
# 789 "/usr/include/c++/10.2.0/fstream" 3
      explicit
      basic_ofstream(const char* __s,
       ios_base::openmode __mode = ios_base::out)
      : __ostream_type(), _M_filebuf()
      {
 this->init(&_M_filebuf);
 this->open(__s, __mode);
      }
# 824 "/usr/include/c++/10.2.0/fstream" 3
      explicit
      basic_ofstream(const std::string& __s,
       ios_base::openmode __mode = ios_base::out)
      : __ostream_type(), _M_filebuf()
      {
 this->init(&_M_filebuf);
 this->open(__s, __mode);
      }
# 848 "/usr/include/c++/10.2.0/fstream" 3
      basic_ofstream(const basic_ofstream&) = delete;

      basic_ofstream(basic_ofstream&& __rhs)
      : __ostream_type(std::move(__rhs)),
      _M_filebuf(std::move(__rhs._M_filebuf))
      { __ostream_type::set_rdbuf(&_M_filebuf); }
# 862 "/usr/include/c++/10.2.0/fstream" 3
      ~basic_ofstream()
      { }




      basic_ofstream&
      operator=(const basic_ofstream&) = delete;

      basic_ofstream&
      operator=(basic_ofstream&& __rhs)
      {
 __ostream_type::operator=(std::move(__rhs));
 _M_filebuf = std::move(__rhs._M_filebuf);
 return *this;
      }

      void
      swap(basic_ofstream& __rhs)
      {
 __ostream_type::swap(__rhs);
 _M_filebuf.swap(__rhs._M_filebuf);
      }
# 894 "/usr/include/c++/10.2.0/fstream" 3
      __filebuf_type*
      rdbuf() const
      { return const_cast<__filebuf_type*>(&_M_filebuf); }





      bool
      is_open()
      { return _M_filebuf.is_open(); }



      bool
      is_open() const
      { return _M_filebuf.is_open(); }
# 920 "/usr/include/c++/10.2.0/fstream" 3
      void
      open(const char* __s, ios_base::openmode __mode = ios_base::out)
      {
 if (!_M_filebuf.open(__s, __mode | ios_base::out))
   this->setstate(ios_base::failbit);
 else


   this->clear();
      }
# 959 "/usr/include/c++/10.2.0/fstream" 3
      void
      open(const std::string& __s, ios_base::openmode __mode = ios_base::out)
      {
 if (!_M_filebuf.open(__s, __mode | ios_base::out))
   this->setstate(ios_base::failbit);
 else


   this->clear();
      }
# 992 "/usr/include/c++/10.2.0/fstream" 3
      void
      close()
      {
 if (!_M_filebuf.close())
   this->setstate(ios_base::failbit);
      }
    };
# 1015 "/usr/include/c++/10.2.0/fstream" 3
  template<typename _CharT, typename _Traits>
    class basic_fstream : public basic_iostream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_filebuf<char_type, traits_type> __filebuf_type;
      typedef basic_ios<char_type, traits_type> __ios_type;
      typedef basic_iostream<char_type, traits_type> __iostream_type;

    private:
      __filebuf_type _M_filebuf;

    public:
# 1043 "/usr/include/c++/10.2.0/fstream" 3
      basic_fstream()
      : __iostream_type(), _M_filebuf()
      { this->init(&_M_filebuf); }






      explicit
      basic_fstream(const char* __s,
      ios_base::openmode __mode = ios_base::in | ios_base::out)
      : __iostream_type(0), _M_filebuf()
      {
 this->init(&_M_filebuf);
 this->open(__s, __mode);
      }
# 1082 "/usr/include/c++/10.2.0/fstream" 3
      explicit
      basic_fstream(const std::string& __s,
      ios_base::openmode __mode = ios_base::in | ios_base::out)
      : __iostream_type(0), _M_filebuf()
      {
 this->init(&_M_filebuf);
 this->open(__s, __mode);
      }
# 1104 "/usr/include/c++/10.2.0/fstream" 3
      basic_fstream(const basic_fstream&) = delete;

      basic_fstream(basic_fstream&& __rhs)
      : __iostream_type(std::move(__rhs)),
      _M_filebuf(std::move(__rhs._M_filebuf))
      { __iostream_type::set_rdbuf(&_M_filebuf); }
# 1118 "/usr/include/c++/10.2.0/fstream" 3
      ~basic_fstream()
      { }




      basic_fstream&
      operator=(const basic_fstream&) = delete;

      basic_fstream&
      operator=(basic_fstream&& __rhs)
      {
 __iostream_type::operator=(std::move(__rhs));
 _M_filebuf = std::move(__rhs._M_filebuf);
 return *this;
      }

      void
      swap(basic_fstream& __rhs)
      {
 __iostream_type::swap(__rhs);
 _M_filebuf.swap(__rhs._M_filebuf);
      }
# 1150 "/usr/include/c++/10.2.0/fstream" 3
      __filebuf_type*
      rdbuf() const
      { return const_cast<__filebuf_type*>(&_M_filebuf); }





      bool
      is_open()
      { return _M_filebuf.is_open(); }



      bool
      is_open() const
      { return _M_filebuf.is_open(); }
# 1176 "/usr/include/c++/10.2.0/fstream" 3
      void
      open(const char* __s,
    ios_base::openmode __mode = ios_base::in | ios_base::out)
      {
 if (!_M_filebuf.open(__s, __mode))
   this->setstate(ios_base::failbit);
 else


   this->clear();
      }
# 1217 "/usr/include/c++/10.2.0/fstream" 3
      void
      open(const std::string& __s,
    ios_base::openmode __mode = ios_base::in | ios_base::out)
      {
 if (!_M_filebuf.open(__s, __mode))
   this->setstate(ios_base::failbit);
 else


   this->clear();
      }
# 1252 "/usr/include/c++/10.2.0/fstream" 3
      void
      close()
      {
 if (!_M_filebuf.close())
   this->setstate(ios_base::failbit);
      }
    };



  template <class _CharT, class _Traits>
    inline void
    swap(basic_filebuf<_CharT, _Traits>& __x,
  basic_filebuf<_CharT, _Traits>& __y)
    { __x.swap(__y); }


  template <class _CharT, class _Traits>
    inline void
    swap(basic_ifstream<_CharT, _Traits>& __x,
  basic_ifstream<_CharT, _Traits>& __y)
    { __x.swap(__y); }


  template <class _CharT, class _Traits>
    inline void
    swap(basic_ofstream<_CharT, _Traits>& __x,
  basic_ofstream<_CharT, _Traits>& __y)
    { __x.swap(__y); }


  template <class _CharT, class _Traits>
    inline void
    swap(basic_fstream<_CharT, _Traits>& __x,
  basic_fstream<_CharT, _Traits>& __y)
    { __x.swap(__y); }



}

# 1 "/usr/include/c++/10.2.0/bits/fstream.tcc" 1 3
# 37 "/usr/include/c++/10.2.0/bits/fstream.tcc" 3
       
# 38 "/usr/include/c++/10.2.0/bits/fstream.tcc" 3



# 1 "/usr/include/c++/10.2.0/cerrno" 1 3
# 39 "/usr/include/c++/10.2.0/cerrno" 3
       
# 40 "/usr/include/c++/10.2.0/cerrno" 3
# 42 "/usr/include/c++/10.2.0/bits/fstream.tcc" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    void
    basic_filebuf<_CharT, _Traits>::
    _M_allocate_internal_buffer()
    {


      if (!_M_buf_allocated && !_M_buf)
 {
   _M_buf = new char_type[_M_buf_size];
   _M_buf_allocated = true;
 }
    }

  template<typename _CharT, typename _Traits>
    void
    basic_filebuf<_CharT, _Traits>::
    _M_destroy_internal_buffer() throw()
    {
      if (_M_buf_allocated)
 {
   delete [] _M_buf;
   _M_buf = 0;
   _M_buf_allocated = false;
 }
      delete [] _M_ext_buf;
      _M_ext_buf = 0;
      _M_ext_buf_size = 0;
      _M_ext_next = 0;
      _M_ext_end = 0;
    }

  template<typename _CharT, typename _Traits>
    basic_filebuf<_CharT, _Traits>::
    basic_filebuf() : __streambuf_type(), _M_lock(), _M_file(&_M_lock),
    _M_mode(ios_base::openmode(0)), _M_state_beg(), _M_state_cur(),
    _M_state_last(), _M_buf(0), _M_buf_size(8192),
    _M_buf_allocated(false), _M_reading(false), _M_writing(false), _M_pback(),
    _M_pback_cur_save(0), _M_pback_end_save(0), _M_pback_init(false),
    _M_codecvt(0), _M_ext_buf(0), _M_ext_buf_size(0), _M_ext_next(0),
    _M_ext_end(0)
    {
      if (has_facet<__codecvt_type>(this->_M_buf_locale))
 _M_codecvt = &use_facet<__codecvt_type>(this->_M_buf_locale);
    }


  template<typename _CharT, typename _Traits>
    basic_filebuf<_CharT, _Traits>::
    basic_filebuf(basic_filebuf&& __rhs)
    : __streambuf_type(__rhs),
    _M_lock(), _M_file(std::move(__rhs._M_file), &_M_lock),
    _M_mode(std::__exchange(__rhs._M_mode, ios_base::openmode(0))),
    _M_state_beg(std::move(__rhs._M_state_beg)),
    _M_state_cur(std::move(__rhs._M_state_cur)),
    _M_state_last(std::move(__rhs._M_state_last)),
    _M_buf(std::__exchange(__rhs._M_buf, nullptr)),
    _M_buf_size(std::__exchange(__rhs._M_buf_size, 1)),
    _M_buf_allocated(std::__exchange(__rhs._M_buf_allocated, false)),
    _M_reading(std::__exchange(__rhs._M_reading, false)),
    _M_writing(std::__exchange(__rhs._M_writing, false)),
    _M_pback(__rhs._M_pback),
    _M_pback_cur_save(std::__exchange(__rhs._M_pback_cur_save, nullptr)),
    _M_pback_end_save(std::__exchange(__rhs._M_pback_end_save, nullptr)),
    _M_pback_init(std::__exchange(__rhs._M_pback_init, false)),
    _M_codecvt(__rhs._M_codecvt),
    _M_ext_buf(std::__exchange(__rhs._M_ext_buf, nullptr)),
    _M_ext_buf_size(std::__exchange(__rhs._M_ext_buf_size, 0)),
    _M_ext_next(std::__exchange(__rhs._M_ext_next, nullptr)),
    _M_ext_end(std::__exchange(__rhs._M_ext_end, nullptr))
    {
      __rhs._M_set_buffer(-1);
      __rhs._M_state_last = __rhs._M_state_cur = __rhs._M_state_beg;
    }

  template<typename _CharT, typename _Traits>
    basic_filebuf<_CharT, _Traits>&
    basic_filebuf<_CharT, _Traits>::
    operator=(basic_filebuf&& __rhs)
    {
      this->close();
      __streambuf_type::operator=(__rhs);
      _M_file.swap(__rhs._M_file);
      _M_mode = std::__exchange(__rhs._M_mode, ios_base::openmode(0));
      _M_state_beg = std::move(__rhs._M_state_beg);
      _M_state_cur = std::move(__rhs._M_state_cur);
      _M_state_last = std::move(__rhs._M_state_last);
      _M_buf = std::__exchange(__rhs._M_buf, nullptr);
      _M_buf_size = std::__exchange(__rhs._M_buf_size, 1);
      _M_buf_allocated = std::__exchange(__rhs._M_buf_allocated, false);
      _M_ext_buf = std::__exchange(__rhs._M_ext_buf, nullptr);
      _M_ext_buf_size = std::__exchange(__rhs._M_ext_buf_size, 0);
      _M_ext_next = std::__exchange(__rhs._M_ext_next, nullptr);
      _M_ext_end = std::__exchange(__rhs._M_ext_end, nullptr);
      _M_reading = std::__exchange(__rhs._M_reading, false);
      _M_writing = std::__exchange(__rhs._M_writing, false);
      _M_pback_cur_save = std::__exchange(__rhs._M_pback_cur_save, nullptr);
      _M_pback_end_save = std::__exchange(__rhs._M_pback_end_save, nullptr);
      _M_pback_init = std::__exchange(__rhs._M_pback_init, false);
      __rhs._M_set_buffer(-1);
      __rhs._M_state_last = __rhs._M_state_cur = __rhs._M_state_beg;
      return *this;
    }

  template<typename _CharT, typename _Traits>
    void
    basic_filebuf<_CharT, _Traits>::
    swap(basic_filebuf& __rhs)
    {
      __streambuf_type::swap(__rhs);
      _M_file.swap(__rhs._M_file);
      std::swap(_M_mode, __rhs._M_mode);
      std::swap(_M_state_beg, __rhs._M_state_beg);
      std::swap(_M_state_cur, __rhs._M_state_cur);
      std::swap(_M_state_last, __rhs._M_state_last);
      std::swap(_M_buf, __rhs._M_buf);
      std::swap(_M_buf_size, __rhs._M_buf_size);
      std::swap(_M_buf_allocated, __rhs._M_buf_allocated);
      std::swap(_M_ext_buf, __rhs._M_ext_buf);
      std::swap(_M_ext_buf_size, __rhs._M_ext_buf_size);
      std::swap(_M_ext_next, __rhs._M_ext_next);
      std::swap(_M_ext_end, __rhs._M_ext_end);
      std::swap(_M_reading, __rhs._M_reading);
      std::swap(_M_writing, __rhs._M_writing);
      std::swap(_M_pback_cur_save, __rhs._M_pback_cur_save);
      std::swap(_M_pback_end_save, __rhs._M_pback_end_save);
      std::swap(_M_pback_init, __rhs._M_pback_init);
    }


  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::__filebuf_type*
    basic_filebuf<_CharT, _Traits>::
    open(const char* __s, ios_base::openmode __mode)
    {
      __filebuf_type *__ret = 0;
      if (!this->is_open())
 {
   _M_file.open(__s, __mode);
   if (this->is_open())
     {
       _M_allocate_internal_buffer();
       _M_mode = __mode;


       _M_reading = false;
       _M_writing = false;
       _M_set_buffer(-1);


       _M_state_last = _M_state_cur = _M_state_beg;


       if ((__mode & ios_base::ate)
    && this->seekoff(0, ios_base::end, __mode)
    == pos_type(off_type(-1)))
  this->close();
       else
  __ret = this;
     }
 }
      return __ret;
    }
# 247 "/usr/include/c++/10.2.0/bits/fstream.tcc" 3
  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::__filebuf_type*
    basic_filebuf<_CharT, _Traits>::
    close()
    {
      if (!this->is_open())
 return 0;

      bool __testfail = false;
      {

 struct __close_sentry
 {
   basic_filebuf *__fb;
   __close_sentry (basic_filebuf *__fbi): __fb(__fbi) { }
   ~__close_sentry ()
   {
     __fb->_M_mode = ios_base::openmode(0);
     __fb->_M_pback_init = false;
     __fb->_M_destroy_internal_buffer();
     __fb->_M_reading = false;
     __fb->_M_writing = false;
     __fb->_M_set_buffer(-1);
     __fb->_M_state_last = __fb->_M_state_cur = __fb->_M_state_beg;
   }
 } __cs (this);

 try
   {
     if (!_M_terminate_output())
       __testfail = true;
   }
 catch(...)
   {
     _M_file.close();
     throw;
   }
      }

      if (!_M_file.close())
 __testfail = true;

      if (__testfail)
 return 0;
      else
 return this;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_filebuf<_CharT, _Traits>::
    showmanyc()
    {
      streamsize __ret = -1;
      const bool __testin = _M_mode & ios_base::in;
      if (__testin && this->is_open())
 {


   __ret = this->egptr() - this->gptr();







   if (__check_facet(_M_codecvt).encoding() >= 0)

     __ret += _M_file.showmanyc() / _M_codecvt->max_length();
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::int_type
    basic_filebuf<_CharT, _Traits>::
    underflow()
    {
      int_type __ret = traits_type::eof();
      const bool __testin = _M_mode & ios_base::in;
      if (__testin)
 {
   if (_M_writing)
     {
       if (overflow() == traits_type::eof())
  return __ret;
       _M_set_buffer(-1);
       _M_writing = false;
     }



   _M_destroy_pback();

   if (this->gptr() < this->egptr())
     return traits_type::to_int_type(*this->gptr());


   const size_t __buflen = _M_buf_size > 1 ? _M_buf_size - 1 : 1;


   bool __got_eof = false;

   streamsize __ilen = 0;
   codecvt_base::result __r = codecvt_base::ok;
   if (__check_facet(_M_codecvt).always_noconv())
     {
       __ilen = _M_file.xsgetn(reinterpret_cast<char*>(this->eback()),
          __buflen);
       if (__ilen == 0)
  __got_eof = true;
     }
   else
     {


       const int __enc = _M_codecvt->encoding();
       streamsize __blen;
       streamsize __rlen;
       if (__enc > 0)
  __blen = __rlen = __buflen * __enc;
       else
  {
    __blen = __buflen + _M_codecvt->max_length() - 1;
    __rlen = __buflen;
  }
       const streamsize __remainder = _M_ext_end - _M_ext_next;
       __rlen = __rlen > __remainder ? __rlen - __remainder : 0;



       if (_M_reading && this->egptr() == this->eback() && __remainder)
  __rlen = 0;



       if (_M_ext_buf_size < __blen)
  {
    char* __buf = new char[__blen];
    if (__remainder)
      __builtin_memcpy(__buf, _M_ext_next, __remainder);

    delete [] _M_ext_buf;
    _M_ext_buf = __buf;
    _M_ext_buf_size = __blen;
  }
       else if (__remainder)
  __builtin_memmove(_M_ext_buf, _M_ext_next, __remainder);

       _M_ext_next = _M_ext_buf;
       _M_ext_end = _M_ext_buf + __remainder;
       _M_state_last = _M_state_cur;

       do
  {
    if (__rlen > 0)
      {



        if (_M_ext_end - _M_ext_buf + __rlen > _M_ext_buf_size)
   {
     __throw_ios_failure(("basic_filebuf::underflow " "codecvt::max_length() " "is not valid")

                          );
   }
        streamsize __elen = _M_file.xsgetn(_M_ext_end, __rlen);
        if (__elen == 0)
   __got_eof = true;
        else if (__elen == -1)
   break;
        _M_ext_end += __elen;
      }

    char_type* __iend = this->eback();
    if (_M_ext_next < _M_ext_end)
      __r = _M_codecvt->in(_M_state_cur, _M_ext_next,
      _M_ext_end, _M_ext_next,
      this->eback(),
      this->eback() + __buflen, __iend);
    if (__r == codecvt_base::noconv)
      {
        size_t __avail = _M_ext_end - _M_ext_buf;
        __ilen = std::min(__avail, __buflen);
        traits_type::copy(this->eback(),
     reinterpret_cast<char_type*>
     (_M_ext_buf), __ilen);
        _M_ext_next = _M_ext_buf + __ilen;
      }
    else
      __ilen = __iend - this->eback();




    if (__r == codecvt_base::error)
      break;

    __rlen = 1;
  }
       while (__ilen == 0 && !__got_eof);
     }

   if (__ilen > 0)
     {
       _M_set_buffer(__ilen);
       _M_reading = true;
       __ret = traits_type::to_int_type(*this->gptr());
     }
   else if (__got_eof)
     {



       _M_set_buffer(-1);
       _M_reading = false;


       if (__r == codecvt_base::partial)
  __throw_ios_failure(("basic_filebuf::underflow " "incomplete character in file")
                                       );
     }
   else if (__r == codecvt_base::error)
     __throw_ios_failure(("basic_filebuf::underflow " "invalid byte sequence in file")
                                    );
   else
     __throw_ios_failure(("basic_filebuf::underflow " "error reading the file")
                             , (*__errno_location ()));
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::int_type
    basic_filebuf<_CharT, _Traits>::
    pbackfail(int_type __i)
    {
      int_type __ret = traits_type::eof();
      const bool __testin = _M_mode & ios_base::in;
      if (__testin)
 {
   if (_M_writing)
     {
       if (overflow() == traits_type::eof())
  return __ret;
       _M_set_buffer(-1);
       _M_writing = false;
     }


   const bool __testpb = _M_pback_init;
   const bool __testeof = traits_type::eq_int_type(__i, __ret);
   int_type __tmp;
   if (this->eback() < this->gptr())
     {
       this->gbump(-1);
       __tmp = traits_type::to_int_type(*this->gptr());
     }
   else if (this->seekoff(-1, ios_base::cur) != pos_type(off_type(-1)))
     {
       __tmp = this->underflow();
       if (traits_type::eq_int_type(__tmp, __ret))
  return __ret;
     }
   else
     {





       return __ret;
     }



   if (!__testeof && traits_type::eq_int_type(__i, __tmp))
     __ret = __i;
   else if (__testeof)
     __ret = traits_type::not_eof(__i);
   else if (!__testpb)
     {
       _M_create_pback();
       _M_reading = true;
       *this->gptr() = traits_type::to_char_type(__i);
       __ret = __i;
     }
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::int_type
    basic_filebuf<_CharT, _Traits>::
    overflow(int_type __c)
    {
      int_type __ret = traits_type::eof();
      const bool __testeof = traits_type::eq_int_type(__c, __ret);
      const bool __testout = (_M_mode & ios_base::out
         || _M_mode & ios_base::app);
      if (__testout)
 {
          if (_M_reading)
            {
              _M_destroy_pback();
              const int __gptr_off = _M_get_ext_pos(_M_state_last);
              if (_M_seek(__gptr_off, ios_base::cur, _M_state_last)
                  == pos_type(off_type(-1)))
                return __ret;
            }
   if (this->pbase() < this->pptr())
     {

       if (!__testeof)
  {
    *this->pptr() = traits_type::to_char_type(__c);
    this->pbump(1);
  }



       if (_M_convert_to_external(this->pbase(),
      this->pptr() - this->pbase()))
  {
    _M_set_buffer(0);
    __ret = traits_type::not_eof(__c);
  }
     }
   else if (_M_buf_size > 1)
     {



       _M_set_buffer(0);
       _M_writing = true;
       if (!__testeof)
  {
    *this->pptr() = traits_type::to_char_type(__c);
    this->pbump(1);
  }
       __ret = traits_type::not_eof(__c);
     }
   else
     {

       char_type __conv = traits_type::to_char_type(__c);
       if (__testeof || _M_convert_to_external(&__conv, 1))
  {
    _M_writing = true;
    __ret = traits_type::not_eof(__c);
  }
     }
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    bool
    basic_filebuf<_CharT, _Traits>::
    _M_convert_to_external(_CharT* __ibuf, streamsize __ilen)
    {

      streamsize __elen;
      streamsize __plen;
      if (__check_facet(_M_codecvt).always_noconv())
 {
   __elen = _M_file.xsputn(reinterpret_cast<char*>(__ibuf), __ilen);
   __plen = __ilen;
 }
      else
 {


   streamsize __blen = __ilen * _M_codecvt->max_length();
   char* __buf = static_cast<char*>(__builtin_alloca(__blen));

   char* __bend;
   const char_type* __iend;
   codecvt_base::result __r;
   __r = _M_codecvt->out(_M_state_cur, __ibuf, __ibuf + __ilen,
    __iend, __buf, __buf + __blen, __bend);

   if (__r == codecvt_base::ok || __r == codecvt_base::partial)
     __blen = __bend - __buf;
   else if (__r == codecvt_base::noconv)
     {

       __buf = reinterpret_cast<char*>(__ibuf);
       __blen = __ilen;
     }
   else
     __throw_ios_failure(("basic_filebuf::_M_convert_to_external " "conversion error")
                           );

   __elen = _M_file.xsputn(__buf, __blen);
   __plen = __blen;


   if (__r == codecvt_base::partial && __elen == __plen)
     {
       const char_type* __iresume = __iend;
       streamsize __rlen = this->pptr() - __iend;
       __r = _M_codecvt->out(_M_state_cur, __iresume,
        __iresume + __rlen, __iend, __buf,
        __buf + __blen, __bend);
       if (__r != codecvt_base::error)
  {
    __rlen = __bend - __buf;
    __elen = _M_file.xsputn(__buf, __rlen);
    __plen = __rlen;
  }
       else
  __throw_ios_failure(("basic_filebuf::_M_convert_to_external " "conversion error")
                        );
     }
 }
      return __elen == __plen;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_filebuf<_CharT, _Traits>::
    xsgetn(_CharT* __s, streamsize __n)
    {

      streamsize __ret = 0;
      if (_M_pback_init)
 {
   if (__n > 0 && this->gptr() == this->eback())
     {
       *__s++ = *this->gptr();
       this->gbump(1);
       __ret = 1;
       --__n;
     }
   _M_destroy_pback();
 }
      else if (_M_writing)
 {
   if (overflow() == traits_type::eof())
     return __ret;
   _M_set_buffer(-1);
   _M_writing = false;
 }




      const bool __testin = _M_mode & ios_base::in;
      const streamsize __buflen = _M_buf_size > 1 ? _M_buf_size - 1 : 1;

      if (__n > __buflen && __check_facet(_M_codecvt).always_noconv()
   && __testin)
 {

   const streamsize __avail = this->egptr() - this->gptr();
   if (__avail != 0)
     {
       traits_type::copy(__s, this->gptr(), __avail);
       __s += __avail;
       this->setg(this->eback(), this->gptr() + __avail, this->egptr());
       __ret += __avail;
       __n -= __avail;
     }



   streamsize __len;
   for (;;)
     {
       __len = _M_file.xsgetn(reinterpret_cast<char*>(__s), __n);
       if (__len == -1)
  __throw_ios_failure(("basic_filebuf::xsgetn " "error reading the file")
                              , (*__errno_location ()));
       if (__len == 0)
  break;

       __n -= __len;
       __ret += __len;
       if (__n == 0)
  break;

       __s += __len;
     }

   if (__n == 0)
     {

       _M_reading = true;
     }
   else if (__len == 0)
     {



       _M_set_buffer(-1);
       _M_reading = false;
     }
 }
      else
 __ret += __streambuf_type::xsgetn(__s, __n);

      return __ret;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_filebuf<_CharT, _Traits>::
    xsputn(const _CharT* __s, streamsize __n)
    {
      streamsize __ret = 0;



      const bool __testout = (_M_mode & ios_base::out
         || _M_mode & ios_base::app);
      if (__check_facet(_M_codecvt).always_noconv()
   && __testout && !_M_reading)
 {

   const streamsize __chunk = 1ul << 10;
   streamsize __bufavail = this->epptr() - this->pptr();


   if (!_M_writing && _M_buf_size > 1)
     __bufavail = _M_buf_size - 1;

   const streamsize __limit = std::min(__chunk, __bufavail);
   if (__n >= __limit)
     {
       const streamsize __buffill = this->pptr() - this->pbase();
       const char* __buf = reinterpret_cast<const char*>(this->pbase());
       __ret = _M_file.xsputn_2(__buf, __buffill,
           reinterpret_cast<const char*>(__s),
           __n);
       if (__ret == __buffill + __n)
  {
    _M_set_buffer(0);
    _M_writing = true;
  }
       if (__ret > __buffill)
  __ret -= __buffill;
       else
  __ret = 0;
     }
   else
     __ret = __streambuf_type::xsputn(__s, __n);
 }
       else
  __ret = __streambuf_type::xsputn(__s, __n);
       return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::__streambuf_type*
    basic_filebuf<_CharT, _Traits>::
    setbuf(char_type* __s, streamsize __n)
    {
      if (!this->is_open())
 {
   if (__s == 0 && __n == 0)
     _M_buf_size = 1;
   else if (__s && __n > 0)
     {
# 820 "/usr/include/c++/10.2.0/bits/fstream.tcc" 3
       _M_buf = __s;
       _M_buf_size = __n;
     }
 }
      return this;
    }




  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::pos_type
    basic_filebuf<_CharT, _Traits>::
    seekoff(off_type __off, ios_base::seekdir __way, ios_base::openmode)
    {
      int __width = 0;
      if (_M_codecvt)
 __width = _M_codecvt->encoding();
      if (__width < 0)
 __width = 0;

      pos_type __ret = pos_type(off_type(-1));
      const bool __testfail = __off != 0 && __width <= 0;
      if (this->is_open() && !__testfail)
 {




   bool __no_movement = __way == ios_base::cur && __off == 0
     && (!_M_writing || _M_codecvt->always_noconv());


   if (!__no_movement)
     _M_destroy_pback();






   __state_type __state = _M_state_beg;
   off_type __computed_off = __off * __width;
   if (_M_reading && __way == ios_base::cur)
     {
       __state = _M_state_last;
       __computed_off += _M_get_ext_pos(__state);
     }
   if (!__no_movement)
     __ret = _M_seek(__computed_off, __way, __state);
   else
     {
       if (_M_writing)
  __computed_off = this->pptr() - this->pbase();

       off_type __file_off = _M_file.seekoff(0, ios_base::cur);
       if (__file_off != off_type(-1))
  {
    __ret = __file_off + __computed_off;
    __ret.state(__state);
  }
     }
 }
      return __ret;
    }





  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::pos_type
    basic_filebuf<_CharT, _Traits>::
    seekpos(pos_type __pos, ios_base::openmode)
    {
      pos_type __ret = pos_type(off_type(-1));
      if (this->is_open())
 {

   _M_destroy_pback();
   __ret = _M_seek(off_type(__pos), ios_base::beg, __pos.state());
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_filebuf<_CharT, _Traits>::pos_type
    basic_filebuf<_CharT, _Traits>::
    _M_seek(off_type __off, ios_base::seekdir __way, __state_type __state)
    {
      pos_type __ret = pos_type(off_type(-1));
      if (_M_terminate_output())
 {
   off_type __file_off = _M_file.seekoff(__off, __way);
   if (__file_off != off_type(-1))
     {
       _M_reading = false;
       _M_writing = false;
       _M_ext_next = _M_ext_end = _M_ext_buf;
       _M_set_buffer(-1);
       _M_state_cur = __state;
       __ret = __file_off;
       __ret.state(_M_state_cur);
     }
 }
      return __ret;
    }




  template<typename _CharT, typename _Traits>
    int basic_filebuf<_CharT, _Traits>::
    _M_get_ext_pos(__state_type& __state)
    {
      if (_M_codecvt->always_noconv())
        return this->gptr() - this->egptr();
      else
        {



          const int __gptr_off =
            _M_codecvt->length(__state, _M_ext_buf, _M_ext_next,
                               this->gptr() - this->eback());
          return _M_ext_buf + __gptr_off - _M_ext_end;
        }
    }

  template<typename _CharT, typename _Traits>
    bool
    basic_filebuf<_CharT, _Traits>::
    _M_terminate_output()
    {

      bool __testvalid = true;
      if (this->pbase() < this->pptr())
 {
   const int_type __tmp = this->overflow();
   if (traits_type::eq_int_type(__tmp, traits_type::eof()))
     __testvalid = false;
 }


      if (_M_writing && !__check_facet(_M_codecvt).always_noconv()
   && __testvalid)
 {



   const size_t __blen = 128;
   char __buf[__blen];
   codecvt_base::result __r;
   streamsize __ilen = 0;

   do
     {
       char* __next;
       __r = _M_codecvt->unshift(_M_state_cur, __buf,
     __buf + __blen, __next);
       if (__r == codecvt_base::error)
  __testvalid = false;
       else if (__r == codecvt_base::ok ||
         __r == codecvt_base::partial)
  {
    __ilen = __next - __buf;
    if (__ilen > 0)
      {
        const streamsize __elen = _M_file.xsputn(__buf, __ilen);
        if (__elen != __ilen)
   __testvalid = false;
      }
  }
     }
   while (__r == codecvt_base::partial && __ilen > 0 && __testvalid);

   if (__testvalid)
     {




       const int_type __tmp = this->overflow();
       if (traits_type::eq_int_type(__tmp, traits_type::eof()))
  __testvalid = false;
     }
 }
      return __testvalid;
    }

  template<typename _CharT, typename _Traits>
    int
    basic_filebuf<_CharT, _Traits>::
    sync()
    {


      int __ret = 0;
      if (this->pbase() < this->pptr())
 {
   const int_type __tmp = this->overflow();
   if (traits_type::eq_int_type(__tmp, traits_type::eof()))
     __ret = -1;
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    void
    basic_filebuf<_CharT, _Traits>::
    imbue(const locale& __loc)
    {
      bool __testvalid = true;

      const __codecvt_type* _M_codecvt_tmp = 0;
      if (__builtin_expect(has_facet<__codecvt_type>(__loc), true))
 _M_codecvt_tmp = &use_facet<__codecvt_type>(__loc);

      if (this->is_open())
 {

   if ((_M_reading || _M_writing)
       && __check_facet(_M_codecvt).encoding() == -1)
     __testvalid = false;
   else
     {
       if (_M_reading)
  {
    if (__check_facet(_M_codecvt).always_noconv())
      {
        if (_M_codecvt_tmp
     && !__check_facet(_M_codecvt_tmp).always_noconv())
   __testvalid = this->seekoff(0, ios_base::cur, _M_mode)
                 != pos_type(off_type(-1));
      }
    else
      {

        _M_ext_next = _M_ext_buf
   + _M_codecvt->length(_M_state_last, _M_ext_buf,
          _M_ext_next,
          this->gptr() - this->eback());
        const streamsize __remainder = _M_ext_end - _M_ext_next;
        if (__remainder)
   __builtin_memmove(_M_ext_buf, _M_ext_next, __remainder);

        _M_ext_next = _M_ext_buf;
        _M_ext_end = _M_ext_buf + __remainder;
        _M_set_buffer(-1);
        _M_state_last = _M_state_cur = _M_state_beg;
      }
  }
       else if (_M_writing && (__testvalid = _M_terminate_output()))
  _M_set_buffer(-1);
     }
 }

      if (__testvalid)
 _M_codecvt = _M_codecvt_tmp;
      else
 _M_codecvt = 0;
    }




  extern template class basic_filebuf<char>;
  extern template class basic_ifstream<char>;
  extern template class basic_ofstream<char>;
  extern template class basic_fstream<char>;


  extern template class basic_filebuf<wchar_t>;
  extern template class basic_ifstream<wchar_t>;
  extern template class basic_ofstream<wchar_t>;
  extern template class basic_fstream<wchar_t>;




}
# 1294 "/usr/include/c++/10.2.0/fstream" 2 3
# 23 "/usr/include/opencascade/Standard_Stream.hxx" 2
# 20 "/usr/include/opencascade/Standard_OStream.hxx" 2


# 21 "/usr/include/opencascade/Standard_OStream.hxx"
typedef std::ostream Standard_OStream;
# 29 "/usr/include/opencascade/Standard_ExtCharacter.hxx" 2
# 39 "/usr/include/opencascade/Standard_ExtCharacter.hxx"
inline Standard_ExtCharacter ToExtCharacter(const Standard_Character achar)
{

    return (Standard_ExtCharacter)( (unsigned char)achar & 0x00ff );
}




inline Standard_Character ToCharacter(const Standard_ExtCharacter achar)
{

    return (Standard_Character)(unsigned char)(achar & 0x00ff);
}




inline Standard_Boolean IsAnAscii(const Standard_ExtCharacter achar)
{
    return ! ( achar & 0xff00 );
}




inline Standard_Boolean IsEqual(const Standard_ExtCharacter One,
    const Standard_ExtCharacter Two)
{ return One == Two; }
# 28 "/usr/include/opencascade/Standard_PrimitiveTypes.hxx" 2
# 1 "/usr/include/opencascade/Standard_CString.hxx" 1
# 23 "/usr/include/opencascade/Standard_CString.hxx"
# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/include/stdarg.h" 1 3 4
# 24 "/usr/include/opencascade/Standard_CString.hxx" 2
# 40 "/usr/include/opencascade/Standard_CString.hxx"
 Standard_Integer HashCode (Standard_CString theString, Standard_Integer theUpperBound);






 Standard_Integer HashCodes (Standard_CString theString, Standard_Integer theLength);






inline Standard_Integer HashCode (const Standard_CString theString,
                                  const Standard_Integer theLength,
                                  const Standard_Integer theUpperBound)
{

  return HashCode (HashCodes (theString, theLength), theUpperBound);
}


inline Standard_Boolean IsEqual (const Standard_CString theOne, const Standard_CString theTwo)
{
  return strcmp (theOne, theTwo) == 0;
}




extern "C" {



 double Atof (const char* theStr);


 double Strtod (const char* theStr, char** theNextPtr);


 int Printf (const char* theFormat, ...);


 int Fprintf (FILE* theFile, const char* theFormat, ...);


 int Sprintf (char* theBuffer, const char* theFormat, ...);
# 96 "/usr/include/opencascade/Standard_CString.hxx"
 int Vsprintf (char* theBuffer, const char* theFormat, va_list theArgList);


}
# 29 "/usr/include/opencascade/Standard_PrimitiveTypes.hxx" 2
# 1 "/usr/include/opencascade/Standard_ExtString.hxx" 1
# 31 "/usr/include/opencascade/Standard_ExtString.hxx"
 Standard_Integer HashCode (Standard_ExtString theExtString, Standard_Integer theUpperBound);
# 30 "/usr/include/opencascade/Standard_PrimitiveTypes.hxx" 2
# 21 "/usr/include/opencascade/Standard_Transient.hxx" 2

class Standard_Type;

namespace opencascade {
  template <class T> class handle;
}




class Standard_Transient
{
public:

  void* operator new (size_t theSize) { return Standard::Allocate (theSize); } void operator delete (void* theAddress) { Standard::Free (theAddress); } void* operator new[] (size_t theSize) { return Standard::Allocate (theSize); } void operator delete[] (void* theAddress) { Standard::Free (theAddress); } void* operator new (size_t, void* theAddress) { return theAddress; } void operator delete (void*, void*) { }

public:


  Standard_Transient() : myRefCount_(0) {}


  Standard_Transient (const Standard_Transient&) : myRefCount_(0) {}


  Standard_Transient& operator= (const Standard_Transient&) { return *this; }


  virtual ~Standard_Transient() {}


  virtual void Delete() const;

public:


  typedef void base_type;

  static const char* get_type_name () { return "Standard_Transient"; }


  static const opencascade::handle<Standard_Type>& get_type_descriptor ();


  virtual const opencascade::handle<Standard_Type>& DynamicType() const;


  Standard_Boolean IsInstance(const opencascade::handle<Standard_Type>& theType) const;


  Standard_Boolean IsInstance(const Standard_CString theTypeName) const;




  Standard_Boolean IsKind(const opencascade::handle<Standard_Type>& theType) const;




  Standard_Boolean IsKind(const Standard_CString theTypeName) const;





  Standard_Transient* This() const;

public:



  Standard_Integer GetRefCount() const { return myRefCount_; }


  void IncrementRefCounter() const;



  Standard_Integer DecrementRefCounter() const;

private:




  mutable volatile Standard_Integer myRefCount_;
};






inline Standard_Integer HashCode (const Standard_Transient* const theTransientObject,
                                  const Standard_Integer theUpperBound)
{
  return ::HashCode (static_cast<const void*> (theTransientObject), theUpperBound);
}


typedef opencascade::handle<Standard_Transient> Handle_Standard_Transient;
# 92 "/usr/include/opencascade/Standard.hxx" 2
# 21 "/usr/include/opencascade/DsgPrs_FixPresentation.hxx" 2

# 1 "/usr/include/opencascade/Standard_Handle.hxx" 1
# 22 "/usr/include/opencascade/Standard_Handle.hxx"
class Standard_Transient;


namespace opencascade {
# 49 "/usr/include/opencascade/Standard_Handle.hxx"
  template <class T>
  class handle
  {
  public:

    typedef T element_type;

  public:


    handle () : entity(0) {}


    handle (const T *thePtr) : entity(const_cast<T*>(thePtr))
    {
      BeginScope();
    }


    handle (const handle& theHandle) : entity(theHandle.entity)
    {
      BeginScope();
    }



    handle (handle&& theHandle) : entity(theHandle.entity)
    {
      theHandle.entity = 0;
    }



    ~handle ()
    {
      EndScope();
    }


    void Nullify()
    {
      EndScope();
    }


    bool IsNull() const { return entity == 0; }


    void reset (T* thePtr)
    {
      Assign (thePtr);
    }


    handle& operator= (const handle& theHandle)
    {
      Assign (theHandle.entity);
      return *this;
    }


    handle& operator= (const T* thePtr)
    {
      Assign (const_cast<T*>(thePtr));
      return *this;
    }



    handle& operator= (handle&& theHandle)
    {
      std::swap (this->entity, theHandle.entity);
      return *this;
    }




    T* get() const { return static_cast<T*>(this->entity); }


    T* operator-> () const { return static_cast<T*>(this->entity); }


    T& operator* () const { return *get(); }


    template <class T2>
    bool operator== (const handle<T2>& theHandle) const
    {
      return get() == theHandle.get();
    }


    template <class T2>
    bool operator== (const T2 *thePtr) const
    {
      return get() == thePtr;
    }


    template <class T2>
    friend bool operator== (const T2 *left, const handle& right)
    {
      return left == right.get();
    }


    template <class T2>
    bool operator!= (const handle<T2>& theHandle) const
    {
      return get() != theHandle.get();
    }


    template <class T2>
    bool operator!= (const T2 *thePtr) const
    {
      return get() != thePtr;
    }


    template <class T2>
    friend bool operator!= (const T2 *left, const handle& right)
    {
      return left != right.get();
    }


    template <class T2>
    bool operator< (const handle<T2>& theHandle) const
    {
      return get() < theHandle.get();
    }


    template <class T2>
    static typename opencascade::std::enable_if<is_base_but_not_same<T2, T>::value, handle>::type
      DownCast (const handle<T2>& theObject)
    {
      return handle (dynamic_cast<T*>(const_cast<T2*>(theObject.get())));
    }


    template <class T2>
    static typename opencascade::std::enable_if<is_base_but_not_same<T2, T>::value, handle>::type
      DownCast (const T2* thePtr)
    {
      return handle (dynamic_cast<T*>(const_cast<T2*>(thePtr)));
    }


    template <class T2>
    __attribute__((deprecated("down-casting from object of the same or unrelated type is meaningless")))
    static handle DownCast (const handle<T2>& theObject, typename opencascade::std::enable_if<!is_base_but_not_same<T2, T>::value, void*>::type = 0)
    {
      return handle (dynamic_cast<T*>(const_cast<T2*>(theObject.get())));
    }


    template <class T2>
    __attribute__((deprecated("down-casting from object of the same or unrelated type is meaningless")))
    static handle DownCast (const T2* thePtr, typename opencascade::std::enable_if<!is_base_but_not_same<T2, T>::value, void*>::type = 0)
    {
      return handle (dynamic_cast<T*>(const_cast<T2*>(thePtr)));
    }






    explicit operator bool () const
    {
      return entity != nullptr;
    }
# 281 "/usr/include/opencascade/Standard_Handle.hxx"
    template <class T2, typename = typename std::enable_if<is_base_but_not_same<T2, T>::value>::type>
    operator const handle<T2>& () const
    {
      return reinterpret_cast<const handle<T2>&>(*this);
    }



    template <class T2, typename = typename std::enable_if<is_base_but_not_same<T2, T>::value>::type>
    operator handle<T2>& ()
    {
      return reinterpret_cast<handle<T2>&>(*this);
    }
# 371 "/usr/include/opencascade/Standard_Handle.hxx"
  private:


    void Assign (Standard_Transient *thePtr)
    {
      if (thePtr == entity)
        return;
      EndScope();
      entity = thePtr;
      BeginScope();
    }


    void BeginScope()
    {
      if (entity != 0)
        entity->IncrementRefCounter();
    }


    void EndScope()
    {
      if (entity != 0 && entity->DecrementRefCounter() == 0)
        entity->Delete();
      entity = 0;
    }

    template <class T2> friend class handle;

  private:
    Standard_Transient* entity;
  };

}
# 413 "/usr/include/opencascade/Standard_Handle.hxx"
template <class TheTransientType>
Standard_Integer HashCode (const opencascade::handle<TheTransientType> & theHandle, const Standard_Integer theUpperBound)
{
  return ::HashCode (theHandle.get(), theUpperBound);
}
# 23 "/usr/include/opencascade/DsgPrs_FixPresentation.hxx" 2

# 1 "/usr/include/opencascade/Prs3d_Drawer.hxx" 1
# 19 "/usr/include/opencascade/Prs3d_Drawer.hxx"
# 1 "/usr/include/opencascade/Standard_Type.hxx" 1
# 34 "/usr/include/opencascade/Standard_Type.hxx"
# 1 "/usr/include/c++/10.2.0/tr2/type_traits" 1 3
# 32 "/usr/include/c++/10.2.0/tr2/type_traits" 3
       
# 33 "/usr/include/c++/10.2.0/tr2/type_traits" 3




# 36 "/usr/include/c++/10.2.0/tr2/type_traits" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


namespace tr2
{
# 55 "/usr/include/c++/10.2.0/tr2/type_traits" 3
  template<typename... _Elements>
    struct __reflection_typelist;


  template<>
    struct __reflection_typelist<>
    {
      typedef std::true_type empty;
    };


  template<typename _First, typename... _Rest>
    struct __reflection_typelist<_First, _Rest...>
    {
      typedef std::false_type empty;

      struct first
      {
 typedef _First type;
      };

      struct rest
      {
 typedef __reflection_typelist<_Rest...> type;
      };
    };






  template<typename _Tp>
    struct bases
    {
      typedef __reflection_typelist<__bases(_Tp)...> type;
    };


  template<typename _Tp>
    struct direct_bases
    {
      typedef __reflection_typelist<__direct_bases(_Tp)...> type;
    };


}


}
# 35 "/usr/include/opencascade/Standard_Type.hxx" 2



# 37 "/usr/include/opencascade/Standard_Type.hxx"
namespace opencascade
{
  template<typename T>
  struct direct_base_class_as_tuple {};

  template<typename ... Ts>
  struct direct_base_class_as_tuple<std::tr2::__reflection_typelist<Ts...> >
  {
    typedef std::tuple<Ts...> type;
  };

  template <typename T, typename Tuple>
  struct has_type;

  template <typename T>
  struct has_type<T, std::tuple<> > : std::false_type {};

  template <typename T, typename U, typename... Ts>
  struct has_type<T, std::tuple<U, Ts...> > : has_type<T, std::tuple<Ts...> > {};

  template <typename T, typename... Ts>
  struct has_type<T, std::tuple<T, Ts...> > : std::true_type {};
}
# 121 "/usr/include/opencascade/Standard_Type.hxx"
namespace opencascade {
  template <typename T>
  class type_instance;
}
# 149 "/usr/include/opencascade/Standard_Type.hxx"
class Standard_Type : public Standard_Transient
{
public:


  Standard_CString SystemName() const { return mySystemName; }


  Standard_CString Name() const { return myName; }


  Standard_Size Size() const { return mySize; }


  const opencascade::handle<Standard_Type>& Parent () const { return myParent; }



  Standard_Boolean SubType (const opencascade::handle<Standard_Type>& theOther) const;



  Standard_Boolean SubType (const Standard_CString theOther) const;


  void Print (Standard_OStream& theStream) const;






  template <class T>
  static const opencascade::handle<Standard_Type>& Instance()
  {
    return opencascade::type_instance<T>::get();
  }
# 195 "/usr/include/opencascade/Standard_Type.hxx"
  static
    Standard_Type* Register (const char* theSystemName, const char* theName,
                             Standard_Size theSize, const opencascade::handle<Standard_Type>& theParent);


  ~Standard_Type ();


  public: typedef Standard_Transient base_type; static const char* get_type_name () { return "Standard_Type"; using direct_base_classes = opencascade::direct_base_class_as_tuple<std::tr2::direct_bases<Standard_Type>::type>::type; static_assert(opencascade::has_type<Standard_Transient, direct_base_classes>::type::value, "OCCT RTTI definition is incorrect: " "Standard_Transient" " is not direct base class of " "Standard_Type"); static_assert(&get_type_name == &Standard_Type::get_type_name, "OCCT RTTI definition is misplaced: current class is not " "Standard_Type"); } static const opencascade::handle<Standard_Type>& get_type_descriptor (); virtual const opencascade::handle<Standard_Type>& DynamicType() const override;

private:


  Standard_Type (const char* theSystemName, const char* theName,
                 Standard_Size theSize, const opencascade::handle<Standard_Type>& theParent);

private:
  Standard_CString mySystemName;
  Standard_CString myName;
  Standard_Size mySize;
  opencascade::handle<Standard_Type> myParent;
};

namespace opencascade {
# 229 "/usr/include/opencascade/Standard_Type.hxx"
  template <typename T>
  class type_instance
  {
    static opencascade::handle<Standard_Type> myInstance;
  public:
    static const opencascade::handle<Standard_Type>& get ();
  };


  template <>
  class type_instance<void>
  {
  public:
    static opencascade::handle<Standard_Type> get () { return 0; }
  };



  template <typename T>
  const opencascade::handle<Standard_Type>& type_instance<T>::get ()
  {
# 259 "/usr/include/opencascade/Standard_Type.hxx"
    static opencascade::handle<Standard_Type> anInstance =
      Standard_Type::Register (typeid(T).name(), T::get_type_name(), sizeof(T),
                               type_instance<typename T::base_type>::get());
    return anInstance;
  }
# 281 "/usr/include/opencascade/Standard_Type.hxx"
}


inline Standard_OStream& operator << (Standard_OStream& theStream, const opencascade::handle<Standard_Type>& theType)
{
  theType->Print (theStream);
  return theStream;
}


class Standard_Type; typedef opencascade::handle<Standard_Type> Handle_Standard_Type;
# 20 "/usr/include/opencascade/Prs3d_Drawer.hxx" 2



# 1 "/usr/include/opencascade/Aspect_TypeOfDeflection.hxx" 1
# 22 "/usr/include/opencascade/Aspect_TypeOfDeflection.hxx"
enum Aspect_TypeOfDeflection
{
Aspect_TOD_RELATIVE,
Aspect_TOD_ABSOLUTE
};
# 24 "/usr/include/opencascade/Prs3d_Drawer.hxx" 2
# 1 "/usr/include/opencascade/Graphic3d_GroupAspect.hxx" 1
# 25 "/usr/include/opencascade/Graphic3d_GroupAspect.hxx"
enum Graphic3d_GroupAspect
{
Graphic3d_ASPECT_LINE,
Graphic3d_ASPECT_TEXT,
Graphic3d_ASPECT_MARKER,
Graphic3d_ASPECT_FILL_AREA
};
# 25 "/usr/include/opencascade/Prs3d_Drawer.hxx" 2
# 1 "/usr/include/opencascade/Graphic3d_PresentationAttributes.hxx" 1
# 19 "/usr/include/opencascade/Graphic3d_PresentationAttributes.hxx"
# 1 "/usr/include/opencascade/Aspect_TypeOfHighlightMethod.hxx" 1
# 25 "/usr/include/opencascade/Aspect_TypeOfHighlightMethod.hxx"
enum Aspect_TypeOfHighlightMethod
{
Aspect_TOHM_COLOR,
Aspect_TOHM_BOUNDBOX
};
# 20 "/usr/include/opencascade/Graphic3d_PresentationAttributes.hxx" 2
# 1 "/usr/include/opencascade/Graphic3d_AspectFillArea3d.hxx" 1
# 20 "/usr/include/opencascade/Graphic3d_AspectFillArea3d.hxx"
# 1 "/usr/include/opencascade/Graphic3d_Aspects.hxx" 1
# 17 "/usr/include/opencascade/Graphic3d_Aspects.hxx"
# 1 "/usr/include/opencascade/Aspect_PolygonOffsetMode.hxx" 1
# 21 "/usr/include/opencascade/Aspect_PolygonOffsetMode.hxx"
typedef enum
{
  Aspect_POM_Off = 0x00,
  Aspect_POM_Fill = 0x01,
  Aspect_POM_Line = 0x02,
  Aspect_POM_Point = 0x04,
  Aspect_POM_All = Aspect_POM_Fill | Aspect_POM_Line | Aspect_POM_Point,
  Aspect_POM_None = 0x08,
  Aspect_POM_Mask = Aspect_POM_All | Aspect_POM_None
} Aspect_PolygonOffsetMode;
# 18 "/usr/include/opencascade/Graphic3d_Aspects.hxx" 2
# 1 "/usr/include/opencascade/Aspect_InteriorStyle.hxx" 1
# 20 "/usr/include/opencascade/Aspect_InteriorStyle.hxx"
enum Aspect_InteriorStyle
{
  Aspect_IS_EMPTY = -1,
  Aspect_IS_SOLID = 0,
  Aspect_IS_HATCH,
  Aspect_IS_HIDDENLINE,
  Aspect_IS_POINT,


  Aspect_IS_HOLLOW = Aspect_IS_EMPTY,
};
# 19 "/usr/include/opencascade/Graphic3d_Aspects.hxx" 2
# 1 "/usr/include/opencascade/Aspect_TypeOfDisplayText.hxx" 1
# 20 "/usr/include/opencascade/Aspect_TypeOfDisplayText.hxx"
enum Aspect_TypeOfDisplayText
{
  Aspect_TODT_NORMAL,
  Aspect_TODT_SUBTITLE,
  Aspect_TODT_DEKALE,
  Aspect_TODT_BLEND,
  Aspect_TODT_DIMENSION,
  Aspect_TODT_SHADOW
};
# 20 "/usr/include/opencascade/Graphic3d_Aspects.hxx" 2
# 1 "/usr/include/opencascade/Aspect_TypeOfLine.hxx" 1
# 20 "/usr/include/opencascade/Aspect_TypeOfLine.hxx"
enum Aspect_TypeOfLine
{
  Aspect_TOL_EMPTY = -1,
  Aspect_TOL_SOLID = 0,
  Aspect_TOL_DASH,
  Aspect_TOL_DOT,
  Aspect_TOL_DOTDASH,
  Aspect_TOL_USERDEFINED
};
# 21 "/usr/include/opencascade/Graphic3d_Aspects.hxx" 2
# 1 "/usr/include/opencascade/Aspect_TypeOfMarker.hxx" 1
# 20 "/usr/include/opencascade/Aspect_TypeOfMarker.hxx"
enum Aspect_TypeOfMarker
{
  Aspect_TOM_EMPTY = -1,
  Aspect_TOM_POINT = 0,
  Aspect_TOM_PLUS,
  Aspect_TOM_STAR,
  Aspect_TOM_X,
  Aspect_TOM_O,
  Aspect_TOM_O_POINT,
  Aspect_TOM_O_PLUS,
  Aspect_TOM_O_STAR,
  Aspect_TOM_O_X,
  Aspect_TOM_RING1,
  Aspect_TOM_RING2,
  Aspect_TOM_RING3,
  Aspect_TOM_BALL,
  Aspect_TOM_USERDEFINED
};
# 22 "/usr/include/opencascade/Graphic3d_Aspects.hxx" 2
# 1 "/usr/include/opencascade/Aspect_TypeOfStyleText.hxx" 1
# 26 "/usr/include/opencascade/Aspect_TypeOfStyleText.hxx"
enum Aspect_TypeOfStyleText
{
Aspect_TOST_NORMAL,
Aspect_TOST_ANNOTATION
};
# 23 "/usr/include/opencascade/Graphic3d_Aspects.hxx" 2
# 1 "/usr/include/opencascade/Font_FontAspect.hxx" 1
# 19 "/usr/include/opencascade/Font_FontAspect.hxx"
enum Font_FontAspect
{
  Font_FontAspect_UNDEFINED = -1,
  Font_FontAspect_Regular = 0,
  Font_FontAspect_Bold,
  Font_FontAspect_Italic,
  Font_FontAspect_BoldItalic,


  Font_FA_Undefined = Font_FontAspect_UNDEFINED,
  Font_FA_Regular = Font_FontAspect_Regular,
  Font_FA_Bold = Font_FontAspect_Bold,
  Font_FA_Italic = Font_FontAspect_Italic,
  Font_FA_BoldItalic = Font_FontAspect_BoldItalic
};
enum { Font_FontAspect_NB = Font_FontAspect_BoldItalic + 1 };
# 24 "/usr/include/opencascade/Graphic3d_Aspects.hxx" 2
# 1 "/usr/include/opencascade/Font_NameOfFont.hxx" 1
# 25 "/usr/include/opencascade/Graphic3d_Aspects.hxx" 2
# 1 "/usr/include/opencascade/Graphic3d_AlphaMode.hxx" 1
# 18 "/usr/include/opencascade/Graphic3d_AlphaMode.hxx"
enum Graphic3d_AlphaMode
{
  Graphic3d_AlphaMode_Opaque = 0,
  Graphic3d_AlphaMode_Mask,
  Graphic3d_AlphaMode_Blend,

  Graphic3d_AlphaMode_BlendAuto = -1,

};
# 26 "/usr/include/opencascade/Graphic3d_Aspects.hxx" 2
# 1 "/usr/include/opencascade/Graphic3d_MarkerImage.hxx" 1
# 19 "/usr/include/opencascade/Graphic3d_MarkerImage.hxx"
# 1 "/usr/include/opencascade/TColStd_HArray1OfByte.hxx" 1
# 18 "/usr/include/opencascade/TColStd_HArray1OfByte.hxx"
# 1 "/usr/include/opencascade/Standard_Byte.hxx" 1
# 19 "/usr/include/opencascade/TColStd_HArray1OfByte.hxx" 2
# 1 "/usr/include/opencascade/TColStd_Array1OfByte.hxx" 1
# 19 "/usr/include/opencascade/TColStd_Array1OfByte.hxx"
# 1 "/usr/include/opencascade/NCollection_Array1.hxx" 1
# 19 "/usr/include/opencascade/NCollection_Array1.hxx"
# 1 "/usr/include/opencascade/Standard_DimensionMismatch.hxx" 1
# 21 "/usr/include/opencascade/Standard_DimensionMismatch.hxx"
# 1 "/usr/include/opencascade/Standard_DefineException.hxx" 1
# 22 "/usr/include/opencascade/Standard_DimensionMismatch.hxx" 2
# 1 "/usr/include/opencascade/Standard_SStream.hxx" 1
# 22 "/usr/include/opencascade/Standard_SStream.hxx"
typedef std::stringstream Standard_SStream;
# 23 "/usr/include/opencascade/Standard_DimensionMismatch.hxx" 2
# 1 "/usr/include/opencascade/Standard_DimensionError.hxx" 1
# 23 "/usr/include/opencascade/Standard_DimensionError.hxx"
# 1 "/usr/include/opencascade/Standard_DomainError.hxx" 1
# 23 "/usr/include/opencascade/Standard_DomainError.hxx"
# 1 "/usr/include/opencascade/Standard_Failure.hxx" 1
# 27 "/usr/include/opencascade/Standard_Failure.hxx"
class Standard_NoSuchObject;


class Standard_Failure;
class Standard_Failure; typedef opencascade::handle<Standard_Failure> Handle_Standard_Failure;



class Standard_Failure : public Standard_Transient
{

public:




  Standard_Failure();


  Standard_Failure (const Standard_Failure& f);


  Standard_Failure(const Standard_CString aString);


  Standard_Failure& operator= (const Standard_Failure& f);


  ~Standard_Failure();




  void Print (Standard_OStream& theStream) const;


  virtual Standard_CString GetMessageString() const;


  virtual void SetMessageString (const Standard_CString aMessage);

  void Reraise();

  void Reraise (const Standard_CString aMessage);


  void Reraise (const Standard_SStream& aReason);




  static void Raise (const Standard_CString aMessage = "");




  static void Raise (const Standard_SStream& aReason);






  static opencascade::handle<Standard_Failure> NewInstance (const Standard_CString aMessage);






  void Jump();




  __attribute__((deprecated("This method is deprecated (not thread-safe), use standard C++ mechanism instead")))
  static opencascade::handle<Standard_Failure> Caught();



  public: typedef Standard_Transient base_type; static const char* get_type_name () { return "Standard_Failure"; using direct_base_classes = opencascade::direct_base_class_as_tuple<std::tr2::direct_bases<Standard_Failure>::type>::type; static_assert(opencascade::has_type<Standard_Transient, direct_base_classes>::type::value, "OCCT RTTI definition is incorrect: " "Standard_Transient" " is not direct base class of " "Standard_Failure"); static_assert(&get_type_name == &Standard_Failure::get_type_name, "OCCT RTTI definition is misplaced: current class is not " "Standard_Failure"); } static const opencascade::handle<Standard_Type>& get_type_descriptor (); virtual const opencascade::handle<Standard_Type>& DynamicType() const override;

protected:






  virtual void Throw() const;



private:


  Standard_CString myMessage;


};

inline Standard_OStream& operator << (Standard_OStream& AStream,
                                      const opencascade::handle<Standard_Failure>& AFailure)
{
  AFailure->Print(AStream);
  return AStream;
}

inline Standard_OStream& operator << (Standard_OStream& AStream,
                                      const Standard_Failure& AFailure)
{
  AFailure.Print(AStream);
  return AStream;
}
# 24 "/usr/include/opencascade/Standard_DomainError.hxx" 2

class Standard_DomainError;
class Standard_DomainError; typedef opencascade::handle<Standard_DomainError> Handle_Standard_DomainError;
# 35 "/usr/include/opencascade/Standard_DomainError.hxx"
class Standard_DomainError : public Standard_Failure { void Throw () const override { throw *this; } public: Standard_DomainError() : Standard_Failure() {} Standard_DomainError(const Standard_CString theMessage) : Standard_Failure(theMessage) {} static void Raise(const Standard_CString theMessage = "") { opencascade::handle<Standard_DomainError> _E = new Standard_DomainError; _E->Reraise(theMessage); } static void Raise(Standard_SStream& theMessage) { opencascade::handle<Standard_DomainError> _E = new Standard_DomainError; _E->Reraise (theMessage); } static opencascade::handle<Standard_DomainError> NewInstance(const Standard_CString theMessage = "") { return new Standard_DomainError(theMessage); } public: typedef Standard_Failure base_type; static const char* get_type_name () { return "Standard_DomainError"; using direct_base_classes = opencascade::direct_base_class_as_tuple<std::tr2::direct_bases<Standard_DomainError>::type>::type; static_assert(opencascade::has_type<Standard_Failure, direct_base_classes>::type::value, "OCCT RTTI definition is incorrect: " "Standard_Failure" " is not direct base class of " "Standard_DomainError"); static_assert(&get_type_name == &Standard_DomainError::get_type_name, "OCCT RTTI definition is misplaced: current class is not " "Standard_DomainError"); } static const opencascade::handle<Standard_Type>& get_type_descriptor () { return Standard_Type::Instance<Standard_DomainError>(); } virtual const opencascade::handle<Standard_Type>& DynamicType() const override { return get_type_descriptor (); } };
# 24 "/usr/include/opencascade/Standard_DimensionError.hxx" 2

class Standard_DimensionError;
class Standard_DimensionError; typedef opencascade::handle<Standard_DimensionError> Handle_Standard_DimensionError;
# 35 "/usr/include/opencascade/Standard_DimensionError.hxx"
class Standard_DimensionError : public Standard_DomainError { void Throw () const override { throw *this; } public: Standard_DimensionError() : Standard_DomainError() {} Standard_DimensionError(const Standard_CString theMessage) : Standard_DomainError(theMessage) {} static void Raise(const Standard_CString theMessage = "") { opencascade::handle<Standard_DimensionError> _E = new Standard_DimensionError; _E->Reraise(theMessage); } static void Raise(Standard_SStream& theMessage) { opencascade::handle<Standard_DimensionError> _E = new Standard_DimensionError; _E->Reraise (theMessage); } static opencascade::handle<Standard_DimensionError> NewInstance(const Standard_CString theMessage = "") { return new Standard_DimensionError(theMessage); } public: typedef Standard_DomainError base_type; static const char* get_type_name () { return "Standard_DimensionError"; using direct_base_classes = opencascade::direct_base_class_as_tuple<std::tr2::direct_bases<Standard_DimensionError>::type>::type; static_assert(opencascade::has_type<Standard_DomainError, direct_base_classes>::type::value, "OCCT RTTI definition is incorrect: " "Standard_DomainError" " is not direct base class of " "Standard_DimensionError"); static_assert(&get_type_name == &Standard_DimensionError::get_type_name, "OCCT RTTI definition is misplaced: current class is not " "Standard_DimensionError"); } static const opencascade::handle<Standard_Type>& get_type_descriptor () { return Standard_Type::Instance<Standard_DimensionError>(); } virtual const opencascade::handle<Standard_Type>& DynamicType() const override { return get_type_descriptor (); } };
# 24 "/usr/include/opencascade/Standard_DimensionMismatch.hxx" 2

class Standard_DimensionMismatch;
class Standard_DimensionMismatch; typedef opencascade::handle<Standard_DimensionMismatch> Handle_Standard_DimensionMismatch;
# 35 "/usr/include/opencascade/Standard_DimensionMismatch.hxx"
class Standard_DimensionMismatch : public Standard_DimensionError { void Throw () const override { throw *this; } public: Standard_DimensionMismatch() : Standard_DimensionError() {} Standard_DimensionMismatch(const Standard_CString theMessage) : Standard_DimensionError(theMessage) {} static void Raise(const Standard_CString theMessage = "") { opencascade::handle<Standard_DimensionMismatch> _E = new Standard_DimensionMismatch; _E->Reraise(theMessage); } static void Raise(Standard_SStream& theMessage) { opencascade::handle<Standard_DimensionMismatch> _E = new Standard_DimensionMismatch; _E->Reraise (theMessage); } static opencascade::handle<Standard_DimensionMismatch> NewInstance(const Standard_CString theMessage = "") { return new Standard_DimensionMismatch(theMessage); } public: typedef Standard_DimensionError base_type; static const char* get_type_name () { return "Standard_DimensionMismatch"; using direct_base_classes = opencascade::direct_base_class_as_tuple<std::tr2::direct_bases<Standard_DimensionMismatch>::type>::type; static_assert(opencascade::has_type<Standard_DimensionError, direct_base_classes>::type::value, "OCCT RTTI definition is incorrect: " "Standard_DimensionError" " is not direct base class of " "Standard_DimensionMismatch"); static_assert(&get_type_name == &Standard_DimensionMismatch::get_type_name, "OCCT RTTI definition is misplaced: current class is not " "Standard_DimensionMismatch"); } static const opencascade::handle<Standard_Type>& get_type_descriptor () { return Standard_Type::Instance<Standard_DimensionMismatch>(); } virtual const opencascade::handle<Standard_Type>& DynamicType() const override { return get_type_descriptor (); } };
# 20 "/usr/include/opencascade/NCollection_Array1.hxx" 2
# 1 "/usr/include/opencascade/Standard_OutOfMemory.hxx" 1
# 23 "/usr/include/opencascade/Standard_OutOfMemory.hxx"
# 1 "/usr/include/opencascade/Standard_ProgramError.hxx" 1
# 25 "/usr/include/opencascade/Standard_ProgramError.hxx"
class Standard_ProgramError;
class Standard_ProgramError; typedef opencascade::handle<Standard_ProgramError> Handle_Standard_ProgramError;
# 35 "/usr/include/opencascade/Standard_ProgramError.hxx"
class Standard_ProgramError : public Standard_Failure { void Throw () const override { throw *this; } public: Standard_ProgramError() : Standard_Failure() {} Standard_ProgramError(const Standard_CString theMessage) : Standard_Failure(theMessage) {} static void Raise(const Standard_CString theMessage = "") { opencascade::handle<Standard_ProgramError> _E = new Standard_ProgramError; _E->Reraise(theMessage); } static void Raise(Standard_SStream& theMessage) { opencascade::handle<Standard_ProgramError> _E = new Standard_ProgramError; _E->Reraise (theMessage); } static opencascade::handle<Standard_ProgramError> NewInstance(const Standard_CString theMessage = "") { return new Standard_ProgramError(theMessage); } public: typedef Standard_Failure base_type; static const char* get_type_name () { return "Standard_ProgramError"; using direct_base_classes = opencascade::direct_base_class_as_tuple<std::tr2::direct_bases<Standard_ProgramError>::type>::type; static_assert(opencascade::has_type<Standard_Failure, direct_base_classes>::type::value, "OCCT RTTI definition is incorrect: " "Standard_Failure" " is not direct base class of " "Standard_ProgramError"); static_assert(&get_type_name == &Standard_ProgramError::get_type_name, "OCCT RTTI definition is misplaced: current class is not " "Standard_ProgramError"); } static const opencascade::handle<Standard_Type>& get_type_descriptor () { return Standard_Type::Instance<Standard_ProgramError>(); } virtual const opencascade::handle<Standard_Type>& DynamicType() const override { return get_type_descriptor (); } };
# 24 "/usr/include/opencascade/Standard_OutOfMemory.hxx" 2

class Standard_OutOfMemory;
class Standard_OutOfMemory; typedef opencascade::handle<Standard_OutOfMemory> Handle_Standard_OutOfMemory;
# 49 "/usr/include/opencascade/Standard_OutOfMemory.hxx"
class Standard_OutOfMemory : public Standard_ProgramError
{
  void Throw () const override;

public:


  Standard_OutOfMemory(const Standard_CString theMessage = 0);


  Standard_CString GetMessageString() const override;


  void SetMessageString (const Standard_CString aMessage) override;


  static void Raise(const Standard_CString theMessage = "");


  static void Raise(Standard_SStream& theMessage);


  static opencascade::handle<Standard_OutOfMemory> NewInstance(const Standard_CString theMessage = "");

  public: typedef Standard_ProgramError base_type; static const char* get_type_name () { return "Standard_OutOfMemory"; using direct_base_classes = opencascade::direct_base_class_as_tuple<std::tr2::direct_bases<Standard_OutOfMemory>::type>::type; static_assert(opencascade::has_type<Standard_ProgramError, direct_base_classes>::type::value, "OCCT RTTI definition is incorrect: " "Standard_ProgramError" " is not direct base class of " "Standard_OutOfMemory"); static_assert(&get_type_name == &Standard_OutOfMemory::get_type_name, "OCCT RTTI definition is misplaced: current class is not " "Standard_OutOfMemory"); } static const opencascade::handle<Standard_Type>& get_type_descriptor (); virtual const opencascade::handle<Standard_Type>& DynamicType() const override;

protected:
  char myBuffer[1024];
};
# 21 "/usr/include/opencascade/NCollection_Array1.hxx" 2
# 1 "/usr/include/opencascade/Standard_OutOfRange.hxx" 1
# 23 "/usr/include/opencascade/Standard_OutOfRange.hxx"
# 1 "/usr/include/opencascade/Standard_RangeError.hxx" 1
# 25 "/usr/include/opencascade/Standard_RangeError.hxx"
class Standard_RangeError;
class Standard_RangeError; typedef opencascade::handle<Standard_RangeError> Handle_Standard_RangeError;
# 44 "/usr/include/opencascade/Standard_RangeError.hxx"
class Standard_RangeError : public Standard_DomainError { void Throw () const override { throw *this; } public: Standard_RangeError() : Standard_DomainError() {} Standard_RangeError(const Standard_CString theMessage) : Standard_DomainError(theMessage) {} static void Raise(const Standard_CString theMessage = "") { opencascade::handle<Standard_RangeError> _E = new Standard_RangeError; _E->Reraise(theMessage); } static void Raise(Standard_SStream& theMessage) { opencascade::handle<Standard_RangeError> _E = new Standard_RangeError; _E->Reraise (theMessage); } static opencascade::handle<Standard_RangeError> NewInstance(const Standard_CString theMessage = "") { return new Standard_RangeError(theMessage); } public: typedef Standard_DomainError base_type; static const char* get_type_name () { return "Standard_RangeError"; using direct_base_classes = opencascade::direct_base_class_as_tuple<std::tr2::direct_bases<Standard_RangeError>::type>::type; static_assert(opencascade::has_type<Standard_DomainError, direct_base_classes>::type::value, "OCCT RTTI definition is incorrect: " "Standard_DomainError" " is not direct base class of " "Standard_RangeError"); static_assert(&get_type_name == &Standard_RangeError::get_type_name, "OCCT RTTI definition is misplaced: current class is not " "Standard_RangeError"); } static const opencascade::handle<Standard_Type>& get_type_descriptor () { return Standard_Type::Instance<Standard_RangeError>(); } virtual const opencascade::handle<Standard_Type>& DynamicType() const override { return get_type_descriptor (); } };
# 24 "/usr/include/opencascade/Standard_OutOfRange.hxx" 2

class Standard_OutOfRange;
class Standard_OutOfRange; typedef opencascade::handle<Standard_OutOfRange> Handle_Standard_OutOfRange;
# 46 "/usr/include/opencascade/Standard_OutOfRange.hxx"
class Standard_OutOfRange : public Standard_RangeError { void Throw () const override { throw *this; } public: Standard_OutOfRange() : Standard_RangeError() {} Standard_OutOfRange(const Standard_CString theMessage) : Standard_RangeError(theMessage) {} static void Raise(const Standard_CString theMessage = "") { opencascade::handle<Standard_OutOfRange> _E = new Standard_OutOfRange; _E->Reraise(theMessage); } static void Raise(Standard_SStream& theMessage) { opencascade::handle<Standard_OutOfRange> _E = new Standard_OutOfRange; _E->Reraise (theMessage); } static opencascade::handle<Standard_OutOfRange> NewInstance(const Standard_CString theMessage = "") { return new Standard_OutOfRange(theMessage); } public: typedef Standard_RangeError base_type; static const char* get_type_name () { return "Standard_OutOfRange"; using direct_base_classes = opencascade::direct_base_class_as_tuple<std::tr2::direct_bases<Standard_OutOfRange>::type>::type; static_assert(opencascade::has_type<Standard_RangeError, direct_base_classes>::type::value, "OCCT RTTI definition is incorrect: " "Standard_RangeError" " is not direct base class of " "Standard_OutOfRange"); static_assert(&get_type_name == &Standard_OutOfRange::get_type_name, "OCCT RTTI definition is misplaced: current class is not " "Standard_OutOfRange"); } static const opencascade::handle<Standard_Type>& get_type_descriptor () { return Standard_Type::Instance<Standard_OutOfRange>(); } virtual const opencascade::handle<Standard_Type>& DynamicType() const override { return get_type_descriptor (); } };
# 22 "/usr/include/opencascade/NCollection_Array1.hxx" 2

# 1 "/usr/include/opencascade/NCollection_DefineAlloc.hxx" 1
# 19 "/usr/include/opencascade/NCollection_DefineAlloc.hxx"
# 1 "/usr/include/opencascade/NCollection_BaseAllocator.hxx" 1
# 32 "/usr/include/opencascade/NCollection_BaseAllocator.hxx"
# 1 "/usr/include/opencascade/NCollection_TypeDef.hxx" 1
# 33 "/usr/include/opencascade/NCollection_BaseAllocator.hxx" 2
# 47 "/usr/include/opencascade/NCollection_BaseAllocator.hxx"
class NCollection_BaseAllocator : public Standard_Transient
{
 public:

  virtual void* Allocate (const size_t size);
  virtual void Free (void * anAddress);





  static const opencascade::handle<NCollection_BaseAllocator>&
    CommonBaseAllocator(void);


  static void StandardCallBack
                    (const Standard_Boolean theIsAlloc,
                     const Standard_Address theStorage,
                     const Standard_Size theRoundSize,
                     const Standard_Size theSize);


  static void PrintMemUsageStatistics();

 protected:

  NCollection_BaseAllocator(void) {}

 private:

  NCollection_BaseAllocator(const NCollection_BaseAllocator&);

 public:

  public: typedef Standard_Transient base_type; static const char* get_type_name () { return "NCollection_BaseAllocator"; using direct_base_classes = opencascade::direct_base_class_as_tuple<std::tr2::direct_bases<NCollection_BaseAllocator>::type>::type; static_assert(opencascade::has_type<Standard_Transient, direct_base_classes>::type::value, "OCCT RTTI definition is incorrect: " "Standard_Transient" " is not direct base class of " "NCollection_BaseAllocator"); static_assert(&get_type_name == &NCollection_BaseAllocator::get_type_name, "OCCT RTTI definition is misplaced: current class is not " "NCollection_BaseAllocator"); } static const opencascade::handle<Standard_Type>& get_type_descriptor (); virtual const opencascade::handle<Standard_Type>& DynamicType() const override;
};

class NCollection_BaseAllocator; typedef opencascade::handle<NCollection_BaseAllocator> Handle_NCollection_BaseAllocator;
# 20 "/usr/include/opencascade/NCollection_DefineAlloc.hxx" 2
# 24 "/usr/include/opencascade/NCollection_Array1.hxx" 2
# 1 "/usr/include/opencascade/NCollection_StlIterator.hxx" 1
# 19 "/usr/include/opencascade/NCollection_StlIterator.hxx"
# 1 "/usr/include/opencascade/Standard_Assert.hxx" 1
# 70 "/usr/include/opencascade/Standard_Assert.hxx"
inline void Standard_ASSERT_DO_NOTHING() {}
# 162 "/usr/include/opencascade/Standard_Assert.hxx"
template <bool condition>
struct Standard_Static_Assert { };


template <>
struct Standard_Static_Assert<true>
{
  static void assert_ok() {}
};
# 20 "/usr/include/opencascade/NCollection_StlIterator.hxx" 2
# 1 "/usr/include/c++/10.2.0/iterator" 1 3
# 58 "/usr/include/c++/10.2.0/iterator" 3
       
# 59 "/usr/include/c++/10.2.0/iterator" 3






# 1 "/usr/include/c++/10.2.0/bits/stream_iterator.h" 1 3
# 33 "/usr/include/c++/10.2.0/bits/stream_iterator.h" 3
       
# 34 "/usr/include/c++/10.2.0/bits/stream_iterator.h" 3




# 37 "/usr/include/c++/10.2.0/bits/stream_iterator.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{








  template<typename _Tp, typename _CharT = char,
           typename _Traits = char_traits<_CharT>, typename _Dist = ptrdiff_t>
    class istream_iterator
    : public iterator<input_iterator_tag, _Tp, _Dist, const _Tp*, const _Tp&>
    {
    public:
      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef basic_istream<_CharT, _Traits> istream_type;

    private:
      istream_type* _M_stream;
      _Tp _M_value;



      bool _M_ok;

    public:

      constexpr istream_iterator()
      : _M_stream(0), _M_value(), _M_ok(false) {}


      istream_iterator(istream_type& __s)
      : _M_stream(std::__addressof(__s)), _M_ok(true)
      { _M_read(); }

      istream_iterator(const istream_iterator& __obj)
      : _M_stream(__obj._M_stream), _M_value(__obj._M_value),
        _M_ok(__obj._M_ok)
      { }
# 88 "/usr/include/c++/10.2.0/bits/stream_iterator.h" 3
      istream_iterator& operator=(const istream_iterator&) = default;
      ~istream_iterator() = default;


      const _Tp&
      operator*() const
      {


                        ;
 return _M_value;
      }

      const _Tp*
      operator->() const { return std::__addressof((operator*())); }

      istream_iterator&
      operator++()
      {


                        ;
 _M_read();
 return *this;
      }

      istream_iterator
      operator++(int)
      {


                        ;
 istream_iterator __tmp = *this;
 _M_read();
 return __tmp;
      }

    private:
      bool
      _M_equal(const istream_iterator& __x) const
      {


 return (_M_ok == __x._M_ok) && (!_M_ok || _M_stream == __x._M_stream);
      }

      void
      _M_read()
      {
        if (_M_stream && !(*_M_stream >> _M_value))
          {
            _M_stream = 0;
            _M_ok = false;
          }
      }



      friend bool
      operator==(const istream_iterator& __x, const istream_iterator& __y)
      { return __x._M_equal(__y); }



      friend bool
      operator!=(const istream_iterator& __x, const istream_iterator& __y)
      { return !__x._M_equal(__y); }






    };
# 174 "/usr/include/c++/10.2.0/bits/stream_iterator.h" 3
  template<typename _Tp, typename _CharT = char,
           typename _Traits = char_traits<_CharT> >
    class ostream_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    public:





      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef basic_ostream<_CharT, _Traits> ostream_type;


    private:
      ostream_type* _M_stream;
      const _CharT* _M_string;

    public:






      ostream_iterator(ostream_type& __s)
      : _M_stream(std::__addressof(__s)), _M_string(0) {}
# 214 "/usr/include/c++/10.2.0/bits/stream_iterator.h" 3
      ostream_iterator(ostream_type& __s, const _CharT* __c)
      : _M_stream(std::__addressof(__s)), _M_string(__c) { }


      ostream_iterator(const ostream_iterator& __obj)
      : _M_stream(__obj._M_stream), _M_string(__obj._M_string) { }


      ostream_iterator& operator=(const ostream_iterator&) = default;




      ostream_iterator&
      operator=(const _Tp& __value)
      {


                        ;
 *_M_stream << __value;
 if (_M_string)
          *_M_stream << _M_string;
 return *this;
      }

      ostream_iterator&
      operator*()
      { return *this; }

      ostream_iterator&
      operator++()
      { return *this; }

      ostream_iterator&
      operator++(int)
      { return *this; }
    };




}
# 66 "/usr/include/c++/10.2.0/iterator" 2 3
# 21 "/usr/include/opencascade/NCollection_StlIterator.hxx" 2








# 28 "/usr/include/opencascade/NCollection_StlIterator.hxx"
template<class Category, class BaseIterator, class ItemType, bool IsConstant>
class NCollection_StlIterator :
  public std::iterator<Category, ItemType, ptrdiff_t,
                       typename opencascade::std::conditional<IsConstant, const ItemType*, ItemType*>::type,
                       typename opencascade::std::conditional<IsConstant, const ItemType&, ItemType&>::type>
{
public:


  NCollection_StlIterator () {}


  NCollection_StlIterator (const BaseIterator& theIterator)
    : myIterator (theIterator)
  { }


  NCollection_StlIterator (const NCollection_StlIterator<Category, BaseIterator, ItemType, false>& theIterator)
    : myIterator (theIterator.Iterator())
  { }


  NCollection_StlIterator& operator= (const NCollection_StlIterator<Category, BaseIterator, ItemType, false>& theIterator)
  {
    myIterator = theIterator.myIterator;
    return *this;
  }


  const BaseIterator& Iterator () const
  {
    return myIterator;
  }


  BaseIterator& ChangeIterator()
  {
    return myIterator;
  }

protected:




  template<bool Condition>
  typename opencascade::std::enable_if<!Condition, ItemType&>::type Reference() const
  {
    return myIterator.ChangeValue();
  }

  template<bool Condition>
  typename opencascade::std::enable_if<Condition, const ItemType&>::type Reference() const
  {
    return myIterator.Value();
  }

public:


  bool operator== (const NCollection_StlIterator& theOther) const
  {
    return myIterator.More() == theOther.myIterator.More() &&
           (!myIterator.More() || myIterator.IsEqual (theOther.myIterator));
  }


  bool operator!= (const NCollection_StlIterator& theOther) const
  {
    return !(*this == theOther);
  }


  typename NCollection_StlIterator::reference operator*() const
  {
    return Reference<IsConstant>();
  }


  typename NCollection_StlIterator::pointer operator->() const
  {
    return &Reference<IsConstant>();
  }


  NCollection_StlIterator& operator++()
  {
    myIterator.Next();
    return *this;
  }


  NCollection_StlIterator operator++(int)
  {
    const NCollection_StlIterator theOld (*this);
    ++(*this);
    return theOld;
  }

public:


  NCollection_StlIterator& operator--()
  {
    Standard_Static_Assert<(opencascade::std::is_same<std::bidirectional_iterator_tag,Category>::value || opencascade::std::is_same<std::random_access_iterator_tag,Category>::value)>::assert_ok();
                                                                                                        ;
    myIterator.Previous();
    return *this;
  }


  NCollection_StlIterator operator--(int)
  {
    NCollection_StlIterator theOld (*this);
    --(*this);
    return theOld;
  }

public:


  NCollection_StlIterator& operator+= (typename NCollection_StlIterator::difference_type theOffset)
  {
    Standard_Static_Assert<(opencascade::std::is_same<std::random_access_iterator_tag,Category>::value)>::assert_ok();;
    myIterator.Offset (theOffset);
    return *this;
  }


  NCollection_StlIterator operator+ (typename NCollection_StlIterator::difference_type theOffset) const
  {
    NCollection_StlIterator aTemp (*this);
    return aTemp += theOffset;
  }


  NCollection_StlIterator& operator-= (typename NCollection_StlIterator::difference_type theOffset)
  {
    return *this += -theOffset;
  }


  NCollection_StlIterator operator- (typename NCollection_StlIterator::difference_type theOffset) const
  {
    NCollection_StlIterator aTemp (*this);
    return aTemp += -theOffset;
  }


  typename NCollection_StlIterator::difference_type operator- (const NCollection_StlIterator& theOther) const
  {
    Standard_Static_Assert<(opencascade::std::is_same<std::random_access_iterator_tag,Category>::value)>::assert_ok();;
    return myIterator.Differ (theOther.myIterator);
  }


  typename NCollection_StlIterator::reference operator[] (typename NCollection_StlIterator::difference_type theOffset) const
  {
    return *(*this + theOffset);
  }


  bool operator< (const NCollection_StlIterator& theOther) const
  {
    return (*this - theOther) < 0;
  }


  bool operator> (const NCollection_StlIterator& theOther) const
  {
    return theOther < *this;
  }


  bool operator<= (const NCollection_StlIterator& theOther) const
  {
    return !(theOther < *this);
  }


  bool operator>= (const NCollection_StlIterator& theOther) const
  {
    return !(*this < theOther);
  }

private:

  BaseIterator myIterator;
};
# 25 "/usr/include/opencascade/NCollection_Array1.hxx" 2
# 56 "/usr/include/opencascade/NCollection_Array1.hxx"
template <class TheItemType>
class NCollection_Array1
{
public:

  typedef TheItemType value_type;

public:

  class Iterator
  {
  public:


    Iterator (void) :
      myPtrCur (
# 71 "/usr/include/opencascade/NCollection_Array1.hxx" 3 4
               __null
# 71 "/usr/include/opencascade/NCollection_Array1.hxx"
                   ),
      myPtrEnd (
# 72 "/usr/include/opencascade/NCollection_Array1.hxx" 3 4
               __null
# 72 "/usr/include/opencascade/NCollection_Array1.hxx"
                   )
    {

    }


    Iterator (const NCollection_Array1& theArray, Standard_Boolean theToEnd = false) :
      myPtrEnd (const_cast<TheItemType*> (&theArray.Last() + 1))
    {
      myPtrCur = theToEnd ? myPtrEnd : const_cast<TheItemType*> (&theArray.First());
    }


    void Init (const NCollection_Array1& theArray)
    {
      myPtrCur = const_cast<TheItemType*> (&theArray.First());
      myPtrEnd = const_cast<TheItemType*> (&theArray.Last() + 1);
    }


    Standard_Boolean More (void) const
    { return myPtrCur < myPtrEnd; }


    void Next (void)
    { ++myPtrCur; }


    void Previous()
    { --myPtrCur; }


    void Offset (ptrdiff_t theOffset)
    { myPtrCur += theOffset; }


    ptrdiff_t Differ (const Iterator& theOther) const
    { return myPtrCur - theOther.myPtrCur; }


    const TheItemType& Value (void) const
    { return *myPtrCur; }


    TheItemType& ChangeValue (void) const
    { return *myPtrCur; }


    Standard_Boolean IsEqual (const Iterator& theOther) const
    { return myPtrCur == theOther.myPtrCur; }

  private:
    TheItemType* myPtrCur;
    TheItemType* myPtrEnd;
  };


  typedef NCollection_StlIterator<std::random_access_iterator_tag, Iterator, TheItemType, false> iterator;


  typedef NCollection_StlIterator<std::random_access_iterator_tag, Iterator, TheItemType, true> const_iterator;


  iterator begin() const { return Iterator (*this, false); }


  iterator end() const { return Iterator (*this, true); }


  const_iterator cbegin() const { return Iterator (*this, false); }


  const_iterator cend() const { return Iterator (*this, true); }

 public:




  NCollection_Array1()
  : myLowerBound (1),
    myUpperBound (0),
    myDeletable (false),
    myData (
# 155 "/usr/include/opencascade/NCollection_Array1.hxx" 3 4
           __null
# 155 "/usr/include/opencascade/NCollection_Array1.hxx"
               )
  {

  }


  NCollection_Array1(const Standard_Integer theLower,
                     const Standard_Integer theUpper) :
                myLowerBound (theLower),
                myUpperBound (theUpper),
                myDeletable (true)
  {
   
# 167 "/usr/include/opencascade/NCollection_Array1.hxx"
#pragma GCC diagnostic push
# 167 "/usr/include/opencascade/NCollection_Array1.hxx"
   
# 167 "/usr/include/opencascade/NCollection_Array1.hxx"
#pragma GCC diagnostic ignored "-Wstrict-overflow"
# 167 "/usr/include/opencascade/NCollection_Array1.hxx"
    if (theUpper < theLower) throw Standard_RangeError("NCollection_Array1::Create");
# 167 "/usr/include/opencascade/NCollection_Array1.hxx"
#pragma GCC diagnostic pop
# 167 "/usr/include/opencascade/NCollection_Array1.hxx"
    ;
    TheItemType* pBegin = new TheItemType[Length()];
    if (!pBegin) throw Standard_OutOfMemory("NCollection_Array1 : Allocation failed");;

    myData = pBegin - theLower;
  }


  NCollection_Array1 (const NCollection_Array1& theOther) :
    myLowerBound (theOther.Lower()),
    myUpperBound (theOther.Upper()),
    myDeletable (true)
  {
    TheItemType* pBegin = new TheItemType[Length()];
    if (!pBegin) throw Standard_OutOfMemory("NCollection_Array1 : Allocation failed");;
    myData = pBegin - myLowerBound;

    Assign (theOther);
  }



  NCollection_Array1 (NCollection_Array1&& theOther)
  : myLowerBound (theOther.myLowerBound),
    myUpperBound (theOther.myUpperBound),
    myDeletable (theOther.myDeletable),
    myData (theOther.myData)
  {
    theOther.myDeletable = false;
  }
# 214 "/usr/include/opencascade/NCollection_Array1.hxx"
  NCollection_Array1 (const TheItemType& theBegin,
                      const Standard_Integer theLower,
                      const Standard_Integer theUpper) :
    myLowerBound (theLower),
    myUpperBound (theUpper),
    myDeletable (false)
  {
   
# 221 "/usr/include/opencascade/NCollection_Array1.hxx"
#pragma GCC diagnostic push
# 221 "/usr/include/opencascade/NCollection_Array1.hxx"
   
# 221 "/usr/include/opencascade/NCollection_Array1.hxx"
#pragma GCC diagnostic ignored "-Wstrict-overflow"
# 221 "/usr/include/opencascade/NCollection_Array1.hxx"
    if (theUpper < theLower) throw Standard_RangeError("NCollection_Array1::Create");
# 221 "/usr/include/opencascade/NCollection_Array1.hxx"
#pragma GCC diagnostic pop
# 221 "/usr/include/opencascade/NCollection_Array1.hxx"
    ;





#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Warray-bounds"

    myData = (TheItemType *) &theBegin - theLower;

#pragma GCC diagnostic pop

  }


  void Init (const TheItemType& theValue)
  {
    TheItemType *pCur = &myData[myLowerBound], *pEnd=&myData[myUpperBound];
    for(; pCur <= pEnd; pCur++)
      *pCur = (TheItemType&) theValue;
  }


  Standard_Integer Size (void) const
  { return Length(); }

  Standard_Integer Length (void) const
  { return (myUpperBound-myLowerBound+1); }


  Standard_Boolean IsEmpty() const { return myUpperBound < myLowerBound; }


  Standard_Integer Lower (void) const
  { return myLowerBound; }

  Standard_Integer Upper (void) const
  { return myUpperBound; }


  Standard_Boolean IsDeletable (void) const
  { return myDeletable; }


  Standard_Boolean IsAllocated (void) const
  { return myDeletable; }




  NCollection_Array1& Assign (const NCollection_Array1& theOther)
  {
    if (&theOther == this)
      return *this;

    if (Length() != theOther.Length()) throw Standard_DimensionMismatch("NCollection_Array1::operator=");;
    if (myData == 
# 278 "/usr/include/opencascade/NCollection_Array1.hxx" 3 4
                 __null
# 278 "/usr/include/opencascade/NCollection_Array1.hxx"
                     )
    {
      return *this;
    }

    TheItemType * pMyItem = &myData[myLowerBound];
    TheItemType * const pEndItem = &(theOther.myData)[theOther.myUpperBound];
    TheItemType * pItem = &(theOther.myData)[theOther.myLowerBound];
    while (pItem <= pEndItem) * pMyItem ++ = * pItem ++;
    return *this;
  }





  NCollection_Array1& Move (NCollection_Array1& theOther)
  {
    if (&theOther == this)
    {
      return *this;
    }

    if (myDeletable)
    {
      delete[] &myData[myLowerBound];
    }

    myLowerBound = theOther.myLowerBound;
    myUpperBound = theOther.myUpperBound;
    myDeletable = theOther.myDeletable;
    myData = theOther.myData;

    theOther.myDeletable = false;

    return *this;
  }


  NCollection_Array1& operator= (const NCollection_Array1& theOther)
  {
    return Assign (theOther);
  }



  NCollection_Array1& operator= (NCollection_Array1&& theOther)
  {
    return Move (theOther);
  }



  const TheItemType& First() const
  {
    return myData[myLowerBound];
  }


  TheItemType& ChangeFirst()
  {
    return myData[myLowerBound];
  }


  const TheItemType& Last() const
  {
    return myData[myUpperBound];
  }


  TheItemType& ChangeLast()
  {
    return myData[myUpperBound];
  }


  const TheItemType& Value (const Standard_Integer theIndex) const
  {
   
# 357 "/usr/include/opencascade/NCollection_Array1.hxx"
#pragma GCC diagnostic push
# 357 "/usr/include/opencascade/NCollection_Array1.hxx"
   
# 357 "/usr/include/opencascade/NCollection_Array1.hxx"
#pragma GCC diagnostic ignored "-Wstrict-overflow"
# 357 "/usr/include/opencascade/NCollection_Array1.hxx"
    if (theIndex < myLowerBound || theIndex > myUpperBound) throw Standard_OutOfRange("NCollection_Array1::Value");
# 357 "/usr/include/opencascade/NCollection_Array1.hxx"
#pragma GCC diagnostic pop
# 357 "/usr/include/opencascade/NCollection_Array1.hxx"
    ;
    return myData[theIndex];
  }


  const TheItemType& operator() (const Standard_Integer theIndex) const
  { return Value (theIndex); }


  const TheItemType& operator[] (Standard_Integer theIndex) const { return Value (theIndex); }


  TheItemType& ChangeValue (const Standard_Integer theIndex)
  {
   
# 371 "/usr/include/opencascade/NCollection_Array1.hxx"
#pragma GCC diagnostic push
# 371 "/usr/include/opencascade/NCollection_Array1.hxx"
   
# 371 "/usr/include/opencascade/NCollection_Array1.hxx"
#pragma GCC diagnostic ignored "-Wstrict-overflow"
# 371 "/usr/include/opencascade/NCollection_Array1.hxx"
    if (theIndex < myLowerBound || theIndex > myUpperBound) throw Standard_OutOfRange("NCollection_Array1::ChangeValue");
# 371 "/usr/include/opencascade/NCollection_Array1.hxx"
#pragma GCC diagnostic pop
# 371 "/usr/include/opencascade/NCollection_Array1.hxx"
    ;
    return myData[theIndex];
  }


  TheItemType& operator() (const Standard_Integer theIndex)
  { return ChangeValue (theIndex); }


  TheItemType& operator[] (Standard_Integer theIndex) { return ChangeValue (theIndex); }


  void SetValue (const Standard_Integer theIndex,
                 const TheItemType& theItem)
  {
   
# 386 "/usr/include/opencascade/NCollection_Array1.hxx"
#pragma GCC diagnostic push
# 386 "/usr/include/opencascade/NCollection_Array1.hxx"
   
# 386 "/usr/include/opencascade/NCollection_Array1.hxx"
#pragma GCC diagnostic ignored "-Wstrict-overflow"
# 386 "/usr/include/opencascade/NCollection_Array1.hxx"
    if (theIndex < myLowerBound || theIndex > myUpperBound) throw Standard_OutOfRange("NCollection_Array1::SetValue");
# 386 "/usr/include/opencascade/NCollection_Array1.hxx"
#pragma GCC diagnostic pop
# 386 "/usr/include/opencascade/NCollection_Array1.hxx"
    ;
    myData[theIndex] = theItem;
  }







  void Resize (const Standard_Integer theLower,
               const Standard_Integer theUpper,
               const Standard_Boolean theToCopyData)
  {
   
# 400 "/usr/include/opencascade/NCollection_Array1.hxx"
#pragma GCC diagnostic push
# 400 "/usr/include/opencascade/NCollection_Array1.hxx"
   
# 400 "/usr/include/opencascade/NCollection_Array1.hxx"
#pragma GCC diagnostic ignored "-Wstrict-overflow"
# 400 "/usr/include/opencascade/NCollection_Array1.hxx"
    if (theUpper < theLower) throw Standard_RangeError("NCollection_Array1::Resize");
# 400 "/usr/include/opencascade/NCollection_Array1.hxx"
#pragma GCC diagnostic pop
# 400 "/usr/include/opencascade/NCollection_Array1.hxx"
    ;
    const Standard_Integer anOldLen = Length();
    const Standard_Integer aNewLen = theUpper - theLower + 1;
    const Standard_Integer aLowerOld = myLowerBound;

    TheItemType* aBeginOld = &myData[aLowerOld];
    myLowerBound = theLower;
    myUpperBound = theUpper;
    if (aNewLen == anOldLen)
    {
      myData = aBeginOld - theLower;
      return;
    }

    if (!theToCopyData && myDeletable)
    {
      delete[] aBeginOld;
    }
    TheItemType* aBeginNew = new TheItemType[aNewLen];
    if (aBeginNew == 
# 419 "/usr/include/opencascade/NCollection_Array1.hxx" 3 4
   __null
# 419 "/usr/include/opencascade/NCollection_Array1.hxx"
   ) throw Standard_OutOfMemory("NCollection_Array1 : Allocation failed");;
    myData = aBeginNew - theLower;
    if (!theToCopyData)
    {
      myDeletable = true;
      return;
    }

    const Standard_Integer aLenCopy = Min (anOldLen, aNewLen);
    for (Standard_Integer anIter = 0; anIter < aLenCopy; ++anIter)
    {
      aBeginNew[anIter] = aBeginOld[anIter];
    }
    if (myDeletable)
    {
      delete[] aBeginOld;
    }
    myDeletable = true;
  }


  ~NCollection_Array1 (void)
  {
    if (myDeletable)
      delete [] &(myData[myLowerBound]);
  }

 protected:

  Standard_Integer myLowerBound;
  Standard_Integer myUpperBound;
  Standard_Boolean myDeletable;
  TheItemType* myData;
};
# 20 "/usr/include/opencascade/TColStd_Array1OfByte.hxx" 2

typedef NCollection_Array1<Standard_Byte> TColStd_Array1OfByte;
# 20 "/usr/include/opencascade/TColStd_HArray1OfByte.hxx" 2
# 1 "/usr/include/opencascade/NCollection_DefineHArray1.hxx" 1
# 22 "/usr/include/opencascade/NCollection_DefineHArray1.hxx"
# 1 "/usr/include/opencascade/NCollection_DefineArray1.hxx" 1
# 23 "/usr/include/opencascade/NCollection_DefineHArray1.hxx" 2
# 21 "/usr/include/opencascade/TColStd_HArray1OfByte.hxx" 2

class TColStd_HArray1OfByte : public TColStd_Array1OfByte, public Standard_Transient { public: void* operator new (size_t theSize) { return Standard::Allocate (theSize); } void operator delete (void* theAddress) { Standard::Free (theAddress); } void* operator new[] (size_t theSize) { return Standard::Allocate (theSize); } void operator delete[] (void* theAddress) { Standard::Free (theAddress); } void* operator new (size_t, void* theAddress) { return theAddress; } void operator delete (void*, void*) { } void* operator new (size_t theSize, const opencascade::handle<NCollection_BaseAllocator>& theAllocator) { return theAllocator->Allocate(theSize); } void operator delete (void* theAddress, const opencascade::handle<NCollection_BaseAllocator>& theAllocator) { theAllocator->Free(theAddress); } TColStd_HArray1OfByte () : TColStd_Array1OfByte () {} TColStd_HArray1OfByte (const Standard_Integer theLower, const Standard_Integer theUpper) : TColStd_Array1OfByte (theLower,theUpper) {} TColStd_HArray1OfByte (const Standard_Integer theLower, const Standard_Integer theUpper, const TColStd_Array1OfByte::value_type& theValue) : TColStd_Array1OfByte (theLower,theUpper) { Init (theValue); } TColStd_HArray1OfByte (const TColStd_Array1OfByte& theOther) : TColStd_Array1OfByte(theOther) {} const TColStd_Array1OfByte& Array1 () const { return *this; } TColStd_Array1OfByte& ChangeArray1 () { return *this; } public: typedef Standard_Transient base_type; static const char* get_type_name () { return "TColStd_HArray1OfByte"; using direct_base_classes = opencascade::direct_base_class_as_tuple<std::tr2::direct_bases<TColStd_HArray1OfByte>::type>::type; static_assert(opencascade::has_type<Standard_Transient, direct_base_classes>::type::value, "OCCT RTTI definition is incorrect: " "Standard_Transient" " is not direct base class of " "TColStd_HArray1OfByte"); static_assert(&get_type_name == &TColStd_HArray1OfByte::get_type_name, "OCCT RTTI definition is misplaced: current class is not " "TColStd_HArray1OfByte"); } static const opencascade::handle<Standard_Type>& get_type_descriptor () { return Standard_Type::Instance<TColStd_HArray1OfByte>(); } virtual const opencascade::handle<Standard_Type>& DynamicType() const override { return get_type_descriptor (); } }; class TColStd_HArray1OfByte; typedef opencascade::handle<TColStd_HArray1OfByte> Handle_TColStd_HArray1OfByte;
# 20 "/usr/include/opencascade/Graphic3d_MarkerImage.hxx" 2
# 1 "/usr/include/opencascade/TCollection_AsciiString.hxx" 1
# 24 "/usr/include/opencascade/TCollection_AsciiString.hxx"
# 1 "/usr/include/opencascade/Standard_PCharacter.hxx" 1
# 19 "/usr/include/opencascade/Standard_PCharacter.hxx"
typedef Standard_Character* Standard_PCharacter;
# 25 "/usr/include/opencascade/TCollection_AsciiString.hxx" 2






# 1 "/usr/include/opencascade/Standard_IStream.hxx" 1
# 21 "/usr/include/opencascade/Standard_IStream.hxx"
typedef std::istream Standard_IStream;
# 32 "/usr/include/opencascade/TCollection_AsciiString.hxx" 2
class Standard_NullObject;
class Standard_OutOfRange;
class Standard_NumericError;
class Standard_NegativeValue;
class TCollection_HAsciiString;
class TCollection_ExtendedString;
# 52 "/usr/include/opencascade/TCollection_AsciiString.hxx"
class TCollection_AsciiString
{
public:

  void* operator new (size_t theSize) { return Standard::Allocate (theSize); } void operator delete (void* theAddress) { Standard::Free (theAddress); } void* operator new[] (size_t theSize) { return Standard::Allocate (theSize); } void operator delete[] (void* theAddress) { Standard::Free (theAddress); } void* operator new (size_t, void* theAddress) { return theAddress; } void operator delete (void*, void*) { }



  TCollection_AsciiString();


  TCollection_AsciiString(const Standard_CString message);


  TCollection_AsciiString(const Standard_CString message, const Standard_Integer aLen);


  TCollection_AsciiString(const Standard_Character aChar);



  TCollection_AsciiString(const Standard_Integer length, const Standard_Character filler);


  TCollection_AsciiString(const Standard_Integer value);


  TCollection_AsciiString(const Standard_Real value);


  TCollection_AsciiString(const TCollection_AsciiString& astring);



  TCollection_AsciiString (TCollection_AsciiString&& theOther)
  : mystring (theOther.mystring),
    mylength (theOther.mylength)
  {
    theOther.mystring = 
# 90 "/usr/include/opencascade/TCollection_AsciiString.hxx" 3 4
                       __null
# 90 "/usr/include/opencascade/TCollection_AsciiString.hxx"
                           ;
    theOther.mylength = 0;
  }




  TCollection_AsciiString(const TCollection_AsciiString& astring, const Standard_Character message);



  TCollection_AsciiString(const TCollection_AsciiString& astring, const Standard_CString message);



  TCollection_AsciiString(const TCollection_AsciiString& astring, const TCollection_AsciiString& message);





  TCollection_AsciiString(const TCollection_ExtendedString& astring, const Standard_Character replaceNonAscii = 0);







  TCollection_AsciiString (const Standard_WideChar* theStringUtf);



  void AssignCat (const Standard_Character other);
void operator += (const Standard_Character other)
{
  AssignCat(other);
}


  void AssignCat (const Standard_Integer other);
void operator += (const Standard_Integer other)
{
  AssignCat(other);
}


  void AssignCat (const Standard_Real other);
void operator += (const Standard_Real other)
{
  AssignCat(other);
}







  void AssignCat (const Standard_CString other);
void operator += (const Standard_CString other)
{
  AssignCat(other);
}



  void AssignCat (const TCollection_AsciiString& other);
void operator += (const TCollection_AsciiString& other)
{
  AssignCat(other);
}







  void Capitalize();
# 181 "/usr/include/opencascade/TCollection_AsciiString.hxx"
    TCollection_AsciiString Cat (const Standard_Character other) const;
  TCollection_AsciiString operator + (const Standard_Character other) const
{
  return Cat(other);
}
# 196 "/usr/include/opencascade/TCollection_AsciiString.hxx"
    TCollection_AsciiString Cat (const Standard_Integer other) const;
  TCollection_AsciiString operator + (const Standard_Integer other) const
{
  return Cat(other);
}
# 211 "/usr/include/opencascade/TCollection_AsciiString.hxx"
    TCollection_AsciiString Cat (const Standard_Real other) const;
  TCollection_AsciiString operator + (const Standard_Real other) const
{
  return Cat(other);
}
# 227 "/usr/include/opencascade/TCollection_AsciiString.hxx"
    TCollection_AsciiString Cat (const Standard_CString other) const;
  TCollection_AsciiString operator + (const Standard_CString other) const
{
  return Cat(other);
}



    TCollection_AsciiString Cat (const TCollection_AsciiString& other) const;
  TCollection_AsciiString operator + (const TCollection_AsciiString& other) const
{
  return Cat(other);
}
# 252 "/usr/include/opencascade/TCollection_AsciiString.hxx"
  void Center (const Standard_Integer Width, const Standard_Character Filler);
# 261 "/usr/include/opencascade/TCollection_AsciiString.hxx"
  void ChangeAll (const Standard_Character aChar, const Standard_Character NewChar, const Standard_Boolean CaseSensitive = true);



  void Clear();




  void Copy (const Standard_CString fromwhere);
void operator = (const Standard_CString fromwhere)
{
  Copy(fromwhere);
}




  void Copy (const TCollection_AsciiString& fromwhere);
void operator = (const TCollection_AsciiString& fromwhere)
{
  Copy(fromwhere);
}


  void Swap (TCollection_AsciiString& theOther);



  TCollection_AsciiString& operator= (TCollection_AsciiString&& theOther) { Swap (theOther); return *this; }



  ~TCollection_AsciiString();
# 308 "/usr/include/opencascade/TCollection_AsciiString.hxx"
  Standard_Integer FirstLocationInSet (const TCollection_AsciiString& Set, const Standard_Integer FromIndex, const Standard_Integer ToIndex) const;
# 322 "/usr/include/opencascade/TCollection_AsciiString.hxx"
  Standard_Integer FirstLocationNotInSet (const TCollection_AsciiString& Set, const Standard_Integer FromIndex, const Standard_Integer ToIndex) const;
# 332 "/usr/include/opencascade/TCollection_AsciiString.hxx"
  void Insert (const Standard_Integer where, const Standard_Character what);





  void Insert (const Standard_Integer where, const Standard_CString what);


  void Insert (const Standard_Integer where, const TCollection_AsciiString& what);
# 352 "/usr/include/opencascade/TCollection_AsciiString.hxx"
  void InsertAfter (const Standard_Integer Index, const TCollection_AsciiString& other);
# 363 "/usr/include/opencascade/TCollection_AsciiString.hxx"
  void InsertBefore (const Standard_Integer Index, const TCollection_AsciiString& other);


  Standard_Boolean IsEmpty() const { return mylength == 0; }




  Standard_Boolean IsEqual (const Standard_CString other) const;
Standard_Boolean operator == (const Standard_CString other) const
{
  return IsEqual(other);
}




  Standard_Boolean IsEqual (const TCollection_AsciiString& other) const;
Standard_Boolean operator == (const TCollection_AsciiString& other) const
{
  return IsEqual(other);
}




  Standard_Boolean IsDifferent (const Standard_CString other) const;
Standard_Boolean operator != (const Standard_CString other) const
{
  return IsDifferent(other);
}




  Standard_Boolean IsDifferent (const TCollection_AsciiString& other) const;
Standard_Boolean operator != (const TCollection_AsciiString& other) const
{
  return IsDifferent(other);
}


  Standard_Boolean IsLess (const Standard_CString other) const;
Standard_Boolean operator < (const Standard_CString other) const
{
  return IsLess(other);
}


  Standard_Boolean IsLess (const TCollection_AsciiString& other) const;
Standard_Boolean operator < (const TCollection_AsciiString& other) const
{
  return IsLess(other);
}


  Standard_Boolean IsGreater (const Standard_CString other) const;
Standard_Boolean operator > (const Standard_CString other) const
{
  return IsGreater(other);
}


  Standard_Boolean IsGreater (const TCollection_AsciiString& other) const;
Standard_Boolean operator > (const TCollection_AsciiString& other) const
{
  return IsGreater(other);
}


  Standard_Boolean StartsWith (const TCollection_AsciiString& theStartString) const;


  Standard_Boolean EndsWith (const TCollection_AsciiString& theEndString) const;




  Standard_Integer IntegerValue() const;



  Standard_Boolean IsIntegerValue() const;



  Standard_Boolean IsRealValue() const;




  Standard_Boolean IsAscii() const;


  void LeftAdjust();
# 469 "/usr/include/opencascade/TCollection_AsciiString.hxx"
  void LeftJustify (const Standard_Integer Width, const Standard_Character Filler);
# 482 "/usr/include/opencascade/TCollection_AsciiString.hxx"
    Standard_Integer Length() const;
# 496 "/usr/include/opencascade/TCollection_AsciiString.hxx"
  Standard_Integer Location (const TCollection_AsciiString& other, const Standard_Integer FromIndex, const Standard_Integer ToIndex) const;
# 510 "/usr/include/opencascade/TCollection_AsciiString.hxx"
  Standard_Integer Location (const Standard_Integer N, const Standard_Character C, const Standard_Integer FromIndex, const Standard_Integer ToIndex) const;
# 519 "/usr/include/opencascade/TCollection_AsciiString.hxx"
  void LowerCase();







  void Prepend (const TCollection_AsciiString& other);


  void Print (Standard_OStream& astream) const;
friend Standard_OStream& operator << (Standard_OStream& astream,const TCollection_AsciiString& astring);


  void Read (Standard_IStream& astream);
friend Standard_IStream& operator >> (Standard_IStream& astream, TCollection_AsciiString& astring);





  Standard_Real RealValue() const;







  void RemoveAll (const Standard_Character C, const Standard_Boolean CaseSensitive);


  void RemoveAll (const Standard_Character what);







  void Remove (const Standard_Integer where, const Standard_Integer ahowmany = 1);


  void RightAdjust();
# 575 "/usr/include/opencascade/TCollection_AsciiString.hxx"
  void RightJustify (const Standard_Integer Width, const Standard_Character Filler);







  Standard_Integer Search (const Standard_CString what) const;




  Standard_Integer Search (const TCollection_AsciiString& what) const;







  Standard_Integer SearchFromEnd (const Standard_CString what) const;




  Standard_Integer SearchFromEnd (const TCollection_AsciiString& what) const;







  void SetValue (const Standard_Integer where, const Standard_Character what);







  void SetValue (const Standard_Integer where, const Standard_CString what);


  void SetValue (const Standard_Integer where, const TCollection_AsciiString& what);





  TCollection_AsciiString Split (const Standard_Integer where);
# 639 "/usr/include/opencascade/TCollection_AsciiString.hxx"
    TCollection_AsciiString SubString (const Standard_Integer FromIndex, const Standard_Integer ToIndex) const;




    Standard_CString ToCString() const;
# 661 "/usr/include/opencascade/TCollection_AsciiString.hxx"
  TCollection_AsciiString Token (const Standard_CString separators = " \t", const Standard_Integer whichone = 1) const;



  void Trunc (const Standard_Integer ahowmany);


  void UpperCase();



  Standard_Integer UsefullLength() const;







  Standard_Character Value (const Standard_Integer where) const;






  static Standard_Integer HashCode (const TCollection_AsciiString& theAsciiString, Standard_Integer theUpperBound);



    static Standard_Boolean IsEqual (const TCollection_AsciiString& string1, const TCollection_AsciiString& string2);



    static Standard_Boolean IsEqual (const TCollection_AsciiString& string1, const Standard_CString string2);


  static Standard_Boolean IsSameString (const TCollection_AsciiString& theString1,
                                                        const TCollection_AsciiString& theString2,
                                                        const Standard_Boolean theIsCaseSensitive);

friend class TCollection_HAsciiString;

private:

  void Split (const Standard_Integer where, TCollection_AsciiString& result);

  void SubString (const Standard_Integer FromIndex, const Standard_Integer ToIndex, TCollection_AsciiString& result) const;

  void Token (const Standard_CString separators, const Standard_Integer whichone, TCollection_AsciiString& result) const;

private:

  Standard_PCharacter mystring;
  Standard_Integer mylength;

};

# 1 "/usr/include/opencascade/TCollection_AsciiString.lxx" 1
# 24 "/usr/include/opencascade/TCollection_AsciiString.lxx"
inline Standard_Integer HashCode (const TCollection_AsciiString& theAsciiString, const Standard_Integer theUpperBound)
{
  return TCollection_AsciiString::HashCode (theAsciiString, theUpperBound);
}





inline Standard_Boolean IsEqual(const TCollection_AsciiString& string1,
        const TCollection_AsciiString& string2)
{
  return TCollection_AsciiString::IsEqual(string1,string2);
}






inline Standard_CString TCollection_AsciiString::ToCString()const
{
  return mystring;
}


inline Standard_Integer TCollection_AsciiString::Length() const
{
 return mylength;
}

inline TCollection_AsciiString TCollection_AsciiString::Cat(const TCollection_AsciiString& other) const
{
  return TCollection_AsciiString( *this , other ) ;
}

inline TCollection_AsciiString TCollection_AsciiString::Cat(const Standard_CString other) const
{
 return TCollection_AsciiString( *this , other ) ;
}

inline TCollection_AsciiString TCollection_AsciiString::Cat(const Standard_Character other) const
{
 return TCollection_AsciiString( *this , other ) ;
}

inline TCollection_AsciiString TCollection_AsciiString::Cat(const Standard_Integer other) const
{

 return TCollection_AsciiString( *this , TCollection_AsciiString(other) ) ;
}

inline TCollection_AsciiString TCollection_AsciiString::Cat(const Standard_Real other) const
{

 return TCollection_AsciiString( *this , TCollection_AsciiString(other) ) ;
}





inline Standard_Integer TCollection_AsciiString::HashCode (const TCollection_AsciiString& theAsciiString,
                                                           const Standard_Integer theUpperBound)
{
  return ::HashCode (theAsciiString.ToCString(), theAsciiString.Length(), theUpperBound);
}





inline Standard_Boolean TCollection_AsciiString::IsEqual(const TCollection_AsciiString& string1,
        const TCollection_AsciiString& string2)
{
  return string1.IsEqual(string2);
}




inline Standard_Boolean TCollection_AsciiString::IsEqual(const TCollection_AsciiString& string1,
        const Standard_CString string2)
{
  return string1.IsEqual( string2 );
}




inline TCollection_AsciiString TCollection_AsciiString::SubString(const Standard_Integer FromIndex,
          const Standard_Integer ToIndex) const
{

 
#pragma GCC diagnostic push
# 118 "/usr/include/opencascade/TCollection_AsciiString.lxx"
 
#pragma GCC diagnostic ignored "-Wstrict-overflow"
# 118 "/usr/include/opencascade/TCollection_AsciiString.lxx"
  if (FromIndex <= 0 || ToIndex <= 0 || (unsigned int)ToIndex > (unsigned int)mylength || (unsigned int)FromIndex > (unsigned int)ToIndex) throw Standard_OutOfRange("TCollection_AsciiString::SubString() out of range");
#pragma GCC diagnostic pop
# 118 "/usr/include/opencascade/TCollection_AsciiString.lxx"
 
                                                                                          ;
  return TCollection_AsciiString( &mystring [ FromIndex - 1 ] ,
                                  ToIndex - FromIndex + 1 ) ;
}
# 720 "/usr/include/opencascade/TCollection_AsciiString.hxx" 2
# 21 "/usr/include/opencascade/Graphic3d_MarkerImage.hxx" 2

class Image_PixMap;



class Graphic3d_MarkerImage : public Standard_Transient
{
public:


  Graphic3d_MarkerImage (const opencascade::handle<Image_PixMap>& theImage);






  Graphic3d_MarkerImage (const opencascade::handle<TColStd_HArray1OfByte>& theBitMap,
                                         const Standard_Integer& theWidth,
                                         const Standard_Integer& theHeight);






  opencascade::handle<TColStd_HArray1OfByte> GetBitMapArray (const Standard_Real& theAlphaValue = 0.5) const;



  const opencascade::handle<Image_PixMap>& GetImage();



  const opencascade::handle<Image_PixMap>& GetImageAlpha();


  const TCollection_AsciiString& GetImageId() const;


  const TCollection_AsciiString& GetImageAlphaId() const;


  void GetTextureSize (Standard_Integer& theWidth,
                                       Standard_Integer& theHeight) const;

private:

  TCollection_AsciiString myImageId;
  TCollection_AsciiString myImageAlphaId;
  opencascade::handle<TColStd_HArray1OfByte> myBitMap;
  opencascade::handle<Image_PixMap> myImage;
  opencascade::handle<Image_PixMap> myImageAlpha;
  Standard_Integer myMargin;
  Standard_Integer myWidth;
  Standard_Integer myHeight;

public:

  public: typedef Standard_Transient base_type; static const char* get_type_name () { return "Graphic3d_MarkerImage"; using direct_base_classes = opencascade::direct_base_class_as_tuple<std::tr2::direct_bases<Graphic3d_MarkerImage>::type>::type; static_assert(opencascade::has_type<Standard_Transient, direct_base_classes>::type::value, "OCCT RTTI definition is incorrect: " "Standard_Transient" " is not direct base class of " "Graphic3d_MarkerImage"); static_assert(&get_type_name == &Graphic3d_MarkerImage::get_type_name, "OCCT RTTI definition is misplaced: current class is not " "Graphic3d_MarkerImage"); } static const opencascade::handle<Standard_Type>& get_type_descriptor (); virtual const opencascade::handle<Standard_Type>& DynamicType() const override;

};

class Graphic3d_MarkerImage; typedef opencascade::handle<Graphic3d_MarkerImage> Handle_Graphic3d_MarkerImage;
# 27 "/usr/include/opencascade/Graphic3d_Aspects.hxx" 2
# 1 "/usr/include/opencascade/Graphic3d_HatchStyle.hxx" 1
# 19 "/usr/include/opencascade/Graphic3d_HatchStyle.hxx"
# 1 "/usr/include/opencascade/Aspect_HatchStyle.hxx" 1
# 20 "/usr/include/opencascade/Aspect_HatchStyle.hxx"
enum Aspect_HatchStyle
{
  Aspect_HS_SOLID = 0,
  Aspect_HS_HORIZONTAL = 7,
  Aspect_HS_HORIZONTAL_WIDE = 11,
  Aspect_HS_VERTICAL = 8,
  Aspect_HS_VERTICAL_WIDE = 12,
  Aspect_HS_DIAGONAL_45 = 5,
  Aspect_HS_DIAGONAL_45_WIDE = 9,
  Aspect_HS_DIAGONAL_135 = 6,
  Aspect_HS_DIAGONAL_135_WIDE = 10,
  Aspect_HS_GRID = 3,
  Aspect_HS_GRID_WIDE = 4,
  Aspect_HS_GRID_DIAGONAL = 1,
  Aspect_HS_GRID_DIAGONAL_WIDE = 2,
  Aspect_HS_NB = 13,
};
# 20 "/usr/include/opencascade/Graphic3d_HatchStyle.hxx" 2
# 1 "/usr/include/opencascade/Image_PixMap.hxx" 1
# 19 "/usr/include/opencascade/Image_PixMap.hxx"
# 1 "/usr/include/opencascade/Image_Format.hxx" 1
# 18 "/usr/include/opencascade/Image_Format.hxx"
enum Image_Format
{
  Image_Format_UNKNOWN = 0,
  Image_Format_Gray = 1,
  Image_Format_Alpha,
  Image_Format_RGB,
  Image_Format_BGR,
  Image_Format_RGB32,
  Image_Format_BGR32,
  Image_Format_RGBA,
  Image_Format_BGRA,
  Image_Format_GrayF,
  Image_Format_AlphaF,
  Image_Format_RGF,
  Image_Format_RGBF,
  Image_Format_BGRF,
  Image_Format_RGBAF,
  Image_Format_BGRAF,
};
enum { Image_Format_NB = Image_Format_BGRAF + 1 };
# 20 "/usr/include/opencascade/Image_PixMap.hxx" 2
# 1 "/usr/include/opencascade/Image_PixMapData.hxx" 1
# 19 "/usr/include/opencascade/Image_PixMapData.hxx"
# 1 "/usr/include/opencascade/Image_Color.hxx" 1
# 22 "/usr/include/opencascade/Image_Color.hxx"
struct Image_ColorRGB
{


  typedef Standard_Byte ComponentType_t;


  static Standard_Integer Length()
  {
    return 3;
  }

public:


  Standard_Byte r() const { return v[0]; }


  Standard_Byte g() const { return v[1]; }


  Standard_Byte b() const { return v[2]; }


  Standard_Byte& r() { return v[0]; }


  Standard_Byte& g() { return v[1]; }


  Standard_Byte& b() { return v[2]; }

public:

  Standard_Byte v[3];

};


struct Image_ColorRGB32
{


  typedef Standard_Byte ComponentType_t;


  static Standard_Integer Length()
  {
    return 3;
  }


  Standard_Byte r() const { return v[0]; }


  Standard_Byte g() const { return v[1]; }


  Standard_Byte b() const { return v[2]; }


  Standard_Byte a_() const { return v[3]; }


  Standard_Byte& r() { return v[0]; }


  Standard_Byte& g() { return v[1]; }


  Standard_Byte& b() { return v[2]; }


  Standard_Byte& a_() { return v[3]; }

public:

  Standard_Byte v[4];

};


struct Image_ColorRGBA
{


  typedef Standard_Byte ComponentType_t;


  static Standard_Integer Length()
  {
    return 4;
  }


  Standard_Byte r() const { return v[0]; }


  Standard_Byte g() const { return v[1]; }


  Standard_Byte b() const { return v[2]; }


  Standard_Byte a() const { return v[3]; }


  Standard_Byte& r() { return v[0]; }


  Standard_Byte& g() { return v[1]; }


  Standard_Byte& b() { return v[2]; }


  Standard_Byte& a() { return v[3]; }

public:

  Standard_Byte v[4];

};


struct Image_ColorBGR
{


  typedef Standard_Byte ComponentType_t;


  static Standard_Integer Length()
  {
    return 3;
  }


  Standard_Byte r() const { return v[2]; }


  Standard_Byte g() const { return v[1]; }


  Standard_Byte b() const { return v[0]; }


  Standard_Byte& r() { return v[2]; }


  Standard_Byte& g() { return v[1]; }


  Standard_Byte& b() { return v[0]; }

public:

  Standard_Byte v[3];

};


struct Image_ColorBGR32
{


  typedef Standard_Byte ComponentType_t;


  static Standard_Integer Length()
  {
    return 3;
  }


  Standard_Byte r() const { return v[2]; }


  Standard_Byte g() const { return v[1]; }


  Standard_Byte b() const { return v[0]; }


  Standard_Byte a_() const { return v[3]; }


  Standard_Byte& r() { return v[2]; }


  Standard_Byte& g() { return v[1]; }


  Standard_Byte& b() { return v[0]; }


  Standard_Byte& a_() { return v[3]; }

public:

  Standard_Byte v[4];

};


struct Image_ColorBGRA
{


  typedef Standard_Byte ComponentType_t;


  static Standard_Integer Length()
  {
    return 4;
  }


  Standard_Byte r() const { return v[2]; }


  Standard_Byte g() const { return v[1]; }


  Standard_Byte b() const { return v[0]; }


  Standard_Byte a() const { return v[3]; }


  Standard_Byte& r() { return v[2]; }


  Standard_Byte& g() { return v[1]; }


  Standard_Byte& b() { return v[0]; }


  Standard_Byte& a() { return v[3]; }

public:

  Standard_Byte v[4];

};


struct Image_ColorRGF
{

  typedef Standard_ShortReal ComponentType_t;


  static Standard_Integer Length() { return 2; }


  Standard_ShortReal r() const { return v[0]; }


  Standard_ShortReal g() const { return v[1]; }


  Standard_ShortReal& r() { return v[0]; }


  Standard_ShortReal& g() { return v[1]; }

public:
  Standard_ShortReal v[2];
};


struct Image_ColorRGBF
{


  typedef Standard_ShortReal ComponentType_t;


  static Standard_Integer Length()
  {
    return 3;
  }


  Standard_ShortReal r() const { return v[0]; }


  Standard_ShortReal g() const { return v[1]; }


  Standard_ShortReal b() const { return v[2]; }


  Standard_ShortReal& r() { return v[0]; }


  Standard_ShortReal& g() { return v[1]; }


  Standard_ShortReal& b() { return v[2]; }

public:

  Standard_ShortReal v[3];

};


struct Image_ColorBGRF
{


  typedef Standard_ShortReal ComponentType_t;


  static Standard_Integer Length()
  {
    return 3;
  }


  Standard_ShortReal r() const { return v[2]; }


  Standard_ShortReal g() const { return v[1]; }


  Standard_ShortReal b() const { return v[0]; }


  Standard_ShortReal& r() { return v[2]; }


  Standard_ShortReal& g() { return v[1]; }


  Standard_ShortReal& b() { return v[0]; }

public:

  Standard_ShortReal v[3];

};


struct Image_ColorRGBAF
{


  typedef Standard_ShortReal ComponentType_t;


  static Standard_Integer Length()
  {
    return 4;
  }


  Standard_ShortReal r() const { return v[0]; }


  Standard_ShortReal g() const { return v[1]; }


  Standard_ShortReal b() const { return v[2]; }


  Standard_ShortReal a() const { return v[3]; }


  Standard_ShortReal& r() { return v[0]; }


  Standard_ShortReal& g() { return v[1]; }


  Standard_ShortReal& b() { return v[2]; }


  Standard_ShortReal& a() { return v[3]; }

public:

  Standard_ShortReal v[4];

};


struct Image_ColorBGRAF
{


  typedef Standard_ShortReal ComponentType_t;


  static Standard_Integer Length()
  {
    return 4;
  }


  Standard_ShortReal r() const { return v[2]; }


  Standard_ShortReal g() const { return v[1]; }


  Standard_ShortReal b() const { return v[0]; }


  Standard_ShortReal a() const { return v[3]; }


  Standard_ShortReal& r() { return v[2]; }


  Standard_ShortReal& g() { return v[1]; }


  Standard_ShortReal& b() { return v[0]; }


  Standard_ShortReal& a() { return v[3]; }

public:

  Standard_ShortReal v[4];

};
# 20 "/usr/include/opencascade/Image_PixMapData.hxx" 2
# 1 "/usr/include/opencascade/NCollection_Buffer.hxx" 1
# 20 "/usr/include/opencascade/NCollection_Buffer.hxx"
# 1 "/usr/include/opencascade/Standard_Dump.hxx" 1
# 17 "/usr/include/opencascade/Standard_Dump.hxx"
# 1 "/usr/include/opencascade/NCollection_IndexedDataMap.hxx" 1
# 19 "/usr/include/opencascade/NCollection_IndexedDataMap.hxx"
# 1 "/usr/include/opencascade/NCollection_BaseMap.hxx" 1
# 22 "/usr/include/opencascade/NCollection_BaseMap.hxx"
# 1 "/usr/include/opencascade/NCollection_ListNode.hxx" 1
# 26 "/usr/include/opencascade/NCollection_ListNode.hxx"
class NCollection_ListNode
{
public:

  void* operator new (size_t theSize, const opencascade::handle<NCollection_BaseAllocator>& theAllocator) { return theAllocator->Allocate(theSize); } void operator delete (void* theAddress, const opencascade::handle<NCollection_BaseAllocator>& theAllocator) { theAllocator->Free(theAddress); }
public:

  NCollection_ListNode (NCollection_ListNode* theNext)
  : myNext(theNext) {}


  NCollection_ListNode*& Next (void)
  { return myNext; }


  NCollection_ListNode* Next (void) const
  { return myNext; }

 private:

  NCollection_ListNode& operator= (const NCollection_ListNode&);


  NCollection_ListNode (const NCollection_ListNode&);

 private:
  NCollection_ListNode * myNext;
};
# 23 "/usr/include/opencascade/NCollection_BaseMap.hxx" 2

typedef void (* NCollection_DelMapNode)
     (NCollection_ListNode*, opencascade::handle<NCollection_BaseAllocator>& theAl);
# 37 "/usr/include/opencascade/NCollection_BaseMap.hxx"
class NCollection_BaseMap
{
public:

  void* operator new (size_t theSize) { return Standard::Allocate (theSize); } void operator delete (void* theAddress) { Standard::Free (theAddress); } void* operator new[] (size_t theSize) { return Standard::Allocate (theSize); } void operator delete[] (void* theAddress) { Standard::Free (theAddress); } void* operator new (size_t, void* theAddress) { return theAddress; } void operator delete (void*, void*) { }
  void* operator new (size_t theSize, const opencascade::handle<NCollection_BaseAllocator>& theAllocator) { return theAllocator->Allocate(theSize); } void operator delete (void* theAddress, const opencascade::handle<NCollection_BaseAllocator>& theAllocator) { theAllocator->Free(theAddress); }

public:

  class Iterator
  {
  protected:

    Iterator (void) :
      myNbBuckets (0),
      myBuckets (
# 52 "/usr/include/opencascade/NCollection_BaseMap.hxx" 3 4
                  __null
# 52 "/usr/include/opencascade/NCollection_BaseMap.hxx"
                      ),
      myBucket (0),
      myNode (
# 54 "/usr/include/opencascade/NCollection_BaseMap.hxx" 3 4
                  __null
# 54 "/usr/include/opencascade/NCollection_BaseMap.hxx"
                      ) {}


    Iterator (const NCollection_BaseMap& theMap) :
      myNbBuckets (theMap.myNbBuckets),
      myBuckets (theMap.myData1),
      myBucket (-1),
      myNode (
# 61 "/usr/include/opencascade/NCollection_BaseMap.hxx" 3 4
                  __null
# 61 "/usr/include/opencascade/NCollection_BaseMap.hxx"
                      )
    {
      if (!myBuckets)
        myNbBuckets = -1;
      else
        do {
          myBucket++;
          if (myBucket > myNbBuckets)
            return;
          myNode = myBuckets[myBucket];
        } while (!myNode);
    }

  public:

    void Initialize (const NCollection_BaseMap& theMap)
    {
      myNbBuckets = theMap.myNbBuckets;
      myBuckets = theMap.myData1;
      myBucket = -1;
      myNode = 
# 81 "/usr/include/opencascade/NCollection_BaseMap.hxx" 3 4
              __null
# 81 "/usr/include/opencascade/NCollection_BaseMap.hxx"
                  ;
      if (!myBuckets)
        myNbBuckets = -1;
      PNext();
    }


    void Reset (void)
    {
      myBucket = -1;
      myNode = 
# 91 "/usr/include/opencascade/NCollection_BaseMap.hxx" 3 4
              __null
# 91 "/usr/include/opencascade/NCollection_BaseMap.hxx"
                  ;
      PNext();
    }


    Standard_Boolean IsEqual (const Iterator& theOther) const
    {
      return myBucket == theOther.myBucket && myNode == theOther.myNode;
    }

  protected:

    Standard_Boolean PMore (void) const
    { return (myNode != 
# 104 "/usr/include/opencascade/NCollection_BaseMap.hxx" 3 4
                       __null
# 104 "/usr/include/opencascade/NCollection_BaseMap.hxx"
                           ); }


    void PNext (void)
    {
      if (!myBuckets)
        return;
      if (myNode)
      {
        myNode = myNode->Next();
        if (myNode)
          return;
      }
      while (!myNode)
      {
        myBucket++;
        if (myBucket > myNbBuckets)
          return;
        myNode = myBuckets[myBucket];
      }
    }

  protected:

    Standard_Integer myNbBuckets;
    NCollection_ListNode **myBuckets;
    Standard_Integer myBucket;
    NCollection_ListNode * myNode;
  };

 public:



  Standard_Integer NbBuckets() const
  { return myNbBuckets; }


  Standard_Integer Extent() const
  { return mySize; }


  Standard_Boolean IsEmpty() const
  { return mySize == 0; }


  void Statistics(Standard_OStream& S) const;


  const opencascade::handle<NCollection_BaseAllocator>& Allocator() const
  { return myAllocator; }

 protected:



  NCollection_BaseMap (const Standard_Integer NbBuckets,
                       const Standard_Boolean single,
                       const opencascade::handle<NCollection_BaseAllocator>& theAllocator)
  : myData1(
# 163 "/usr/include/opencascade/NCollection_BaseMap.hxx" 3 4
           __null
# 163 "/usr/include/opencascade/NCollection_BaseMap.hxx"
               ),
    myData2(
# 164 "/usr/include/opencascade/NCollection_BaseMap.hxx" 3 4
           __null
# 164 "/usr/include/opencascade/NCollection_BaseMap.hxx"
               ),
    myNbBuckets(NbBuckets),
    mySize(0),
    isDouble(!single)
  {
    myAllocator = (theAllocator.IsNull() ? NCollection_BaseAllocator::CommonBaseAllocator() : theAllocator);
  }


  virtual ~NCollection_BaseMap() {}


  Standard_Boolean BeginResize
    (const Standard_Integer NbBuckets,
     Standard_Integer& NewBuckets,
     NCollection_ListNode**& data1,
     NCollection_ListNode**& data2) const;


  void EndResize
    (const Standard_Integer NbBuckets,
     const Standard_Integer NewBuckets,
     NCollection_ListNode** data1,
     NCollection_ListNode** data2);


  Standard_Boolean Resizable() const
  { return IsEmpty() || (mySize > myNbBuckets); }


  Standard_Integer Increment() { return ++mySize; }


  Standard_Integer Decrement() { return --mySize; }


  void Destroy(NCollection_DelMapNode fDel,
                               Standard_Boolean doReleaseMemory = true);


  Standard_Integer NextPrimeForMap
    (const Standard_Integer N) const;


  void exchangeMapsData (NCollection_BaseMap& theOther)
  {
    std::swap (myAllocator, theOther.myAllocator);
    std::swap (myData1, theOther.myData1);
    std::swap (myData2, theOther.myData2);
    std::swap (myNbBuckets, theOther.myNbBuckets);
    std::swap (mySize, theOther.mySize);

  }

 protected:

  opencascade::handle<NCollection_BaseAllocator> myAllocator;
  NCollection_ListNode ** myData1;
  NCollection_ListNode ** myData2;

 private:

  Standard_Integer myNbBuckets;
  Standard_Integer mySize;
  Standard_Boolean isDouble;


  friend class Iterator;
};
# 20 "/usr/include/opencascade/NCollection_IndexedDataMap.hxx" 2
# 1 "/usr/include/opencascade/NCollection_TListNode.hxx" 1
# 25 "/usr/include/opencascade/NCollection_TListNode.hxx"
template <class TheItemType> class NCollection_TListNode
  : public NCollection_ListNode
{
 public:

  NCollection_TListNode (const TheItemType& theItem,
                         NCollection_ListNode* theNext=
# 31 "/usr/include/opencascade/NCollection_TListNode.hxx" 3 4
                                                      __null
# 31 "/usr/include/opencascade/NCollection_TListNode.hxx"
                                                          ) :
    NCollection_ListNode (theNext), myValue(theItem) { }

  const TheItemType& Value () const { return myValue; }

  TheItemType& ChangeValue () { return myValue; }


  static void delNode (NCollection_ListNode * theNode,
                       opencascade::handle<NCollection_BaseAllocator>& theAl)
  {
    ((NCollection_TListNode *) theNode)->myValue.~TheItemType();
    theAl->Free(theNode);
  }


 protected:
  TheItemType myValue;

};
# 21 "/usr/include/opencascade/NCollection_IndexedDataMap.hxx" 2
# 1 "/usr/include/opencascade/Standard_TypeMismatch.hxx" 1
# 25 "/usr/include/opencascade/Standard_TypeMismatch.hxx"
class Standard_TypeMismatch;
class Standard_TypeMismatch; typedef opencascade::handle<Standard_TypeMismatch> Handle_Standard_TypeMismatch;
# 35 "/usr/include/opencascade/Standard_TypeMismatch.hxx"
class Standard_TypeMismatch : public Standard_DomainError { void Throw () const override { throw *this; } public: Standard_TypeMismatch() : Standard_DomainError() {} Standard_TypeMismatch(const Standard_CString theMessage) : Standard_DomainError(theMessage) {} static void Raise(const Standard_CString theMessage = "") { opencascade::handle<Standard_TypeMismatch> _E = new Standard_TypeMismatch; _E->Reraise(theMessage); } static void Raise(Standard_SStream& theMessage) { opencascade::handle<Standard_TypeMismatch> _E = new Standard_TypeMismatch; _E->Reraise (theMessage); } static opencascade::handle<Standard_TypeMismatch> NewInstance(const Standard_CString theMessage = "") { return new Standard_TypeMismatch(theMessage); } public: typedef Standard_DomainError base_type; static const char* get_type_name () { return "Standard_TypeMismatch"; using direct_base_classes = opencascade::direct_base_class_as_tuple<std::tr2::direct_bases<Standard_TypeMismatch>::type>::type; static_assert(opencascade::has_type<Standard_DomainError, direct_base_classes>::type::value, "OCCT RTTI definition is incorrect: " "Standard_DomainError" " is not direct base class of " "Standard_TypeMismatch"); static_assert(&get_type_name == &Standard_TypeMismatch::get_type_name, "OCCT RTTI definition is misplaced: current class is not " "Standard_TypeMismatch"); } static const opencascade::handle<Standard_Type>& get_type_descriptor () { return Standard_Type::Instance<Standard_TypeMismatch>(); } virtual const opencascade::handle<Standard_Type>& DynamicType() const override { return get_type_descriptor (); } };
# 22 "/usr/include/opencascade/NCollection_IndexedDataMap.hxx" 2
# 1 "/usr/include/opencascade/Standard_NoSuchObject.hxx" 1
# 25 "/usr/include/opencascade/Standard_NoSuchObject.hxx"
class Standard_NoSuchObject;
class Standard_NoSuchObject; typedef opencascade::handle<Standard_NoSuchObject> Handle_Standard_NoSuchObject;
# 35 "/usr/include/opencascade/Standard_NoSuchObject.hxx"
class Standard_NoSuchObject : public Standard_DomainError { void Throw () const override { throw *this; } public: Standard_NoSuchObject() : Standard_DomainError() {} Standard_NoSuchObject(const Standard_CString theMessage) : Standard_DomainError(theMessage) {} static void Raise(const Standard_CString theMessage = "") { opencascade::handle<Standard_NoSuchObject> _E = new Standard_NoSuchObject; _E->Reraise(theMessage); } static void Raise(Standard_SStream& theMessage) { opencascade::handle<Standard_NoSuchObject> _E = new Standard_NoSuchObject; _E->Reraise (theMessage); } static opencascade::handle<Standard_NoSuchObject> NewInstance(const Standard_CString theMessage = "") { return new Standard_NoSuchObject(theMessage); } public: typedef Standard_DomainError base_type; static const char* get_type_name () { return "Standard_NoSuchObject"; using direct_base_classes = opencascade::direct_base_class_as_tuple<std::tr2::direct_bases<Standard_NoSuchObject>::type>::type; static_assert(opencascade::has_type<Standard_DomainError, direct_base_classes>::type::value, "OCCT RTTI definition is incorrect: " "Standard_DomainError" " is not direct base class of " "Standard_NoSuchObject"); static_assert(&get_type_name == &Standard_NoSuchObject::get_type_name, "OCCT RTTI definition is misplaced: current class is not " "Standard_NoSuchObject"); } static const opencascade::handle<Standard_Type>& get_type_descriptor () { return Standard_Type::Instance<Standard_NoSuchObject>(); } virtual const opencascade::handle<Standard_Type>& DynamicType() const override { return get_type_descriptor (); } };
# 23 "/usr/include/opencascade/NCollection_IndexedDataMap.hxx" 2

# 1 "/usr/include/opencascade/NCollection_DefaultHasher.hxx" 1
# 31 "/usr/include/opencascade/NCollection_DefaultHasher.hxx"
template <class TheKeyType>
inline Standard_Integer HashCode_Proxy (const TheKeyType& theKey, const Standard_Integer theUpperBound)
{
  return HashCode (theKey, theUpperBound);
}






template <class TheKeyType>
inline Standard_Boolean IsEqual (const TheKeyType& theKey1,
                                 const TheKeyType& theKey2)
{
  return theKey1 == theKey2;
}






template <class TheKeyType>
inline Standard_Boolean IsEqual_Proxy (const TheKeyType& theKey1,
                                       const TheKeyType& theKey2)
{
  return IsEqual (theKey1, theKey2);
}
# 70 "/usr/include/opencascade/NCollection_DefaultHasher.hxx"
template <class TheKeyType> class NCollection_DefaultHasher {
public:




  static Standard_Integer HashCode (const TheKeyType& theKey, const Standard_Integer theUpperBound)
  {
    return HashCode_Proxy (theKey, theUpperBound);
  }


  static Standard_Boolean IsEqual(const TheKeyType& theKey1,
                                  const TheKeyType& theKey2) {
    return IsEqual_Proxy(theKey1, theKey2);
  }
};
# 25 "/usr/include/opencascade/NCollection_IndexedDataMap.hxx" 2
# 47 "/usr/include/opencascade/NCollection_IndexedDataMap.hxx"
template < class TheKeyType,
           class TheItemType,
           class Hasher = NCollection_DefaultHasher<TheKeyType> >
class NCollection_IndexedDataMap : public NCollection_BaseMap
{
public:

  typedef TheKeyType key_type;

  typedef TheItemType value_type;

private:

  class IndexedDataMapNode : public NCollection_TListNode<TheItemType>
  {
  public:

    IndexedDataMapNode (const TheKeyType& theKey1,
                        const Standard_Integer theIndex,
                        const TheItemType& theItem,
                        NCollection_ListNode* theNext1)
    : NCollection_TListNode<TheItemType>(theItem,theNext1),
      myKey1 (theKey1),
      myIndex (theIndex)
    {
    }

    TheKeyType& Key1() { return myKey1; }

    Standard_Integer& Index() { return myIndex; }


    static void delNode (NCollection_ListNode * theNode,
                         opencascade::handle<NCollection_BaseAllocator>& theAl)
    {
      ((IndexedDataMapNode *) theNode)->~IndexedDataMapNode();
      theAl->Free(theNode);
    }
  private:
    TheKeyType myKey1;
    Standard_Integer myIndex;
  };

 public:

  class Iterator
  {
  public:

    Iterator()
    : myMap (
# 97 "/usr/include/opencascade/NCollection_IndexedDataMap.hxx" 3 4
            __null
# 97 "/usr/include/opencascade/NCollection_IndexedDataMap.hxx"
                ),
      myIndex (0) {}


    Iterator (const NCollection_IndexedDataMap& theMap)
    : myMap ((NCollection_IndexedDataMap*)&theMap),
      myIndex (1) {}


    Standard_Boolean More(void) const
    { return (myMap != 
# 107 "/usr/include/opencascade/NCollection_IndexedDataMap.hxx" 3 4
                      __null
# 107 "/usr/include/opencascade/NCollection_IndexedDataMap.hxx"
                          ) && (myIndex <= myMap->Extent()); }


    void Next(void)
    { ++myIndex; }


    const TheItemType& Value(void) const
    {
      if (!More()) throw Standard_NoSuchObject("NCollection_IndexedDataMap::Iterator::Value");;
      return myMap->FindFromIndex(myIndex);
    }


    TheItemType& ChangeValue(void) const
    {
      if (!More()) throw Standard_NoSuchObject("NCollection_IndexedDataMap::Iterator::ChangeValue");;
      return myMap->ChangeFromIndex(myIndex);
    }


    const TheKeyType& Key() const
    {
      if (!More()) throw Standard_NoSuchObject("NCollection_IndexedDataMap::Iterator::Key");;
      return myMap->FindKey(myIndex);
    }


    Standard_Boolean IsEqual (const Iterator& theOther) const
    {
      return myMap == theOther.myMap &&
             myIndex == theOther.myIndex;
    }

  private:
    NCollection_IndexedDataMap* myMap;
    Standard_Integer myIndex;
  };


  typedef NCollection_StlIterator<std::forward_iterator_tag, Iterator, TheItemType, false> iterator;


  typedef NCollection_StlIterator<std::forward_iterator_tag, Iterator, TheItemType, true> const_iterator;


  iterator begin() const { return Iterator (*this); }


  iterator end() const { return Iterator(); }


  const_iterator cbegin() const { return Iterator (*this); }


  const_iterator cend() const { return Iterator(); }

 public:



  NCollection_IndexedDataMap() : NCollection_BaseMap (1, false, opencascade::handle<NCollection_BaseAllocator>()) {}


  explicit NCollection_IndexedDataMap (const Standard_Integer theNbBuckets,
                                       const opencascade::handle<NCollection_BaseAllocator>& theAllocator = 0L)
  : NCollection_BaseMap (theNbBuckets, false, theAllocator) {}


  NCollection_IndexedDataMap (const NCollection_IndexedDataMap& theOther)
    : NCollection_BaseMap (theOther.NbBuckets(), false, theOther.myAllocator)
  { *this = theOther; }



  void Exchange (NCollection_IndexedDataMap& theOther)
  {
    this->exchangeMapsData (theOther);
  }



  NCollection_IndexedDataMap& Assign (const NCollection_IndexedDataMap& theOther)
  {
    if (this == &theOther)
      return *this;

    Clear();
    Standard_Integer anExt = theOther.Extent();
    if (anExt)
    {
      ReSize (anExt-1);
      for (Standard_Integer anIndexIter = 1; anIndexIter <= anExt; ++anIndexIter)
      {
        const TheKeyType& aKey1 = theOther.FindKey (anIndexIter);
        const TheItemType& anItem = theOther.FindFromIndex(anIndexIter);
        const Standard_Integer iK1 = Hasher::HashCode (aKey1, NbBuckets());
        IndexedDataMapNode* pNode = new (this->myAllocator) IndexedDataMapNode (aKey1, anIndexIter, anItem, myData1[iK1]);
        myData1[iK1] = pNode;
        myData2[anIndexIter - 1] = pNode;
        Increment();
      }
    }
    return *this;
  }


  NCollection_IndexedDataMap& operator= (const NCollection_IndexedDataMap& theOther)
  {
    return Assign (theOther);
  }


  void ReSize (const Standard_Integer N)
  {
    NCollection_ListNode** ppNewData1 = 
# 222 "/usr/include/opencascade/NCollection_IndexedDataMap.hxx" 3 4
                                       __null
# 222 "/usr/include/opencascade/NCollection_IndexedDataMap.hxx"
                                           ;
    NCollection_ListNode** ppNewData2 = 
# 223 "/usr/include/opencascade/NCollection_IndexedDataMap.hxx" 3 4
                                       __null
# 223 "/usr/include/opencascade/NCollection_IndexedDataMap.hxx"
                                           ;
    Standard_Integer newBuck;
    if (BeginResize (N, newBuck, ppNewData1, ppNewData2))
    {
      if (myData1)
      {
        memcpy (ppNewData2, myData2, sizeof(IndexedDataMapNode*) * Extent());
        for (Standard_Integer aBucketIter = 0; aBucketIter <= NbBuckets(); ++aBucketIter)
        {
          if (myData1[aBucketIter])
          {
            IndexedDataMapNode* p = (IndexedDataMapNode *) myData1[aBucketIter];
            while (p)
            {
              const Standard_Integer iK1 = Hasher::HashCode (p->Key1(), newBuck);
              IndexedDataMapNode* q = (IndexedDataMapNode* )p->Next();
              p->Next() = ppNewData1[iK1];
              ppNewData1[iK1] = p;
              p = q;
            }
          }
        }
      }
      EndResize (N, newBuck, ppNewData1, ppNewData2);
    }
  }





  Standard_Integer Add (const TheKeyType& theKey1, const TheItemType& theItem)
  {
    if (Resizable())
    {
      ReSize(Extent());
    }

    const Standard_Integer iK1 = Hasher::HashCode (theKey1, NbBuckets());
    IndexedDataMapNode* pNode = (IndexedDataMapNode* )myData1[iK1];
    while (pNode)
    {
      if (Hasher::IsEqual (pNode->Key1(), theKey1))
      {
        return pNode->Index();
      }
      pNode = (IndexedDataMapNode *) pNode->Next();
    }

    const Standard_Integer aNewIndex = Increment();
    pNode = new (this->myAllocator) IndexedDataMapNode (theKey1, aNewIndex, theItem, myData1[iK1]);
    myData1[iK1] = pNode;
    myData2[aNewIndex - 1] = pNode;
    return aNewIndex;
  }


  Standard_Boolean Contains (const TheKeyType& theKey1) const
  {
    if (IsEmpty())
      return false;
    Standard_Integer iK1 = Hasher::HashCode (theKey1, NbBuckets());
    IndexedDataMapNode * pNode1;
    pNode1 = (IndexedDataMapNode *) myData1[iK1];
    while (pNode1)
    {
      if (Hasher::IsEqual(pNode1->Key1(), theKey1))
        return true;
      pNode1 = (IndexedDataMapNode *) pNode1->Next();
    }
    return false;
  }


  void Substitute (const Standard_Integer theIndex,
                   const TheKeyType& theKey1,
                   const TheItemType& theItem)
  {
   

#pragma GCC diagnostic push
# 301 "/usr/include/opencascade/NCollection_IndexedDataMap.hxx"
   

#pragma GCC diagnostic ignored "-Wstrict-overflow"
# 301 "/usr/include/opencascade/NCollection_IndexedDataMap.hxx"
    if (theIndex < 1 || theIndex > Extent()) throw Standard_OutOfRange("NCollection_IndexedDataMap::Substitute : " "Index is out of range");

#pragma GCC diagnostic pop
# 301 "/usr/include/opencascade/NCollection_IndexedDataMap.hxx"
   

                                                          ;


    const Standard_Integer iK1 = Hasher::HashCode (theKey1, NbBuckets());
    IndexedDataMapNode* p = (IndexedDataMapNode *) myData1[iK1];
    while (p)
    {
      if (Hasher::IsEqual (p->Key1(), theKey1))
      {
        if (p->Index() != theIndex)
        {
          throw Standard_DomainError ("NCollection_IndexedDataMap::Substitute : "
                                      "Attempt to substitute existing key");
        }
        p->Key1() = theKey1;
        p->ChangeValue() = theItem;
        return;
      }
      p = (IndexedDataMapNode *) p->Next();
    }


    p = (IndexedDataMapNode* )myData2[theIndex - 1];


    const Standard_Integer iK = Hasher::HashCode (p->Key1(), NbBuckets());
    IndexedDataMapNode * q = (IndexedDataMapNode *) myData1[iK];
    if (q == p)
      myData1[iK] = (IndexedDataMapNode *) p->Next();
    else
    {
      while (q->Next() != p)
        q = (IndexedDataMapNode *) q->Next();
      q->Next() = p->Next();
    }


    p->Key1() = theKey1;
    p->ChangeValue() = theItem;
    p->Next() = myData1[iK1];
    myData1[iK1] = p;
  }


  void Swap (const Standard_Integer theIndex1,
             const Standard_Integer theIndex2)
  {
   
#pragma GCC diagnostic push
# 350 "/usr/include/opencascade/NCollection_IndexedDataMap.hxx"
   
#pragma GCC diagnostic ignored "-Wstrict-overflow"
# 350 "/usr/include/opencascade/NCollection_IndexedDataMap.hxx"
    if (theIndex1 < 1 || theIndex1 > Extent() || theIndex2 < 1 || theIndex2 > Extent()) throw Standard_OutOfRange("NCollection_IndexedDataMap::Swap");
#pragma GCC diagnostic pop
# 350 "/usr/include/opencascade/NCollection_IndexedDataMap.hxx"
   
                                                                                                            ;

    if (theIndex1 == theIndex2)
    {
      return;
    }

    IndexedDataMapNode* aP1 = (IndexedDataMapNode* )myData2[theIndex1 - 1];
    IndexedDataMapNode* aP2 = (IndexedDataMapNode* )myData2[theIndex2 - 1];
    std::swap (aP1->Index(), aP2->Index());
    myData2[theIndex2 - 1] = aP1;
    myData2[theIndex1 - 1] = aP2;
  }


  void RemoveLast (void)
  {
    const Standard_Integer aLastIndex = Extent();
   
# 369 "/usr/include/opencascade/NCollection_IndexedDataMap.hxx"
#pragma GCC diagnostic push
# 369 "/usr/include/opencascade/NCollection_IndexedDataMap.hxx"
   
# 369 "/usr/include/opencascade/NCollection_IndexedDataMap.hxx"
#pragma GCC diagnostic ignored "-Wstrict-overflow"
# 369 "/usr/include/opencascade/NCollection_IndexedDataMap.hxx"
    if (aLastIndex == 0) throw Standard_OutOfRange("NCollection_IndexedDataMap::RemoveLast");
# 369 "/usr/include/opencascade/NCollection_IndexedDataMap.hxx"
#pragma GCC diagnostic pop
# 369 "/usr/include/opencascade/NCollection_IndexedDataMap.hxx"
    ;


    IndexedDataMapNode* p = (IndexedDataMapNode* )myData2[aLastIndex - 1];
    myData2[aLastIndex - 1] = 
# 373 "/usr/include/opencascade/NCollection_IndexedDataMap.hxx" 3 4
                             __null
# 373 "/usr/include/opencascade/NCollection_IndexedDataMap.hxx"
                                 ;


    const Standard_Integer iK1 = Hasher::HashCode (p->Key1(), NbBuckets());
    IndexedDataMapNode* q = (IndexedDataMapNode *) myData1[iK1];
    if (q == p)
      myData1[iK1] = (IndexedDataMapNode *) p->Next();
    else
    {
      while (q->Next() != p)
        q = (IndexedDataMapNode *) q->Next();
      q->Next() = p->Next();
    }
    p->~IndexedDataMapNode();
    this->myAllocator->Free(p);
    Decrement();
  }



  void RemoveFromIndex(const Standard_Integer theIndex)
  {
    const Standard_Integer aLastInd = Extent();
   
# 396 "/usr/include/opencascade/NCollection_IndexedDataMap.hxx"
#pragma GCC diagnostic push
# 396 "/usr/include/opencascade/NCollection_IndexedDataMap.hxx"
   
# 396 "/usr/include/opencascade/NCollection_IndexedDataMap.hxx"
#pragma GCC diagnostic ignored "-Wstrict-overflow"
# 396 "/usr/include/opencascade/NCollection_IndexedDataMap.hxx"
    if (theIndex < 1 || theIndex > aLastInd) throw Standard_OutOfRange("NCollection_IndexedDataMap::Remove");
# 396 "/usr/include/opencascade/NCollection_IndexedDataMap.hxx"
#pragma GCC diagnostic pop
# 396 "/usr/include/opencascade/NCollection_IndexedDataMap.hxx"
    ;
    if (theIndex != aLastInd)
    {
      Swap (theIndex, aLastInd);
    }
    RemoveLast();
  }



  void RemoveKey(const TheKeyType& theKey1)
  {
    Standard_Integer anIndToRemove = FindIndex(theKey1);
    if (anIndToRemove > 0) {
      RemoveFromIndex(anIndToRemove);
    }
  }


  const TheKeyType& FindKey (const Standard_Integer theIndex) const
  {
   
# 417 "/usr/include/opencascade/NCollection_IndexedDataMap.hxx"
#pragma GCC diagnostic push
# 417 "/usr/include/opencascade/NCollection_IndexedDataMap.hxx"
   
# 417 "/usr/include/opencascade/NCollection_IndexedDataMap.hxx"
#pragma GCC diagnostic ignored "-Wstrict-overflow"
# 417 "/usr/include/opencascade/NCollection_IndexedDataMap.hxx"
    if (theIndex < 1 || theIndex > Extent()) throw Standard_OutOfRange("NCollection_IndexedDataMap::FindKey");
# 417 "/usr/include/opencascade/NCollection_IndexedDataMap.hxx"
#pragma GCC diagnostic pop
# 417 "/usr/include/opencascade/NCollection_IndexedDataMap.hxx"
    ;
    IndexedDataMapNode* aNode = (IndexedDataMapNode* )myData2[theIndex - 1];
    return aNode->Key1();
  }


  const TheItemType& FindFromIndex (const Standard_Integer theIndex) const
  {
   
# 425 "/usr/include/opencascade/NCollection_IndexedDataMap.hxx"
#pragma GCC diagnostic push
# 425 "/usr/include/opencascade/NCollection_IndexedDataMap.hxx"
   
# 425 "/usr/include/opencascade/NCollection_IndexedDataMap.hxx"
#pragma GCC diagnostic ignored "-Wstrict-overflow"
# 425 "/usr/include/opencascade/NCollection_IndexedDataMap.hxx"
    if (theIndex < 1 || theIndex > Extent()) throw Standard_OutOfRange("NCollection_IndexedDataMap::FindFromIndex");
# 425 "/usr/include/opencascade/NCollection_IndexedDataMap.hxx"
#pragma GCC diagnostic pop
# 425 "/usr/include/opencascade/NCollection_IndexedDataMap.hxx"
    ;
    IndexedDataMapNode* aNode = (IndexedDataMapNode* )myData2[theIndex - 1];
    return aNode->Value();
  }


  const TheItemType& operator() (const Standard_Integer theIndex) const { return FindFromIndex (theIndex); }


  TheItemType& ChangeFromIndex (const Standard_Integer theIndex)
  {
   
# 436 "/usr/include/opencascade/NCollection_IndexedDataMap.hxx"
#pragma GCC diagnostic push
# 436 "/usr/include/opencascade/NCollection_IndexedDataMap.hxx"
   
# 436 "/usr/include/opencascade/NCollection_IndexedDataMap.hxx"
#pragma GCC diagnostic ignored "-Wstrict-overflow"
# 436 "/usr/include/opencascade/NCollection_IndexedDataMap.hxx"
    if (theIndex < 1 || theIndex > Extent()) throw Standard_OutOfRange("NCollection_IndexedDataMap::ChangeFromIndex");
# 436 "/usr/include/opencascade/NCollection_IndexedDataMap.hxx"
#pragma GCC diagnostic pop
# 436 "/usr/include/opencascade/NCollection_IndexedDataMap.hxx"
    ;
    IndexedDataMapNode* aNode = (IndexedDataMapNode* )myData2[theIndex - 1];
    return aNode->ChangeValue();
  }


  TheItemType& operator() (const Standard_Integer theIndex) { return ChangeFromIndex (theIndex); }


  Standard_Integer FindIndex(const TheKeyType& theKey1) const
  {
    if (IsEmpty()) return 0;
    IndexedDataMapNode* pNode1 = (IndexedDataMapNode* )myData1[Hasher::HashCode(theKey1,NbBuckets())];
    while (pNode1)
    {
      if (Hasher::IsEqual (pNode1->Key1(), theKey1))
      {
        return pNode1->Index();
      }
      pNode1 = (IndexedDataMapNode*) pNode1->Next();
    }
    return 0;
  }


  const TheItemType& FindFromKey(const TheKeyType& theKey1) const
  {
    if (IsEmpty()) throw Standard_NoSuchObject("NCollection_IndexedDataMap::FindFromKey");;

    IndexedDataMapNode* pNode1 = (IndexedDataMapNode* )myData1[Hasher::HashCode(theKey1,NbBuckets())];
    while (pNode1)
    {
      if (Hasher::IsEqual (pNode1->Key1(), theKey1))
      {
        return pNode1->Value();
      }
      pNode1 = (IndexedDataMapNode*) pNode1->Next();
    }
    throw Standard_NoSuchObject("NCollection_IndexedDataMap::FindFromKey");
  }


  TheItemType& ChangeFromKey (const TheKeyType& theKey1)
  {
    if (IsEmpty()) throw Standard_NoSuchObject("NCollection_IndexedDataMap::ChangeFromKey");;

    IndexedDataMapNode* pNode1 = (IndexedDataMapNode* )myData1[Hasher::HashCode(theKey1,NbBuckets())];
    while (pNode1)
    {
      if (Hasher::IsEqual (pNode1->Key1(), theKey1))
      {
        return pNode1->ChangeValue();
      }
      pNode1 = (IndexedDataMapNode*) pNode1->Next();
    }
    throw Standard_NoSuchObject("NCollection_IndexedDataMap::ChangeFromKey");
  }



  const TheItemType* Seek(const TheKeyType& theKey1) const
  {
    return const_cast< NCollection_IndexedDataMap * >( this )->ChangeSeek(theKey1);


  }



  TheItemType* ChangeSeek (const TheKeyType& theKey1)
  {
    if (!IsEmpty())
    {
      IndexedDataMapNode* pNode1 = (IndexedDataMapNode* )myData1[Hasher::HashCode(theKey1,NbBuckets())];
      while (pNode1)
      {
        if (Hasher::IsEqual (pNode1->Key1(), theKey1))
        {
          return &pNode1->ChangeValue();
        }
        pNode1 = (IndexedDataMapNode*) pNode1->Next();
      }
    }
    return 0L;
  }



  Standard_Boolean FindFromKey (const TheKeyType& theKey1,
                                TheItemType& theValue) const
  {
    if (IsEmpty())
    {
      return false;
    }
    for (IndexedDataMapNode* aNode = (IndexedDataMapNode* )myData1[Hasher::HashCode (theKey1, NbBuckets())];
         aNode != 
# 532 "/usr/include/opencascade/NCollection_IndexedDataMap.hxx" 3 4
                 __null
# 532 "/usr/include/opencascade/NCollection_IndexedDataMap.hxx"
                     ; aNode = (IndexedDataMapNode* )aNode->Next())
    {
      if (Hasher::IsEqual (aNode->Key1(), theKey1))
      {
        theValue = aNode->Value();
        return true;
      }
    }
    return false;
  }



  void Clear(const Standard_Boolean doReleaseMemory = true)
  { Destroy (IndexedDataMapNode::delNode, doReleaseMemory); }


  void Clear (const opencascade::handle<NCollection_BaseAllocator>& theAllocator)
  {
    Clear();
    this->myAllocator = ( ! theAllocator.IsNull() ? theAllocator :
                    NCollection_BaseAllocator::CommonBaseAllocator() );
  }


  virtual ~NCollection_IndexedDataMap (void)
  { Clear(); }


  Standard_Integer Size(void) const
  { return Extent(); }

 private:


};
# 18 "/usr/include/opencascade/Standard_Dump.hxx" 2
# 1 "/usr/include/opencascade/NCollection_List.hxx" 1
# 19 "/usr/include/opencascade/NCollection_List.hxx"
# 1 "/usr/include/opencascade/NCollection_TListIterator.hxx" 1
# 19 "/usr/include/opencascade/NCollection_TListIterator.hxx"
# 1 "/usr/include/opencascade/NCollection_BaseList.hxx" 1
# 32 "/usr/include/opencascade/NCollection_BaseList.hxx"
typedef void (* NCollection_DelListNode)
     (NCollection_ListNode*, opencascade::handle<NCollection_BaseAllocator>& theAl);


class NCollection_BaseList
{
public:

  void* operator new (size_t theSize) { return Standard::Allocate (theSize); } void operator delete (void* theAddress) { Standard::Free (theAddress); } void* operator new[] (size_t theSize) { return Standard::Allocate (theSize); } void operator delete[] (void* theAddress) { Standard::Free (theAddress); } void* operator new (size_t, void* theAddress) { return theAddress; } void operator delete (void*, void*) { }
  void* operator new (size_t theSize, const opencascade::handle<NCollection_BaseAllocator>& theAllocator) { return theAllocator->Allocate(theSize); } void operator delete (void* theAddress, const opencascade::handle<NCollection_BaseAllocator>& theAllocator) { theAllocator->Free(theAddress); }

public:
  class Iterator
  {
  public:

    Iterator (void) :
      myCurrent (
# 49 "/usr/include/opencascade/NCollection_BaseList.hxx" 3 4
                __null
# 49 "/usr/include/opencascade/NCollection_BaseList.hxx"
                    ),
      myPrevious(
# 50 "/usr/include/opencascade/NCollection_BaseList.hxx" 3 4
                __null
# 50 "/usr/include/opencascade/NCollection_BaseList.hxx"
                    ) {}

    Iterator (const NCollection_BaseList& theList) :
      myCurrent (theList.myFirst),
      myPrevious(
# 54 "/usr/include/opencascade/NCollection_BaseList.hxx" 3 4
                __null
# 54 "/usr/include/opencascade/NCollection_BaseList.hxx"
                    ) {}

    void Init (const NCollection_BaseList& theList)
    {
      myCurrent = theList.myFirst;
      myPrevious = 
# 59 "/usr/include/opencascade/NCollection_BaseList.hxx" 3 4
                  __null
# 59 "/usr/include/opencascade/NCollection_BaseList.hxx"
                      ;
    }

    void Initialize (const NCollection_BaseList& theList)
    {
      Init(theList);
    }

    Standard_Boolean More (void) const
    { return (myCurrent!=
# 68 "/usr/include/opencascade/NCollection_BaseList.hxx" 3 4
                        __null
# 68 "/usr/include/opencascade/NCollection_BaseList.hxx"
                            ); }


    Standard_Boolean operator== (const Iterator& theIt) const
    {
      return myCurrent == theIt.myCurrent;
    }


    Standard_Boolean IsEqual (const Iterator& theOther) const
    {
      return *this == theOther;
    }
  protected:
    void Init (const NCollection_BaseList& theList,
               NCollection_ListNode * const thePrev)
    {
      myCurrent = thePrev ? thePrev -> Next() :
                             (NCollection_ListNode *)theList.PLast();
      myPrevious = thePrev;
    }
  public:
    NCollection_ListNode * myCurrent;
    NCollection_ListNode * myPrevious;
    friend class NCollection_BaseList;
  };

 public:



  Standard_Integer Extent (void) const
  { return myLength; }



  Standard_Boolean IsEmpty (void) const
  { return (myFirst == 
# 105 "/usr/include/opencascade/NCollection_BaseList.hxx" 3 4
                      __null
# 105 "/usr/include/opencascade/NCollection_BaseList.hxx"
                          ); }



  const opencascade::handle<NCollection_BaseAllocator>& Allocator() const
  { return myAllocator; }



  virtual ~NCollection_BaseList (void)
  {}

 protected:




  NCollection_BaseList (const opencascade::handle<NCollection_BaseAllocator>& theAllocator=0L) :
    myFirst(
# 123 "/usr/include/opencascade/NCollection_BaseList.hxx" 3 4
           __null
# 123 "/usr/include/opencascade/NCollection_BaseList.hxx"
               ),
    myLast(
# 124 "/usr/include/opencascade/NCollection_BaseList.hxx" 3 4
          __null
# 124 "/usr/include/opencascade/NCollection_BaseList.hxx"
              ),
    myLength(0)
  {
    myAllocator = (theAllocator.IsNull() ? NCollection_BaseAllocator::CommonBaseAllocator() : theAllocator);
  }



  void PClear (NCollection_DelListNode fDel);



  const NCollection_ListNode* PFirst (void) const
  { return myFirst; }



  const NCollection_ListNode* PLast (void) const
  { return myLast; }



  void PAppend (NCollection_ListNode* theNode);



  void PAppend (NCollection_ListNode* theNode,
                                Iterator& theIt)
  {
    NCollection_ListNode * aPrev = myLast;
    PAppend (theNode);
    theIt.Init (* this, aPrev);
  }



  void PAppend (NCollection_BaseList& theOther);



  void PPrepend (NCollection_ListNode* theNode);



  void PPrepend (NCollection_BaseList& theOther);



  void PRemoveFirst
    (NCollection_DelListNode fDel);



  void PRemove
    (Iterator& theIter,
     NCollection_DelListNode fDel);



  void PInsertBefore (NCollection_ListNode* theNode,
                                      Iterator& theIter);



  void PInsertBefore (NCollection_BaseList& theOther,
                                      Iterator& theIter);



  void PInsertAfter (NCollection_ListNode* theNode,
                                     Iterator& theIter);



  void PInsertAfter (NCollection_BaseList& theOther,
                                     Iterator& theIter);



  void PReverse ();

 protected:

  opencascade::handle<NCollection_BaseAllocator> myAllocator;
  NCollection_ListNode * myFirst;
  NCollection_ListNode * myLast;
  Standard_Integer myLength;


  friend class Iterator;
};
# 20 "/usr/include/opencascade/NCollection_TListIterator.hxx" 2







template <class TheItemType> class NCollection_TListIterator
  : public NCollection_BaseList::Iterator
{
 public:

  NCollection_TListIterator (void) :
    NCollection_BaseList::Iterator () {}

  NCollection_TListIterator (const NCollection_BaseList& theList) :
    NCollection_BaseList::Iterator (theList) {}

  Standard_Boolean More (void) const
  { return (myCurrent!=
# 39 "/usr/include/opencascade/NCollection_TListIterator.hxx" 3 4
                      __null
# 39 "/usr/include/opencascade/NCollection_TListIterator.hxx"
                          ); }

  void Next (void)
  {
    myPrevious = myCurrent;
    myCurrent = myCurrent->Next();
  }


  const TheItemType& Value (void) const
  { return ((const NCollection_TListNode<TheItemType>*) myCurrent)->Value(); }


  TheItemType& Value (void)
  { return ((NCollection_TListNode<TheItemType>*) myCurrent)->ChangeValue(); }


  TheItemType& ChangeValue (void) const
  { return ((NCollection_TListNode<TheItemType> *)myCurrent)->ChangeValue(); }
};
# 20 "/usr/include/opencascade/NCollection_List.hxx" 2
# 29 "/usr/include/opencascade/NCollection_List.hxx"
template <class TheItemType>
class NCollection_List : public NCollection_BaseList
{
public:

  typedef TheItemType value_type;

public:
  typedef NCollection_TListNode<TheItemType> ListNode;
  typedef NCollection_TListIterator<TheItemType> Iterator;


  typedef NCollection_StlIterator<std::forward_iterator_tag, Iterator, TheItemType, false> iterator;


  typedef NCollection_StlIterator<std::forward_iterator_tag, Iterator, TheItemType, true> const_iterator;


  iterator begin() const { return Iterator (*this); }


  iterator end() const { return Iterator(); }


  const_iterator cbegin() const { return Iterator (*this); }


  const_iterator cend() const { return Iterator(); }

 public:



  NCollection_List() : NCollection_BaseList(opencascade::handle<NCollection_BaseAllocator>()) {}


  explicit NCollection_List(const opencascade::handle<NCollection_BaseAllocator>& theAllocator) : NCollection_BaseList(theAllocator) {}


  NCollection_List (const NCollection_List& theOther) :
    NCollection_BaseList(theOther.myAllocator)
  {
    Assign (theOther);
  }


  Standard_Integer Size (void) const
  { return Extent(); }



  NCollection_List& Assign (const NCollection_List& theOther)
  {
    if (this != &theOther) {
      Clear();
      appendList(theOther.PFirst());
    }
    return *this;
  }


  NCollection_List& operator= (const NCollection_List& theOther)
  {
    return Assign (theOther);
  }


  void Clear (const opencascade::handle<NCollection_BaseAllocator>& theAllocator=0L)
  {
    PClear (ListNode::delNode);
    if (!theAllocator.IsNull())
      this->myAllocator = theAllocator;
  }


  const TheItemType& First (void) const
  {
    if (IsEmpty()) throw Standard_NoSuchObject("NCollection_List::First");;
    return ((const ListNode *) PFirst())->Value();
  }


  TheItemType& First (void)
  {
    if (IsEmpty()) throw Standard_NoSuchObject("NCollection_List::First");;
    return ((ListNode *) PFirst())->ChangeValue();
  }


  const TheItemType& Last (void) const
  {
    if (IsEmpty()) throw Standard_NoSuchObject("NCollection_List::Last");;
    return ((const ListNode *) PLast())->Value();
  }


  TheItemType& Last (void)
  {
    if (IsEmpty()) throw Standard_NoSuchObject("NCollection_List::Last");;
    return ((ListNode *) PLast())->ChangeValue();
  }


  TheItemType& Append (const TheItemType& theItem)
  {
    ListNode * pNew = new (this->myAllocator) ListNode(theItem);
    PAppend(pNew);
    return ((ListNode *) PLast())->ChangeValue();
  }



  void Append (const TheItemType& theItem, Iterator& theIter)
  {
    ListNode * pNew = new (this->myAllocator) ListNode(theItem);
    PAppend(pNew, theIter);
  }



  void Append (NCollection_List& theOther)
  {
    if (this == &theOther || theOther.Extent()<1)
      return;
    if (this->myAllocator == theOther.myAllocator)
    {


      PAppend(theOther);
    }
    else
    {

      appendList(theOther.myFirst);
      theOther.Clear();
    }
  }


  TheItemType& Prepend (const TheItemType& theItem)
  {
    ListNode * pNew = new (this->myAllocator) ListNode(theItem);
    PPrepend(pNew);
    return ((ListNode *) PFirst())->ChangeValue();
  }


  void Prepend (NCollection_List& theOther)
  {
    if (this == &theOther || theOther.Extent()<1)
      return;
    if (this->myAllocator == theOther.myAllocator)
    {


      PPrepend(theOther);
    }
    else
    {

      Iterator it(*this);
      prependList(theOther.PFirst(), it);
      theOther.Clear();
    }
  }


  void RemoveFirst (void)
  { PRemoveFirst (ListNode::delNode); }



  void Remove (Iterator& theIter)
  {
    PRemove (theIter, ListNode::delNode);
  }


  template<typename TheValueType>
  Standard_Boolean Remove (const TheValueType& theObject)
  {
    for (Iterator anIter (*this); anIter.More(); anIter.Next())
    {
      if (anIter.Value() == theObject)
      {
        Remove (anIter);
        return true;
      }
    }
    return false;
  }


  TheItemType& InsertBefore (const TheItemType& theItem,
                             Iterator& theIter)
  {
    ListNode * pNew = new (this->myAllocator) ListNode(theItem);
    PInsertBefore (pNew, theIter);
    return pNew -> ChangeValue();
  }


  void InsertBefore (NCollection_List& theOther,
                     Iterator& theIter)
  {
    if (this == &theOther)
      return;

    if (this->myAllocator == theOther.myAllocator)
    {


      PInsertBefore (theOther, theIter);
    }
    else
    {

      prependList(theOther.myFirst, theIter);
      theOther.Clear();
    }
  }


  TheItemType& InsertAfter (const TheItemType& theItem,
                            Iterator& theIter)
  {
    ListNode * pNew = new (this->myAllocator) ListNode(theItem);
    PInsertAfter (pNew, theIter);
    return pNew -> ChangeValue();
  }


  void InsertAfter (NCollection_List& theOther,
                    Iterator& theIter)
  {
    if (!theIter.More())
    {
      Append(theOther);
      return;
    }
    if (this->myAllocator == theOther.myAllocator)
    {


      PInsertAfter (theOther, theIter);
    }
    else
    {

      Iterator anIter;
      anIter.myPrevious = theIter.myCurrent;
      anIter.myCurrent = theIter.myCurrent->Next();
      prependList(theOther.PFirst(), anIter);
      theOther.Clear();
    }
  }


  void Reverse ()
  { PReverse(); }


  template<typename TheValueType>
  Standard_Boolean Contains (const TheValueType& theObject) const
  {
    for (Iterator anIter (*this); anIter.More(); anIter.Next())
    {
      if (anIter.Value() == theObject)
      {
        return true;
      }
    }
    return false;
  }


  virtual ~NCollection_List (void)
  { Clear(); }

 private:



  void appendList(const NCollection_ListNode * pCur) {
    while (pCur) {
      NCollection_ListNode * pNew =
        new (this->myAllocator) ListNode(((const ListNode *)(pCur))->Value());
      PAppend(pNew);
      pCur = pCur->Next();
    }
  }


  void prependList(const NCollection_ListNode * pCur, Iterator& theIter) {
    while (pCur) {
      NCollection_ListNode * pNew =
        new (this->myAllocator) ListNode (((const ListNode *)(pCur))->Value());
      PInsertBefore(pNew, theIter);
      pCur = pCur->Next();
    }
  }
};
# 19 "/usr/include/opencascade/Standard_Dump.hxx" 2
# 234 "/usr/include/opencascade/Standard_Dump.hxx"
enum Standard_JsonKey
{
  Standard_JsonKey_None,
  Standard_JsonKey_OpenChild,
  Standard_JsonKey_CloseChild,
  Standard_JsonKey_OpenContainer,
  Standard_JsonKey_CloseContainer,
  Standard_JsonKey_Quote,
  Standard_JsonKey_SeparatorKeyToValue,
  Standard_JsonKey_SeparatorValueToValue
};


struct Standard_DumpValue
{
  Standard_DumpValue() : myStartPosition (0) {}
  Standard_DumpValue (const TCollection_AsciiString& theValue, const Standard_Integer theStartPos)
    : myValue (theValue), myStartPosition (theStartPos) {}

  TCollection_AsciiString myValue;
  Standard_Integer myStartPosition;
};


class Standard_Dump
{
public:



  static TCollection_AsciiString Text (const Standard_SStream& theStream);
# 273 "/usr/include/opencascade/Standard_Dump.hxx"
  static TCollection_AsciiString FormatJson (const Standard_SStream& theStream, const Standard_Integer theIndent = 3);
# 286 "/usr/include/opencascade/Standard_Dump.hxx"
  static Standard_Boolean SplitJson (const TCollection_AsciiString& theStreamStr,
                                                     NCollection_IndexedDataMap<TCollection_AsciiString, Standard_DumpValue>& theKeyToValues);


  static NCollection_List<Standard_Integer> HierarchicalValueIndices (
    const NCollection_IndexedDataMap<TCollection_AsciiString, TCollection_AsciiString>& theValues);


  static Standard_Boolean HasChildKey (const TCollection_AsciiString& theSourceValue);


  static Standard_CString JsonKeyToString (const Standard_JsonKey theKey);


  static Standard_Integer JsonKeyLength (const Standard_JsonKey theKey);


  static void AddValuesSeparator (Standard_OStream& theOStream);


  static TCollection_AsciiString GetPointerPrefix() { return "0x"; }





  static TCollection_AsciiString GetPointerInfo (const opencascade::handle<Standard_Transient>& thePointer,
                                                                 const bool isShortInfo = true);





  static TCollection_AsciiString GetPointerInfo (const void* thePointer,
                                                                 const bool isShortInfo = true);





  static void DumpKeyToClass (Standard_OStream& theOStream,
                                              const TCollection_AsciiString& theKey,
                                              const TCollection_AsciiString& theField);




  static void DumpCharacterValues (Standard_OStream& theOStream, int theCount, ...);




  static void DumpRealValues (Standard_OStream& theOStream, int theCount, ...);





  static Standard_Boolean ProcessStreamName (const TCollection_AsciiString& theStreamStr,
                                                             const TCollection_AsciiString& theName,
                                                             Standard_Integer& theStreamPos);





  static Standard_Boolean ProcessFieldName (const TCollection_AsciiString& theStreamStr,
                                                            const TCollection_AsciiString& theName,
                                                            Standard_Integer& theStreamPos);





  static Standard_Boolean InitRealValues (const TCollection_AsciiString& theStreamStr,
                                                          Standard_Integer& theStreamPos,
                                                          int theCount, ...);





  static Standard_Boolean InitValue (const TCollection_AsciiString& theStreamStr,
                                                     Standard_Integer& theStreamPos,
                                                     TCollection_AsciiString& theValue);




  static TCollection_AsciiString DumpFieldToName (const TCollection_AsciiString& theField);

private:






  static Standard_Boolean splitKeyToValue (const TCollection_AsciiString& theStreamStr,
                                                           Standard_Integer theStartIndex,
                                                           Standard_Integer& theNextIndex,
                                                           NCollection_IndexedDataMap<TCollection_AsciiString, Standard_DumpValue>& theValues);



  static Standard_Boolean jsonKey (const TCollection_AsciiString& theStreamStr,
                                                   Standard_Integer theStartIndex,
                                                   Standard_Integer& theNextIndex,
                                                   Standard_JsonKey& theKey);




  static Standard_Integer nextClosePosition (const TCollection_AsciiString& theSourceValue,
                                                             const Standard_Integer theStartPosition,
                                                             const Standard_JsonKey theCloseKey,
                                                             const Standard_JsonKey theOpenKey);

};
# 21 "/usr/include/opencascade/NCollection_Buffer.hxx" 2



class NCollection_Buffer : public Standard_Transient
{

public:






  NCollection_Buffer (const opencascade::handle<NCollection_BaseAllocator>& theAlloc,
                      const Standard_Size theSize = 0,
                      Standard_Byte* theData = 
# 36 "/usr/include/opencascade/NCollection_Buffer.hxx" 3 4
                                                                        __null
# 36 "/usr/include/opencascade/NCollection_Buffer.hxx"
                                                                            )
  : myData (
# 37 "/usr/include/opencascade/NCollection_Buffer.hxx" 3 4
           __null
# 37 "/usr/include/opencascade/NCollection_Buffer.hxx"
               ),
    mySize (0),
    myAllocator (theAlloc)
  {
    if (theData != 
# 41 "/usr/include/opencascade/NCollection_Buffer.hxx" 3 4
                  __null
# 41 "/usr/include/opencascade/NCollection_Buffer.hxx"
                      )
    {
      myData = theData;
      mySize = theSize;
    }
    else
    {
      Allocate (theSize);
    }
  }


  ~NCollection_Buffer()
  {
    Free();
  }


  const Standard_Byte* Data() const
  {
    return myData;
  }


  Standard_Byte* ChangeData()
  {
    return myData;
  }


  bool IsEmpty() const
  {
    return myData == 
# 73 "/usr/include/opencascade/NCollection_Buffer.hxx" 3 4
                    __null
# 73 "/usr/include/opencascade/NCollection_Buffer.hxx"
                        ;
  }


  Standard_Size Size() const
  {
    return mySize;
  }


  const opencascade::handle<NCollection_BaseAllocator>& Allocator() const
  {
    return myAllocator;
  }


  void SetAllocator (const opencascade::handle<NCollection_BaseAllocator>& theAlloc)
  {
    Free();
    myAllocator = theAlloc;
  }



  bool Allocate (const Standard_Size theSize)
  {
    Free();
    mySize = theSize;
    if (theSize != 0
    || !myAllocator.IsNull())
    {
      myData = (Standard_Byte* )myAllocator->Allocate (theSize);
    }

    if (myData == 
# 107 "/usr/include/opencascade/NCollection_Buffer.hxx" 3 4
                 __null
# 107 "/usr/include/opencascade/NCollection_Buffer.hxx"
                     )
    {
      mySize = 0;
      return false;
    }
    return true;
  }


  void Free()
  {
    if (!myAllocator.IsNull())
    {
      myAllocator->Free (myData);
    }
    myData = 
# 122 "/usr/include/opencascade/NCollection_Buffer.hxx" 3 4
            __null
# 122 "/usr/include/opencascade/NCollection_Buffer.hxx"
                ;
    mySize = 0;
  }


  virtual void DumpJson (Standard_OStream& theOStream, Standard_Integer theDepth = -1) const
  {
    (void)theDepth;
    { TCollection_AsciiString aName = Standard_Dump::DumpFieldToName ("myData"); Standard_Dump::AddValuesSeparator (theOStream); theOStream << "\"" << aName << "\": \"" << Standard_Dump::GetPointerInfo (myData) << "\""; }
    { TCollection_AsciiString aName = Standard_Dump::DumpFieldToName ("mySize"); Standard_Dump::AddValuesSeparator (theOStream); theOStream << "\"" << aName << "\": " << mySize; }
    { TCollection_AsciiString aName = Standard_Dump::DumpFieldToName ("myAllocator.get()"); Standard_Dump::AddValuesSeparator (theOStream); theOStream << "\"" << aName << "\": \"" << Standard_Dump::GetPointerInfo (myAllocator.get()) << "\""; }
  }

protected:

  Standard_Byte* myData;
  Standard_Size mySize;
  opencascade::handle<NCollection_BaseAllocator> myAllocator;

public:

  public: typedef Standard_Transient base_type; static const char* get_type_name () { return "NCollection_Buffer"; using direct_base_classes = opencascade::direct_base_class_as_tuple<std::tr2::direct_bases<NCollection_Buffer>::type>::type; static_assert(opencascade::has_type<Standard_Transient, direct_base_classes>::type::value, "OCCT RTTI definition is incorrect: " "Standard_Transient" " is not direct base class of " "NCollection_Buffer"); static_assert(&get_type_name == &NCollection_Buffer::get_type_name, "OCCT RTTI definition is misplaced: current class is not " "NCollection_Buffer"); } static const opencascade::handle<Standard_Type>& get_type_descriptor () { return Standard_Type::Instance<NCollection_Buffer>(); } virtual const opencascade::handle<Standard_Type>& DynamicType() const override { return get_type_descriptor (); }

};

class NCollection_Buffer; typedef opencascade::handle<NCollection_Buffer> Handle_NCollection_Buffer;
# 21 "/usr/include/opencascade/Image_PixMapData.hxx" 2


class Image_PixMapData : public NCollection_Buffer
{
public:


  Image_PixMapData()
  : NCollection_Buffer (opencascade::handle<NCollection_BaseAllocator>()),
    myTopRowPtr (
# 30 "/usr/include/opencascade/Image_PixMapData.hxx" 3 4
                 __null
# 30 "/usr/include/opencascade/Image_PixMapData.hxx"
                     ),
    SizeBPP (0),
    SizeX (0),
    SizeY (0),
    SizeRowBytes (0),
    TopToDown (Standard_Size(-1))
  {

  }


  bool Init (const opencascade::handle<NCollection_BaseAllocator>& theAlloc,
             const Standard_Size theSizeBPP,
             const Standard_Size theSizeX,
             const Standard_Size theSizeY,
             const Standard_Size theSizeRowBytes,
             Standard_Byte* theDataPtr)
  {
    SetAllocator (theAlloc);

    myData = theDataPtr;
    myTopRowPtr = 
# 51 "/usr/include/opencascade/Image_PixMapData.hxx" 3 4
                  __null
# 51 "/usr/include/opencascade/Image_PixMapData.hxx"
                      ;
    SizeBPP = theSizeBPP;
    SizeX = theSizeX;
    SizeY = theSizeY;
    SizeRowBytes = theSizeRowBytes != 0 ? theSizeRowBytes : (theSizeX * theSizeBPP);
    mySize = SizeRowBytes * SizeY;
    if (myData == 
# 57 "/usr/include/opencascade/Image_PixMapData.hxx" 3 4
                 __null
# 57 "/usr/include/opencascade/Image_PixMapData.hxx"
                     )
    {
      Allocate (mySize);
    }
    SetTopDown (TopToDown == 1);
    return !IsEmpty();
  }


  void ZeroData()
  {
    if (myData != 
# 68 "/usr/include/opencascade/Image_PixMapData.hxx" 3 4
                 __null
# 68 "/usr/include/opencascade/Image_PixMapData.hxx"
                     )
    {
      memset (myData, 0, mySize);
    }
  }


  inline const Standard_Byte* Row (const Standard_Size theRow) const
  {
    return myTopRowPtr + ptrdiff_t(SizeRowBytes * theRow * TopToDown);
  }


  inline Standard_Byte* ChangeRow (const Standard_Size theRow)
  {
    return myTopRowPtr + ptrdiff_t(SizeRowBytes * theRow * TopToDown);
  }


  inline const Standard_Byte* Value (const Standard_Size theRow,
                                     const Standard_Size theCol) const
  {
    return myTopRowPtr + ptrdiff_t(SizeRowBytes * theRow * TopToDown) + SizeBPP * theCol;
  }


  inline Standard_Byte* ChangeValue (const Standard_Size theRow,
                                     const Standard_Size theCol)
  {
    return myTopRowPtr + ptrdiff_t(SizeRowBytes * theRow * TopToDown) + SizeBPP * theCol;
  }



  inline Standard_Size MaxRowAligmentBytes() const
  {
    Standard_Size anAlignment = 2;
    for (; anAlignment <= 16; anAlignment <<= 1)
    {
      if ((SizeRowBytes % anAlignment) != 0 || (Standard_Size(myData) % anAlignment) != 0)
      {
        return (anAlignment >> 1);
      }
    }
    return anAlignment;
  }




  inline void SetTopDown (const bool theIsTopDown)
  {
    TopToDown = (theIsTopDown ? 1 : Standard_Size(-1));
    myTopRowPtr = ((TopToDown == 1 || myData == 
# 121 "/usr/include/opencascade/Image_PixMapData.hxx" 3 4
                                               __null
# 121 "/usr/include/opencascade/Image_PixMapData.hxx"
                                                   )
                ? myData : (myData + SizeRowBytes * (SizeY - 1)));
  }

protected:

  Standard_Byte* myTopRowPtr;

public:

  Standard_Size SizeBPP;
  Standard_Size SizeX;
  Standard_Size SizeY;
  Standard_Size SizeRowBytes;
  Standard_Size TopToDown;


public:

  public: typedef NCollection_Buffer base_type; static const char* get_type_name () { return "Image_PixMapData"; using direct_base_classes = opencascade::direct_base_class_as_tuple<std::tr2::direct_bases<Image_PixMapData>::type>::type; static_assert(opencascade::has_type<NCollection_Buffer, direct_base_classes>::type::value, "OCCT RTTI definition is incorrect: " "NCollection_Buffer" " is not direct base class of " "Image_PixMapData"); static_assert(&get_type_name == &Image_PixMapData::get_type_name, "OCCT RTTI definition is misplaced: current class is not " "Image_PixMapData"); } static const opencascade::handle<Standard_Type>& get_type_descriptor () { return Standard_Type::Instance<Image_PixMapData>(); } virtual const opencascade::handle<Standard_Type>& DynamicType() const override { return get_type_descriptor (); }

};

class Image_PixMapData; typedef opencascade::handle<Image_PixMapData> Handle_Image_PixMapData;
# 21 "/usr/include/opencascade/Image_PixMap.hxx" 2

# 1 "/usr/include/opencascade/Quantity_ColorRGBA.hxx" 1
# 17 "/usr/include/opencascade/Quantity_ColorRGBA.hxx"
# 1 "/usr/include/opencascade/Quantity_Color.hxx" 1
# 22 "/usr/include/opencascade/Quantity_Color.hxx"
# 1 "/usr/include/opencascade/Standard_ShortReal.hxx" 1
# 18 "/usr/include/opencascade/Standard_ShortReal.hxx"
# 1 "/usr/include/c++/10.2.0/cmath" 1 3
# 39 "/usr/include/c++/10.2.0/cmath" 3
       
# 40 "/usr/include/c++/10.2.0/cmath" 3
# 19 "/usr/include/opencascade/Standard_ShortReal.hxx" 2
# 34 "/usr/include/opencascade/Standard_ShortReal.hxx"
inline Standard_ShortReal ShortRealSmall()
{ return 1.17549435082228750796873653722224568e-38F; }




inline Standard_ShortReal Abs(const Standard_ShortReal Value)



{ return float( fabs (Value) ) ; }





inline Standard_Integer ShortRealDigits()
{ return 6; }





inline Standard_ShortReal ShortRealEpsilon()
{ return 1.19209289550781250000000000000000000e-7F; }




inline Standard_ShortReal ShortRealFirst()
{ Standard_ShortReal MaxFloatTmp = -3.40282346638528859811704183484516925e+38F;
  return MaxFloatTmp; }





inline Standard_Integer ShortRealFirst10Exp()
{ return (-37); }




inline Standard_ShortReal ShortRealLast()
{ return 3.40282346638528859811704183484516925e+38F; }





inline Standard_Integer ShortRealLast10Exp()
{ return 38; }





inline Standard_Integer ShortRealMantissa()
{ return 24; }




inline Standard_Integer ShortRealRadix()
{ return 2; }




inline Standard_Integer ShortRealSize()
{ return (8 * sizeof(Standard_ShortReal)); }




inline Standard_ShortReal Max (const Standard_ShortReal Val1,
       const Standard_ShortReal Val2)
{
  if (Val1 >= Val2) {
    return Val1;
  } else {
    return Val2;
  }
}




inline Standard_ShortReal Min (const Standard_ShortReal Val1,
       const Standard_ShortReal Val2)
{
  if (Val1 <= Val2) {
    return Val1;
  } else {
    return Val2;
  }
}
# 146 "/usr/include/opencascade/Standard_ShortReal.hxx"
 Standard_Integer HashCode (Standard_ShortReal theShortReal, Standard_Integer theUpperBound);




inline Standard_Boolean IsEqual (const Standard_ShortReal Value1,
      const Standard_ShortReal Value2)
{ return Abs((Value1 - Value2)) < ShortRealSmall(); }
# 23 "/usr/include/opencascade/Quantity_Color.hxx" 2

# 1 "/usr/include/opencascade/Quantity_NameOfColor.hxx" 1
# 22 "/usr/include/opencascade/Quantity_NameOfColor.hxx"
enum Quantity_NameOfColor
{
Quantity_NOC_BLACK,
Quantity_NOC_MATRABLUE,
Quantity_NOC_MATRAGRAY,
Quantity_NOC_ALICEBLUE,
Quantity_NOC_ANTIQUEWHITE,
Quantity_NOC_ANTIQUEWHITE1,
Quantity_NOC_ANTIQUEWHITE2,
Quantity_NOC_ANTIQUEWHITE3,
Quantity_NOC_ANTIQUEWHITE4,
Quantity_NOC_AQUAMARINE1,
Quantity_NOC_AQUAMARINE2,
Quantity_NOC_AQUAMARINE4,
Quantity_NOC_AZURE,
Quantity_NOC_AZURE2,
Quantity_NOC_AZURE3,
Quantity_NOC_AZURE4,
Quantity_NOC_BEIGE,
Quantity_NOC_BISQUE,
Quantity_NOC_BISQUE2,
Quantity_NOC_BISQUE3,
Quantity_NOC_BISQUE4,
Quantity_NOC_BLANCHEDALMOND,
Quantity_NOC_BLUE,
Quantity_NOC_BLUE1 = Quantity_NOC_BLUE,
Quantity_NOC_BLUE2,
Quantity_NOC_BLUE3,
Quantity_NOC_BLUE4,
Quantity_NOC_BLUEVIOLET,
Quantity_NOC_BROWN,
Quantity_NOC_BROWN1,
Quantity_NOC_BROWN2,
Quantity_NOC_BROWN3,
Quantity_NOC_BROWN4,
Quantity_NOC_BURLYWOOD,
Quantity_NOC_BURLYWOOD1,
Quantity_NOC_BURLYWOOD2,
Quantity_NOC_BURLYWOOD3,
Quantity_NOC_BURLYWOOD4,
Quantity_NOC_CADETBLUE,
Quantity_NOC_CADETBLUE1,
Quantity_NOC_CADETBLUE2,
Quantity_NOC_CADETBLUE3,
Quantity_NOC_CADETBLUE4,
Quantity_NOC_CHARTREUSE,
Quantity_NOC_CHARTREUSE1 = Quantity_NOC_CHARTREUSE,
Quantity_NOC_CHARTREUSE2,
Quantity_NOC_CHARTREUSE3,
Quantity_NOC_CHARTREUSE4,
Quantity_NOC_CHOCOLATE,
Quantity_NOC_CHOCOLATE1,
Quantity_NOC_CHOCOLATE2,
Quantity_NOC_CHOCOLATE3,
Quantity_NOC_CHOCOLATE4,
Quantity_NOC_CORAL,
Quantity_NOC_CORAL1,
Quantity_NOC_CORAL2,
Quantity_NOC_CORAL3,
Quantity_NOC_CORAL4,
Quantity_NOC_CORNFLOWERBLUE,
Quantity_NOC_CORNSILK1,
Quantity_NOC_CORNSILK2,
Quantity_NOC_CORNSILK3,
Quantity_NOC_CORNSILK4,
Quantity_NOC_CYAN,
Quantity_NOC_CYAN1 = Quantity_NOC_CYAN,
Quantity_NOC_CYAN2,
Quantity_NOC_CYAN3,
Quantity_NOC_CYAN4,
Quantity_NOC_DARKGOLDENROD,
Quantity_NOC_DARKGOLDENROD1,
Quantity_NOC_DARKGOLDENROD2,
Quantity_NOC_DARKGOLDENROD3,
Quantity_NOC_DARKGOLDENROD4,
Quantity_NOC_DARKGREEN,
Quantity_NOC_DARKKHAKI,
Quantity_NOC_DARKOLIVEGREEN,
Quantity_NOC_DARKOLIVEGREEN1,
Quantity_NOC_DARKOLIVEGREEN2,
Quantity_NOC_DARKOLIVEGREEN3,
Quantity_NOC_DARKOLIVEGREEN4,
Quantity_NOC_DARKORANGE,
Quantity_NOC_DARKORANGE1,
Quantity_NOC_DARKORANGE2,
Quantity_NOC_DARKORANGE3,
Quantity_NOC_DARKORANGE4,
Quantity_NOC_DARKORCHID,
Quantity_NOC_DARKORCHID1,
Quantity_NOC_DARKORCHID2,
Quantity_NOC_DARKORCHID3,
Quantity_NOC_DARKORCHID4,
Quantity_NOC_DARKSALMON,
Quantity_NOC_DARKSEAGREEN,
Quantity_NOC_DARKSEAGREEN1,
Quantity_NOC_DARKSEAGREEN2,
Quantity_NOC_DARKSEAGREEN3,
Quantity_NOC_DARKSEAGREEN4,
Quantity_NOC_DARKSLATEBLUE,
Quantity_NOC_DARKSLATEGRAY1,
Quantity_NOC_DARKSLATEGRAY2,
Quantity_NOC_DARKSLATEGRAY3,
Quantity_NOC_DARKSLATEGRAY4,
Quantity_NOC_DARKSLATEGRAY,
Quantity_NOC_DARKTURQUOISE,
Quantity_NOC_DARKVIOLET,
Quantity_NOC_DEEPPINK,
Quantity_NOC_DEEPPINK2,
Quantity_NOC_DEEPPINK3,
Quantity_NOC_DEEPPINK4,
Quantity_NOC_DEEPSKYBLUE1,
Quantity_NOC_DEEPSKYBLUE2,
Quantity_NOC_DEEPSKYBLUE3,
Quantity_NOC_DEEPSKYBLUE4,
Quantity_NOC_DODGERBLUE1,
Quantity_NOC_DODGERBLUE2,
Quantity_NOC_DODGERBLUE3,
Quantity_NOC_DODGERBLUE4,
Quantity_NOC_FIREBRICK,
Quantity_NOC_FIREBRICK1,
Quantity_NOC_FIREBRICK2,
Quantity_NOC_FIREBRICK3,
Quantity_NOC_FIREBRICK4,
Quantity_NOC_FLORALWHITE,
Quantity_NOC_FORESTGREEN,
Quantity_NOC_GAINSBORO,
Quantity_NOC_GHOSTWHITE,
Quantity_NOC_GOLD,
Quantity_NOC_GOLD1 = Quantity_NOC_GOLD,
Quantity_NOC_GOLD2,
Quantity_NOC_GOLD3,
Quantity_NOC_GOLD4,
Quantity_NOC_GOLDENROD,
Quantity_NOC_GOLDENROD1,
Quantity_NOC_GOLDENROD2,
Quantity_NOC_GOLDENROD3,
Quantity_NOC_GOLDENROD4,
Quantity_NOC_GRAY,
Quantity_NOC_GRAY0,
Quantity_NOC_GRAY1,
Quantity_NOC_GRAY2,
Quantity_NOC_GRAY3,
Quantity_NOC_GRAY4,
Quantity_NOC_GRAY5,
Quantity_NOC_GRAY6,
Quantity_NOC_GRAY7,
Quantity_NOC_GRAY8,
Quantity_NOC_GRAY9,
Quantity_NOC_GRAY10,
Quantity_NOC_GRAY11,
Quantity_NOC_GRAY12,
Quantity_NOC_GRAY13,
Quantity_NOC_GRAY14,
Quantity_NOC_GRAY15,
Quantity_NOC_GRAY16,
Quantity_NOC_GRAY17,
Quantity_NOC_GRAY18,
Quantity_NOC_GRAY19,
Quantity_NOC_GRAY20,
Quantity_NOC_GRAY21,
Quantity_NOC_GRAY22,
Quantity_NOC_GRAY23,
Quantity_NOC_GRAY24,
Quantity_NOC_GRAY25,
Quantity_NOC_GRAY26,
Quantity_NOC_GRAY27,
Quantity_NOC_GRAY28,
Quantity_NOC_GRAY29,
Quantity_NOC_GRAY30,
Quantity_NOC_GRAY31,
Quantity_NOC_GRAY32,
Quantity_NOC_GRAY33,
Quantity_NOC_GRAY34,
Quantity_NOC_GRAY35,
Quantity_NOC_GRAY36,
Quantity_NOC_GRAY37,
Quantity_NOC_GRAY38,
Quantity_NOC_GRAY39,
Quantity_NOC_GRAY40,
Quantity_NOC_GRAY41,
Quantity_NOC_GRAY42,
Quantity_NOC_GRAY43,
Quantity_NOC_GRAY44,
Quantity_NOC_GRAY45,
Quantity_NOC_GRAY46,
Quantity_NOC_GRAY47,
Quantity_NOC_GRAY48,
Quantity_NOC_GRAY49,
Quantity_NOC_GRAY50,
Quantity_NOC_GRAY51,
Quantity_NOC_GRAY52,
Quantity_NOC_GRAY53,
Quantity_NOC_GRAY54,
Quantity_NOC_GRAY55,
Quantity_NOC_GRAY56,
Quantity_NOC_GRAY57,
Quantity_NOC_GRAY58,
Quantity_NOC_GRAY59,
Quantity_NOC_GRAY60,
Quantity_NOC_GRAY61,
Quantity_NOC_GRAY62,
Quantity_NOC_GRAY63,
Quantity_NOC_GRAY64,
Quantity_NOC_GRAY65,
Quantity_NOC_GRAY66,
Quantity_NOC_GRAY67,
Quantity_NOC_GRAY68,
Quantity_NOC_GRAY69,
Quantity_NOC_GRAY70,
Quantity_NOC_GRAY71,
Quantity_NOC_GRAY72,
Quantity_NOC_GRAY73,
Quantity_NOC_GRAY74,
Quantity_NOC_GRAY75,
Quantity_NOC_GRAY76,
Quantity_NOC_GRAY77,
Quantity_NOC_GRAY78,
Quantity_NOC_GRAY79,
Quantity_NOC_GRAY80,
Quantity_NOC_GRAY81,
Quantity_NOC_GRAY82,
Quantity_NOC_GRAY83,
Quantity_NOC_GRAY85,
Quantity_NOC_GRAY86,
Quantity_NOC_GRAY87,
Quantity_NOC_GRAY88,
Quantity_NOC_GRAY89,
Quantity_NOC_GRAY90,
Quantity_NOC_GRAY91,
Quantity_NOC_GRAY92,
Quantity_NOC_GRAY93,
Quantity_NOC_GRAY94,
Quantity_NOC_GRAY95,
Quantity_NOC_GRAY97,
Quantity_NOC_GRAY98,
Quantity_NOC_GRAY99,
Quantity_NOC_GREEN,
Quantity_NOC_GREEN1 = Quantity_NOC_GREEN,
Quantity_NOC_GREEN2,
Quantity_NOC_GREEN3,
Quantity_NOC_GREEN4,
Quantity_NOC_GREENYELLOW,
Quantity_NOC_HONEYDEW,
Quantity_NOC_HONEYDEW2,
Quantity_NOC_HONEYDEW3,
Quantity_NOC_HONEYDEW4,
Quantity_NOC_HOTPINK,
Quantity_NOC_HOTPINK1,
Quantity_NOC_HOTPINK2,
Quantity_NOC_HOTPINK3,
Quantity_NOC_HOTPINK4,
Quantity_NOC_INDIANRED,
Quantity_NOC_INDIANRED1,
Quantity_NOC_INDIANRED2,
Quantity_NOC_INDIANRED3,
Quantity_NOC_INDIANRED4,
Quantity_NOC_IVORY,
Quantity_NOC_IVORY2,
Quantity_NOC_IVORY3,
Quantity_NOC_IVORY4,
Quantity_NOC_KHAKI,
Quantity_NOC_KHAKI1,
Quantity_NOC_KHAKI2,
Quantity_NOC_KHAKI3,
Quantity_NOC_KHAKI4,
Quantity_NOC_LAVENDER,
Quantity_NOC_LAVENDERBLUSH1,
Quantity_NOC_LAVENDERBLUSH2,
Quantity_NOC_LAVENDERBLUSH3,
Quantity_NOC_LAVENDERBLUSH4,
Quantity_NOC_LAWNGREEN,
Quantity_NOC_LEMONCHIFFON1,
Quantity_NOC_LEMONCHIFFON2,
Quantity_NOC_LEMONCHIFFON3,
Quantity_NOC_LEMONCHIFFON4,
Quantity_NOC_LIGHTBLUE,
Quantity_NOC_LIGHTBLUE1,
Quantity_NOC_LIGHTBLUE2,
Quantity_NOC_LIGHTBLUE3,
Quantity_NOC_LIGHTBLUE4,
Quantity_NOC_LIGHTCORAL,
Quantity_NOC_LIGHTCYAN,
Quantity_NOC_LIGHTCYAN1 = Quantity_NOC_LIGHTCYAN,
Quantity_NOC_LIGHTCYAN2,
Quantity_NOC_LIGHTCYAN3,
Quantity_NOC_LIGHTCYAN4,
Quantity_NOC_LIGHTGOLDENROD,
Quantity_NOC_LIGHTGOLDENROD1,
Quantity_NOC_LIGHTGOLDENROD2,
Quantity_NOC_LIGHTGOLDENROD3,
Quantity_NOC_LIGHTGOLDENROD4,
Quantity_NOC_LIGHTGOLDENRODYELLOW,
Quantity_NOC_LIGHTGRAY,
Quantity_NOC_LIGHTPINK,
Quantity_NOC_LIGHTPINK1,
Quantity_NOC_LIGHTPINK2,
Quantity_NOC_LIGHTPINK3,
Quantity_NOC_LIGHTPINK4,
Quantity_NOC_LIGHTSALMON1,
Quantity_NOC_LIGHTSALMON2,
Quantity_NOC_LIGHTSALMON3,
Quantity_NOC_LIGHTSALMON4,
Quantity_NOC_LIGHTSEAGREEN,
Quantity_NOC_LIGHTSKYBLUE,
Quantity_NOC_LIGHTSKYBLUE1,
Quantity_NOC_LIGHTSKYBLUE2,
Quantity_NOC_LIGHTSKYBLUE3,
Quantity_NOC_LIGHTSKYBLUE4,
Quantity_NOC_LIGHTSLATEBLUE,
Quantity_NOC_LIGHTSLATEGRAY,
Quantity_NOC_LIGHTSTEELBLUE,
Quantity_NOC_LIGHTSTEELBLUE1,
Quantity_NOC_LIGHTSTEELBLUE2,
Quantity_NOC_LIGHTSTEELBLUE3,
Quantity_NOC_LIGHTSTEELBLUE4,
Quantity_NOC_LIGHTYELLOW,
Quantity_NOC_LIGHTYELLOW2,
Quantity_NOC_LIGHTYELLOW3,
Quantity_NOC_LIGHTYELLOW4,
Quantity_NOC_LIMEGREEN,
Quantity_NOC_LINEN,
Quantity_NOC_MAGENTA,
Quantity_NOC_MAGENTA1 = Quantity_NOC_MAGENTA,
Quantity_NOC_MAGENTA2,
Quantity_NOC_MAGENTA3,
Quantity_NOC_MAGENTA4,
Quantity_NOC_MAROON,
Quantity_NOC_MAROON1,
Quantity_NOC_MAROON2,
Quantity_NOC_MAROON3,
Quantity_NOC_MAROON4,
Quantity_NOC_MEDIUMAQUAMARINE,
Quantity_NOC_MEDIUMORCHID,
Quantity_NOC_MEDIUMORCHID1,
Quantity_NOC_MEDIUMORCHID2,
Quantity_NOC_MEDIUMORCHID3,
Quantity_NOC_MEDIUMORCHID4,
Quantity_NOC_MEDIUMPURPLE,
Quantity_NOC_MEDIUMPURPLE1,
Quantity_NOC_MEDIUMPURPLE2,
Quantity_NOC_MEDIUMPURPLE3,
Quantity_NOC_MEDIUMPURPLE4,
Quantity_NOC_MEDIUMSEAGREEN,
Quantity_NOC_MEDIUMSLATEBLUE,
Quantity_NOC_MEDIUMSPRINGGREEN,
Quantity_NOC_MEDIUMTURQUOISE,
Quantity_NOC_MEDIUMVIOLETRED,
Quantity_NOC_MIDNIGHTBLUE,
Quantity_NOC_MINTCREAM,
Quantity_NOC_MISTYROSE,
Quantity_NOC_MISTYROSE2,
Quantity_NOC_MISTYROSE3,
Quantity_NOC_MISTYROSE4,
Quantity_NOC_MOCCASIN,
Quantity_NOC_NAVAJOWHITE1,
Quantity_NOC_NAVAJOWHITE2,
Quantity_NOC_NAVAJOWHITE3,
Quantity_NOC_NAVAJOWHITE4,
Quantity_NOC_NAVYBLUE,
Quantity_NOC_OLDLACE,
Quantity_NOC_OLIVEDRAB,
Quantity_NOC_OLIVEDRAB1,
Quantity_NOC_OLIVEDRAB2,
Quantity_NOC_OLIVEDRAB3,
Quantity_NOC_OLIVEDRAB4,
Quantity_NOC_ORANGE,
Quantity_NOC_ORANGE1 = Quantity_NOC_ORANGE,
Quantity_NOC_ORANGE2,
Quantity_NOC_ORANGE3,
Quantity_NOC_ORANGE4,
Quantity_NOC_ORANGERED,
Quantity_NOC_ORANGERED1 = Quantity_NOC_ORANGERED,
Quantity_NOC_ORANGERED2,
Quantity_NOC_ORANGERED3,
Quantity_NOC_ORANGERED4,
Quantity_NOC_ORCHID,
Quantity_NOC_ORCHID1,
Quantity_NOC_ORCHID2,
Quantity_NOC_ORCHID3,
Quantity_NOC_ORCHID4,
Quantity_NOC_PALEGOLDENROD,
Quantity_NOC_PALEGREEN,
Quantity_NOC_PALEGREEN1,
Quantity_NOC_PALEGREEN2,
Quantity_NOC_PALEGREEN3,
Quantity_NOC_PALEGREEN4,
Quantity_NOC_PALETURQUOISE,
Quantity_NOC_PALETURQUOISE1,
Quantity_NOC_PALETURQUOISE2,
Quantity_NOC_PALETURQUOISE3,
Quantity_NOC_PALETURQUOISE4,
Quantity_NOC_PALEVIOLETRED,
Quantity_NOC_PALEVIOLETRED1,
Quantity_NOC_PALEVIOLETRED2,
Quantity_NOC_PALEVIOLETRED3,
Quantity_NOC_PALEVIOLETRED4,
Quantity_NOC_PAPAYAWHIP,
Quantity_NOC_PEACHPUFF,
Quantity_NOC_PEACHPUFF2,
Quantity_NOC_PEACHPUFF3,
Quantity_NOC_PEACHPUFF4,
Quantity_NOC_PERU,
Quantity_NOC_PINK,
Quantity_NOC_PINK1,
Quantity_NOC_PINK2,
Quantity_NOC_PINK3,
Quantity_NOC_PINK4,
Quantity_NOC_PLUM,
Quantity_NOC_PLUM1,
Quantity_NOC_PLUM2,
Quantity_NOC_PLUM3,
Quantity_NOC_PLUM4,
Quantity_NOC_POWDERBLUE,
Quantity_NOC_PURPLE,
Quantity_NOC_PURPLE1,
Quantity_NOC_PURPLE2,
Quantity_NOC_PURPLE3,
Quantity_NOC_PURPLE4,
Quantity_NOC_RED,
Quantity_NOC_RED1 = Quantity_NOC_RED,
Quantity_NOC_RED2,
Quantity_NOC_RED3,
Quantity_NOC_RED4,
Quantity_NOC_ROSYBROWN,
Quantity_NOC_ROSYBROWN1,
Quantity_NOC_ROSYBROWN2,
Quantity_NOC_ROSYBROWN3,
Quantity_NOC_ROSYBROWN4,
Quantity_NOC_ROYALBLUE,
Quantity_NOC_ROYALBLUE1,
Quantity_NOC_ROYALBLUE2,
Quantity_NOC_ROYALBLUE3,
Quantity_NOC_ROYALBLUE4,
Quantity_NOC_SADDLEBROWN,
Quantity_NOC_SALMON,
Quantity_NOC_SALMON1,
Quantity_NOC_SALMON2,
Quantity_NOC_SALMON3,
Quantity_NOC_SALMON4,
Quantity_NOC_SANDYBROWN,
Quantity_NOC_SEAGREEN,
Quantity_NOC_SEAGREEN1,
Quantity_NOC_SEAGREEN2,
Quantity_NOC_SEAGREEN3,
Quantity_NOC_SEAGREEN4,
Quantity_NOC_SEASHELL,
Quantity_NOC_SEASHELL2,
Quantity_NOC_SEASHELL3,
Quantity_NOC_SEASHELL4,
Quantity_NOC_BEET,
Quantity_NOC_TEAL,
Quantity_NOC_SIENNA,
Quantity_NOC_SIENNA1,
Quantity_NOC_SIENNA2,
Quantity_NOC_SIENNA3,
Quantity_NOC_SIENNA4,
Quantity_NOC_SKYBLUE,
Quantity_NOC_SKYBLUE1,
Quantity_NOC_SKYBLUE2,
Quantity_NOC_SKYBLUE3,
Quantity_NOC_SKYBLUE4,
Quantity_NOC_SLATEBLUE,
Quantity_NOC_SLATEBLUE1,
Quantity_NOC_SLATEBLUE2,
Quantity_NOC_SLATEBLUE3,
Quantity_NOC_SLATEBLUE4,
Quantity_NOC_SLATEGRAY1,
Quantity_NOC_SLATEGRAY2,
Quantity_NOC_SLATEGRAY3,
Quantity_NOC_SLATEGRAY4,
Quantity_NOC_SLATEGRAY,
Quantity_NOC_SNOW,
Quantity_NOC_SNOW2,
Quantity_NOC_SNOW3,
Quantity_NOC_SNOW4,
Quantity_NOC_SPRINGGREEN,
Quantity_NOC_SPRINGGREEN2,
Quantity_NOC_SPRINGGREEN3,
Quantity_NOC_SPRINGGREEN4,
Quantity_NOC_STEELBLUE,
Quantity_NOC_STEELBLUE1,
Quantity_NOC_STEELBLUE2,
Quantity_NOC_STEELBLUE3,
Quantity_NOC_STEELBLUE4,
Quantity_NOC_TAN,
Quantity_NOC_TAN1,
Quantity_NOC_TAN2,
Quantity_NOC_TAN3,
Quantity_NOC_TAN4,
Quantity_NOC_THISTLE,
Quantity_NOC_THISTLE1,
Quantity_NOC_THISTLE2,
Quantity_NOC_THISTLE3,
Quantity_NOC_THISTLE4,
Quantity_NOC_TOMATO,
Quantity_NOC_TOMATO1 = Quantity_NOC_TOMATO,
Quantity_NOC_TOMATO2,
Quantity_NOC_TOMATO3,
Quantity_NOC_TOMATO4,
Quantity_NOC_TURQUOISE,
Quantity_NOC_TURQUOISE1,
Quantity_NOC_TURQUOISE2,
Quantity_NOC_TURQUOISE3,
Quantity_NOC_TURQUOISE4,
Quantity_NOC_VIOLET,
Quantity_NOC_VIOLETRED,
Quantity_NOC_VIOLETRED1,
Quantity_NOC_VIOLETRED2,
Quantity_NOC_VIOLETRED3,
Quantity_NOC_VIOLETRED4,
Quantity_NOC_WHEAT,
Quantity_NOC_WHEAT1,
Quantity_NOC_WHEAT2,
Quantity_NOC_WHEAT3,
Quantity_NOC_WHEAT4,
Quantity_NOC_WHITESMOKE,
Quantity_NOC_YELLOW,
Quantity_NOC_YELLOW1 = Quantity_NOC_YELLOW,
Quantity_NOC_YELLOW2,
Quantity_NOC_YELLOW3,
Quantity_NOC_YELLOW4,
Quantity_NOC_YELLOWGREEN,
Quantity_NOC_WHITE
};
# 25 "/usr/include/opencascade/Quantity_Color.hxx" 2
# 1 "/usr/include/opencascade/Quantity_TypeOfColor.hxx" 1
# 21 "/usr/include/opencascade/Quantity_TypeOfColor.hxx"
enum Quantity_TypeOfColor
{

  Quantity_TOC_RGB,


  Quantity_TOC_sRGB,






  Quantity_TOC_HLS,
# 49 "/usr/include/opencascade/Quantity_TypeOfColor.hxx"
  Quantity_TOC_CIELab,
# 66 "/usr/include/opencascade/Quantity_TypeOfColor.hxx"
  Quantity_TOC_CIELch
};
# 26 "/usr/include/opencascade/Quantity_Color.hxx" 2

# 1 "/usr/include/opencascade/NCollection_Vec4.hxx" 1
# 18 "/usr/include/opencascade/NCollection_Vec4.hxx"
# 1 "/usr/include/opencascade/NCollection_Vec3.hxx" 1
# 18 "/usr/include/opencascade/NCollection_Vec3.hxx"
# 1 "/usr/include/c++/10.2.0/cstring" 1 3
# 39 "/usr/include/c++/10.2.0/cstring" 3
       
# 40 "/usr/include/c++/10.2.0/cstring" 3
# 71 "/usr/include/c++/10.2.0/cstring" 3

# 71 "/usr/include/c++/10.2.0/cstring" 3
extern "C++"
{
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::memchr;
  using ::memcmp;
  using ::memcpy;
  using ::memmove;
  using ::memset;
  using ::strcat;
  using ::strcmp;
  using ::strcoll;
  using ::strcpy;
  using ::strcspn;
  using ::strerror;
  using ::strlen;
  using ::strncat;
  using ::strncmp;
  using ::strncpy;
  using ::strspn;
  using ::strtok;
  using ::strxfrm;
  using ::strchr;
  using ::strpbrk;
  using ::strrchr;
  using ::strstr;
# 122 "/usr/include/c++/10.2.0/cstring" 3

}
}
# 19 "/usr/include/opencascade/NCollection_Vec3.hxx" 2
# 1 "/usr/include/c++/10.2.0/cmath" 1 3
# 39 "/usr/include/c++/10.2.0/cmath" 3
       
# 40 "/usr/include/c++/10.2.0/cmath" 3
# 20 "/usr/include/opencascade/NCollection_Vec3.hxx" 2
# 1 "/usr/include/opencascade/NCollection_Vec2.hxx" 1
# 18 "/usr/include/opencascade/NCollection_Vec2.hxx"
# 1 "/usr/include/c++/10.2.0/cmath" 1 3
# 39 "/usr/include/c++/10.2.0/cmath" 3
       
# 40 "/usr/include/c++/10.2.0/cmath" 3
# 19 "/usr/include/opencascade/NCollection_Vec2.hxx" 2
# 30 "/usr/include/opencascade/NCollection_Vec2.hxx"

# 30 "/usr/include/opencascade/NCollection_Vec2.hxx"
template<typename Element_t>
class NCollection_Vec2
{

public:


  static int Length()
  {
    return 2;
  }


  NCollection_Vec2()
  {
    v[0] = v[1] = Element_t(0);
  }


  explicit NCollection_Vec2 (const Element_t theXY)
  {
    v[0] = v[1] = theXY;
  }


  explicit NCollection_Vec2 (const Element_t theX,
                             const Element_t theY)
  {
    v[0] = theX;
    v[1] = theY;
  }






  template <typename OtherElement_t>
  explicit NCollection_Vec2 (const NCollection_Vec2<OtherElement_t>& theOtherVec2)
  {
    v[0] = static_cast<Element_t> (theOtherVec2[0]);
    v[1] = static_cast<Element_t> (theOtherVec2[1]);
  }


  void SetValues (const Element_t theX,
                  const Element_t theY)
  {
    v[0] = theX;
    v[1] = theY;
  }


  Element_t x() const { return v[0]; }


  Element_t y() const { return v[1]; }


  const NCollection_Vec2<Element_t> xy() const { return NCollection_Vec2<Element_t>(x(), y()); } const NCollection_Vec2<Element_t> yx() const { return NCollection_Vec2<Element_t>(y(), x()); }


  Element_t& x() { return v[0]; }


  Element_t& y() { return v[1]; }


  bool IsEqual (const NCollection_Vec2& theOther) const
  {
    return v[0] == theOther.v[0]
        && v[1] == theOther.v[1];
  }


  bool operator== (const NCollection_Vec2& theOther) { return IsEqual (theOther); }
  bool operator== (const NCollection_Vec2& theOther) const { return IsEqual (theOther); }


  bool operator!= (const NCollection_Vec2& theOther) { return !IsEqual (theOther); }
  bool operator!= (const NCollection_Vec2& theOther) const { return !IsEqual (theOther); }


  const Element_t* GetData() const { return v; }
        Element_t* ChangeData() { return v; }
  operator const Element_t*() const { return v; }
  operator Element_t*() { return v; }


  NCollection_Vec2& operator+= (const NCollection_Vec2& theAdd)
  {
    v[0] += theAdd.v[0];
    v[1] += theAdd.v[1];
    return *this;
  }


  friend NCollection_Vec2 operator+ (const NCollection_Vec2& theLeft,
                                     const NCollection_Vec2& theRight)
  {
    return NCollection_Vec2 (theLeft.v[0] + theRight.v[0],
                             theLeft.v[1] + theRight.v[1]);
  }


  NCollection_Vec2& operator-= (const NCollection_Vec2& theDec)
  {
    v[0] -= theDec.v[0];
    v[1] -= theDec.v[1];
    return *this;
  }


  friend NCollection_Vec2 operator- (const NCollection_Vec2& theLeft,
                                     const NCollection_Vec2& theRight)
  {
    return NCollection_Vec2 (theLeft.v[0] - theRight.v[0],
                             theLeft.v[1] - theRight.v[1]);
  }


  NCollection_Vec2 operator-() const
  {
    return NCollection_Vec2 (-x(), -y());
  }


  NCollection_Vec2& operator*= (const NCollection_Vec2& theRight)
  {
    v[0] *= theRight.v[0];
    v[1] *= theRight.v[1];
    return *this;
  }


  friend NCollection_Vec2 operator* (const NCollection_Vec2& theLeft,
                                     const NCollection_Vec2& theRight)
  {
    return NCollection_Vec2 (theLeft.v[0] * theRight.v[0],
                             theLeft.v[1] * theRight.v[1]);
  }


  void Multiply (const Element_t theFactor)
  {
    v[0] *= theFactor;
    v[1] *= theFactor;
  }


  NCollection_Vec2 Multiplied (const Element_t theFactor) const
  {
    return NCollection_Vec2 (v[0] * theFactor,
                             v[1] * theFactor);
  }


  NCollection_Vec2 cwiseMin (const NCollection_Vec2& theVec) const
  {
    return NCollection_Vec2 (v[0] < theVec.v[0] ? v[0] : theVec.v[0],
                             v[1] < theVec.v[1] ? v[1] : theVec.v[1]);
  }


  NCollection_Vec2 cwiseMax (const NCollection_Vec2& theVec) const
  {
    return NCollection_Vec2 (v[0] > theVec.v[0] ? v[0] : theVec.v[0],
                             v[1] > theVec.v[1] ? v[1] : theVec.v[1]);
  }


  NCollection_Vec2 cwiseAbs() const
  {
    return NCollection_Vec2 (std::abs (v[0]),
                             std::abs (v[1]));
  }


  Element_t maxComp() const
  {
    return v[0] > v[1] ? v[0] : v[1];
  }


  Element_t minComp() const
  {
    return v[0] < v[1] ? v[0] : v[1];
  }


  NCollection_Vec2& operator*= (const Element_t theFactor)
  {
    Multiply (theFactor);
    return *this;
  }


  NCollection_Vec2& operator/= (const Element_t theInvFactor)
  {
    v[0] /= theInvFactor;
    v[1] /= theInvFactor;
    return *this;
  }


  NCollection_Vec2& operator/= (const NCollection_Vec2& theRight)
  {
    v[0] /= theRight.v[0];
    v[1] /= theRight.v[1];
    return *this;
  }


  NCollection_Vec2 operator* (const Element_t theFactor) const
  {
    return Multiplied (theFactor);
  }


  NCollection_Vec2 operator/ (const Element_t theInvFactor) const
  {
    return NCollection_Vec2(v[0] / theInvFactor,
            v[1] / theInvFactor);
  }


  friend NCollection_Vec2 operator/ (const NCollection_Vec2& theLeft,
                                     const NCollection_Vec2& theRight)
  {
    return NCollection_Vec2 (theLeft.v[0] / theRight.v[0],
                             theLeft.v[1] / theRight.v[1]);
  }


  Element_t Dot (const NCollection_Vec2& theOther) const
  {
    return x() * theOther.x() + y() * theOther.y();
  }


  Element_t Modulus() const
  {
    return std::sqrt (x() * x() + y() * y());
  }



  Element_t SquareModulus() const
  {
    return x() * x() + y() * y();
  }


  static NCollection_Vec2 DX()
  {
    return NCollection_Vec2 (Element_t(1), Element_t(0));
  }


  static NCollection_Vec2 DY()
  {
    return NCollection_Vec2 (Element_t(0), Element_t(1));
  }


  void DumpJson (Standard_OStream& theOStream, Standard_Integer theDepth = -1) const
  {
    (void)theDepth;
    { Standard_Dump::AddValuesSeparator (theOStream); theOStream << "\"" << "Vec2" << "\": ["; Standard_Dump::DumpRealValues (theOStream, 2, v[0], v[1]); theOStream << "]"; }
  }

private:

  Element_t v[2];

};
# 21 "/usr/include/opencascade/NCollection_Vec3.hxx" 2
# 34 "/usr/include/opencascade/NCollection_Vec3.hxx"
template<typename Element_t>
class NCollection_Vec3
{

public:


  static int Length()
  {
    return 3;
  }


  NCollection_Vec3()
  {
    std::memset (this, 0, sizeof(NCollection_Vec3));
  }


  explicit NCollection_Vec3 (Element_t theValue)
  {
    v[0] = v[1] = v[2] = theValue;
  }


  explicit NCollection_Vec3 (const Element_t theX,
                             const Element_t theY,
                             const Element_t theZ)
  {
    v[0] = theX;
    v[1] = theY;
    v[2] = theZ;
  }


  explicit NCollection_Vec3 (const NCollection_Vec2<Element_t>& theVec2, Element_t theZ = Element_t(0))
  {
    v[0] = theVec2[0];
    v[1] = theVec2[1];
    v[2] = theZ;
  }






  template <typename OtherElement_t>
  explicit NCollection_Vec3 (const NCollection_Vec3<OtherElement_t>& theOtherVec3)
  {
    v[0] = static_cast<Element_t> (theOtherVec3[0]);
    v[1] = static_cast<Element_t> (theOtherVec3[1]);
    v[2] = static_cast<Element_t> (theOtherVec3[2]);
  }


  void SetValues (const Element_t theX,
                  const Element_t theY,
                  const Element_t theZ)
  {
    v[0] = theX;
    v[1] = theY;
    v[2] = theZ;
  }


  void SetValues (const NCollection_Vec2<Element_t>& theVec2, Element_t theZ)
  {
    v[0] = theVec2.x();
    v[1] = theVec2.y();
    v[2] = theZ;
  }


  Element_t x() const { return v[0]; }


  Element_t r() const { return v[0]; }


  Element_t y() const { return v[1]; }


  Element_t g() const { return v[1]; }


  Element_t z() const { return v[2]; }


  Element_t b() const { return v[2]; }


  const NCollection_Vec2<Element_t> xy() const { return NCollection_Vec2<Element_t>(x(), y()); } const NCollection_Vec2<Element_t> yx() const { return NCollection_Vec2<Element_t>(y(), x()); }
  const NCollection_Vec2<Element_t> xz() const { return NCollection_Vec2<Element_t>(x(), z()); } const NCollection_Vec2<Element_t> zx() const { return NCollection_Vec2<Element_t>(z(), x()); }
  const NCollection_Vec2<Element_t> yz() const { return NCollection_Vec2<Element_t>(y(), z()); } const NCollection_Vec2<Element_t> zy() const { return NCollection_Vec2<Element_t>(z(), y()); }


  const NCollection_Vec3<Element_t> xyz() const { return NCollection_Vec3<Element_t>(x(), y(), z()); } const NCollection_Vec3<Element_t> xzy() const { return NCollection_Vec3<Element_t>(x(), z(), y()); } const NCollection_Vec3<Element_t> yxz() const { return NCollection_Vec3<Element_t>(y(), x(), z()); } const NCollection_Vec3<Element_t> yzx() const { return NCollection_Vec3<Element_t>(y(), z(), x()); } const NCollection_Vec3<Element_t> zyx() const { return NCollection_Vec3<Element_t>(z(), y(), x()); } const NCollection_Vec3<Element_t> zxy() const { return NCollection_Vec3<Element_t>(z(), x(), y()); }


  Element_t& x() { return v[0]; }


  Element_t& r() { return v[0]; }


  Element_t& y() { return v[1]; }


  Element_t& g() { return v[1]; }


  Element_t& z() { return v[2]; }


  Element_t& b() { return v[2]; }


  bool IsEqual (const NCollection_Vec3& theOther) const
  {
    return v[0] == theOther.v[0]
        && v[1] == theOther.v[1]
        && v[2] == theOther.v[2];
  }


  bool operator== (const NCollection_Vec3& theOther) { return IsEqual (theOther); }
  bool operator== (const NCollection_Vec3& theOther) const { return IsEqual (theOther); }


  bool operator!= (const NCollection_Vec3& theOther) { return !IsEqual (theOther); }
  bool operator!= (const NCollection_Vec3& theOther) const { return !IsEqual (theOther); }


  const Element_t* GetData() const { return v; }
        Element_t* ChangeData() { return v; }
  operator const Element_t*() const { return v; }
  operator Element_t*() { return v; }


  NCollection_Vec3& operator+= (const NCollection_Vec3& theAdd)
  {
    v[0] += theAdd.v[0];
    v[1] += theAdd.v[1];
    v[2] += theAdd.v[2];
    return *this;
  }


  friend NCollection_Vec3 operator+ (const NCollection_Vec3& theLeft,
                                     const NCollection_Vec3& theRight)
  {
    NCollection_Vec3 aSumm = NCollection_Vec3 (theLeft);
    return aSumm += theRight;
  }


  NCollection_Vec3 operator-() const
  {
    return NCollection_Vec3 (-x(), -y(), -z());
  }


  NCollection_Vec3& operator-= (const NCollection_Vec3& theDec)
  {
    v[0] -= theDec.v[0];
    v[1] -= theDec.v[1];
    v[2] -= theDec.v[2];
    return *this;
  }


  friend NCollection_Vec3 operator- (const NCollection_Vec3& theLeft,
                                     const NCollection_Vec3& theRight)
  {
    NCollection_Vec3 aSumm = NCollection_Vec3 (theLeft);
    return aSumm -= theRight;
  }


  void Multiply (const Element_t theFactor)
  {
    v[0] *= theFactor;
    v[1] *= theFactor;
    v[2] *= theFactor;
  }


  NCollection_Vec3& operator*= (const NCollection_Vec3& theRight)
  {
    v[0] *= theRight.v[0];
    v[1] *= theRight.v[1];
    v[2] *= theRight.v[2];
    return *this;
  }


  friend NCollection_Vec3 operator* (const NCollection_Vec3& theLeft,
                                     const NCollection_Vec3& theRight)
  {
    NCollection_Vec3 aResult = NCollection_Vec3 (theLeft);
    return aResult *= theRight;
  }


  NCollection_Vec3& operator*= (const Element_t theFactor)
  {
    Multiply (theFactor);
    return *this;
  }


  NCollection_Vec3 operator* (const Element_t theFactor) const
  {
    return Multiplied (theFactor);
  }


  NCollection_Vec3 Multiplied (const Element_t theFactor) const
  {
    NCollection_Vec3 aCopyVec3 (*this);
    aCopyVec3 *= theFactor;
    return aCopyVec3;
  }


  NCollection_Vec3 cwiseMin (const NCollection_Vec3& theVec) const
  {
    return NCollection_Vec3 (v[0] < theVec.v[0] ? v[0] : theVec.v[0],
                             v[1] < theVec.v[1] ? v[1] : theVec.v[1],
                             v[2] < theVec.v[2] ? v[2] : theVec.v[2]);
  }


  NCollection_Vec3 cwiseMax (const NCollection_Vec3& theVec) const
  {
    return NCollection_Vec3 (v[0] > theVec.v[0] ? v[0] : theVec.v[0],
                             v[1] > theVec.v[1] ? v[1] : theVec.v[1],
                             v[2] > theVec.v[2] ? v[2] : theVec.v[2]);
  }


  NCollection_Vec3 cwiseAbs() const
  {
    return NCollection_Vec3 (std::abs (v[0]),
                             std::abs (v[1]),
                             std::abs (v[2]));
  }


  Element_t maxComp() const
  {
    return v[0] > v[1] ? (v[0] > v[2] ? v[0] : v[2])
                       : (v[1] > v[2] ? v[1] : v[2]);
  }


  Element_t minComp() const
  {
    return v[0] < v[1] ? (v[0] < v[2] ? v[0] : v[2])
                       : (v[1] < v[2] ? v[1] : v[2]);
  }


  NCollection_Vec3& operator/= (const Element_t theInvFactor)
  {
    v[0] /= theInvFactor;
    v[1] /= theInvFactor;
    v[2] /= theInvFactor;
    return *this;
  }


  NCollection_Vec3& operator/= (const NCollection_Vec3& theRight)
  {
    v[0] /= theRight.v[0];
    v[1] /= theRight.v[1];
    v[2] /= theRight.v[2];
    return *this;
  }


  NCollection_Vec3 operator/ (const Element_t theInvFactor) const
  {
    NCollection_Vec3 aResult (*this);
    return aResult /= theInvFactor;
  }


  friend NCollection_Vec3 operator/ (const NCollection_Vec3& theLeft,
                                     const NCollection_Vec3& theRight)
  {
    NCollection_Vec3 aResult = NCollection_Vec3 (theLeft);
    return aResult /= theRight;
  }


  Element_t Dot (const NCollection_Vec3& theOther) const
  {
    return x() * theOther.x() + y() * theOther.y() + z() * theOther.z();
  }


  Element_t Modulus() const
  {
    return std::sqrt (x() * x() + y() * y() + z() * z());
  }



  Element_t SquareModulus() const
  {
    return x() * x() + y() * y() + z() * z();
  }


  void Normalize()
  {
    Element_t aModulus = Modulus();
    if (aModulus != Element_t(0))
    {
      x() = x() / aModulus;
      y() = y() / aModulus;
      z() = z() / aModulus;
    }
  }


  NCollection_Vec3 Normalized() const
  {
    NCollection_Vec3 aCopy (*this);
    aCopy.Normalize();
    return aCopy;
  }


  static NCollection_Vec3 Cross (const NCollection_Vec3& theVec1,
                                 const NCollection_Vec3& theVec2)
  {
    return NCollection_Vec3(theVec1.y() * theVec2.z() - theVec1.z() * theVec2.y(),
            theVec1.z() * theVec2.x() - theVec1.x() * theVec2.z(),
            theVec1.x() * theVec2.y() - theVec1.y() * theVec2.x());
  }




  static NCollection_Vec3 GetLERP (const NCollection_Vec3& theFrom,
                                   const NCollection_Vec3& theTo,
                                   const Element_t theT)
  {
    return theFrom * (Element_t(1) - theT) + theTo * theT;
  }


  static NCollection_Vec3 DX()
  {
    return NCollection_Vec3 (Element_t(1), Element_t(0), Element_t(0));
  }


  static NCollection_Vec3 DY()
  {
    return NCollection_Vec3 (Element_t(0), Element_t(1), Element_t(0));
  }


  static NCollection_Vec3 DZ()
  {
    return NCollection_Vec3 (Element_t(0), Element_t(0), Element_t(1));
  }


  void DumpJson (Standard_OStream& theOStream, Standard_Integer theDepth = -1) const
  {
    (void)theDepth;
    { Standard_Dump::AddValuesSeparator (theOStream); theOStream << "\"" << "Vec3" << "\": ["; Standard_Dump::DumpRealValues (theOStream, 3, v[0], v[1], v[2]); theOStream << "]"; }
  }

private:

  Element_t v[3];

};


template<> inline NCollection_Vec3<float>& NCollection_Vec3<float>::operator/= (const float theInvFactor)
{
  Multiply (1.0f / theInvFactor);
  return *this;
}


template<> inline NCollection_Vec3<double>& NCollection_Vec3<double>::operator/= (const double theInvFactor)
{
  Multiply (1.0 / theInvFactor);
  return *this;
}
# 19 "/usr/include/opencascade/NCollection_Vec4.hxx" 2






template<typename Element_t>
class NCollection_Vec4
{

public:


  static int Length()
  {
    return 4;
  }


  NCollection_Vec4()
  {
    std::memset (this, 0, sizeof(NCollection_Vec4));
  }


  explicit NCollection_Vec4 (const Element_t theValue)
  {
    v[0] = v[1] = v[2] = v[3] = theValue;
  }


  explicit NCollection_Vec4 (const Element_t theX,
                             const Element_t theY,
                             const Element_t theZ,
                             const Element_t theW)
  {
    v[0] = theX;
    v[1] = theY;
    v[2] = theZ;
    v[3] = theW;
  }


  explicit NCollection_Vec4 (const NCollection_Vec2<Element_t>& theVec2)
  {
    v[0] = theVec2[0];
    v[1] = theVec2[1];
    v[2] = v[3] = Element_t (0);
  }


  explicit NCollection_Vec4(const NCollection_Vec3<Element_t>& theVec3, const Element_t theW = Element_t(0))
  {
    std::memcpy (this, &theVec3, sizeof(NCollection_Vec3<Element_t>));
    v[3] = theW;
  }






  template <typename OtherElement_t>
  explicit NCollection_Vec4 (const NCollection_Vec4<OtherElement_t>& theOtherVec4)
  {
    v[0] = static_cast<Element_t> (theOtherVec4[0]);
    v[1] = static_cast<Element_t> (theOtherVec4[1]);
    v[2] = static_cast<Element_t> (theOtherVec4[2]);
    v[3] = static_cast<Element_t> (theOtherVec4[3]);
  }


  void SetValues (const Element_t theX,
                  const Element_t theY,
                  const Element_t theZ,
                  const Element_t theW)
  {
    v[0] = theX;
    v[1] = theY;
    v[2] = theZ;
    v[3] = theW;
  }


  void SetValues (const NCollection_Vec3<Element_t>& theVec3, const Element_t theW)
  {
    v[0] = theVec3.x();
    v[1] = theVec3.y();
    v[2] = theVec3.z();
    v[3] = theW;
  }


  Element_t x() const { return v[0]; }


  Element_t r() const { return v[0]; }


  Element_t y() const { return v[1]; }


  Element_t g() const { return v[1]; }


  Element_t z() const { return v[2]; }


  Element_t b() const { return v[2]; }


  Element_t w() const { return v[3]; }


  Element_t a() const { return v[3]; }


  const NCollection_Vec2<Element_t> xy() const { return NCollection_Vec2<Element_t>(x(), y()); } const NCollection_Vec2<Element_t> yx() const { return NCollection_Vec2<Element_t>(y(), x()); }
  const NCollection_Vec2<Element_t> xz() const { return NCollection_Vec2<Element_t>(x(), z()); } const NCollection_Vec2<Element_t> zx() const { return NCollection_Vec2<Element_t>(z(), x()); }
  const NCollection_Vec2<Element_t> xw() const { return NCollection_Vec2<Element_t>(x(), w()); } const NCollection_Vec2<Element_t> wx() const { return NCollection_Vec2<Element_t>(w(), x()); }
  const NCollection_Vec2<Element_t> yz() const { return NCollection_Vec2<Element_t>(y(), z()); } const NCollection_Vec2<Element_t> zy() const { return NCollection_Vec2<Element_t>(z(), y()); }
  const NCollection_Vec2<Element_t> yw() const { return NCollection_Vec2<Element_t>(y(), w()); } const NCollection_Vec2<Element_t> wy() const { return NCollection_Vec2<Element_t>(w(), y()); }
  const NCollection_Vec2<Element_t> zw() const { return NCollection_Vec2<Element_t>(z(), w()); } const NCollection_Vec2<Element_t> wz() const { return NCollection_Vec2<Element_t>(w(), z()); }


  const NCollection_Vec3<Element_t> xyz() const { return NCollection_Vec3<Element_t>(x(), y(), z()); } const NCollection_Vec3<Element_t> xzy() const { return NCollection_Vec3<Element_t>(x(), z(), y()); } const NCollection_Vec3<Element_t> yxz() const { return NCollection_Vec3<Element_t>(y(), x(), z()); } const NCollection_Vec3<Element_t> yzx() const { return NCollection_Vec3<Element_t>(y(), z(), x()); } const NCollection_Vec3<Element_t> zyx() const { return NCollection_Vec3<Element_t>(z(), y(), x()); } const NCollection_Vec3<Element_t> zxy() const { return NCollection_Vec3<Element_t>(z(), x(), y()); }
  const NCollection_Vec3<Element_t> xyw() const { return NCollection_Vec3<Element_t>(x(), y(), w()); } const NCollection_Vec3<Element_t> xwy() const { return NCollection_Vec3<Element_t>(x(), w(), y()); } const NCollection_Vec3<Element_t> yxw() const { return NCollection_Vec3<Element_t>(y(), x(), w()); } const NCollection_Vec3<Element_t> ywx() const { return NCollection_Vec3<Element_t>(y(), w(), x()); } const NCollection_Vec3<Element_t> wyx() const { return NCollection_Vec3<Element_t>(w(), y(), x()); } const NCollection_Vec3<Element_t> wxy() const { return NCollection_Vec3<Element_t>(w(), x(), y()); }
  const NCollection_Vec3<Element_t> xzw() const { return NCollection_Vec3<Element_t>(x(), z(), w()); } const NCollection_Vec3<Element_t> xwz() const { return NCollection_Vec3<Element_t>(x(), w(), z()); } const NCollection_Vec3<Element_t> zxw() const { return NCollection_Vec3<Element_t>(z(), x(), w()); } const NCollection_Vec3<Element_t> zwx() const { return NCollection_Vec3<Element_t>(z(), w(), x()); } const NCollection_Vec3<Element_t> wzx() const { return NCollection_Vec3<Element_t>(w(), z(), x()); } const NCollection_Vec3<Element_t> wxz() const { return NCollection_Vec3<Element_t>(w(), x(), z()); }
  const NCollection_Vec3<Element_t> yzw() const { return NCollection_Vec3<Element_t>(y(), z(), w()); } const NCollection_Vec3<Element_t> ywz() const { return NCollection_Vec3<Element_t>(y(), w(), z()); } const NCollection_Vec3<Element_t> zyw() const { return NCollection_Vec3<Element_t>(z(), y(), w()); } const NCollection_Vec3<Element_t> zwy() const { return NCollection_Vec3<Element_t>(z(), w(), y()); } const NCollection_Vec3<Element_t> wzy() const { return NCollection_Vec3<Element_t>(w(), z(), y()); } const NCollection_Vec3<Element_t> wyz() const { return NCollection_Vec3<Element_t>(w(), y(), z()); }


  const NCollection_Vec3<Element_t> rgb() const { return NCollection_Vec3<Element_t>(r(), g(), b()); } const NCollection_Vec3<Element_t> rbg() const { return NCollection_Vec3<Element_t>(r(), b(), g()); } const NCollection_Vec3<Element_t> grb() const { return NCollection_Vec3<Element_t>(g(), r(), b()); } const NCollection_Vec3<Element_t> gbr() const { return NCollection_Vec3<Element_t>(g(), b(), r()); } const NCollection_Vec3<Element_t> bgr() const { return NCollection_Vec3<Element_t>(b(), g(), r()); } const NCollection_Vec3<Element_t> brg() const { return NCollection_Vec3<Element_t>(b(), r(), g()); }


  Element_t& x() { return v[0]; }


  Element_t& r() { return v[0]; }


  Element_t& y() { return v[1]; }


  Element_t& g() { return v[1]; }


  Element_t& z() { return v[2]; }


  Element_t& b() { return v[2]; }


  Element_t& w() { return v[3]; }


  Element_t& a() { return v[3]; }


  bool IsEqual (const NCollection_Vec4& theOther) const
  {
    return v[0] == theOther.v[0]
        && v[1] == theOther.v[1]
        && v[2] == theOther.v[2]
        && v[3] == theOther.v[3];
  }


  bool operator== (const NCollection_Vec4& theOther) { return IsEqual (theOther); }
  bool operator== (const NCollection_Vec4& theOther) const { return IsEqual (theOther); }


  bool operator!= (const NCollection_Vec4& theOther) { return !IsEqual (theOther); }
  bool operator!= (const NCollection_Vec4& theOther) const { return !IsEqual (theOther); }


  const Element_t* GetData() const { return v; }
        Element_t* ChangeData() { return v; }
  operator const Element_t*() const { return v; }
  operator Element_t*() { return v; }


  NCollection_Vec4& operator+= (const NCollection_Vec4& theAdd)
  {
    v[0] += theAdd.v[0];
    v[1] += theAdd.v[1];
    v[2] += theAdd.v[2];
    v[3] += theAdd.v[3];
    return *this;
  }


  friend NCollection_Vec4 operator+ (const NCollection_Vec4& theLeft,
                                     const NCollection_Vec4& theRight)
  {
    NCollection_Vec4 aSumm = NCollection_Vec4 (theLeft);
    return aSumm += theRight;
  }


  NCollection_Vec4 operator-() const
  {
    return NCollection_Vec4 (-x(), -y(), -z(), -w());
  }


  NCollection_Vec4& operator-= (const NCollection_Vec4& theDec)
  {
    v[0] -= theDec.v[0];
    v[1] -= theDec.v[1];
    v[2] -= theDec.v[2];
    v[3] -= theDec.v[3];
    return *this;
  }


  friend NCollection_Vec4 operator- (const NCollection_Vec4& theLeft,
                                     const NCollection_Vec4& theRight)
  {
    NCollection_Vec4 aSumm = NCollection_Vec4 (theLeft);
    return aSumm -= theRight;
  }


  NCollection_Vec4& operator*= (const NCollection_Vec4& theRight)
  {
    v[0] *= theRight.v[0];
    v[1] *= theRight.v[1];
    v[2] *= theRight.v[2];
    v[3] *= theRight.v[3];
    return *this;
  }


  friend NCollection_Vec4 operator* (const NCollection_Vec4& theLeft,
                                     const NCollection_Vec4& theRight)
  {
    NCollection_Vec4 aResult = NCollection_Vec4 (theLeft);
    return aResult *= theRight;
  }


  void Multiply (const Element_t theFactor)
  {
    v[0] *= theFactor;
    v[1] *= theFactor;
    v[2] *= theFactor;
    v[3] *= theFactor;
  }


  NCollection_Vec4& operator*=(const Element_t theFactor)
  {
    Multiply (theFactor);
    return *this;
  }


  NCollection_Vec4 operator* (const Element_t theFactor) const
  {
    return Multiplied (theFactor);
  }


  NCollection_Vec4 Multiplied (const Element_t theFactor) const
  {
    NCollection_Vec4 aCopyVec4 (*this);
    aCopyVec4 *= theFactor;
    return aCopyVec4;
  }


  NCollection_Vec4 cwiseMin (const NCollection_Vec4& theVec) const
  {
    return NCollection_Vec4 (v[0] < theVec.v[0] ? v[0] : theVec.v[0],
                             v[1] < theVec.v[1] ? v[1] : theVec.v[1],
                             v[2] < theVec.v[2] ? v[2] : theVec.v[2],
                             v[3] < theVec.v[3] ? v[3] : theVec.v[3]);
  }


  NCollection_Vec4 cwiseMax (const NCollection_Vec4& theVec) const
  {
    return NCollection_Vec4 (v[0] > theVec.v[0] ? v[0] : theVec.v[0],
                             v[1] > theVec.v[1] ? v[1] : theVec.v[1],
                             v[2] > theVec.v[2] ? v[2] : theVec.v[2],
                             v[3] > theVec.v[3] ? v[3] : theVec.v[3]);
  }


  NCollection_Vec4 cwiseAbs() const
  {
    return NCollection_Vec4 (std::abs (v[0]),
                             std::abs (v[1]),
                             std::abs (v[2]),
                             std::abs (v[3]));
  }


  Element_t maxComp() const
  {
    const Element_t aMax1 = v[0] > v[1] ? v[0] : v[1];
    const Element_t aMax2 = v[2] > v[3] ? v[2] : v[3];

    return aMax1 > aMax2 ? aMax1 : aMax2;
  }


  Element_t minComp() const
  {
    const Element_t aMin1 = v[0] < v[1] ? v[0] : v[1];
    const Element_t aMin2 = v[2] < v[3] ? v[2] : v[3];

    return aMin1 < aMin2 ? aMin1 : aMin2;
  }


  Element_t Dot (const NCollection_Vec4& theOther) const
  {
    return x() * theOther.x() +
           y() * theOther.y() +
           z() * theOther.z() +
           w() * theOther.w();
  }


  NCollection_Vec4& operator/= (const Element_t theInvFactor)
  {
    v[0] /= theInvFactor;
    v[1] /= theInvFactor;
    v[2] /= theInvFactor;
    v[3] /= theInvFactor;
    return *this;
  }


  NCollection_Vec4& operator/= (const NCollection_Vec4& theRight)
  {
    v[0] /= theRight.v[0];
    v[1] /= theRight.v[1];
    v[2] /= theRight.v[2];
    v[3] /= theRight.v[3];
    return *this;
  }


  NCollection_Vec4 operator/ (const Element_t theInvFactor)
  {
    NCollection_Vec4 aResult(*this);
    return aResult /= theInvFactor;
  }


  friend NCollection_Vec4 operator/ (const NCollection_Vec4& theLeft,
                                     const NCollection_Vec4& theRight)
  {
    NCollection_Vec4 aResult = NCollection_Vec4 (theLeft);
    return aResult /= theRight;
  }


  void DumpJson (Standard_OStream& theOStream, Standard_Integer theDepth = -1) const
  {
    (void)theDepth;
    { Standard_Dump::AddValuesSeparator (theOStream); theOStream << "\"" << "Vec4" << "\": ["; Standard_Dump::DumpRealValues (theOStream, 4, v[0], v[1], v[2], v[3]); theOStream << "]"; }
  }

private:

  Element_t v[4];

};


template<> inline NCollection_Vec4<float>& NCollection_Vec4<float>::operator/= (const float theInvFactor)
{
  Multiply (1.0f / theInvFactor);
  return *this;
}


template<> inline NCollection_Vec4<double>& NCollection_Vec4<double>::operator/= (const double theInvFactor)
{
  Multiply (1.0 / theInvFactor);
  return *this;
}
# 28 "/usr/include/opencascade/Quantity_Color.hxx" 2







class Quantity_Color
{
public:

  void* operator new (size_t theSize) { return Standard::Allocate (theSize); } void operator delete (void* theAddress) { Standard::Free (theAddress); } void* operator new[] (size_t theSize) { return Standard::Allocate (theSize); } void operator delete[] (void* theAddress) { Standard::Free (theAddress); } void* operator new (size_t, void* theAddress) { return theAddress; } void operator delete (void*, void*) { }


  Quantity_Color() : myRgb (valuesOf (Quantity_NOC_YELLOW, Quantity_TOC_RGB)) {}


  Quantity_Color (const Quantity_NameOfColor theName) : myRgb (valuesOf (theName, Quantity_TOC_RGB)) {}



  Quantity_Color (const Standard_Real theC1,
                                  const Standard_Real theC2,
                                  const Standard_Real theC3,
                                  const Quantity_TypeOfColor theType);


  explicit Quantity_Color (const NCollection_Vec3<float>& theRgb);


  Quantity_NameOfColor Name() const;


  void SetValues (const Quantity_NameOfColor theName) { myRgb = valuesOf (theName, Quantity_TOC_RGB); }


  const NCollection_Vec3<float>& Rgb () const { return myRgb; }


  operator const NCollection_Vec3<float>&() const { return myRgb; }



  void Values (Standard_Real& theC1,
                               Standard_Real& theC2,
                               Standard_Real& theC3,
                               const Quantity_TypeOfColor theType) const;



  void SetValues (const Standard_Real theC1,
                                  const Standard_Real theC2,
                                  const Standard_Real theC3,
                                  const Quantity_TypeOfColor theType);


  Standard_Real Red() const { return myRgb.r(); }


  Standard_Real Green() const { return myRgb.g(); }


  Standard_Real Blue() const { return myRgb.b(); }




  Standard_Real Hue() const { return Convert_LinearRGB_To_HLS (myRgb)[0]; }


  Standard_Real Light() const { return Convert_LinearRGB_To_HLS (myRgb)[1]; }




  void ChangeIntensity (const Standard_Real theDelta);


  Standard_Real Saturation() const { return Convert_LinearRGB_To_HLS (myRgb)[2]; }




  void ChangeContrast (const Standard_Real theDelta);


  Standard_Boolean IsDifferent (const Quantity_Color& theOther) const { return (SquareDistance (theOther) > Epsilon() * Epsilon()); }


  Standard_Boolean operator!= (const Quantity_Color& theOther) const { return IsDifferent (theOther); }


  Standard_Boolean IsEqual (const Quantity_Color& theOther) const { return (SquareDistance (theOther) <= Epsilon() * Epsilon()); }


  Standard_Boolean operator== (const Quantity_Color& theOther) const { return IsEqual (theOther); }


  Standard_Real Distance (const Quantity_Color& theColor) const
  {
    return (NCollection_Vec3<Standard_Real> (myRgb) - NCollection_Vec3<Standard_Real> (theColor.myRgb)).Modulus();
  }


  Standard_Real SquareDistance (const Quantity_Color& theColor) const
  {
    return (NCollection_Vec3<Standard_Real> (myRgb) - NCollection_Vec3<Standard_Real> (theColor.myRgb)).SquareModulus();
  }






  void Delta (const Quantity_Color& theColor,
                              Standard_Real& DC, Standard_Real& DI) const;






  Standard_Real DeltaE2000 (const Quantity_Color& theOther) const;

public:


  static Quantity_NameOfColor Name (const Standard_Real theR, const Standard_Real theG, const Standard_Real theB)
  {
    const Quantity_Color aColor (theR, theG, theB, Quantity_TOC_RGB);
    return aColor.Name();
  }


  static Standard_CString StringName (const Quantity_NameOfColor theColor);




  static Standard_Boolean ColorFromName (const Standard_CString theName, Quantity_NameOfColor& theColor);





  static Standard_Boolean ColorFromName (const Standard_CString theColorNameString, Quantity_Color& theColor)
  {
    Quantity_NameOfColor aColorName = Quantity_NOC_BLACK;
    if (!ColorFromName (theColorNameString, aColorName))
    {
      return false;
    }
    theColor = aColorName;
    return true;
  }

public:






  static bool ColorFromHex (const Standard_CString theHexColorString, Quantity_Color& theColor);


  static TCollection_AsciiString ColorToHex (const Quantity_Color& theColor,
                                             const bool theToPrefixHash = true)
  {
    NCollection_Vec3<Standard_ShortReal> anSRgb = Convert_LinearRGB_To_sRGB ((NCollection_Vec3<Standard_ShortReal> )theColor);
    NCollection_Vec3<Standard_Integer> anSRgbInt (anSRgb * 255.0f + NCollection_Vec3<Standard_ShortReal> (0.5f));
    char aBuff[10];
    Sprintf (aBuff, theToPrefixHash ? "#%02X%02X%02X" : "%02X%02X%02X",
             anSRgbInt.r(), anSRgbInt.g(), anSRgbInt.b());
    return aBuff;
  }


  static NCollection_Vec3<float> Convert_sRGB_To_HLS (const NCollection_Vec3<float>& theRgb);


  static NCollection_Vec3<float> Convert_HLS_To_sRGB (const NCollection_Vec3<float>& theHls);


  static NCollection_Vec3<float> Convert_LinearRGB_To_HLS (const NCollection_Vec3<float>& theRgb)
  {
    return Convert_sRGB_To_HLS (Convert_LinearRGB_To_sRGB (theRgb));
  }


  static NCollection_Vec3<float> Convert_HLS_To_LinearRGB (const NCollection_Vec3<float>& theHls)
  {
    return Convert_sRGB_To_LinearRGB (Convert_HLS_To_sRGB (theHls));
  }


  static NCollection_Vec3<float> Convert_LinearRGB_To_Lab (const NCollection_Vec3<float>& theRgb);


  static NCollection_Vec3<float> Convert_Lab_To_Lch (const NCollection_Vec3<float>& theLab);



  static NCollection_Vec3<float> Convert_Lab_To_LinearRGB (const NCollection_Vec3<float>& theLab);


  static NCollection_Vec3<float> Convert_Lch_To_Lab (const NCollection_Vec3<float>& theLch);







  static void Color2argb (const Quantity_Color& theColor,
                          Standard_Integer& theARGB)
  {
    const NCollection_Vec3<Standard_Integer> aColor (static_cast<Standard_Integer> (255.0f * theColor.myRgb.r() + 0.5f),
                                                     static_cast<Standard_Integer> (255.0f * theColor.myRgb.g() + 0.5f),
                                                     static_cast<Standard_Integer> (255.0f * theColor.myRgb.b() + 0.5f));
    theARGB = (((aColor.r() & 0xff) << 16)
             | ((aColor.g() & 0xff) << 8)
             | (aColor.b() & 0xff));
  }




  static void Argb2color (const Standard_Integer theARGB,
                          Quantity_Color& theColor)
  {
    const NCollection_Vec3<Standard_Real> aColor (static_cast <Standard_Real> ((theARGB & 0xff0000) >> 16),
                                                  static_cast <Standard_Real> ((theARGB & 0x00ff00) >> 8),
                                                  static_cast <Standard_Real> ((theARGB & 0x0000ff)));
    theColor.SetValues (aColor.r() / 255.0, aColor.g() / 255.0, aColor.b() / 255.0, Quantity_TOC_sRGB);
  }


  static Standard_Real Convert_LinearRGB_To_sRGB (Standard_Real theLinearValue)
  {
    return theLinearValue <= 0.0031308
         ? theLinearValue * 12.92
         : Pow (theLinearValue, 1.0/2.4) * 1.055 - 0.055;
  }


  static float Convert_LinearRGB_To_sRGB (float theLinearValue)
  {
    return theLinearValue <= 0.0031308f
         ? theLinearValue * 12.92f
         : powf (theLinearValue, 1.0f/2.4f) * 1.055f - 0.055f;
  }


  static Standard_Real Convert_sRGB_To_LinearRGB (Standard_Real thesRGBValue)
  {
    return thesRGBValue <= 0.04045
         ? thesRGBValue / 12.92
         : Pow ((thesRGBValue + 0.055) / 1.055, 2.4);
  }


  static float Convert_sRGB_To_LinearRGB (float thesRGBValue)
  {
    return thesRGBValue <= 0.04045f
         ? thesRGBValue / 12.92f
         : powf ((thesRGBValue + 0.055f) / 1.055f, 2.4f);
  }


  template<typename T>
  static NCollection_Vec3<T> Convert_LinearRGB_To_sRGB (const NCollection_Vec3<T>& theRGB)
  {
    return NCollection_Vec3<T> (Convert_LinearRGB_To_sRGB (theRGB.r()),
                                Convert_LinearRGB_To_sRGB (theRGB.g()),
                                Convert_LinearRGB_To_sRGB (theRGB.b()));
  }


  template<typename T>
  static NCollection_Vec3<T> Convert_sRGB_To_LinearRGB (const NCollection_Vec3<T>& theRGB)
  {
    return NCollection_Vec3<T> (Convert_sRGB_To_LinearRGB (theRGB.r()),
                                Convert_sRGB_To_LinearRGB (theRGB.g()),
                                Convert_sRGB_To_LinearRGB (theRGB.b()));
  }


  static float Convert_LinearRGB_To_sRGB_approx22 (float theLinearValue) { return powf (theLinearValue, 2.2f); }


  static float Convert_sRGB_To_LinearRGB_approx22 (float thesRGBValue) { return powf (thesRGBValue, 1.0f/2.2f); }


  static NCollection_Vec3<float> Convert_LinearRGB_To_sRGB_approx22 (const NCollection_Vec3<float>& theRGB)
  {
    return NCollection_Vec3<float> (Convert_LinearRGB_To_sRGB_approx22 (theRGB.r()),
                                    Convert_LinearRGB_To_sRGB_approx22 (theRGB.g()),
                                    Convert_LinearRGB_To_sRGB_approx22 (theRGB.b()));
  }


  static NCollection_Vec3<float> Convert_sRGB_To_LinearRGB_approx22 (const NCollection_Vec3<float>& theRGB)
  {
    return NCollection_Vec3<float> (Convert_sRGB_To_LinearRGB_approx22 (theRGB.r()),
                                    Convert_sRGB_To_LinearRGB_approx22 (theRGB.g()),
                                    Convert_sRGB_To_LinearRGB_approx22 (theRGB.b()));
  }


  static void HlsRgb (const Standard_Real theH, const Standard_Real theL, const Standard_Real theS,
                      Standard_Real& theR, Standard_Real& theG, Standard_Real& theB)
  {
    const NCollection_Vec3<float> anRgb = Convert_HLS_To_sRGB (NCollection_Vec3<float> ((float )theH, (float )theL, (float )theS));
    theR = anRgb[0];
    theG = anRgb[1];
    theB = anRgb[2];
  }


  static void RgbHls (const Standard_Real theR, const Standard_Real theG, const Standard_Real theB,
                      Standard_Real& theH, Standard_Real& theL, Standard_Real& theS)
  {
    const NCollection_Vec3<float> aHls = Convert_sRGB_To_HLS (NCollection_Vec3<float> ((float )theR, (float )theG, (float )theB));
    theH = aHls[0];
    theL = aHls[1];
    theS = aHls[2];
  }

public:


  static Standard_Real Epsilon();


  static void SetEpsilon (const Standard_Real theEpsilon);


  void DumpJson (Standard_OStream& theOStream, Standard_Integer theDepth = -1) const;


  Standard_Boolean InitFromJson (const Standard_SStream& theSStream, Standard_Integer& theStreamPos);

private:


  static NCollection_Vec3<float> valuesOf (const Quantity_NameOfColor theName,
                                                           const Quantity_TypeOfColor theType);

private:

  NCollection_Vec3<float> myRgb;

};
# 18 "/usr/include/opencascade/Quantity_ColorRGBA.hxx" 2
# 1 "/usr/include/opencascade/Standard_Assert.hxx" 1
# 19 "/usr/include/opencascade/Quantity_ColorRGBA.hxx" 2


class Quantity_ColorRGBA
{
public:


  Quantity_ColorRGBA() : myAlpha (1.0f) {}


  explicit Quantity_ColorRGBA (const Quantity_Color& theRgb)
  : myRgb (theRgb), myAlpha (1.0f)
  {}


  Quantity_ColorRGBA (const Quantity_Color& theRgb, float theAlpha)
  : myRgb (theRgb), myAlpha (theAlpha)
  {}


  explicit Quantity_ColorRGBA (const NCollection_Vec4<float>& theRgba)
  : myRgb (theRgba.rgb()), myAlpha (theRgba.a())
  {}


  Quantity_ColorRGBA (float theRed, float theGreen, float theBlue, float theAlpha)
  : myRgb (theRed, theGreen, theBlue, Quantity_TOC_RGB),
    myAlpha (theAlpha)
  {}


  void SetValues (float theRed, float theGreen, float theBlue, float theAlpha)
  {
    myRgb.SetValues (theRed, theGreen, theBlue, Quantity_TOC_RGB);
    myAlpha = theAlpha;
  }


  const Quantity_Color& GetRGB() const { return myRgb; }


  Quantity_Color& ChangeRGB() { return myRgb; }


  void SetRGB (const Quantity_Color& theRgb) { myRgb = theRgb; }


  Standard_ShortReal Alpha() const { return myAlpha; }


  void SetAlpha (const Standard_ShortReal theAlpha) { myAlpha = theAlpha; }


  operator const NCollection_Vec4<float>&() const { return *(const NCollection_Vec4<float>* )this; }


  bool IsDifferent (const Quantity_ColorRGBA& theOther) const
  {
    return myRgb.IsDifferent (theOther.GetRGB())
        || Abs(myAlpha - theOther.myAlpha) > (float )Quantity_Color::Epsilon();
  }


  bool operator!= (const Quantity_ColorRGBA& theOther) const { return IsDifferent (theOther); }


  bool IsEqual (const Quantity_ColorRGBA& theOther) const
  {
    return myRgb.IsEqual (theOther.GetRGB())
        && Abs(myAlpha - theOther.myAlpha) <= (float )Quantity_Color::Epsilon();
  }


  bool operator== (const Quantity_ColorRGBA& theOther) const { return IsEqual (theOther); }

public:







  static Standard_Boolean ColorFromName (const Standard_CString theColorNameString, Quantity_ColorRGBA& theColor)
  {
    Quantity_ColorRGBA aColor;
    if (!Quantity_Color::ColorFromName (theColorNameString, aColor.ChangeRGB()))
    {
      return false;
    }
    theColor = aColor;
    return true;
  }
# 120 "/usr/include/opencascade/Quantity_ColorRGBA.hxx"
  static bool ColorFromHex (const char* const theHexColorString,
                                            Quantity_ColorRGBA& theColor,
                                            const bool theAlphaComponentIsOff = false);


  static TCollection_AsciiString ColorToHex (const Quantity_ColorRGBA& theColor,
                                             const bool theToPrefixHash = true)
  {
    NCollection_Vec4<Standard_ShortReal> anSRgb = Convert_LinearRGB_To_sRGB ((NCollection_Vec4<Standard_ShortReal> )theColor);
    NCollection_Vec4<Standard_Integer> anSRgbInt (anSRgb * 255.0f + NCollection_Vec4<Standard_ShortReal> (0.5f));
    char aBuff[12];
    Sprintf (aBuff, theToPrefixHash ? "#%02X%02X%02X%02X" : "%02X%02X%02X%02X",
             anSRgbInt.r(), anSRgbInt.g(), anSRgbInt.b(), anSRgbInt.a());
    return aBuff;
  }

public:


  static NCollection_Vec4<float> Convert_LinearRGB_To_sRGB (const NCollection_Vec4<float>& theRGB)
  {
    return NCollection_Vec4<float> (Quantity_Color::Convert_LinearRGB_To_sRGB (theRGB.r()),
                                    Quantity_Color::Convert_LinearRGB_To_sRGB (theRGB.g()),
                                    Quantity_Color::Convert_LinearRGB_To_sRGB (theRGB.b()),
                                    theRGB.a());
  }


  static NCollection_Vec4<float> Convert_sRGB_To_LinearRGB (const NCollection_Vec4<float>& theRGB)
  {
    return NCollection_Vec4<float> (Quantity_Color::Convert_sRGB_To_LinearRGB (theRGB.r()),
                                    Quantity_Color::Convert_sRGB_To_LinearRGB (theRGB.g()),
                                    Quantity_Color::Convert_sRGB_To_LinearRGB (theRGB.b()),
                                    theRGB.a());
  }

public:


  void DumpJson (Standard_OStream& theOStream, Standard_Integer theDepth = -1) const;


  Standard_Boolean InitFromJson (const Standard_SStream& theSStream, Standard_Integer& theStreamPos);

private:

  static void myTestSize3() { Standard_Static_Assert<sizeof(float) * 3 == sizeof(Quantity_Color)>::assert_ok();; }
  static void myTestSize4() { Standard_Static_Assert<sizeof(float) * 4 == sizeof(Quantity_ColorRGBA)>::assert_ok();; }

private:

  Quantity_Color myRgb;
  Standard_ShortReal myAlpha;

};
# 23 "/usr/include/opencascade/Image_PixMap.hxx" 2


class Image_PixMap : public Standard_Transient
{
  public: typedef Standard_Transient base_type; static const char* get_type_name () { return "Image_PixMap"; using direct_base_classes = opencascade::direct_base_class_as_tuple<std::tr2::direct_bases<Image_PixMap>::type>::type; static_assert(opencascade::has_type<Standard_Transient, direct_base_classes>::type::value, "OCCT RTTI definition is incorrect: " "Standard_Transient" " is not direct base class of " "Image_PixMap"); static_assert(&get_type_name == &Image_PixMap::get_type_name, "OCCT RTTI definition is misplaced: current class is not " "Image_PixMap"); } static const opencascade::handle<Standard_Type>& get_type_descriptor (); virtual const opencascade::handle<Standard_Type>& DynamicType() const override;
public:


  static inline bool IsBigEndianHost()
  {
    union { int myInt; char myChar[sizeof(int)]; } aUnion;
    aUnion.myInt = 1;
    return !aUnion.myChar[0];
  }
# 46 "/usr/include/opencascade/Image_PixMap.hxx"
  static bool SwapRgbaBgra (Image_PixMap& theImage);


  static void ToBlackWhite (Image_PixMap& theImage);


  static const opencascade::handle<NCollection_BaseAllocator>& DefaultAllocator();

public:

  Image_Format Format() const { return myImgFormat; }





  void SetFormat (const Image_Format thePixelFormat);


  inline Standard_Size Width() const
  {
    return myData.SizeX;
  }


  inline Standard_Size Height() const
  {
    return myData.SizeY;
  }


  inline Standard_Size SizeX() const
  {
    return myData.SizeX;
  }


  inline Standard_Size SizeY() const
  {
    return myData.SizeY;
  }


  inline Standard_Real Ratio() const
  {
    return (SizeY() > 0) ? (Standard_Real(SizeX()) / Standard_Real(SizeY())) : 1.0;
  }


  bool IsEmpty() const
  {
    return myData.IsEmpty();
  }


  Image_PixMap();


  virtual ~Image_PixMap();







  Quantity_ColorRGBA PixelColor (const Standard_Integer theX,
                                                 const Standard_Integer theY,
                                                 const Standard_Boolean theToLinearize = false) const;







  void SetPixelColor (const Standard_Integer theX,
                      const Standard_Integer theY,
                      const Quantity_Color& theColor,
                      const Standard_Boolean theToDeLinearize = false)
  {
    SetPixelColor (theX, theY, Quantity_ColorRGBA (theColor, 1.0f), theToDeLinearize);
  }







  void SetPixelColor (const Standard_Integer theX,
                                      const Standard_Integer theY,
                                      const Quantity_ColorRGBA& theColor,
                                      const Standard_Boolean theToDeLinearize = false);





  virtual bool InitWrapper (Image_Format thePixelFormat,
                                            Standard_Byte* theDataPtr,
                                            const Standard_Size theSizeX,
                                            const Standard_Size theSizeY,
                                            const Standard_Size theSizeRowBytes = 0);



  virtual bool InitTrash (Image_Format thePixelFormat,
                                          const Standard_Size theSizeX,
                                          const Standard_Size theSizeY,
                                          const Standard_Size theSizeRowBytes = 0);



  virtual bool InitCopy (const Image_PixMap& theCopy);



  bool InitZero (Image_Format thePixelFormat,
                                 const Standard_Size theSizeX,
                                 const Standard_Size theSizeY,
                                 const Standard_Size theSizeRowBytes = 0,
                                 const Standard_Byte theValue = 0);


  virtual void Clear();

public:
# 184 "/usr/include/opencascade/Image_PixMap.hxx"
  inline bool IsTopDown() const
  {
    return myData.TopToDown == 1;
  }




  inline void SetTopDown (const bool theIsTopDown)
  {
    myData.SetTopDown (theIsTopDown);
  }



  inline Standard_Size TopDownInc() const
  {
    return myData.TopToDown;
  }


  inline const Standard_Byte* Data() const
  {
    return myData.Data();
  }


  inline Standard_Byte* ChangeData()
  {
    return myData.ChangeData();
  }


  inline const Standard_Byte* Row (const Standard_Size theRow) const
  {
    return myData.Row (theRow);
  }


  inline Standard_Byte* ChangeRow (const Standard_Size theRow)
  {
    return myData.ChangeRow (theRow);
  }


  inline Standard_Size SizePixelBytes() const
  {
    return myData.SizeBPP;
  }


  static Standard_Size SizePixelBytes (const Image_Format thePixelFormat);



  inline Standard_Size SizeRowBytes() const
  {
    return myData.SizeRowBytes;
  }


  inline Standard_Size RowExtraBytes() const
  {
    return SizeRowBytes() - SizeX() * SizePixelBytes();
  }



  inline Standard_Size MaxRowAligmentBytes() const
  {
    return myData.MaxRowAligmentBytes();
  }


  inline Standard_Size SizeBytes() const
  {
    return myData.Size();
  }



  template <typename ColorType_t>
  inline const ColorType_t& Value (const Standard_Size theRow,
                                   const Standard_Size theCol) const
  {
    return *reinterpret_cast<const ColorType_t*>(myData.Value (theRow, theCol));
  }



  template <typename ColorType_t>
  inline ColorType_t& ChangeValue (const Standard_Size theRow,
                                   const Standard_Size theCol)
  {
    return *reinterpret_cast<ColorType_t* >(myData.ChangeValue (theRow, theCol));
  }



  const Standard_Byte* RawValue (Standard_Size theRow,
                                 Standard_Size theCol) const
  {
    return myData.Value (theRow, theCol);
  }



  Standard_Byte* ChangeRawValue (Standard_Size theRow,
                                 Standard_Size theCol)
  {
    return myData.ChangeValue (theRow, theCol);
  }

public:

  __attribute__((deprecated("This member is deprecated, use Image_Format enumeration instead")))
  typedef Image_Format ImgFormat;
  static const Image_Format ImgUNKNOWN = Image_Format_UNKNOWN;
  static const Image_Format ImgGray = Image_Format_Gray;
  static const Image_Format ImgAlpha = Image_Format_Alpha;
  static const Image_Format ImgRGB = Image_Format_RGB;
  static const Image_Format ImgBGR = Image_Format_BGR;
  static const Image_Format ImgRGB32 = Image_Format_RGB32;
  static const Image_Format ImgBGR32 = Image_Format_BGR32;
  static const Image_Format ImgRGBA = Image_Format_RGBA;
  static const Image_Format ImgBGRA = Image_Format_BGRA;
  static const Image_Format ImgGrayF = Image_Format_GrayF;
  static const Image_Format ImgAlphaF = Image_Format_AlphaF;
  static const Image_Format ImgRGBF = Image_Format_RGBF;
  static const Image_Format ImgBGRF = Image_Format_BGRF;
  static const Image_Format ImgRGBAF = Image_Format_RGBAF;
  static const Image_Format ImgBGRAF = Image_Format_BGRAF;

protected:

  Image_PixMapData myData;
  Image_Format myImgFormat;

private:


  Image_PixMap (const Image_PixMap& );
  Image_PixMap& operator= (const Image_PixMap& );

};

class Image_PixMap; typedef opencascade::handle<Image_PixMap> Handle_Image_PixMap;
# 21 "/usr/include/opencascade/Graphic3d_HatchStyle.hxx" 2





class Graphic3d_HatchStyle : public Standard_Transient
{
  public: typedef Standard_Transient base_type; static const char* get_type_name () { return "Graphic3d_HatchStyle"; using direct_base_classes = opencascade::direct_base_class_as_tuple<std::tr2::direct_bases<Graphic3d_HatchStyle>::type>::type; static_assert(opencascade::has_type<Standard_Transient, direct_base_classes>::type::value, "OCCT RTTI definition is incorrect: " "Standard_Transient" " is not direct base class of " "Graphic3d_HatchStyle"); static_assert(&get_type_name == &Graphic3d_HatchStyle::get_type_name, "OCCT RTTI definition is misplaced: current class is not " "Graphic3d_HatchStyle"); } static const opencascade::handle<Standard_Type>& get_type_descriptor (); virtual const opencascade::handle<Standard_Type>& DynamicType() const override;

public:



  Graphic3d_HatchStyle (const opencascade::handle<Image_PixMap>& thePattern);



  Graphic3d_HatchStyle (const Aspect_HatchStyle theType)
  : myHatchType (theType) {}


  const Standard_Byte* Pattern() const;




  Standard_Integer HatchType() const
  {
    return myHatchType;
  }


  void DumpJson (Standard_OStream& theOStream, Standard_Integer theDepth = -1) const;

private:

  opencascade::handle<NCollection_Buffer> myPattern;
  Standard_Integer myHatchType;
};

class Graphic3d_HatchStyle; typedef opencascade::handle<Graphic3d_HatchStyle> Handle_Graphic3d_HatchStyle;
# 28 "/usr/include/opencascade/Graphic3d_Aspects.hxx" 2
# 1 "/usr/include/opencascade/Graphic3d_MaterialAspect.hxx" 1
# 19 "/usr/include/opencascade/Graphic3d_MaterialAspect.hxx"
# 1 "/usr/include/opencascade/Graphic3d_BSDF.hxx" 1
# 19 "/usr/include/opencascade/Graphic3d_BSDF.hxx"
# 1 "/usr/include/opencascade/Graphic3d_Vec3.hxx" 1
# 20 "/usr/include/opencascade/Graphic3d_Vec3.hxx"
typedef NCollection_Vec3<Standard_ShortReal> Graphic3d_Vec3;
typedef NCollection_Vec3<Standard_Real> Graphic3d_Vec3d;
typedef NCollection_Vec3<Standard_Integer> Graphic3d_Vec3i;
typedef NCollection_Vec3<unsigned int> Graphic3d_Vec3u;
typedef NCollection_Vec3<Standard_Byte> Graphic3d_Vec3ub;
typedef NCollection_Vec3<Standard_Character> Graphic3d_Vec3b;
# 20 "/usr/include/opencascade/Graphic3d_BSDF.hxx" 2
# 1 "/usr/include/opencascade/Graphic3d_Vec4.hxx" 1
# 20 "/usr/include/opencascade/Graphic3d_Vec4.hxx"
typedef NCollection_Vec4<Standard_ShortReal> Graphic3d_Vec4;
typedef NCollection_Vec4<Standard_Real> Graphic3d_Vec4d;
typedef NCollection_Vec4<Standard_Integer> Graphic3d_Vec4i;
typedef NCollection_Vec4<unsigned int> Graphic3d_Vec4u;
typedef NCollection_Vec4<Standard_Byte> Graphic3d_Vec4ub;
typedef NCollection_Vec4<Standard_Character> Graphic3d_Vec4b;
# 21 "/usr/include/opencascade/Graphic3d_BSDF.hxx" 2

class Graphic3d_PBRMaterial;


enum Graphic3d_FresnelModel
{
  Graphic3d_FM_SCHLICK = 0,
  Graphic3d_FM_CONSTANT = 1,
  Graphic3d_FM_CONDUCTOR = 2,
  Graphic3d_FM_DIELECTRIC = 3
};


class Graphic3d_Fresnel
{
public:


  Graphic3d_Fresnel() : myFresnelType (Graphic3d_FM_CONSTANT)
  {

    myFresnelData = Graphic3d_Vec3 (0.f, 1.f, 0.f);
  }


  static Graphic3d_Fresnel CreateSchlick (const Graphic3d_Vec3& theSpecularColor)
  {
    return Graphic3d_Fresnel (Graphic3d_FM_SCHLICK, theSpecularColor);
  }


  static Graphic3d_Fresnel CreateConstant (const Standard_ShortReal theReflection)
  {
    return Graphic3d_Fresnel (Graphic3d_FM_CONSTANT, Graphic3d_Vec3 (0.f, 1.f, theReflection));
  }


  static Graphic3d_Fresnel CreateDielectric (Standard_ShortReal theRefractionIndex)
  {
    return Graphic3d_Fresnel (Graphic3d_FM_DIELECTRIC, Graphic3d_Vec3 (0.f, theRefractionIndex, 0.f));
  }


  static Graphic3d_Fresnel CreateConductor (Standard_ShortReal theRefractionIndex,
                                            Standard_ShortReal theAbsorptionIndex)
  {
    return Graphic3d_Fresnel (Graphic3d_FM_CONDUCTOR, Graphic3d_Vec3 (0.f, theRefractionIndex, theAbsorptionIndex));
  }


  static Graphic3d_Fresnel CreateConductor (const Graphic3d_Vec3& theRefractionIndex,
                                                            const Graphic3d_Vec3& theAbsorptionIndex);

public:


  Graphic3d_Vec4 Serialize() const;


  bool operator== (const Graphic3d_Fresnel& theOther) const
  {
    return myFresnelType == theOther.myFresnelType
        && myFresnelData == theOther.myFresnelData;
  }


  Graphic3d_FresnelModel FresnelType() const
  {
    return myFresnelType;
  }


  void DumpJson (Standard_OStream& theOStream, Standard_Integer theDepth = -1) const;

protected:


  Graphic3d_Fresnel (Graphic3d_FresnelModel theType, const Graphic3d_Vec3& theData)
  : myFresnelType (theType),
    myFresnelData (theData)
  {

  }

private:


  Graphic3d_FresnelModel myFresnelType;


  Graphic3d_Vec3 myFresnelData;
};
# 124 "/usr/include/opencascade/Graphic3d_BSDF.hxx"
class Graphic3d_BSDF
{
public:


  Graphic3d_Vec4 Kc;


  Graphic3d_Vec3 Kd;


  Graphic3d_Vec4 Ks;


  Graphic3d_Vec3 Kt;


  Graphic3d_Vec3 Le;


  Graphic3d_Vec4 Absorption;


  Graphic3d_Fresnel FresnelCoat;


  Graphic3d_Fresnel FresnelBase;

public:


  static Graphic3d_BSDF CreateDiffuse (const Graphic3d_Vec3& theWeight);


  static Graphic3d_BSDF CreateMetallic (const Graphic3d_Vec3& theWeight,
                                                        const Graphic3d_Fresnel& theFresnel,
                                                        const Standard_ShortReal theRoughness);




  static Graphic3d_BSDF CreateTransparent (const Graphic3d_Vec3& theWeight,
                                                           const Graphic3d_Vec3& theAbsorptionColor,
                                                           const Standard_ShortReal theAbsorptionCoeff);




  static Graphic3d_BSDF CreateGlass (const Graphic3d_Vec3& theWeight,
                                                     const Graphic3d_Vec3& theAbsorptionColor,
                                                     const Standard_ShortReal theAbsorptionCoeff,
                                                     const Standard_ShortReal theRefractionIndex);


  static Graphic3d_BSDF CreateMetallicRoughness (const Graphic3d_PBRMaterial& thePbr);

public:


  Graphic3d_BSDF();


  void Normalize();


  bool operator== (const Graphic3d_BSDF& theOther) const;


  void DumpJson (Standard_OStream& theOStream, Standard_Integer theDepth = -1) const;

};
# 20 "/usr/include/opencascade/Graphic3d_MaterialAspect.hxx" 2
# 1 "/usr/include/opencascade/Graphic3d_PBRMaterial.hxx" 1
# 20 "/usr/include/opencascade/Graphic3d_PBRMaterial.hxx"
# 1 "/usr/include/opencascade/Graphic3d_Vec2.hxx" 1
# 20 "/usr/include/opencascade/Graphic3d_Vec2.hxx"
typedef NCollection_Vec2<Standard_ShortReal> Graphic3d_Vec2;
typedef NCollection_Vec2<Standard_Real> Graphic3d_Vec2d;
typedef NCollection_Vec2<Standard_Integer> Graphic3d_Vec2i;
typedef NCollection_Vec2<unsigned int> Graphic3d_Vec2u;
typedef NCollection_Vec2<Standard_Byte> Graphic3d_Vec2ub;
typedef NCollection_Vec2<Standard_Character> Graphic3d_Vec2b;
# 21 "/usr/include/opencascade/Graphic3d_PBRMaterial.hxx" 2





class Graphic3d_PBRMaterial
{
public:
# 37 "/usr/include/opencascade/Graphic3d_PBRMaterial.hxx"
  Graphic3d_PBRMaterial();


  Graphic3d_PBRMaterial (const Graphic3d_BSDF& theBSDF);




  Standard_ShortReal Metallic() const { return myMetallic; }


  void SetMetallic (Standard_ShortReal theMetallic);


  static Standard_ShortReal Roughness(Standard_ShortReal theNormalizedRoughness);


  Standard_ShortReal Roughness() const { return Roughness(myRoughness); }




  Standard_ShortReal NormalizedRoughness() const { return myRoughness; }


  void SetRoughness (Standard_ShortReal theRoughness);


  Standard_ShortReal IOR() const { return myIOR; }



  void SetIOR (Standard_ShortReal theIOR);


  const Quantity_ColorRGBA& Color() const { return myColor; }


  void SetColor (const Quantity_ColorRGBA& theColor);


  void SetColor (const Quantity_Color& theColor);


  Standard_ShortReal Alpha() const { return myColor.Alpha(); };


  void SetAlpha (Standard_ShortReal theAlpha);



  Graphic3d_Vec3 Emission() const { return myEmission; }


  void SetEmission (const Graphic3d_Vec3& theEmission);


  void SetBSDF (const Graphic3d_BSDF& theBSDF);

public:


  Standard_Boolean operator== (const Graphic3d_PBRMaterial& theOther) const
  {
    return (myMetallic == theOther.myMetallic)
        && (myRoughness == theOther.myRoughness)
        && (myIOR == theOther.myIOR)
        && (myColor == theOther.myColor)
        && (myEmission == theOther.myEmission);
  }

public:





  static void GenerateEnvLUT (const opencascade::handle<Image_PixMap>& theLUT,
                                              unsigned int theNbIntegralSamples = 1024);





  static Standard_ShortReal RoughnessFromSpecular (const Quantity_Color& theSpecular,
                                                                   const Standard_Real theShiness);




  static Standard_ShortReal MetallicFromSpecular (const Quantity_Color& theSpecular)
  {
    return ((Graphic3d_Vec3 )theSpecular).maxComp();
  }

public:


  static Standard_ShortReal MinRoughness() { return 0.01f; }

public:
# 152 "/usr/include/opencascade/Graphic3d_PBRMaterial.hxx"
  static Standard_ShortReal SpecIBLMapSamplesFactor (Standard_ShortReal theProbability,
                                                                     Standard_ShortReal theRoughness);


  void DumpJson (Standard_OStream& theOStream, Standard_Integer theDepth = -1) const;

private:


  static Standard_ShortReal lutGenGeometryFactor (Standard_ShortReal theCosL,
                                                  Standard_ShortReal theCosV,
                                                  Standard_ShortReal theRoughness);




  static Graphic3d_Vec2 lutGenHammersley (unsigned int theNumber, unsigned int theCount);



  static Standard_ShortReal lutGenImportanceSampleCosTheta (Standard_ShortReal theHammerslayPointComponent,
                                                            Standard_ShortReal theRoughness);



  static Graphic3d_Vec3 lutGenImportanceSample (const Graphic3d_Vec2 &theHammerslayPoint,
                                                Standard_ShortReal theRoughness);




  static Graphic3d_Vec3 lutGenView (Standard_ShortReal theCosV);




  static Graphic3d_Vec3 lutGenReflect (const Graphic3d_Vec3 &theVector,
                                       const Graphic3d_Vec3 &theAxis);

private:

  Quantity_ColorRGBA myColor;
  Standard_ShortReal myMetallic;
  Standard_ShortReal myRoughness;
  Graphic3d_Vec3 myEmission;
  Standard_ShortReal myIOR;

};
# 21 "/usr/include/opencascade/Graphic3d_MaterialAspect.hxx" 2
# 1 "/usr/include/opencascade/Graphic3d_NameOfMaterial.hxx" 1
# 22 "/usr/include/opencascade/Graphic3d_NameOfMaterial.hxx"
enum Graphic3d_NameOfMaterial
{
  Graphic3d_NameOfMaterial_Brass,
  Graphic3d_NameOfMaterial_Bronze,
  Graphic3d_NameOfMaterial_Copper,
  Graphic3d_NameOfMaterial_Gold,
  Graphic3d_NameOfMaterial_Pewter,
  Graphic3d_NameOfMaterial_Plastered,
  Graphic3d_NameOfMaterial_Plastified,
  Graphic3d_NameOfMaterial_Silver,
  Graphic3d_NameOfMaterial_Steel,
  Graphic3d_NameOfMaterial_Stone,
  Graphic3d_NameOfMaterial_ShinyPlastified,
  Graphic3d_NameOfMaterial_Satin,
  Graphic3d_NameOfMaterial_Metalized,
  Graphic3d_NameOfMaterial_Ionized,
  Graphic3d_NameOfMaterial_Chrome,
  Graphic3d_NameOfMaterial_Aluminum,
  Graphic3d_NameOfMaterial_Obsidian,
  Graphic3d_NameOfMaterial_Neon,
  Graphic3d_NameOfMaterial_Jade,
  Graphic3d_NameOfMaterial_Charcoal,
  Graphic3d_NameOfMaterial_Water,
  Graphic3d_NameOfMaterial_Glass,
  Graphic3d_NameOfMaterial_Diamond,
  Graphic3d_NameOfMaterial_Transparent,
  Graphic3d_NameOfMaterial_DEFAULT,

  Graphic3d_NameOfMaterial_UserDefined,



  Graphic3d_NOM_BRASS = Graphic3d_NameOfMaterial_Brass,
  Graphic3d_NOM_BRONZE = Graphic3d_NameOfMaterial_Bronze,
  Graphic3d_NOM_COPPER = Graphic3d_NameOfMaterial_Copper,
  Graphic3d_NOM_GOLD = Graphic3d_NameOfMaterial_Gold,
  Graphic3d_NOM_PEWTER = Graphic3d_NameOfMaterial_Pewter,
  Graphic3d_NOM_PLASTER = Graphic3d_NameOfMaterial_Plastered,
  Graphic3d_NOM_PLASTIC = Graphic3d_NameOfMaterial_Plastified,
  Graphic3d_NOM_SILVER = Graphic3d_NameOfMaterial_Silver,
  Graphic3d_NOM_STEEL = Graphic3d_NameOfMaterial_Steel,
  Graphic3d_NOM_STONE = Graphic3d_NameOfMaterial_Stone,
  Graphic3d_NOM_SHINY_PLASTIC = Graphic3d_NameOfMaterial_ShinyPlastified,
  Graphic3d_NOM_SATIN = Graphic3d_NameOfMaterial_Satin,
  Graphic3d_NOM_METALIZED = Graphic3d_NameOfMaterial_Metalized,
  Graphic3d_NOM_NEON_GNC = Graphic3d_NameOfMaterial_Ionized,
  Graphic3d_NOM_CHROME = Graphic3d_NameOfMaterial_Chrome,
  Graphic3d_NOM_ALUMINIUM = Graphic3d_NameOfMaterial_Aluminum,
  Graphic3d_NOM_OBSIDIAN = Graphic3d_NameOfMaterial_Obsidian,
  Graphic3d_NOM_NEON_PHC = Graphic3d_NameOfMaterial_Neon,
  Graphic3d_NOM_JADE = Graphic3d_NameOfMaterial_Jade,
  Graphic3d_NOM_CHARCOAL = Graphic3d_NameOfMaterial_Charcoal,
  Graphic3d_NOM_WATER = Graphic3d_NameOfMaterial_Water,
  Graphic3d_NOM_GLASS = Graphic3d_NameOfMaterial_Glass,
  Graphic3d_NOM_DIAMOND = Graphic3d_NameOfMaterial_Diamond,
  Graphic3d_NOM_TRANSPARENT = Graphic3d_NameOfMaterial_Transparent,
  Graphic3d_NOM_DEFAULT = Graphic3d_NameOfMaterial_DEFAULT,
  Graphic3d_NOM_UserDefined = Graphic3d_NameOfMaterial_UserDefined
};
# 22 "/usr/include/opencascade/Graphic3d_MaterialAspect.hxx" 2
# 1 "/usr/include/opencascade/Graphic3d_TypeOfMaterial.hxx" 1
# 21 "/usr/include/opencascade/Graphic3d_TypeOfMaterial.hxx"
enum Graphic3d_TypeOfMaterial
{
  Graphic3d_MATERIAL_ASPECT,
  Graphic3d_MATERIAL_PHYSIC
};
# 23 "/usr/include/opencascade/Graphic3d_MaterialAspect.hxx" 2
# 1 "/usr/include/opencascade/Graphic3d_TypeOfReflection.hxx" 1
# 21 "/usr/include/opencascade/Graphic3d_TypeOfReflection.hxx"
enum Graphic3d_TypeOfReflection
{
  Graphic3d_TOR_AMBIENT = 0,
  Graphic3d_TOR_DIFFUSE,
  Graphic3d_TOR_SPECULAR,
  Graphic3d_TOR_EMISSION
};

enum
{
  Graphic3d_TypeOfReflection_NB = 4
};
# 24 "/usr/include/opencascade/Graphic3d_MaterialAspect.hxx" 2
# 32 "/usr/include/opencascade/Graphic3d_MaterialAspect.hxx"
class Graphic3d_MaterialAspect
{
public:
  void* operator new (size_t theSize) { return Standard::Allocate (theSize); } void operator delete (void* theAddress) { Standard::Free (theAddress); } void* operator new[] (size_t theSize) { return Standard::Allocate (theSize); } void operator delete[] (void* theAddress) { Standard::Free (theAddress); } void* operator new (size_t, void* theAddress) { return theAddress; } void operator delete (void*, void*) { }


  static Standard_Integer NumberOfMaterials() { return Graphic3d_NameOfMaterial_DEFAULT; }


  static Standard_CString MaterialName (const Standard_Integer theRank);


  static Graphic3d_TypeOfMaterial MaterialType (const Standard_Integer theRank);





  static Standard_Boolean MaterialFromName (const Standard_CString theName,
                                                            Graphic3d_NameOfMaterial& theMat);


  static Graphic3d_NameOfMaterial MaterialFromName (const Standard_CString theName)
  {
    Graphic3d_NameOfMaterial aMat = Graphic3d_NameOfMaterial_DEFAULT;
    MaterialFromName (theName, aMat);
    return aMat;
  }

public:


  Graphic3d_MaterialAspect();


  Graphic3d_MaterialAspect (const Graphic3d_NameOfMaterial theName);


  Graphic3d_NameOfMaterial Name() const { return myMaterialName; }


  Graphic3d_NameOfMaterial RequestedName() const { return myRequestedMaterialName; }





  const TCollection_AsciiString& StringName() const { return myStringName; }


  Standard_CString MaterialName() const { return myStringName.ToCString(); }



  void SetMaterialName (const TCollection_AsciiString& theName)
  {


    myMaterialName = Graphic3d_NameOfMaterial_UserDefined;
    myStringName = theName;
  }




  void Reset()
  {
    init (myRequestedMaterialName);
  }



  const Quantity_Color& Color() const { return myColors[Graphic3d_TOR_DIFFUSE]; }



  void SetColor (const Quantity_Color& theColor);


  Standard_ShortReal Transparency() const { return myTransparencyCoef; }


  Standard_ShortReal Alpha() const { return 1.0f - myTransparencyCoef; }






  void SetTransparency (const Standard_ShortReal theValue);


  void SetAlpha (Standard_ShortReal theValue) { SetTransparency (1.0f - theValue); }


  const Quantity_Color& AmbientColor() const { return myColors[Graphic3d_TOR_AMBIENT]; }


  void SetAmbientColor (const Quantity_Color& theColor);


  const Quantity_Color& DiffuseColor() const { return myColors[Graphic3d_TOR_DIFFUSE]; }


  void SetDiffuseColor (const Quantity_Color& theColor);


  const Quantity_Color& SpecularColor() const { return myColors[Graphic3d_TOR_SPECULAR]; }


  void SetSpecularColor (const Quantity_Color& theColor);


  const Quantity_Color& EmissiveColor() const { return myColors[Graphic3d_TOR_EMISSION]; }


  void SetEmissiveColor (const Quantity_Color& theColor);


  Standard_ShortReal Shininess() const { return myShininess; }



  void SetShininess (const Standard_ShortReal theValue);



  void IncreaseShine (const Standard_ShortReal theDelta);


  Standard_ShortReal RefractionIndex() const { return myRefractionIndex; }



  void SetRefractionIndex (const Standard_ShortReal theValue);


  const Graphic3d_BSDF& BSDF() const { return myBSDF; }


  void SetBSDF (const Graphic3d_BSDF& theBSDF) { myBSDF = theBSDF; }


  const Graphic3d_PBRMaterial& PBRMaterial () const { return myPBRMaterial; }


  void SetPBRMaterial (const Graphic3d_PBRMaterial& thePBRMaterial) { myPBRMaterial = thePBRMaterial; }


  Standard_Boolean ReflectionMode (const Graphic3d_TypeOfReflection theType) const
  {
    return !myColors[theType].IsEqual (Quantity_NOC_BLACK);
  }


  Graphic3d_TypeOfMaterial MaterialType() const { return myMaterialType; }


  Standard_Boolean MaterialType (const Graphic3d_TypeOfMaterial theType) const { return myMaterialType == theType; }


  void SetMaterialType (const Graphic3d_TypeOfMaterial theType);


  Standard_Boolean IsDifferent (const Graphic3d_MaterialAspect& theOther) const { return !IsEqual (theOther); }


  Standard_Boolean operator!= (const Graphic3d_MaterialAspect& theOther) const { return IsDifferent (theOther); }


  Standard_Boolean IsEqual (const Graphic3d_MaterialAspect& theOther) const
  {
    return myTransparencyCoef == theOther.myTransparencyCoef
        && myRefractionIndex == theOther.myRefractionIndex
        && myBSDF == theOther.myBSDF
        && myPBRMaterial == theOther.myPBRMaterial
        && myShininess == theOther.myShininess
        && myColors[Graphic3d_TOR_AMBIENT] == theOther.myColors[Graphic3d_TOR_AMBIENT]
        && myColors[Graphic3d_TOR_DIFFUSE] == theOther.myColors[Graphic3d_TOR_DIFFUSE]
        && myColors[Graphic3d_TOR_SPECULAR] == theOther.myColors[Graphic3d_TOR_SPECULAR]
        && myColors[Graphic3d_TOR_EMISSION] == theOther.myColors[Graphic3d_TOR_EMISSION];
  }


  Standard_Boolean operator== (const Graphic3d_MaterialAspect& theOther) const { return IsEqual (theOther); }


  void DumpJson (Standard_OStream& theOStream, Standard_Integer theDepth = -1) const;

public:


  __attribute__((deprecated("Deprecated method, specific material component should be zerroed instead")))
  void SetReflectionModeOff (const Graphic3d_TypeOfReflection theType)
  {
    if (!ReflectionMode (theType))
    {
      return;
    }

    switch (theType)
    {
      case Graphic3d_TOR_AMBIENT: SetAmbientColor (Quantity_NOC_BLACK); break;
      case Graphic3d_TOR_DIFFUSE: SetDiffuseColor (Quantity_NOC_BLACK); break;
      case Graphic3d_TOR_SPECULAR: SetSpecularColor(Quantity_NOC_BLACK); break;
      case Graphic3d_TOR_EMISSION: SetEmissiveColor(Quantity_NOC_BLACK); break;
    }
  }

private:


  void init (const Graphic3d_NameOfMaterial theName);


  void setUserMaterial()
  {


    if (myMaterialName != Graphic3d_NameOfMaterial_UserDefined)
    {
      myMaterialName = Graphic3d_NameOfMaterial_UserDefined;
      myStringName = "UserDefined";
    }
  }

private:

  Graphic3d_BSDF myBSDF;
  Graphic3d_PBRMaterial myPBRMaterial;
  TCollection_AsciiString myStringName;
  Quantity_Color myColors[Graphic3d_TypeOfReflection_NB];
  Standard_ShortReal myTransparencyCoef;
  Standard_ShortReal myRefractionIndex;
  Standard_ShortReal myShininess;

  Graphic3d_TypeOfMaterial myMaterialType;
  Graphic3d_NameOfMaterial myMaterialName;
  Graphic3d_NameOfMaterial myRequestedMaterialName;

};
# 29 "/usr/include/opencascade/Graphic3d_Aspects.hxx" 2
# 1 "/usr/include/opencascade/Graphic3d_PolygonOffset.hxx" 1
# 21 "/usr/include/opencascade/Graphic3d_PolygonOffset.hxx"
struct Graphic3d_PolygonOffset
{
  Aspect_PolygonOffsetMode Mode;
  Standard_ShortReal Factor;
  Standard_ShortReal Units;


  Graphic3d_PolygonOffset() : Mode(Aspect_POM_Fill), Factor (1.0f), Units (1.0f) {}


  bool operator== (const Graphic3d_PolygonOffset& theOther) const
  {
    return Mode == theOther.Mode
        && Factor == theOther.Factor
        && Units == theOther.Units;
  }


  void DumpJson (Standard_OStream& theOStream, Standard_Integer theDepth = -1) const;

};
# 30 "/usr/include/opencascade/Graphic3d_Aspects.hxx" 2
# 1 "/usr/include/opencascade/Graphic3d_ShaderProgram.hxx" 1
# 19 "/usr/include/opencascade/Graphic3d_ShaderProgram.hxx"
# 1 "/usr/include/opencascade/Graphic3d_ShaderAttribute.hxx" 1
# 23 "/usr/include/opencascade/Graphic3d_ShaderAttribute.hxx"
class Graphic3d_ShaderAttribute : public Standard_Transient
{
public:


  Graphic3d_ShaderAttribute (const TCollection_AsciiString& theName,
                                             const int theLocation);


  virtual ~Graphic3d_ShaderAttribute();


  const TCollection_AsciiString& Name() const
  {
    return myName;
  }


  int Location() const
  {
    return myLocation;
  }

protected:

  TCollection_AsciiString myName;
  int myLocation;

public:

  public: typedef Standard_Transient base_type; static const char* get_type_name () { return "Graphic3d_ShaderAttribute"; using direct_base_classes = opencascade::direct_base_class_as_tuple<std::tr2::direct_bases<Graphic3d_ShaderAttribute>::type>::type; static_assert(opencascade::has_type<Standard_Transient, direct_base_classes>::type::value, "OCCT RTTI definition is incorrect: " "Standard_Transient" " is not direct base class of " "Graphic3d_ShaderAttribute"); static_assert(&get_type_name == &Graphic3d_ShaderAttribute::get_type_name, "OCCT RTTI definition is misplaced: current class is not " "Graphic3d_ShaderAttribute"); } static const opencascade::handle<Standard_Type>& get_type_descriptor (); virtual const opencascade::handle<Standard_Type>& DynamicType() const override;

};

class Graphic3d_ShaderAttribute; typedef opencascade::handle<Graphic3d_ShaderAttribute> Handle_Graphic3d_ShaderAttribute;
# 20 "/usr/include/opencascade/Graphic3d_ShaderProgram.hxx" 2
# 1 "/usr/include/opencascade/Graphic3d_ShaderObject.hxx" 1
# 19 "/usr/include/opencascade/Graphic3d_ShaderObject.hxx"
# 1 "/usr/include/opencascade/OSD_Path.hxx" 1
# 24 "/usr/include/opencascade/OSD_Path.hxx"
# 1 "/usr/include/opencascade/OSD_SysType.hxx" 1
# 25 "/usr/include/opencascade/OSD_SysType.hxx"
enum OSD_SysType
{
OSD_Unknown,
OSD_Default,
OSD_UnixBSD,
OSD_UnixSystemV,
OSD_VMS,
OSD_OS2,
OSD_OSF,
OSD_MacOs,
OSD_Taligent,
OSD_WindowsNT,
OSD_LinuxREDHAT,
OSD_Aix
};
# 25 "/usr/include/opencascade/OSD_Path.hxx" 2

class OSD_Path
{
public:
  void* operator new (size_t theSize) { return Standard::Allocate (theSize); } void operator delete (void* theAddress) { Standard::Free (theAddress); } void* operator new[] (size_t theSize) { return Standard::Allocate (theSize); } void operator delete[] (void* theAddress) { Standard::Free (theAddress); } void* operator new (size_t, void* theAddress) { return theAddress; } void operator delete (void*, void*) { }



  OSD_Path();
# 45 "/usr/include/opencascade/OSD_Path.hxx"
  OSD_Path(const TCollection_AsciiString& aDependentName, const OSD_SysType aSysType = OSD_Default);
# 67 "/usr/include/opencascade/OSD_Path.hxx"
  OSD_Path(const TCollection_AsciiString& aNode, const TCollection_AsciiString& aUsername, const TCollection_AsciiString& aPassword, const TCollection_AsciiString& aDisk, const TCollection_AsciiString& aTrek, const TCollection_AsciiString& aName, const TCollection_AsciiString& anExtension);


  void Values (TCollection_AsciiString& aNode, TCollection_AsciiString& aUsername, TCollection_AsciiString& aPassword, TCollection_AsciiString& aDisk, TCollection_AsciiString& aTrek, TCollection_AsciiString& aName, TCollection_AsciiString& anExtension) const;


  void SetValues (const TCollection_AsciiString& aNode, const TCollection_AsciiString& aUsername, const TCollection_AsciiString& aPassword, const TCollection_AsciiString& aDisk, const TCollection_AsciiString& aTrek, const TCollection_AsciiString& aName, const TCollection_AsciiString& anExtension);
# 90 "/usr/include/opencascade/OSD_Path.hxx"
  void SystemName (TCollection_AsciiString& FullName, const OSD_SysType aType = OSD_Default) const;


  void ExpandedName (TCollection_AsciiString& aName);


  static Standard_Boolean IsValid (const TCollection_AsciiString& theDependentName, const OSD_SysType theSysType = OSD_Default);







  void UpTrek();




  void DownTrek (const TCollection_AsciiString& aName);




  Standard_Integer TrekLength() const;







  void RemoveATrek (const Standard_Integer where);





  void RemoveATrek (const TCollection_AsciiString& aName);




  TCollection_AsciiString TrekValue (const Standard_Integer where) const;




  void InsertATrek (const TCollection_AsciiString& aName, const Standard_Integer where);


  TCollection_AsciiString Node() const;


  TCollection_AsciiString UserName() const;


  TCollection_AsciiString Password() const;


  TCollection_AsciiString Disk() const;


  TCollection_AsciiString Trek() const;



  TCollection_AsciiString Name() const;



  TCollection_AsciiString Extension() const;


  void SetNode (const TCollection_AsciiString& aName);


  void SetUserName (const TCollection_AsciiString& aName);


  void SetPassword (const TCollection_AsciiString& aName);


  void SetDisk (const TCollection_AsciiString& aName);


  void SetTrek (const TCollection_AsciiString& aName);



  void SetName (const TCollection_AsciiString& aName);


  void SetExtension (const TCollection_AsciiString& aName);




  Standard_Boolean LocateExecFile (OSD_Path& aPath);

public:







  static TCollection_AsciiString RelativePath (const TCollection_AsciiString& DirPath, const TCollection_AsciiString& AbsFilePath);






  static TCollection_AsciiString AbsolutePath (const TCollection_AsciiString& DirPath, const TCollection_AsciiString& RelFilePath);
# 214 "/usr/include/opencascade/OSD_Path.hxx"
  static void FolderAndFileFromPath (const TCollection_AsciiString& theFilePath,
                                                     TCollection_AsciiString& theFolder,
                                                     TCollection_AsciiString& theFileName);
# 226 "/usr/include/opencascade/OSD_Path.hxx"
  static void FileNameAndExtension (const TCollection_AsciiString& theFilePath,
                                                    TCollection_AsciiString& theName,
                                                    TCollection_AsciiString& theExtension);






  static Standard_Boolean IsDosPath (const char* thePath) { return thePath[0] != '\0' && thePath[1] == ':'; }







  static Standard_Boolean IsNtExtendedPath (const char* thePath)
  {
    return ::strncmp (thePath, "\\\\?\\", 4) == 0;
  }





  static Standard_Boolean IsUncPath (const char* thePath)
  {
    if (::strncmp (thePath, "\\\\", 2) == 0)
    {
      return thePath[2] != '?'
          || IsUncExtendedPath (thePath);
    }
    return ::strncmp (thePath, "//", 2) == 0;
  }





  static Standard_Boolean IsUncExtendedPath (const char* thePath)
  {
    return ::strncmp (thePath, "\\\\?\\UNC\\", 8) == 0;
  }





  static Standard_Boolean IsUnixPath (const char* thePath)
  {
    return thePath[0] == '/' && thePath[1] != '/';
  }





  static Standard_Boolean IsContentProtocolPath (const char* thePath)
  {
    return ::strncmp (thePath, "content://", 10) == 0;
  }






  static Standard_Boolean IsRemoteProtocolPath (const char* thePath)
  {
    const char* anIter = thePath;
    if (*anIter == ':')
    {
      return false;
    }
    for (; *anIter != '\0'; ++anIter)
    {
      if (*anIter == ':')
      {
        return *(++anIter) == '/'
            && *(++anIter) == '/';
      }
    }
    return false;
  }




  static Standard_Boolean IsRelativePath (const char* thePath)
  {
    return !IsUncPath (thePath)
        && !IsDosPath (thePath)
        && !IsNtExtendedPath (thePath)
        && !IsUnixPath (thePath)
        && !IsRemoteProtocolPath (thePath);
  }




  static Standard_Boolean IsAbsolutePath (const char* thePath)
  {
    return !IsRelativePath (thePath);
  }

private:

  TCollection_AsciiString myNode;
  TCollection_AsciiString myUserName;
  TCollection_AsciiString myPassword;
  TCollection_AsciiString myDisk;
  TCollection_AsciiString myTrek;
  TCollection_AsciiString myName;
  TCollection_AsciiString myExtension;
  Standard_Boolean myUNCFlag;
  OSD_SysType mySysDep;

};
# 20 "/usr/include/opencascade/Graphic3d_ShaderObject.hxx" 2

# 1 "/usr/include/opencascade/Graphic3d_TypeOfShaderObject.hxx" 1
# 20 "/usr/include/opencascade/Graphic3d_TypeOfShaderObject.hxx"
enum Graphic3d_TypeOfShaderObject
{

  Graphic3d_TOS_VERTEX = 0x01,
  Graphic3d_TOS_TESS_CONTROL = 0x02,
  Graphic3d_TOS_TESS_EVALUATION = 0x04,
  Graphic3d_TOS_GEOMETRY = 0x08,
  Graphic3d_TOS_FRAGMENT = 0x10,

  Graphic3d_TOS_COMPUTE = 0x20
};
# 22 "/usr/include/opencascade/Graphic3d_ShaderObject.hxx" 2




class Graphic3d_ShaderObject : public Standard_Transient
{
private:


  Graphic3d_ShaderObject (const Graphic3d_TypeOfShaderObject theType);

public:


  virtual ~Graphic3d_ShaderObject();


  virtual Standard_Boolean IsDone() const;


  const OSD_Path& Path() const { return myPath; }


  const TCollection_AsciiString& Source() const { return mySource; }


  Graphic3d_TypeOfShaderObject Type() const { return myType; }


  const TCollection_AsciiString& GetId() const { return myID; }


  static opencascade::handle<Graphic3d_ShaderObject> CreateFromFile (const Graphic3d_TypeOfShaderObject theType,
                                                                        const TCollection_AsciiString& thePath);


  static opencascade::handle<Graphic3d_ShaderObject> CreateFromSource (const Graphic3d_TypeOfShaderObject theType,
                                                                          const TCollection_AsciiString& theSource);

public:

  public: typedef Standard_Transient base_type; static const char* get_type_name () { return "Graphic3d_ShaderObject"; using direct_base_classes = opencascade::direct_base_class_as_tuple<std::tr2::direct_bases<Graphic3d_ShaderObject>::type>::type; static_assert(opencascade::has_type<Standard_Transient, direct_base_classes>::type::value, "OCCT RTTI definition is incorrect: " "Standard_Transient" " is not direct base class of " "Graphic3d_ShaderObject"); static_assert(&get_type_name == &Graphic3d_ShaderObject::get_type_name, "OCCT RTTI definition is misplaced: current class is not " "Graphic3d_ShaderObject"); } static const opencascade::handle<Standard_Type>& get_type_descriptor (); virtual const opencascade::handle<Standard_Type>& DynamicType() const override;

protected:

  TCollection_AsciiString myID;
  TCollection_AsciiString mySource;
  OSD_Path myPath;

private:


  Graphic3d_TypeOfShaderObject myType;
};

class Graphic3d_ShaderObject; typedef opencascade::handle<Graphic3d_ShaderObject> Handle_Graphic3d_ShaderObject;
# 21 "/usr/include/opencascade/Graphic3d_ShaderProgram.hxx" 2
# 1 "/usr/include/opencascade/Graphic3d_ShaderVariable.hxx" 1
# 19 "/usr/include/opencascade/Graphic3d_ShaderVariable.hxx"
# 1 "/usr/include/opencascade/Graphic3d_Vec.hxx" 1
# 22 "/usr/include/opencascade/Graphic3d_Vec.hxx"
# 1 "/usr/include/opencascade/Graphic3d_Mat4.hxx" 1
# 17 "/usr/include/opencascade/Graphic3d_Mat4.hxx"
# 1 "/usr/include/opencascade/NCollection_Mat4.hxx" 1
# 27 "/usr/include/opencascade/NCollection_Mat4.hxx"
template<typename Element_t>
class NCollection_Mat4
{

public:



  static size_t Rows()
  {
    return 4;
  }



  static size_t Cols()
  {
    return 4;
  }



  NCollection_Mat4()
  {
    InitIdentity();
  }






  template <typename OtherElement_t>
  explicit NCollection_Mat4 (const NCollection_Mat4<OtherElement_t>& theOtherMat4)
  {
    ConvertFrom (theOtherMat4);
  }





  Element_t GetValue (const size_t theRow, const size_t theCol) const
  {
    return myMat[theCol * 4 + theRow];
  }





  Element_t& ChangeValue (const size_t theRow, const size_t theCol)
  {
    return myMat[theCol * 4 + theRow];
  }





  void SetValue (const size_t theRow,
                 const size_t theCol,
                 const Element_t theValue)
  {
    myMat[theCol * 4 + theRow] = theValue;
  }




  NCollection_Vec4<Element_t> GetRow (const size_t theRow) const
  {
    return NCollection_Vec4<Element_t> (GetValue (theRow, 0),
                                        GetValue (theRow, 1),
                                        GetValue (theRow, 2),
                                        GetValue (theRow, 3));
  }




  void SetRow (const size_t theRow, const NCollection_Vec3<Element_t>& theVec)
  {
    SetValue (theRow, 0, theVec.x());
    SetValue (theRow, 1, theVec.y());
    SetValue (theRow, 2, theVec.z());
  }




  void SetRow (const size_t theRow, const NCollection_Vec4<Element_t>& theVec)
  {
    SetValue (theRow, 0, theVec.x());
    SetValue (theRow, 1, theVec.y());
    SetValue (theRow, 2, theVec.z());
    SetValue (theRow, 3, theVec.w());
  }




  NCollection_Vec4<Element_t> GetColumn (const size_t theCol) const
  {
    return NCollection_Vec4<Element_t> (GetValue (0, theCol),
                                        GetValue (1, theCol),
                                        GetValue (2, theCol),
                                        GetValue (3, theCol));
  }




  void SetColumn (const size_t theCol,
                  const NCollection_Vec3<Element_t>& theVec)
  {
    SetValue (0, theCol, theVec.x());
    SetValue (1, theCol, theVec.y());
    SetValue (2, theCol, theVec.z());
  }




  void SetColumn (const size_t theCol,
                  const NCollection_Vec4<Element_t>& theVec)
  {
    SetValue (0, theCol, theVec.x());
    SetValue (1, theCol, theVec.y());
    SetValue (2, theCol, theVec.z());
    SetValue (3, theCol, theVec.w());
  }



  NCollection_Vec4<Element_t> GetDiagonal() const
  {
    return NCollection_Vec4<Element_t> (GetValue (0, 0),
                                        GetValue (1, 1),
                                        GetValue (2, 2),
                                        GetValue (3, 3));
  }



  void SetDiagonal (const NCollection_Vec3<Element_t>& theVec)
  {
    SetValue (0, 0, theVec.x());
    SetValue (1, 1, theVec.y());
    SetValue (2, 2, theVec.z());
  }



  void SetDiagonal (const NCollection_Vec4<Element_t>& theVec)
  {
    SetValue (0, 0, theVec.x());
    SetValue (1, 1, theVec.y());
    SetValue (2, 2, theVec.z());
    SetValue (3, 3, theVec.w());
  }


  void InitIdentity()
  {
    std::memcpy (this, myIdentityArray, sizeof (NCollection_Mat4));
  }


  bool IsIdentity() const
  {
    return std::memcmp (this, myIdentityArray, sizeof (NCollection_Mat4)) == 0;
  }


  bool IsEqual (const NCollection_Mat4& theOther) const
  {
    return std::memcmp (this, &theOther, sizeof(NCollection_Mat4)) == 0;
  }


  bool operator== (const NCollection_Mat4& theOther) { return IsEqual (theOther); }
  bool operator== (const NCollection_Mat4& theOther) const { return IsEqual (theOther); }


  bool operator!= (const NCollection_Mat4& theOther) { return !IsEqual (theOther); }
  bool operator!= (const NCollection_Mat4& theOther) const { return !IsEqual (theOther); }


  const Element_t* GetData() const { return myMat; }
  Element_t* ChangeData() { return myMat; }
  operator const Element_t*() const { return myMat; }
  operator Element_t*() { return myMat; }



  NCollection_Vec4<Element_t> operator* (const NCollection_Vec4<Element_t>& theVec) const
  {
    return NCollection_Vec4<Element_t> (
      GetValue (0, 0) * theVec.x() + GetValue (0, 1) * theVec.y() + GetValue (0, 2) * theVec.z() + GetValue (0, 3) * theVec.w(),
      GetValue (1, 0) * theVec.x() + GetValue (1, 1) * theVec.y() + GetValue (1, 2) * theVec.z() + GetValue (1, 3) * theVec.w(),
      GetValue (2, 0) * theVec.x() + GetValue (2, 1) * theVec.y() + GetValue (2, 2) * theVec.z() + GetValue (2, 3) * theVec.w(),
      GetValue (3, 0) * theVec.x() + GetValue (3, 1) * theVec.y() + GetValue (3, 2) * theVec.z() + GetValue (3, 3) * theVec.w());
  }




  NCollection_Mat4 Multiply (const NCollection_Mat4& theMatA,
                             const NCollection_Mat4& theMatB)
  {
    NCollection_Mat4 aMatRes;

    size_t aInputElem;
    for (size_t aResElem = 0; aResElem < 16; ++aResElem)
    {
      aMatRes[aResElem] = (Element_t )0;
      for (aInputElem = 0; aInputElem < 4; ++aInputElem)
      {
        aMatRes[aResElem] += theMatA.GetValue(aResElem % 4, aInputElem)
                           * theMatB.GetValue(aInputElem, aResElem / 4);
      }
    }

    return aMatRes;
  }



  void Multiply (const NCollection_Mat4& theMat)
  {
    *this = Multiply(*this, theMat);
  }



  NCollection_Mat4& operator*= (const NCollection_Mat4& theMat)
  {
    Multiply (theMat);
    return *this;
  }




  NCollection_Mat4 operator* (const NCollection_Mat4& theMat) const
  {
    return Multiplied (theMat);
  }




  NCollection_Mat4 Multiplied (const NCollection_Mat4& theMat) const
  {
    NCollection_Mat4 aTempMat (*this);
    aTempMat *= theMat;
    return aTempMat;
  }



  void Multiply (const Element_t theFactor)
  {
    for (size_t i = 0; i < 16; ++i)
    {
      myMat[i] *= theFactor;
    }
  }



  NCollection_Mat4& operator*=(const Element_t theFactor)
  {
    Multiply (theFactor);
    return *this;
  }




  NCollection_Mat4 operator* (const Element_t theFactor) const
  {
    return Multiplied (theFactor);
  }




  NCollection_Mat4 Multiplied (const Element_t theFactor) const
  {
    NCollection_Mat4 aTempMat (*this);
    aTempMat *= theFactor;
    return aTempMat;
  }



  void Translate (const NCollection_Vec3<Element_t>& theVec)
  {
    NCollection_Mat4 aTempMat;
    aTempMat.SetColumn (3, theVec);
    this->Multiply (aTempMat);
  }



  NCollection_Mat4 Transposed() const
  {
    NCollection_Mat4 aTempMat;
    aTempMat.SetRow (0, GetColumn (0));
    aTempMat.SetRow (1, GetColumn (1));
    aTempMat.SetRow (2, GetColumn (2));
    aTempMat.SetRow (3, GetColumn (3));
    return aTempMat;
  }


  void Transpose()
  {
    *this = Transposed();
  }




  bool Inverted (NCollection_Mat4<Element_t>& theOutMx) const
  {
    Element_t* inv = theOutMx.myMat;


    const Element_t* m = myMat;

    inv[ 0] = m[ 5] * (m[10] * m[15] - m[11] * m[14]) -
              m[ 9] * (m[ 6] * m[15] - m[ 7] * m[14]) -
              m[13] * (m[ 7] * m[10] - m[ 6] * m[11]);

    inv[ 1] = m[ 1] * (m[11] * m[14] - m[10] * m[15]) -
              m[ 9] * (m[ 3] * m[14] - m[ 2] * m[15]) -
              m[13] * (m[ 2] * m[11] - m[ 3] * m[10]);

    inv[ 2] = m[ 1] * (m[ 6] * m[15] - m[ 7] * m[14]) -
              m[ 5] * (m[ 2] * m[15] - m[ 3] * m[14]) -
              m[13] * (m[ 3] * m[ 6] - m[ 2] * m[ 7]);

    inv[ 3] = m[ 1] * (m[ 7] * m[10] - m[ 6] * m[11]) -
              m[ 5] * (m[ 3] * m[10] - m[ 2] * m[11]) -
              m[ 9] * (m[ 2] * m[ 7] - m[ 3] * m[ 6]);

    inv[ 4] = m[ 4] * (m[11] * m[14] - m[10] * m[15]) -
              m[ 8] * (m[ 7] * m[14] - m[ 6] * m[15]) -
              m[12] * (m[ 6] * m[11] - m[ 7] * m[10]);

    inv[ 5] = m[ 0] * (m[10] * m[15] - m[11] * m[14]) -
              m[ 8] * (m[ 2] * m[15] - m[ 3] * m[14]) -
              m[12] * (m[ 3] * m[10] - m[ 2] * m[11]);

    inv[ 6] = m[ 0] * (m[ 7] * m[14] - m[ 6] * m[15]) -
              m[ 4] * (m[ 3] * m[14] - m[ 2] * m[15]) -
              m[12] * (m[ 2] * m[ 7] - m[ 3] * m[ 6]);

    inv[ 7] = m[ 0] * (m[ 6] * m[11] - m[ 7] * m[10]) -
              m[ 4] * (m[ 2] * m[11] - m[ 3] * m[10]) -
              m[ 8] * (m[ 3] * m[ 6] - m[ 2] * m[ 7]);

    inv[ 8] = m[ 4] * (m[ 9] * m[15] - m[11] * m[13]) -
              m[ 8] * (m[ 5] * m[15] - m[ 7] * m[13]) -
              m[12] * (m[ 7] * m[ 9] - m[ 5] * m[11]);

    inv[ 9] = m[ 0] * (m[11] * m[13] - m[ 9] * m[15]) -
              m[ 8] * (m[ 3] * m[13] - m[ 1] * m[15]) -
              m[12] * (m[ 1] * m[11] - m[ 3] * m[ 9]);

    inv[10] = m[ 0] * (m[ 5] * m[15] - m[ 7] * m[13]) -
              m[ 4] * (m[ 1] * m[15] - m[ 3] * m[13]) -
              m[12] * (m[ 3] * m[ 5] - m[ 1] * m[ 7]);

    inv[11] = m[ 0] * (m[ 7] * m[ 9] - m[ 5] * m[11]) -
              m[ 4] * (m[ 3] * m[ 9] - m[ 1] * m[11]) -
              m[ 8] * (m[ 1] * m[ 7] - m[ 3] * m[ 5]);

    inv[12] = m[ 4] * (m[10] * m[13] - m[ 9] * m[14]) -
              m[ 8] * (m[ 6] * m[13] - m[ 5] * m[14]) -
              m[12] * (m[ 5] * m[10] - m[ 6] * m[ 9]);

    inv[13] = m[ 0] * (m[ 9] * m[14] - m[10] * m[13]) -
              m[ 8] * (m[ 1] * m[14] - m[ 2] * m[13]) -
              m[12] * (m[ 2] * m[ 9] - m[ 1] * m[10]);

    inv[14] = m[ 0] * (m[ 6] * m[13] - m[ 5] * m[14]) -
              m[ 4] * (m[ 2] * m[13] - m[ 1] * m[14]) -
              m[12] * (m[ 1] * m[ 6] - m[ 2] * m[ 5]);

    inv[15] = m[ 0] * (m[ 5] * m[10] - m[ 6] * m[ 9]) -
              m[ 4] * (m[ 1] * m[10] - m[ 2] * m[ 9]) -
              m[ 8] * (m[ 2] * m[ 5] - m[ 1] * m[ 6]);

    Element_t aDet = m[0] * inv[ 0] +
                     m[1] * inv[ 4] +
                     m[2] * inv[ 8] +
                     m[3] * inv[12];

    if (aDet == 0)
      return false;

    aDet = (Element_t) 1. / aDet;

    for (int i = 0; i < 16; ++i)
      inv[i] *= aDet;

    return true;
  }


  template <typename Other_t>
  void ConvertFrom (const NCollection_Mat4<Other_t>& theFrom)
  {
    for (int anIdx = 0; anIdx < 16; ++anIdx)
    {
      myMat[anIdx] = static_cast<Element_t> (theFrom.myMat[anIdx]);
    }
  }


  template <typename Other_t>
  void Convert (const NCollection_Mat4<Other_t>& theFrom) { ConvertFrom (theFrom); }


  static NCollection_Mat4<Element_t>& Map (Element_t* theData)
  {
    return *reinterpret_cast<NCollection_Mat4<Element_t>*> (theData);
  }


  static const NCollection_Mat4<Element_t>& Map (const Element_t* theData)
  {
    return *reinterpret_cast<const NCollection_Mat4<Element_t>*> (theData);
  }


  void DumpJson (Standard_OStream& theOStream, Standard_Integer) const
  {
    { Standard_Dump::AddValuesSeparator (theOStream); theOStream << "\"" << "NCollection_Mat4" << "\": ["; Standard_Dump::DumpRealValues (theOStream, 16, GetValue (0, 0), GetValue (0, 1), GetValue (0, 2), GetValue (0, 3), GetValue (1, 0), GetValue (1, 1), GetValue (1, 2), GetValue (1, 3), GetValue (2, 0), GetValue (2, 1), GetValue (2, 2), GetValue (2, 3), GetValue (3, 0), GetValue (3, 1), GetValue (3, 2), GetValue (3, 3)); theOStream << "]"; }




  }

private:

  Element_t myMat[16];

private:

  static Element_t myIdentityArray[16];


  template<class OtherType> friend class NCollection_Mat4;

};

template<typename Element_t>
Element_t NCollection_Mat4<Element_t>::myIdentityArray[] =
  {1, 0, 0, 0,
   0, 1, 0, 0,
   0, 0, 1, 0,
   0, 0, 0, 1};
# 18 "/usr/include/opencascade/Graphic3d_Mat4.hxx" 2


typedef NCollection_Mat4<Standard_ShortReal> Graphic3d_Mat4;
# 23 "/usr/include/opencascade/Graphic3d_Vec.hxx" 2
# 1 "/usr/include/opencascade/Graphic3d_Mat4d.hxx" 1
# 20 "/usr/include/opencascade/Graphic3d_Mat4d.hxx"
typedef NCollection_Mat4<Standard_Real> Graphic3d_Mat4d;
# 24 "/usr/include/opencascade/Graphic3d_Vec.hxx" 2
# 20 "/usr/include/opencascade/Graphic3d_ShaderVariable.hxx" 2




struct Graphic3d_ValueInterface
{

  virtual ~Graphic3d_ValueInterface();


  virtual Standard_Size TypeID() const = 0;


  template <class T> T& As();


  template <class T> const T& As() const;
};


template<class T>
struct Graphic3d_UniformValueTypeID {

};

template<>
struct Graphic3d_UniformValueTypeID<Standard_Integer> {
  static const Standard_Size ID = 47;
};

template<>
struct Graphic3d_UniformValueTypeID<Standard_ShortReal> {
  static const Standard_Size ID = 52;
};

template<>
struct Graphic3d_UniformValueTypeID<Graphic3d_Vec2> {
  static const Standard_Size ID = 57;
};

template<>
struct Graphic3d_UniformValueTypeID<Graphic3d_Vec3> {
  static const Standard_Size ID = 62;
};

template<>
struct Graphic3d_UniformValueTypeID<Graphic3d_Vec4> {
  static const Standard_Size ID = 67;
};

template<>
struct Graphic3d_UniformValueTypeID<Graphic3d_Vec2i> {
  static const Standard_Size ID = 72;
};

template<>
struct Graphic3d_UniformValueTypeID<Graphic3d_Vec3i> {
  static const Standard_Size ID = 77;
};

template<>
struct Graphic3d_UniformValueTypeID<Graphic3d_Vec4i> {
  static const Standard_Size ID = 82;
};


template <class T>
struct Graphic3d_UniformValue : public Graphic3d_ValueInterface
{

  Graphic3d_UniformValue (const T& theValue) : Value (theValue) { }


  virtual Standard_Size TypeID() const;


  T Value;
};


typedef Graphic3d_UniformValue<Standard_Integer> Graphic3d_UniformInt;


typedef Graphic3d_UniformValue<Graphic3d_Vec2i> Graphic3d_UniformVec2i;


typedef Graphic3d_UniformValue<Graphic3d_Vec3i> Graphic3d_UniformVec3i;


typedef Graphic3d_UniformValue<Graphic3d_Vec4i> Graphic3d_UniformVec4i;


typedef Graphic3d_UniformValue<Standard_ShortReal> Graphic3d_UniformFloat;


typedef Graphic3d_UniformValue<Graphic3d_Vec2> Graphic3d_UniformVec2;


typedef Graphic3d_UniformValue<Graphic3d_Vec3> Graphic3d_UniformVec3;


typedef Graphic3d_UniformValue<Graphic3d_Vec4> Graphic3d_UniformVec4;


class Graphic3d_ShaderVariable : public Standard_Transient
{
public:


  virtual ~Graphic3d_ShaderVariable();


  const TCollection_AsciiString& Name() const;


  Standard_Boolean IsDone() const;


  Graphic3d_ValueInterface* Value();


  template<class T>
  static Graphic3d_ShaderVariable* Create (const TCollection_AsciiString& theName,
                                           const T& theValue);

public:

  public: typedef Standard_Transient base_type; static const char* get_type_name () { return "Graphic3d_ShaderVariable"; using direct_base_classes = opencascade::direct_base_class_as_tuple<std::tr2::direct_bases<Graphic3d_ShaderVariable>::type>::type; static_assert(opencascade::has_type<Standard_Transient, direct_base_classes>::type::value, "OCCT RTTI definition is incorrect: " "Standard_Transient" " is not direct base class of " "Graphic3d_ShaderVariable"); static_assert(&get_type_name == &Graphic3d_ShaderVariable::get_type_name, "OCCT RTTI definition is misplaced: current class is not " "Graphic3d_ShaderVariable"); } static const opencascade::handle<Standard_Type>& get_type_descriptor (); virtual const opencascade::handle<Standard_Type>& DynamicType() const override;

protected:


  Graphic3d_ShaderVariable (const TCollection_AsciiString& theName);

protected:


  TCollection_AsciiString myName;


  Graphic3d_ValueInterface* myValue;
};

class Graphic3d_ShaderVariable; typedef opencascade::handle<Graphic3d_ShaderVariable> Handle_Graphic3d_ShaderVariable;

# 1 "/usr/include/opencascade/Graphic3d_ShaderVariable.lxx" 1
# 20 "/usr/include/opencascade/Graphic3d_ShaderVariable.lxx"
template <class T> inline
T& Graphic3d_ValueInterface::As()
{
  Graphic3d_UniformValue<T>* aPtr = dynamic_cast<Graphic3d_UniformValue<T>*> (this);
  return aPtr->Value;
}





template <class T> inline
const T& Graphic3d_ValueInterface::As() const
{
  const Graphic3d_UniformValue<T>* aPtr = dynamic_cast<const Graphic3d_UniformValue<T>*> (this);
  return aPtr->Value;
}





template <class T> inline
Standard_Size Graphic3d_UniformValue<T>::TypeID() const
{
  return Graphic3d_UniformValueTypeID<T>::ID;
}





template<class T> inline
Graphic3d_ShaderVariable* Graphic3d_ShaderVariable::Create (const TCollection_AsciiString& theName,
                                                            const T& theValue)
{
  Graphic3d_ShaderVariable* theVariable = new Graphic3d_ShaderVariable (theName);
  theVariable->myValue = new Graphic3d_UniformValue<T> (theValue);
  return theVariable;
}
# 166 "/usr/include/opencascade/Graphic3d_ShaderVariable.hxx" 2
# 22 "/usr/include/opencascade/Graphic3d_ShaderProgram.hxx" 2
# 1 "/usr/include/opencascade/Graphic3d_TextureParams.hxx" 1
# 17 "/usr/include/opencascade/Graphic3d_TextureParams.hxx"
# 1 "/usr/include/opencascade/Graphic3d_LevelOfTextureAnisotropy.hxx" 1
# 22 "/usr/include/opencascade/Graphic3d_LevelOfTextureAnisotropy.hxx"
enum Graphic3d_LevelOfTextureAnisotropy
{
Graphic3d_LOTA_OFF,
Graphic3d_LOTA_FAST,
Graphic3d_LOTA_MIDDLE,
Graphic3d_LOTA_QUALITY
};
# 18 "/usr/include/opencascade/Graphic3d_TextureParams.hxx" 2


# 1 "/usr/include/opencascade/Graphic3d_TextureUnit.hxx" 1
# 18 "/usr/include/opencascade/Graphic3d_TextureUnit.hxx"
enum Graphic3d_TextureUnit
{

  Graphic3d_TextureUnit_0,
  Graphic3d_TextureUnit_1,
  Graphic3d_TextureUnit_2,
  Graphic3d_TextureUnit_3,
  Graphic3d_TextureUnit_4,
  Graphic3d_TextureUnit_5,
  Graphic3d_TextureUnit_6,
  Graphic3d_TextureUnit_7,
  Graphic3d_TextureUnit_8,
  Graphic3d_TextureUnit_9,
  Graphic3d_TextureUnit_10,
  Graphic3d_TextureUnit_11,
  Graphic3d_TextureUnit_12,
  Graphic3d_TextureUnit_13,
  Graphic3d_TextureUnit_14,
  Graphic3d_TextureUnit_15,





  Graphic3d_TextureUnit_BaseColor = Graphic3d_TextureUnit_0,


  Graphic3d_TextureUnit_Emissive = Graphic3d_TextureUnit_1,



  Graphic3d_TextureUnit_Occlusion = Graphic3d_TextureUnit_2,


  Graphic3d_TextureUnit_Normal = Graphic3d_TextureUnit_3,




  Graphic3d_TextureUnit_MetallicRoughness = Graphic3d_TextureUnit_4,



  Graphic3d_TextureUnit_EnvMap = Graphic3d_TextureUnit_0,






  Graphic3d_TextureUnit_PointSprite = Graphic3d_TextureUnit_1,




  Graphic3d_TextureUnit_PbrEnvironmentLUT = -3,



  Graphic3d_TextureUnit_PbrIblDiffuseSH = -2,



  Graphic3d_TextureUnit_PbrIblSpecular = -1,
};
enum
{
  Graphic3d_TextureUnit_NB = Graphic3d_TextureUnit_15 + 1,
};
# 21 "/usr/include/opencascade/Graphic3d_TextureParams.hxx" 2
# 1 "/usr/include/opencascade/Graphic3d_TypeOfTextureFilter.hxx" 1
# 22 "/usr/include/opencascade/Graphic3d_TypeOfTextureFilter.hxx"
enum Graphic3d_TypeOfTextureFilter
{
Graphic3d_TOTF_NEAREST,
Graphic3d_TOTF_BILINEAR,
Graphic3d_TOTF_TRILINEAR
};
# 22 "/usr/include/opencascade/Graphic3d_TextureParams.hxx" 2
# 1 "/usr/include/opencascade/Graphic3d_TypeOfTextureMode.hxx" 1
# 21 "/usr/include/opencascade/Graphic3d_TypeOfTextureMode.hxx"
enum Graphic3d_TypeOfTextureMode
{
Graphic3d_TOTM_OBJECT,
Graphic3d_TOTM_SPHERE,
Graphic3d_TOTM_EYE,
Graphic3d_TOTM_MANUAL,
Graphic3d_TOTM_SPRITE
};
# 23 "/usr/include/opencascade/Graphic3d_TextureParams.hxx" 2







class Graphic3d_TextureParams : public Standard_Transient
{
  public: typedef Standard_Transient base_type; static const char* get_type_name () { return "Graphic3d_TextureParams"; using direct_base_classes = opencascade::direct_base_class_as_tuple<std::tr2::direct_bases<Graphic3d_TextureParams>::type>::type; static_assert(opencascade::has_type<Standard_Transient, direct_base_classes>::type::value, "OCCT RTTI definition is incorrect: " "Standard_Transient" " is not direct base class of " "Graphic3d_TextureParams"); static_assert(&get_type_name == &Graphic3d_TextureParams::get_type_name, "OCCT RTTI definition is misplaced: current class is not " "Graphic3d_TextureParams"); } static const opencascade::handle<Standard_Type>& get_type_descriptor (); virtual const opencascade::handle<Standard_Type>& DynamicType() const override;
public:


  Graphic3d_TextureParams();


  virtual ~Graphic3d_TextureParams();


  Graphic3d_TextureUnit TextureUnit() const { return myTextureUnit; }


  void SetTextureUnit (Graphic3d_TextureUnit theUnit) { myTextureUnit = theUnit; }



  Standard_Boolean IsModulate() const { return myToModulate; }


  void SetModulate (const Standard_Boolean theToModulate);



  Standard_Boolean IsRepeat() const { return myToRepeat; }


  void SetRepeat (const Standard_Boolean theToRepeat);



  Graphic3d_TypeOfTextureFilter Filter() const { return myFilter; }


  void SetFilter (const Graphic3d_TypeOfTextureFilter theFilter);



  Graphic3d_LevelOfTextureAnisotropy AnisoFilter() const { return myAnisoLevel; }


  void SetAnisoFilter (const Graphic3d_LevelOfTextureAnisotropy theLevel);



  Standard_ShortReal Rotation() const { return myRotAngle; }


  void SetRotation (const Standard_ShortReal theAngleDegrees);



  const Graphic3d_Vec2& Scale() const { return myScale; }


  void SetScale (const Graphic3d_Vec2 theScale);



  const Graphic3d_Vec2& Translation() const { return myTranslation; }


  void SetTranslation (const Graphic3d_Vec2 theVec);



  Graphic3d_TypeOfTextureMode GenMode() const { return myGenMode; }


  const Graphic3d_Vec4& GenPlaneS() const { return myGenPlaneS; }


  const Graphic3d_Vec4& GenPlaneT() const { return myGenPlaneT; }


  void SetGenMode (const Graphic3d_TypeOfTextureMode theMode, const Graphic3d_Vec4 thePlaneS, const Graphic3d_Vec4 thePlaneT);


  Standard_Integer BaseLevel() const { return myBaseLevel; }



  Standard_Integer MaxLevel() const { return myMaxLevel; }




  void SetLevelsRange (Standard_Integer theFirstLevel, Standard_Integer theSecondLevel = 0)
  {
    myMaxLevel = theFirstLevel > theSecondLevel ? theFirstLevel : theSecondLevel;
    myBaseLevel = theFirstLevel > theSecondLevel ? theSecondLevel : theFirstLevel;
  }


  unsigned int SamplerRevision() const { return mySamplerRevision; }

private:


  void updateSamplerRevision() { ++mySamplerRevision; }

private:

  Graphic3d_Vec4 myGenPlaneS;
  Graphic3d_Vec4 myGenPlaneT;
  Graphic3d_Vec2 myScale;
  Graphic3d_Vec2 myTranslation;
  unsigned int mySamplerRevision;
  Graphic3d_TextureUnit myTextureUnit;
  Graphic3d_TypeOfTextureFilter myFilter;
  Graphic3d_LevelOfTextureAnisotropy myAnisoLevel;
  Graphic3d_TypeOfTextureMode myGenMode;
  Standard_Integer myBaseLevel;
  Standard_Integer myMaxLevel;
  Standard_ShortReal myRotAngle;
  Standard_Boolean myToModulate;
  Standard_Boolean myToRepeat;

};

class Graphic3d_TextureParams; typedef opencascade::handle<Graphic3d_TextureParams> Handle_Graphic3d_TextureParams;
# 23 "/usr/include/opencascade/Graphic3d_ShaderProgram.hxx" 2
# 1 "/usr/include/opencascade/Graphic3d_TextureSetBits.hxx" 1
# 20 "/usr/include/opencascade/Graphic3d_TextureSetBits.hxx"
enum Graphic3d_TextureSetBits
{
  Graphic3d_TextureSetBits_NONE = 0,
  Graphic3d_TextureSetBits_BaseColor = (unsigned int )(1 << int(Graphic3d_TextureUnit_BaseColor)),
  Graphic3d_TextureSetBits_Emissive = (unsigned int )(1 << int(Graphic3d_TextureUnit_Emissive)),
  Graphic3d_TextureSetBits_Occlusion = (unsigned int )(1 << int(Graphic3d_TextureUnit_Occlusion)),
  Graphic3d_TextureSetBits_Normal = (unsigned int )(1 << int(Graphic3d_TextureUnit_Normal)),
  Graphic3d_TextureSetBits_MetallicRoughness = (unsigned int )(1 << int(Graphic3d_TextureUnit_MetallicRoughness)),
};
# 24 "/usr/include/opencascade/Graphic3d_ShaderProgram.hxx" 2
# 1 "/usr/include/opencascade/NCollection_Sequence.hxx" 1
# 19 "/usr/include/opencascade/NCollection_Sequence.hxx"
# 1 "/usr/include/opencascade/NCollection_BaseSequence.hxx" 1
# 25 "/usr/include/opencascade/NCollection_BaseSequence.hxx"
class NCollection_SeqNode
{
public:

  void* operator new (size_t theSize, const opencascade::handle<NCollection_BaseAllocator>& theAllocator) { return theAllocator->Allocate(theSize); } void operator delete (void* theAddress, const opencascade::handle<NCollection_BaseAllocator>& theAllocator) { theAllocator->Free(theAddress); }
public:
  NCollection_SeqNode () : myNext (
# 31 "/usr/include/opencascade/NCollection_BaseSequence.hxx" 3 4
                                  __null
# 31 "/usr/include/opencascade/NCollection_BaseSequence.hxx"
                                      ), myPrevious (
# 31 "/usr/include/opencascade/NCollection_BaseSequence.hxx" 3 4
                                                     __null
# 31 "/usr/include/opencascade/NCollection_BaseSequence.hxx"
                                                         ) {}
  NCollection_SeqNode * Next () const { return myNext; }
  NCollection_SeqNode * Previous () const { return myPrevious; }
  void SetNext (NCollection_SeqNode * theNext) { myNext = theNext; }
  void SetPrevious (NCollection_SeqNode * thePrev) { myPrevious = thePrev; }

 private:
  NCollection_SeqNode* myNext;
  NCollection_SeqNode* myPrevious;
};

typedef void (* NCollection_DelSeqNode)
     (NCollection_SeqNode*, opencascade::handle<NCollection_BaseAllocator>& theAl);





class NCollection_BaseSequence
{
public:

  void* operator new (size_t theSize) { return Standard::Allocate (theSize); } void operator delete (void* theAddress) { Standard::Free (theAddress); } void* operator new[] (size_t theSize) { return Standard::Allocate (theSize); } void operator delete[] (void* theAddress) { Standard::Free (theAddress); } void* operator new (size_t, void* theAddress) { return theAddress; } void operator delete (void*, void*) { }
  void* operator new (size_t theSize, const opencascade::handle<NCollection_BaseAllocator>& theAllocator) { return theAllocator->Allocate(theSize); } void operator delete (void* theAddress, const opencascade::handle<NCollection_BaseAllocator>& theAllocator) { theAllocator->Free(theAddress); }

public:
  class Iterator
  {
  public:

    Iterator (void) : myCurrent (
# 61 "/usr/include/opencascade/NCollection_BaseSequence.hxx" 3 4
                                __null
# 61 "/usr/include/opencascade/NCollection_BaseSequence.hxx"
                                    ), myPrevious(
# 61 "/usr/include/opencascade/NCollection_BaseSequence.hxx" 3 4
                                                  __null
# 61 "/usr/include/opencascade/NCollection_BaseSequence.hxx"
                                                      ) {}


    Iterator (const NCollection_BaseSequence& theSeq,
              const Standard_Boolean isStart)
    {
      Init (theSeq, isStart);
    }


    void Init (const NCollection_BaseSequence& theSeq,
               const Standard_Boolean isStart = true)
    {
      myCurrent = (isStart ? theSeq.myFirstItem : 
# 74 "/usr/include/opencascade/NCollection_BaseSequence.hxx" 3 4
                                                  __null
# 74 "/usr/include/opencascade/NCollection_BaseSequence.hxx"
                                                      );
      myPrevious = (isStart ? 
# 75 "/usr/include/opencascade/NCollection_BaseSequence.hxx" 3 4
                             __null 
# 75 "/usr/include/opencascade/NCollection_BaseSequence.hxx"
                                  : theSeq.myLastItem);
    }


    void Previous()
    {
      myCurrent = myPrevious;
      if (myCurrent)
        myPrevious = myCurrent->Previous();
    }

  protected:
    NCollection_SeqNode* myCurrent;
    NCollection_SeqNode* myPrevious;
    friend class NCollection_BaseSequence;
  };

 public:


      Standard_Boolean IsEmpty () const {return (mySize == 0);}
      Standard_Integer Length () const {return mySize;}


      const opencascade::handle<NCollection_BaseAllocator>& Allocator() const
      { return myAllocator; }

 protected:


  NCollection_BaseSequence (const opencascade::handle<NCollection_BaseAllocator>& theAllocator) :
    myFirstItem (
# 106 "/usr/include/opencascade/NCollection_BaseSequence.hxx" 3 4
                       __null
# 106 "/usr/include/opencascade/NCollection_BaseSequence.hxx"
                           ),
    myLastItem (
# 107 "/usr/include/opencascade/NCollection_BaseSequence.hxx" 3 4
                       __null
# 107 "/usr/include/opencascade/NCollection_BaseSequence.hxx"
                           ),
    myCurrentItem (
# 108 "/usr/include/opencascade/NCollection_BaseSequence.hxx" 3 4
                       __null
# 108 "/usr/include/opencascade/NCollection_BaseSequence.hxx"
                           ),
    myCurrentIndex (0),
    mySize (0)
  {
    myAllocator = (theAllocator.IsNull() ? NCollection_BaseAllocator::CommonBaseAllocator() : theAllocator);
  }


  virtual ~NCollection_BaseSequence() {}

  void ClearSeq (NCollection_DelSeqNode fDel);
  void PAppend (NCollection_SeqNode *);
  void PAppend (NCollection_BaseSequence& S);
  void PPrepend (NCollection_SeqNode *);
  void PPrepend (NCollection_BaseSequence& S);
  void PInsertAfter(Iterator& thePosition,
                                      NCollection_SeqNode *);
  void PInsertAfter(const Standard_Integer Index,
                                      NCollection_SeqNode *);
  void PInsertAfter(const Standard_Integer Index,
                                      NCollection_BaseSequence& S);
  void PSplit (const Standard_Integer Index,
                                      NCollection_BaseSequence& Sub);
  void RemoveSeq (Iterator& thePosition,
                                      NCollection_DelSeqNode fDel);
  void RemoveSeq (const Standard_Integer Index,
                                      NCollection_DelSeqNode fDel);
  void RemoveSeq (const Standard_Integer From,
                                      const Standard_Integer To,
                                      NCollection_DelSeqNode fDel);
  void PReverse ();
  void PExchange (const Standard_Integer I,
                                      const Standard_Integer J) ;
  NCollection_SeqNode *
                         Find (const Standard_Integer) const;

 protected:


  opencascade::handle<NCollection_BaseAllocator> myAllocator;
  NCollection_SeqNode* myFirstItem;
  NCollection_SeqNode* myLastItem;
  NCollection_SeqNode* myCurrentItem;
  Standard_Integer myCurrentIndex;
  Standard_Integer mySize;

 private:


  NCollection_BaseSequence
                           (const NCollection_BaseSequence& Other);
  void Nullify()
  {
    myFirstItem = myLastItem = myCurrentItem = 
# 161 "/usr/include/opencascade/NCollection_BaseSequence.hxx" 3 4
                                              __null
# 161 "/usr/include/opencascade/NCollection_BaseSequence.hxx"
                                                  ;
    myCurrentIndex = mySize = 0;
  }

  friend class Iterator;
};
# 20 "/usr/include/opencascade/NCollection_Sequence.hxx" 2
# 29 "/usr/include/opencascade/NCollection_Sequence.hxx"
template <class TheItemType>
class NCollection_Sequence : public NCollection_BaseSequence
{
public:

  typedef TheItemType value_type;

public:

  class Node : public NCollection_SeqNode
  {
  public:

    Node (const TheItemType& theItem) :
      NCollection_SeqNode ()
      { myValue = theItem; }

    const TheItemType& Value () const { return myValue; }

    TheItemType& ChangeValue () { return myValue; }

  private:
    TheItemType myValue;
  };

 public:

  class Iterator : public NCollection_BaseSequence::Iterator
  {
  public:

    Iterator (void) {}

    Iterator (const NCollection_Sequence& theSeq,
               const Standard_Boolean isStart = true)
      : NCollection_BaseSequence::Iterator (theSeq, isStart) {}

    Standard_Boolean More (void) const
    { return (myCurrent!=
# 67 "/usr/include/opencascade/NCollection_Sequence.hxx" 3 4
                        __null
# 67 "/usr/include/opencascade/NCollection_Sequence.hxx"
                            ); }

    void Next (void)
    {
      if (myCurrent)
      {
        myPrevious = myCurrent;
        myCurrent = myCurrent->Next();
      }
    }

    const TheItemType& Value (void) const
    { return ((const Node *)myCurrent)->Value(); }

    TheItemType& ChangeValue (void) const
    { return ((Node *)myCurrent)->ChangeValue(); }

    Standard_Boolean IsEqual (const Iterator& theOther) const
    {
      return myCurrent == theOther.myCurrent;
    }
  };


  typedef NCollection_StlIterator<std::bidirectional_iterator_tag, Iterator, TheItemType, false> iterator;


  typedef NCollection_StlIterator<std::bidirectional_iterator_tag, Iterator, TheItemType, true> const_iterator;


  iterator begin() const { return Iterator (*this, true); }


  iterator end() const { Iterator anIter (*this, false); anIter.Next(); return anIter; }


  const_iterator cbegin() const { return Iterator (*this, true); }


  const_iterator cend() const { Iterator anIter (*this, false); anIter.Next(); return anIter; }

 public:



  NCollection_Sequence() : NCollection_BaseSequence(opencascade::handle<NCollection_BaseAllocator>()) {}


  explicit NCollection_Sequence (const opencascade::handle<NCollection_BaseAllocator>& theAllocator) : NCollection_BaseSequence(theAllocator) {}


  NCollection_Sequence (const NCollection_Sequence& theOther) :
    NCollection_BaseSequence(theOther.myAllocator)
  {
    Assign (theOther);
  }


  Standard_Integer Size (void) const
  { return mySize; }


  Standard_Integer Length (void) const
  { return mySize; }



  Standard_Integer Lower() const
  {
    return 1;
  }



  Standard_Integer Upper() const
  {
    return mySize;
  }


  Standard_Boolean IsEmpty (void) const
  { return (mySize==0); }


  void Reverse (void)
  { PReverse(); }


  void Exchange (const Standard_Integer I,
                 const Standard_Integer J )
  { PExchange(I, J); }


  static void delNode (NCollection_SeqNode * theNode,
                       opencascade::handle<NCollection_BaseAllocator>& theAl)
  {
    ((Node *) theNode)->~Node();
    theAl->Free(theNode);
  }


  void Clear (const opencascade::handle<NCollection_BaseAllocator>& theAllocator=0L)
  {
    ClearSeq (delNode);
    if (!theAllocator.IsNull())
      this->myAllocator = theAllocator;
  }



  NCollection_Sequence& Assign (const NCollection_Sequence& theOther)
  {
    if (this != &theOther)
    {
      Clear();
      appendSeq((const Node *)theOther.myFirstItem);
    }
    return * this;
  }


  NCollection_Sequence& operator= (const NCollection_Sequence& theOther)
  {
    return Assign (theOther);
  }


  void Remove (Iterator& thePosition)
  { RemoveSeq (thePosition, delNode); }


  void Remove (const Standard_Integer theIndex)
  { RemoveSeq (theIndex, delNode); }


  void Remove (const Standard_Integer theFromIndex,
               const Standard_Integer theToIndex)
  { RemoveSeq (theFromIndex, theToIndex, delNode); }


  void Append (const TheItemType& theItem)
  { PAppend (new (this->myAllocator) Node (theItem)); }


  void Append (NCollection_Sequence& theSeq)
  {
    if (this == &theSeq || theSeq.IsEmpty())
      return;
    if (this->myAllocator == theSeq.myAllocator)
    {


      PAppend(theSeq);
    }
    else
    {

      appendSeq((const Node *)theSeq.myFirstItem);
      theSeq.Clear();
    }
  }


  void Prepend (const TheItemType& theItem)
  { PPrepend (new (this->myAllocator) Node (theItem)); }


  void Prepend (NCollection_Sequence& theSeq)
  {
    if (this == &theSeq || theSeq.IsEmpty())
      return;
    if (this->myAllocator == theSeq.myAllocator)
    {


      PPrepend(theSeq);
    }
    else
    {

      prependSeq((const Node *)theSeq.myFirstItem, 1);
      theSeq.Clear();
    }
  }


  void InsertBefore (const Standard_Integer theIndex,
                     const TheItemType& theItem)
  { InsertAfter (theIndex-1, theItem); }


  void InsertBefore (const Standard_Integer theIndex,
                     NCollection_Sequence& theSeq)
  { InsertAfter (theIndex-1, theSeq); }


  void InsertAfter (Iterator& thePosition,
                     const TheItemType& theItem)
  { PInsertAfter (thePosition, new (this->myAllocator) Node (theItem)); }


  void InsertAfter (const Standard_Integer theIndex,
                     NCollection_Sequence& theSeq)
  {
    if (this == &theSeq || theSeq.IsEmpty())
      return;
    if (this->myAllocator == theSeq.myAllocator)
    {


      PInsertAfter(theIndex, theSeq);
    }
    else
    {

      prependSeq((const Node *)theSeq.myFirstItem, theIndex + 1);
      theSeq.Clear();
    }
  }


  void InsertAfter (const Standard_Integer theIndex,
                    const TheItemType& theItem)
  {
   
# 291 "/usr/include/opencascade/NCollection_Sequence.hxx"
#pragma GCC diagnostic push
# 291 "/usr/include/opencascade/NCollection_Sequence.hxx"
   
# 291 "/usr/include/opencascade/NCollection_Sequence.hxx"
#pragma GCC diagnostic ignored "-Wstrict-overflow"
# 291 "/usr/include/opencascade/NCollection_Sequence.hxx"
    if (theIndex < 0 || theIndex > mySize) throw Standard_OutOfRange("NCollection_Sequence::InsertAfter");
# 291 "/usr/include/opencascade/NCollection_Sequence.hxx"
#pragma GCC diagnostic pop
# 291 "/usr/include/opencascade/NCollection_Sequence.hxx"
    ;
    PInsertAfter (theIndex, new (this->myAllocator) Node (theItem));
  }


  void Split (const Standard_Integer theIndex, NCollection_Sequence& theSeq)
  {
    theSeq.Clear (this->myAllocator);
    PSplit (theIndex, theSeq);
  }


  const TheItemType& First () const
  {
    if (mySize == 0) throw Standard_NoSuchObject("NCollection_Sequence::First");;
    return ((const Node *) myFirstItem) -> Value();
  }


  TheItemType& ChangeFirst()
  {
    if (mySize == 0) throw Standard_NoSuchObject("NCollection_Sequence::ChangeFirst");;
    return ((Node* )myFirstItem)->ChangeValue();
  }


  const TheItemType& Last () const
  {
    if (mySize == 0) throw Standard_NoSuchObject("NCollection_Sequence::Last");;
    return ((const Node *) myLastItem) -> Value();
  }


  TheItemType& ChangeLast()
  {
    if (mySize == 0) throw Standard_NoSuchObject("NCollection_Sequence::ChangeLast");;
    return ((Node* )myLastItem)->ChangeValue();
  }


  const TheItemType& Value (const Standard_Integer theIndex) const
  {
   
# 333 "/usr/include/opencascade/NCollection_Sequence.hxx"
#pragma GCC diagnostic push
# 333 "/usr/include/opencascade/NCollection_Sequence.hxx"
   
# 333 "/usr/include/opencascade/NCollection_Sequence.hxx"
#pragma GCC diagnostic ignored "-Wstrict-overflow"
# 333 "/usr/include/opencascade/NCollection_Sequence.hxx"
    if (theIndex <= 0 || theIndex > mySize) throw Standard_OutOfRange("NCollection_Sequence::Value");
# 333 "/usr/include/opencascade/NCollection_Sequence.hxx"
#pragma GCC diagnostic pop
# 333 "/usr/include/opencascade/NCollection_Sequence.hxx"
    ;

    NCollection_Sequence * const aLocalTHIS = (NCollection_Sequence *) this;
    aLocalTHIS -> myCurrentItem = Find (theIndex);
    aLocalTHIS -> myCurrentIndex = theIndex;
    return ((const Node *) myCurrentItem) -> Value();
  }


  const TheItemType& operator() (const Standard_Integer theIndex) const
  { return Value(theIndex); }


  TheItemType& ChangeValue (const Standard_Integer theIndex)
  {
   
# 348 "/usr/include/opencascade/NCollection_Sequence.hxx"
#pragma GCC diagnostic push
# 348 "/usr/include/opencascade/NCollection_Sequence.hxx"
   
# 348 "/usr/include/opencascade/NCollection_Sequence.hxx"
#pragma GCC diagnostic ignored "-Wstrict-overflow"
# 348 "/usr/include/opencascade/NCollection_Sequence.hxx"
    if (theIndex <= 0 || theIndex > mySize) throw Standard_OutOfRange("NCollection_Sequence::ChangeValue");
# 348 "/usr/include/opencascade/NCollection_Sequence.hxx"
#pragma GCC diagnostic pop
# 348 "/usr/include/opencascade/NCollection_Sequence.hxx"
    ;

    myCurrentItem = Find (theIndex);
    myCurrentIndex = theIndex;
    return ((Node *) myCurrentItem) -> ChangeValue();
  }


  TheItemType& operator() (const Standard_Integer theIndex)
  { return ChangeValue(theIndex); }


  void SetValue (const Standard_Integer theIndex,
                 const TheItemType& theItem)
  { ChangeValue (theIndex) = theItem; }


  virtual ~NCollection_Sequence (void)
  { Clear(); }

 private:


  friend class Iterator;




  void appendSeq(const Node * pCur)
  {
    while (pCur)
    {
      Node* pNew = new (this->myAllocator) Node(pCur->Value());
      PAppend(pNew);
      pCur = (const Node *)pCur->Next();
    }
  }


  void prependSeq(const Node * pCur, Standard_Integer ind)
  {
    ind--;
    while (pCur)
    {
      Node* pNew = new (this->myAllocator) Node(pCur->Value());
      PInsertAfter(ind++, pNew);
      pCur = (const Node *)pCur->Next();
    }
  }

};
# 25 "/usr/include/opencascade/Graphic3d_ShaderProgram.hxx" 2


typedef NCollection_Sequence<opencascade::handle<Graphic3d_ShaderObject> > Graphic3d_ShaderObjectList;


typedef NCollection_Sequence<opencascade::handle<Graphic3d_ShaderVariable> > Graphic3d_ShaderVariableList;


typedef NCollection_Sequence<opencascade::handle<Graphic3d_ShaderAttribute> > Graphic3d_ShaderAttributeList;


class Graphic3d_ShaderProgram : public Standard_Transient
{
  public: typedef Standard_Transient base_type; static const char* get_type_name () { return "Graphic3d_ShaderProgram"; using direct_base_classes = opencascade::direct_base_class_as_tuple<std::tr2::direct_bases<Graphic3d_ShaderProgram>::type>::type; static_assert(opencascade::has_type<Standard_Transient, direct_base_classes>::type::value, "OCCT RTTI definition is incorrect: " "Standard_Transient" " is not direct base class of " "Graphic3d_ShaderProgram"); static_assert(&get_type_name == &Graphic3d_ShaderProgram::get_type_name, "OCCT RTTI definition is misplaced: current class is not " "Graphic3d_ShaderProgram"); } static const opencascade::handle<Standard_Type>& get_type_descriptor (); virtual const opencascade::handle<Standard_Type>& DynamicType() const override;
public:


  static const Standard_Integer THE_MAX_LIGHTS_DEFAULT = 8;


  static const Standard_Integer THE_MAX_CLIP_PLANES_DEFAULT = 8;


  static const Standard_Integer THE_NB_FRAG_OUTPUTS = 1;

public:


  Graphic3d_ShaderProgram();


  virtual ~Graphic3d_ShaderProgram();


  virtual Standard_Boolean IsDone() const;


  const TCollection_AsciiString& GetId() const { return myID; }




  void SetId (const TCollection_AsciiString& theId) { myID = theId; }


  const TCollection_AsciiString& Header() const { return myHeader; }
# 79 "/usr/include/opencascade/Graphic3d_ShaderProgram.hxx"
  void SetHeader (const TCollection_AsciiString& theHeader) { myHeader = theHeader; }


  void AppendToHeader (const TCollection_AsciiString& theHeaderLine)
  {
    if (!myHeader.IsEmpty())
    {
      myHeader += "\n";
    }
    myHeader += theHeaderLine;
  }




  Standard_Integer NbLightsMax() const { return myNbLightsMax; }


  void SetNbLightsMax (Standard_Integer theNbLights) { myNbLightsMax = theNbLights; }




  Standard_Integer NbClipPlanesMax() const { return myNbClipPlanesMax; }


  void SetNbClipPlanesMax (Standard_Integer theNbPlanes) { myNbClipPlanesMax = theNbPlanes; }


  Standard_Boolean AttachShader (const opencascade::handle<Graphic3d_ShaderObject>& theShader);


  Standard_Boolean DetachShader (const opencascade::handle<Graphic3d_ShaderObject>& theShader);


  const Graphic3d_ShaderObjectList& ShaderObjects() const { return myShaderObjects; }



  const Graphic3d_ShaderVariableList& Variables() const { return myVariables; }


  const Graphic3d_ShaderAttributeList& VertexAttributes() const { return myAttributes; }



  void SetVertexAttributes (const Graphic3d_ShaderAttributeList& theAttributes);



  Standard_Integer NbFragmentOutputs() const { return myNbFragOutputs; }



  void SetNbFragmentOutputs (const Standard_Integer theNbOutputs) { myNbFragOutputs = theNbOutputs; }


  Standard_Boolean HasAlphaTest() const { return myHasAlphaTest; }



  void SetAlphaTest (Standard_Boolean theAlphaTest) { myHasAlphaTest = theAlphaTest; }


  Standard_Boolean HasDefaultSampler() const { return myHasDefSampler; }


  void SetDefaultSampler (Standard_Boolean theHasDefSampler) { myHasDefSampler = theHasDefSampler; }


  Standard_Boolean HasWeightOitOutput() const { return myHasWeightOitOutput; }



  void SetWeightOitOutput (Standard_Boolean theOutput) { myHasWeightOitOutput = theOutput; }



  Standard_Boolean IsPBR() const { return myIsPBR; }


  void SetPBR (Standard_Boolean theIsPBR) { myIsPBR = theIsPBR; }


  Standard_Integer TextureSetBits() const { return myTextureSetBits; }


  void SetTextureSetBits (Standard_Integer theBits) { myTextureSetBits = theBits; }




  template<class T>
  Standard_Boolean PushVariable (const TCollection_AsciiString& theName,
                                 const T& theValue);


  void ClearVariables();


  Standard_Boolean PushVariableFloat (const TCollection_AsciiString& theName, const float theValue) { return PushVariable (theName, theValue); }


  Standard_Boolean PushVariableVec2 (const TCollection_AsciiString& theName, const Graphic3d_Vec2& theValue) { return PushVariable (theName, theValue); }


  Standard_Boolean PushVariableVec3 (const TCollection_AsciiString& theName, const Graphic3d_Vec3& theValue) { return PushVariable (theName, theValue); }


  Standard_Boolean PushVariableVec4 (const TCollection_AsciiString& theName, const Graphic3d_Vec4& theValue) { return PushVariable (theName, theValue); }


  Standard_Boolean PushVariableInt (const TCollection_AsciiString& theName, const int theValue) { return PushVariable (theName, theValue); }


  Standard_Boolean PushVariableVec2i (const TCollection_AsciiString& theName, const Graphic3d_Vec2i& theValue) { return PushVariable (theName, theValue); }


  Standard_Boolean PushVariableVec3i (const TCollection_AsciiString& theName, const Graphic3d_Vec3i& theValue) { return PushVariable (theName, theValue); }


  Standard_Boolean PushVariableVec4i (const TCollection_AsciiString& theName, const Graphic3d_Vec4i& theValue) { return PushVariable (theName, theValue); }

public:



  static const TCollection_AsciiString& ShadersFolder();

private:

  TCollection_AsciiString myID;
  Graphic3d_ShaderObjectList myShaderObjects;
  Graphic3d_ShaderVariableList myVariables;
  Graphic3d_ShaderAttributeList myAttributes;
  TCollection_AsciiString myHeader;
  Standard_Integer myNbLightsMax;
  Standard_Integer myNbClipPlanesMax;
  Standard_Integer myNbFragOutputs;
  Standard_Integer myTextureSetBits;
  Standard_Boolean myHasDefSampler;
  Standard_Boolean myHasAlphaTest;
  Standard_Boolean myHasWeightOitOutput;
  Standard_Boolean myIsPBR;

};

class Graphic3d_ShaderProgram; typedef opencascade::handle<Graphic3d_ShaderProgram> Handle_Graphic3d_ShaderProgram;





template<class T> inline
Standard_Boolean Graphic3d_ShaderProgram::PushVariable (const TCollection_AsciiString& theName,
                                                        const T& theValue)
{
  opencascade::handle<Graphic3d_ShaderVariable> aVariable = Graphic3d_ShaderVariable::Create (theName, theValue);
  if (aVariable.IsNull() || !aVariable->IsDone())
  {
    return false;
  }

  myVariables.Append (aVariable);
  return true;
}
# 31 "/usr/include/opencascade/Graphic3d_Aspects.hxx" 2
# 1 "/usr/include/opencascade/Graphic3d_TextureMap.hxx" 1
# 20 "/usr/include/opencascade/Graphic3d_TextureMap.hxx"
# 1 "/usr/include/opencascade/Graphic3d_TextureRoot.hxx" 1
# 22 "/usr/include/opencascade/Graphic3d_TextureRoot.hxx"
# 1 "/usr/include/opencascade/Graphic3d_TypeOfTexture.hxx" 1
# 21 "/usr/include/opencascade/Graphic3d_TypeOfTexture.hxx"
enum Graphic3d_TypeOfTexture
{
Graphic3d_TOT_1D,
Graphic3d_TOT_2D,
Graphic3d_TOT_2D_MIPMAP,
Graphic3d_TOT_CUBEMAP
};
# 23 "/usr/include/opencascade/Graphic3d_TextureRoot.hxx" 2





class Image_CompressedPixMap;
class Image_SupportedFormats;
class Graphic3d_TextureParams;


class Graphic3d_TextureRoot : public Standard_Transient
{
  public: typedef Standard_Transient base_type; static const char* get_type_name () { return "Graphic3d_TextureRoot"; using direct_base_classes = opencascade::direct_base_class_as_tuple<std::tr2::direct_bases<Graphic3d_TextureRoot>::type>::type; static_assert(opencascade::has_type<Standard_Transient, direct_base_classes>::type::value, "OCCT RTTI definition is incorrect: " "Standard_Transient" " is not direct base class of " "Graphic3d_TextureRoot"); static_assert(&get_type_name == &Graphic3d_TextureRoot::get_type_name, "OCCT RTTI definition is misplaced: current class is not " "Graphic3d_TextureRoot"); } static const opencascade::handle<Standard_Type>& get_type_descriptor (); virtual const opencascade::handle<Standard_Type>& DynamicType() const override;
public:



  static TCollection_AsciiString TexturesFolder();

public:


  ~Graphic3d_TextureRoot();



  virtual Standard_Boolean IsDone() const;



  const OSD_Path& Path() const { return myPath; }


  Graphic3d_TypeOfTexture Type() const { return myType; }
# 74 "/usr/include/opencascade/Graphic3d_TextureRoot.hxx"
  const TCollection_AsciiString& GetId() const { return myTexId; }


  Standard_Size Revision() const { return myRevision; }




  void UpdateRevision() { ++myRevision; }






  virtual opencascade::handle<Image_CompressedPixMap> GetCompressedImage (const opencascade::handle<Image_SupportedFormats>& theSupported);
# 98 "/usr/include/opencascade/Graphic3d_TextureRoot.hxx"
  virtual opencascade::handle<Image_PixMap> GetImage (const opencascade::handle<Image_SupportedFormats>& theSupported);


  const opencascade::handle<Graphic3d_TextureParams>& GetParams() const { return myParams; }
# 111 "/usr/include/opencascade/Graphic3d_TextureRoot.hxx"
  Standard_Boolean IsColorMap() const { return myIsColorMap; }


  void SetColorMap (Standard_Boolean theIsColor) { myIsColorMap = theIsColor; }


  Standard_Boolean IsTopDown() const { return myIsTopDown; }

protected:




  Graphic3d_TextureRoot(const TCollection_AsciiString& theFileName, const Graphic3d_TypeOfTexture theType);




  Graphic3d_TextureRoot(const opencascade::handle<Image_PixMap>& thePixmap, const Graphic3d_TypeOfTexture theType);


  void generateId();


  static void convertToCompatible (const opencascade::handle<Image_SupportedFormats>& theSupported,
                                                   const opencascade::handle<Image_PixMap>& theImage);


  virtual opencascade::handle<Image_PixMap> GetImage() const { return opencascade::handle<Image_PixMap>(); }

protected:

  opencascade::handle<Graphic3d_TextureParams> myParams;
  TCollection_AsciiString myTexId;
  opencascade::handle<Image_PixMap> myPixMap;
  OSD_Path myPath;
  Standard_Size myRevision;
  Graphic3d_TypeOfTexture myType;
  Standard_Boolean myIsColorMap;
  Standard_Boolean myIsTopDown;


};

class Graphic3d_TextureRoot; typedef opencascade::handle<Graphic3d_TextureRoot> Handle_Graphic3d_TextureRoot;
# 21 "/usr/include/opencascade/Graphic3d_TextureMap.hxx" 2


class TCollection_AsciiString;


class Graphic3d_TextureMap : public Graphic3d_TextureRoot
{
  public: typedef Graphic3d_TextureRoot base_type; static const char* get_type_name () { return "Graphic3d_TextureMap"; using direct_base_classes = opencascade::direct_base_class_as_tuple<std::tr2::direct_bases<Graphic3d_TextureMap>::type>::type; static_assert(opencascade::has_type<Graphic3d_TextureRoot, direct_base_classes>::type::value, "OCCT RTTI definition is incorrect: " "Graphic3d_TextureRoot" " is not direct base class of " "Graphic3d_TextureMap"); static_assert(&get_type_name == &Graphic3d_TextureMap::get_type_name, "OCCT RTTI definition is misplaced: current class is not " "Graphic3d_TextureMap"); } static const opencascade::handle<Standard_Type>& get_type_descriptor (); virtual const opencascade::handle<Standard_Type>& DynamicType() const override;
public:


  void EnableSmooth();


  Standard_Boolean IsSmoothed() const;


  void DisableSmooth();



  void EnableModulate();



  void DisableModulate();


  Standard_Boolean IsModulate() const;



  void EnableRepeat();



  void DisableRepeat();


  Standard_Boolean IsRepeat() const;



  Graphic3d_LevelOfTextureAnisotropy AnisoFilter() const;


  void SetAnisoFilter (const Graphic3d_LevelOfTextureAnisotropy theLevel);

protected:

  Graphic3d_TextureMap(const TCollection_AsciiString& theFileName, const Graphic3d_TypeOfTexture theType);

  Graphic3d_TextureMap(const opencascade::handle<Image_PixMap>& thePixMap, const Graphic3d_TypeOfTexture theType);

};

class Graphic3d_TextureMap; typedef opencascade::handle<Graphic3d_TextureMap> Handle_Graphic3d_TextureMap;
# 32 "/usr/include/opencascade/Graphic3d_Aspects.hxx" 2
# 1 "/usr/include/opencascade/Graphic3d_TextureSet.hxx" 1
# 22 "/usr/include/opencascade/Graphic3d_TextureSet.hxx"
class Graphic3d_TextureSet : public Standard_Transient
{
  public: typedef Standard_Transient base_type; static const char* get_type_name () { return "Graphic3d_TextureSet"; using direct_base_classes = opencascade::direct_base_class_as_tuple<std::tr2::direct_bases<Graphic3d_TextureSet>::type>::type; static_assert(opencascade::has_type<Standard_Transient, direct_base_classes>::type::value, "OCCT RTTI definition is incorrect: " "Standard_Transient" " is not direct base class of " "Graphic3d_TextureSet"); static_assert(&get_type_name == &Graphic3d_TextureSet::get_type_name, "OCCT RTTI definition is misplaced: current class is not " "Graphic3d_TextureSet"); } static const opencascade::handle<Standard_Type>& get_type_descriptor (); virtual const opencascade::handle<Standard_Type>& DynamicType() const override;
public:


  class Iterator : public NCollection_Array1<opencascade::handle<Graphic3d_TextureMap> >::Iterator
  {
  public:

    Iterator() {}


    Iterator (const opencascade::handle<Graphic3d_TextureSet>& theSet)
    {
      if (!theSet.IsNull())
      {
        NCollection_Array1<opencascade::handle<Graphic3d_TextureMap> >::Iterator::Init (theSet->myTextures);
      }
    }
  };

public:


  Graphic3d_TextureSet() {}


  Graphic3d_TextureSet (Standard_Integer theNbTextures)
  : myTextures (0, theNbTextures - 1) {}


  Graphic3d_TextureSet (const opencascade::handle<Graphic3d_TextureMap>& theTexture)
  : myTextures (0, 0)
  {
    myTextures.ChangeFirst() = theTexture;
  }


  Standard_Boolean IsEmpty() const { return myTextures.IsEmpty(); }


  Standard_Integer Size() const { return myTextures.Size(); }


  Standard_Integer Lower() const { return myTextures.Lower(); }


  Standard_Integer Upper() const { return myTextures.Upper(); }


  const opencascade::handle<Graphic3d_TextureMap>& First() const { return myTextures.First(); }


  void SetFirst (const opencascade::handle<Graphic3d_TextureMap>& theTexture) { myTextures.ChangeFirst() = theTexture; }


  const opencascade::handle<Graphic3d_TextureMap>& Value (Standard_Integer theIndex) const { return myTextures.Value (theIndex); }


  void SetValue (Standard_Integer theIndex,
                 const opencascade::handle<Graphic3d_TextureMap>& theTexture) { myTextures.SetValue (theIndex, theTexture); }

protected:

  NCollection_Array1<opencascade::handle<Graphic3d_TextureMap> > myTextures;

};
# 33 "/usr/include/opencascade/Graphic3d_Aspects.hxx" 2
# 1 "/usr/include/opencascade/Graphic3d_TypeOfShadingModel.hxx" 1
# 21 "/usr/include/opencascade/Graphic3d_TypeOfShadingModel.hxx"
enum Graphic3d_TypeOfShadingModel
{

  Graphic3d_TOSM_DEFAULT = -1,




  Graphic3d_TOSM_UNLIT = 0,





  Graphic3d_TOSM_FACET,






  Graphic3d_TOSM_VERTEX,




  Graphic3d_TOSM_FRAGMENT,


  Graphic3d_TOSM_PBR,


  Graphic3d_TOSM_PBR_FACET,


  Graphic3d_TOSM_NONE = Graphic3d_TOSM_UNLIT,
  V3d_COLOR = Graphic3d_TOSM_NONE,
  V3d_FLAT = Graphic3d_TOSM_FACET,
  V3d_GOURAUD = Graphic3d_TOSM_VERTEX,
  V3d_PHONG = Graphic3d_TOSM_FRAGMENT
};

enum
{

  Graphic3d_TypeOfShadingModel_NB = Graphic3d_TOSM_PBR_FACET + 1
};
# 34 "/usr/include/opencascade/Graphic3d_Aspects.hxx" 2
# 1 "/usr/include/opencascade/TCollection_HAsciiString.hxx" 1
# 31 "/usr/include/opencascade/TCollection_HAsciiString.hxx"
class Standard_NullObject;
class Standard_OutOfRange;
class Standard_NumericError;
class Standard_NegativeValue;
class TCollection_AsciiString;
class TCollection_HExtendedString;


class TCollection_HAsciiString;
class TCollection_HAsciiString; typedef opencascade::handle<TCollection_HAsciiString> Handle_TCollection_HAsciiString;
# 50 "/usr/include/opencascade/TCollection_HAsciiString.hxx"
class TCollection_HAsciiString : public Standard_Transient
{

public:



  TCollection_HAsciiString();


  TCollection_HAsciiString(const Standard_CString message);


  TCollection_HAsciiString(const Standard_Character aChar);



  TCollection_HAsciiString(const Standard_Integer length, const Standard_Character filler);


  TCollection_HAsciiString(const Standard_Integer value);


  TCollection_HAsciiString(const Standard_Real value);


  TCollection_HAsciiString(const TCollection_AsciiString& aString);


  TCollection_HAsciiString(const opencascade::handle<TCollection_HAsciiString>& aString);





  TCollection_HAsciiString(const opencascade::handle<TCollection_HExtendedString>& aString, const Standard_Character replaceNonAscii);


    void AssignCat (const Standard_CString other);



    void AssignCat (const opencascade::handle<TCollection_HAsciiString>& other);
# 101 "/usr/include/opencascade/TCollection_HAsciiString.hxx"
  void Capitalize();
# 115 "/usr/include/opencascade/TCollection_HAsciiString.hxx"
  opencascade::handle<TCollection_HAsciiString> Cat (const Standard_CString other) const;




  opencascade::handle<TCollection_HAsciiString> Cat (const opencascade::handle<TCollection_HAsciiString>& other) const;
# 137 "/usr/include/opencascade/TCollection_HAsciiString.hxx"
  void Center (const Standard_Integer Width, const Standard_Character Filler);
# 153 "/usr/include/opencascade/TCollection_HAsciiString.hxx"
  void ChangeAll (const Standard_Character aChar, const Standard_Character NewChar, const Standard_Boolean CaseSensitive = true);



  void Clear();
# 172 "/usr/include/opencascade/TCollection_HAsciiString.hxx"
  Standard_Integer FirstLocationInSet (const opencascade::handle<TCollection_HAsciiString>& Set, const Standard_Integer FromIndex, const Standard_Integer ToIndex) const;
# 187 "/usr/include/opencascade/TCollection_HAsciiString.hxx"
  Standard_Integer FirstLocationNotInSet (const opencascade::handle<TCollection_HAsciiString>& Set, const Standard_Integer FromIndex, const Standard_Integer ToIndex) const;
# 197 "/usr/include/opencascade/TCollection_HAsciiString.hxx"
  void Insert (const Standard_Integer where, const Standard_Character what);


  void Insert (const Standard_Integer where, const Standard_CString what);


  void Insert (const Standard_Integer where, const opencascade::handle<TCollection_HAsciiString>& what);







  void InsertAfter (const Standard_Integer Index, const opencascade::handle<TCollection_HAsciiString>& other);
# 220 "/usr/include/opencascade/TCollection_HAsciiString.hxx"
  void InsertBefore (const Standard_Integer Index, const opencascade::handle<TCollection_HAsciiString>& other);


  Standard_Boolean IsEmpty() const;


  Standard_Boolean IsLess (const opencascade::handle<TCollection_HAsciiString>& other) const;


  Standard_Boolean IsGreater (const opencascade::handle<TCollection_HAsciiString>& other) const;




  Standard_Integer IntegerValue() const;


  Standard_Boolean IsIntegerValue() const;


  Standard_Boolean IsRealValue() const;




  Standard_Boolean IsAscii() const;



  Standard_Boolean IsDifferent (const opencascade::handle<TCollection_HAsciiString>& S) const;



  Standard_Boolean IsSameString (const opencascade::handle<TCollection_HAsciiString>& S) const;



  Standard_Boolean IsSameString (const opencascade::handle<TCollection_HAsciiString>& S, const Standard_Boolean CaseSensitive) const;


  void LeftAdjust();
# 272 "/usr/include/opencascade/TCollection_HAsciiString.hxx"
  void LeftJustify (const Standard_Integer Width, const Standard_Character Filler);



    Standard_Integer Length() const;
# 290 "/usr/include/opencascade/TCollection_HAsciiString.hxx"
  Standard_Integer Location (const opencascade::handle<TCollection_HAsciiString>& other, const Standard_Integer FromIndex, const Standard_Integer ToIndex) const;
# 303 "/usr/include/opencascade/TCollection_HAsciiString.hxx"
  Standard_Integer Location (const Standard_Integer N, const Standard_Character C, const Standard_Integer FromIndex, const Standard_Integer ToIndex) const;


  void LowerCase();







  void Prepend (const opencascade::handle<TCollection_HAsciiString>& other);


  void Print (Standard_OStream& astream) const;





  Standard_Real RealValue() const;







  void RemoveAll (const Standard_Character C, const Standard_Boolean CaseSensitive);


  void RemoveAll (const Standard_Character what);







  void Remove (const Standard_Integer where, const Standard_Integer ahowmany = 1);


  void RightAdjust();
# 357 "/usr/include/opencascade/TCollection_HAsciiString.hxx"
  void RightJustify (const Standard_Integer Width, const Standard_Character Filler);







  Standard_Integer Search (const Standard_CString what) const;




  Standard_Integer Search (const opencascade::handle<TCollection_HAsciiString>& what) const;







  Standard_Integer SearchFromEnd (const Standard_CString what) const;




  Standard_Integer SearchFromEnd (const opencascade::handle<TCollection_HAsciiString>& what) const;







  void SetValue (const Standard_Integer where, const Standard_Character what);







  void SetValue (const Standard_Integer where, const Standard_CString what);


  void SetValue (const Standard_Integer where, const opencascade::handle<TCollection_HAsciiString>& what);





  opencascade::handle<TCollection_HAsciiString> Split (const Standard_Integer where);
# 422 "/usr/include/opencascade/TCollection_HAsciiString.hxx"
  opencascade::handle<TCollection_HAsciiString> SubString (const Standard_Integer FromIndex, const Standard_Integer ToIndex) const;




    Standard_CString ToCString() const;
# 444 "/usr/include/opencascade/TCollection_HAsciiString.hxx"
  opencascade::handle<TCollection_HAsciiString> Token (const Standard_CString separators = " \t", const Standard_Integer whichone = 1) const;



  void Trunc (const Standard_Integer ahowmany);


  void UpperCase();



  Standard_Integer UsefullLength() const;







  Standard_Character Value (const Standard_Integer where) const;


    const TCollection_AsciiString& String() const;

  Standard_Boolean IsSameState (const opencascade::handle<TCollection_HAsciiString>& other) const;




  public: typedef Standard_Transient base_type; static const char* get_type_name () { return "TCollection_HAsciiString"; using direct_base_classes = opencascade::direct_base_class_as_tuple<std::tr2::direct_bases<TCollection_HAsciiString>::type>::type; static_assert(opencascade::has_type<Standard_Transient, direct_base_classes>::type::value, "OCCT RTTI definition is incorrect: " "Standard_Transient" " is not direct base class of " "TCollection_HAsciiString"); static_assert(&get_type_name == &TCollection_HAsciiString::get_type_name, "OCCT RTTI definition is misplaced: current class is not " "TCollection_HAsciiString"); } static const opencascade::handle<Standard_Type>& get_type_descriptor (); virtual const opencascade::handle<Standard_Type>& DynamicType() const override;

protected:




private:


  TCollection_AsciiString myString;


};


# 1 "/usr/include/opencascade/TCollection_HAsciiString.lxx" 1
# 18 "/usr/include/opencascade/TCollection_HAsciiString.lxx"
inline void TCollection_HAsciiString::AssignCat(const Standard_CString other)
{myString.AssignCat(other);}




inline void TCollection_HAsciiString::AssignCat
                      (const opencascade::handle<TCollection_HAsciiString>& other)
{myString.AssignCat(other->String());}





inline Standard_Integer TCollection_HAsciiString::Length() const
{return myString.mylength;}




inline const TCollection_AsciiString& TCollection_HAsciiString::String() const
{return myString;}


inline Standard_CString TCollection_HAsciiString::ToCString() const
{ return myString.ToCString(); }
# 490 "/usr/include/opencascade/TCollection_HAsciiString.hxx" 2
# 35 "/usr/include/opencascade/Graphic3d_Aspects.hxx" 2


class Graphic3d_Aspects : public Standard_Transient
{
  public: typedef Standard_Transient base_type; static const char* get_type_name () { return "Graphic3d_Aspects"; using direct_base_classes = opencascade::direct_base_class_as_tuple<std::tr2::direct_bases<Graphic3d_Aspects>::type>::type; static_assert(opencascade::has_type<Standard_Transient, direct_base_classes>::type::value, "OCCT RTTI definition is incorrect: " "Standard_Transient" " is not direct base class of " "Graphic3d_Aspects"); static_assert(&get_type_name == &Graphic3d_Aspects::get_type_name, "OCCT RTTI definition is misplaced: current class is not " "Graphic3d_Aspects"); } static const opencascade::handle<Standard_Type>& get_type_descriptor (); virtual const opencascade::handle<Standard_Type>& DynamicType() const override;
public:


  Graphic3d_Aspects();


  Aspect_InteriorStyle InteriorStyle() const { return myInteriorStyle; }


  void SetInteriorStyle (const Aspect_InteriorStyle theStyle) { myInteriorStyle = theStyle; }



  Graphic3d_TypeOfShadingModel ShadingModel() const { return myShadingModel; }


  void SetShadingModel (const Graphic3d_TypeOfShadingModel theShadingModel) { myShadingModel = theShadingModel; }


  Graphic3d_AlphaMode AlphaMode() const { return myAlphaMode; }



  Standard_ShortReal AlphaCutoff() const { return myAlphaCutoff; }


  void SetAlphaMode (Graphic3d_AlphaMode theMode, Standard_ShortReal theAlphaCutoff = 0.5f)
  {
    myAlphaMode = theMode;
    myAlphaCutoff = theAlphaCutoff;
  }


  const Quantity_ColorRGBA& ColorRGBA() const { return myInteriorColor; }


  const Quantity_Color& Color() const { return myInteriorColor.GetRGB(); }


  void SetColor (const Quantity_Color& theColor) { myInteriorColor.SetRGB(theColor); }


  const Quantity_Color& InteriorColor() const { return myInteriorColor.GetRGB(); }


  const Quantity_ColorRGBA& InteriorColorRGBA() const { return myInteriorColor; }


  void SetInteriorColor (const Quantity_Color& theColor) { myInteriorColor.SetRGB (theColor); }


  void SetInteriorColor (const Quantity_ColorRGBA& theColor) { myInteriorColor = theColor; }


  const Quantity_Color& BackInteriorColor() const { return myBackInteriorColor.GetRGB(); }


  const Quantity_ColorRGBA& BackInteriorColorRGBA() const { return myBackInteriorColor; }


  void SetBackInteriorColor (const Quantity_Color& theColor) { myBackInteriorColor.SetRGB (theColor); }


  void SetBackInteriorColor (const Quantity_ColorRGBA& theColor) { myBackInteriorColor = theColor; }


  const Graphic3d_MaterialAspect& FrontMaterial() const { return myFrontMaterial; }


  Graphic3d_MaterialAspect& ChangeFrontMaterial() { return myFrontMaterial; }


  void SetFrontMaterial (const Graphic3d_MaterialAspect& theMaterial) { myFrontMaterial = theMaterial; }


  const Graphic3d_MaterialAspect& BackMaterial() const { return myBackMaterial; }


  Graphic3d_MaterialAspect& ChangeBackMaterial() { return myBackMaterial; }


  void SetBackMaterial (const Graphic3d_MaterialAspect& theMaterial) { myBackMaterial = theMaterial; }


  bool ToSuppressBackFaces() const { return myToSuppressBackFaces; }


  void SetSuppressBackFaces (bool theToSuppress) { myToSuppressBackFaces = theToSuppress; }


  bool BackFace() const { return myToSuppressBackFaces; }


  void AllowBackFace() { myToSuppressBackFaces = false; }




  void SuppressBackFace() { myToSuppressBackFaces = true; }


  bool Distinguish() const { return myToDistinguishMaterials; }


  void SetDistinguish (bool toDistinguish) { myToDistinguishMaterials = toDistinguish; }


  void SetDistinguishOn() { myToDistinguishMaterials = true; }


  void SetDistinguishOff() { myToDistinguishMaterials = false; }


  const opencascade::handle<Graphic3d_ShaderProgram>& ShaderProgram() const { return myProgram; }


  void SetShaderProgram (const opencascade::handle<Graphic3d_ShaderProgram>& theProgram) { myProgram = theProgram; }


  const opencascade::handle<Graphic3d_TextureSet>& TextureSet() const { return myTextureSet; }


  void SetTextureSet (const opencascade::handle<Graphic3d_TextureSet>& theTextures) { myTextureSet = theTextures; }



  opencascade::handle<Graphic3d_TextureMap> TextureMap() const
  {
    return !myTextureSet.IsNull() && !myTextureSet->IsEmpty()
          ? myTextureSet->First()
          : opencascade::handle<Graphic3d_TextureMap>();
  }




  void SetTextureMap (const opencascade::handle<Graphic3d_TextureMap>& theTexture);


  bool ToMapTexture() const { return myToMapTexture; }


  bool TextureMapState() const { return myToMapTexture; }


  void SetTextureMapOn (bool theToMap) { myToMapTexture = theToMap; }


  void SetTextureMapOn() { myToMapTexture = true; }


  void SetTextureMapOff() { myToMapTexture = false; }


  const Graphic3d_PolygonOffset& PolygonOffset() const { return myPolygonOffset; }


  void SetPolygonOffset (const Graphic3d_PolygonOffset& theOffset) { myPolygonOffset = theOffset; }


  void PolygonOffsets (Standard_Integer& theMode,
                       Standard_ShortReal& theFactor,
                       Standard_ShortReal& theUnits) const
  {
    theMode = myPolygonOffset.Mode;
    theFactor = myPolygonOffset.Factor;
    theUnits = myPolygonOffset.Units;
  }
# 225 "/usr/include/opencascade/Graphic3d_Aspects.hxx"
  void SetPolygonOffsets (const Standard_Integer theMode,
                          const Standard_ShortReal theFactor = 1.0f,
                          const Standard_ShortReal theUnits = 0.0f)
  {
    myPolygonOffset.Mode = (Aspect_PolygonOffsetMode )(theMode & Aspect_POM_Mask);
    myPolygonOffset.Factor = theFactor;
    myPolygonOffset.Units = theUnits;
  }


public:


  Aspect_TypeOfLine LineType() const { return myLineType; }


  void SetLineType (Aspect_TypeOfLine theType)
  {
    myLineType = theType;
    myLinePattern = DefaultLinePatternForType (theType);
  }


  uint16_t LinePattern() const { return myLinePattern; }


  void SetLinePattern (uint16_t thePattern)
  {
    myLineType = DefaultLineTypeForPattern (thePattern);
    myLinePattern = thePattern;
  }


  uint16_t LineStippleFactor() const { return myLineFactor; }


  void SetLineStippleFactor (uint16_t theFactor)
  {
    if (theFactor == 0 || theFactor > 256)
    {
      throw Standard_OutOfRange ("Graphic3d_Aspects::SetLineStippleFactor(), bad factor value");
    }
    myLineFactor = theFactor;
  }


  Standard_ShortReal LineWidth() const { return myLineWidth; }



  void SetLineWidth (Standard_ShortReal theWidth)
  {
    if (theWidth <= 0.0f)
    {
      throw Standard_OutOfRange ("Bad value for EdgeLineWidth");
    }
    myLineWidth = theWidth;
  }


  static uint16_t DefaultLinePatternForType (Aspect_TypeOfLine theType)
  {
    switch (theType)
    {
      case Aspect_TOL_DASH: return 0xFFC0;
      case Aspect_TOL_DOT: return 0xCCCC;
      case Aspect_TOL_DOTDASH: return 0xFF18;
      case Aspect_TOL_EMPTY: return 0x0000;
      case Aspect_TOL_SOLID: return 0xFFFF;
      case Aspect_TOL_USERDEFINED: return 0xFF24;
    }
    return 0xFFFF;
  }


  static Aspect_TypeOfLine DefaultLineTypeForPattern (uint16_t thePattern)
  {
    switch (thePattern)
    {
      case 0x0000: return Aspect_TOL_EMPTY;
      case 0xFFC0: return Aspect_TOL_DASH;
      case 0xCCCC: return Aspect_TOL_DOT;
      case 0xFF18: return Aspect_TOL_DOTDASH;
      case 0xFFFF: return Aspect_TOL_SOLID;
      case 0xFF24: return Aspect_TOL_USERDEFINED;
    }
    return Aspect_TOL_USERDEFINED;
  }


public:


  Aspect_TypeOfMarker MarkerType() const { return myMarkerType; }


  void SetMarkerType (Aspect_TypeOfMarker theType) { myMarkerType = theType; }


  Standard_ShortReal MarkerScale() const { return myMarkerScale; }





  void SetMarkerScale (const Standard_ShortReal theScale)
  {
    if (theScale <= 0.0f)
    {
      throw Standard_OutOfRange ("Bad value for MarkerScale");
    }
    myMarkerScale = theScale;
  }



  const opencascade::handle<Graphic3d_MarkerImage>& MarkerImage() const { return myMarkerImage; }


  void SetMarkerImage (const opencascade::handle<Graphic3d_MarkerImage>& theImage) { myMarkerImage = theImage; }


  bool IsMarkerSprite() const
  {
    if (myMarkerType == Aspect_TOM_POINT
     || myMarkerType == Aspect_TOM_EMPTY)
    {
      return false;
    }

    return myMarkerType != Aspect_TOM_USERDEFINED
       || !myMarkerImage.IsNull();
  }


public:


  const opencascade::handle<TCollection_HAsciiString>& TextFont() const { return myTextFont; }


  void SetTextFont (const opencascade::handle<TCollection_HAsciiString>& theFont) { myTextFont = theFont; }


  Font_FontAspect TextFontAspect() const { return myTextFontAspect; }


  void SetTextFontAspect (Font_FontAspect theFontAspect) { myTextFontAspect = theFontAspect; }


  Aspect_TypeOfDisplayText TextDisplayType() const { return myTextDisplayType; }


  void SetTextDisplayType (Aspect_TypeOfDisplayText theType) { myTextDisplayType = theType; }


  const Quantity_ColorRGBA& ColorSubTitleRGBA() const { return myEdgeColor; }


  const Quantity_Color& ColorSubTitle() const { return myEdgeColor.GetRGB(); }


  void SetColorSubTitle (const Quantity_Color& theColor) { myEdgeColor.SetRGB (theColor); }


  void SetColorSubTitle (const Quantity_ColorRGBA& theColor) { myEdgeColor = theColor; }


  bool IsTextZoomable() const { return myIsTextZoomable; }


  void SetTextZoomable (bool theFlag) { myIsTextZoomable = theFlag; }


  Aspect_TypeOfStyleText TextStyle() const { return myTextStyle; }


  void SetTextStyle (Aspect_TypeOfStyleText theStyle) { myTextStyle = theStyle; }


  Standard_ShortReal TextAngle() const { return myTextAngle; }


  void SetTextAngle (Standard_ShortReal theAngle) { myTextAngle = (Standard_ShortReal )theAngle; }


public:


  bool ToDrawEdges() const { return myToDrawEdges && myLineType != Aspect_TOL_EMPTY; }


  void SetDrawEdges (bool theToDraw)
  {
    myToDrawEdges = theToDraw;
    if (myLineType == Aspect_TOL_EMPTY)
    {
      myLineType = Aspect_TOL_SOLID;
    }
  }


  void SetEdgeOn() { SetDrawEdges (true); }


  void SetEdgeOff() { SetDrawEdges (false); }


  const Quantity_Color& EdgeColor() const { return myEdgeColor.GetRGB(); }


  const Quantity_ColorRGBA& EdgeColorRGBA() const { return myEdgeColor; }


  void SetEdgeColor (const Quantity_Color& theColor) { myEdgeColor.SetRGB (theColor); }


  void SetEdgeColor (const Quantity_ColorRGBA& theColor) { myEdgeColor = theColor; }


  Aspect_TypeOfLine EdgeLineType() const { return myLineType; }


  void SetEdgeLineType (Aspect_TypeOfLine theType) { SetLineType (theType); }


  Standard_ShortReal EdgeWidth() const { return myLineWidth; }


  void SetEdgeWidth (Standard_Real theWidth) { SetLineWidth ((Standard_ShortReal )theWidth); }
# 463 "/usr/include/opencascade/Graphic3d_Aspects.hxx"
  bool ToSkipFirstEdge() const { return myToSkipFirstEdge; }


  void SetSkipFirstEdge (bool theToSkipFirstEdge) { myToSkipFirstEdge = theToSkipFirstEdge; }


  bool ToDrawSilhouette() const { return myToDrawSilhouette; }


  void SetDrawSilhouette (bool theToDraw) { myToDrawSilhouette = theToDraw; }

public:


  const opencascade::handle<Graphic3d_HatchStyle>& HatchStyle() const { return myHatchStyle; }


  void SetHatchStyle (const opencascade::handle<Graphic3d_HatchStyle>& theStyle) { myHatchStyle = theStyle; }



  void SetHatchStyle (const Aspect_HatchStyle theStyle)
  {
    if (theStyle == Aspect_HS_SOLID)
    {
      myHatchStyle.Nullify();
      return;
    }

    myHatchStyle = new Graphic3d_HatchStyle (theStyle);
  }

public:


  bool IsEqual (const Graphic3d_Aspects& theOther)
  {
    if (this == &theOther)
    {
      return true;
    }

    return myProgram == theOther.myProgram
        && myTextureSet == theOther.myTextureSet
        && myMarkerImage == theOther.myMarkerImage
        && myInteriorColor == theOther.myInteriorColor
        && myBackInteriorColor == theOther.myBackInteriorColor
        && myFrontMaterial == theOther.myFrontMaterial
        && myBackMaterial == theOther.myBackMaterial
        && myInteriorStyle == theOther.myInteriorStyle
        && myShadingModel == theOther.myShadingModel
        && myAlphaMode == theOther.myAlphaMode
        && myAlphaCutoff == theOther.myAlphaCutoff
        && myLineType == theOther.myLineType
        && myEdgeColor == theOther.myEdgeColor
        && myLineWidth == theOther.myLineWidth
        && myLineFactor == theOther.myLineFactor
        && myLinePattern == theOther.myLinePattern
        && myMarkerType == theOther.myMarkerType
        && myMarkerScale == theOther.myMarkerScale
        && myHatchStyle == theOther.myHatchStyle
        && myTextFont == theOther.myTextFont
        && myPolygonOffset == theOther.myPolygonOffset
        && myTextStyle == theOther.myTextStyle
        && myTextDisplayType == theOther.myTextDisplayType
        && myTextFontAspect == theOther.myTextFontAspect
        && myTextAngle == theOther.myTextAngle
        && myToSkipFirstEdge == theOther.myToSkipFirstEdge
        && myToDistinguishMaterials == theOther.myToDistinguishMaterials
        && myToDrawEdges == theOther.myToDrawEdges
        && myToDrawSilhouette == theOther.myToDrawSilhouette
        && myToSuppressBackFaces == theOther.myToSuppressBackFaces
        && myToMapTexture == theOther.myToMapTexture
        && myIsTextZoomable == theOther.myIsTextZoomable;
  }


  virtual void DumpJson (Standard_OStream& theOStream, Standard_Integer theDepth = -1) const;


protected:

  opencascade::handle<Graphic3d_ShaderProgram> myProgram;
  opencascade::handle<Graphic3d_TextureSet> myTextureSet;
  opencascade::handle<Graphic3d_MarkerImage> myMarkerImage;
  opencascade::handle<Graphic3d_HatchStyle> myHatchStyle;
  opencascade::handle<TCollection_HAsciiString> myTextFont;
  Graphic3d_MaterialAspect myFrontMaterial;
  Graphic3d_MaterialAspect myBackMaterial;

  Quantity_ColorRGBA myInteriorColor;
  Quantity_ColorRGBA myBackInteriorColor;
  Quantity_ColorRGBA myEdgeColor;

  Graphic3d_PolygonOffset myPolygonOffset;
  Aspect_InteriorStyle myInteriorStyle;
  Graphic3d_TypeOfShadingModel myShadingModel;
  Graphic3d_AlphaMode myAlphaMode;
  Standard_ShortReal myAlphaCutoff;

  Aspect_TypeOfLine myLineType;
  Standard_ShortReal myLineWidth;
  uint16_t myLineFactor;
  uint16_t myLinePattern;

  Aspect_TypeOfMarker myMarkerType;
  Standard_ShortReal myMarkerScale;

  Aspect_TypeOfStyleText myTextStyle;
  Aspect_TypeOfDisplayText myTextDisplayType;
  Font_FontAspect myTextFontAspect;
  Standard_ShortReal myTextAngle;

  bool myToSkipFirstEdge;
  bool myToDistinguishMaterials;
  bool myToDrawEdges;
  bool myToDrawSilhouette;
  bool myToSuppressBackFaces;
  bool myToMapTexture;
  bool myIsTextZoomable;

};

class Graphic3d_Aspects; typedef opencascade::handle<Graphic3d_Aspects> Handle_Graphic3d_Aspects;
# 21 "/usr/include/opencascade/Graphic3d_AspectFillArea3d.hxx" 2


class Graphic3d_AspectFillArea3d : public Graphic3d_Aspects
{
  public: typedef Graphic3d_Aspects base_type; static const char* get_type_name () { return "Graphic3d_AspectFillArea3d"; using direct_base_classes = opencascade::direct_base_class_as_tuple<std::tr2::direct_bases<Graphic3d_AspectFillArea3d>::type>::type; static_assert(opencascade::has_type<Graphic3d_Aspects, direct_base_classes>::type::value, "OCCT RTTI definition is incorrect: " "Graphic3d_Aspects" " is not direct base class of " "Graphic3d_AspectFillArea3d"); static_assert(&get_type_name == &Graphic3d_AspectFillArea3d::get_type_name, "OCCT RTTI definition is misplaced: current class is not " "Graphic3d_AspectFillArea3d"); } static const opencascade::handle<Standard_Type>& get_type_descriptor (); virtual const opencascade::handle<Standard_Type>& DynamicType() const override;
public:
# 43 "/usr/include/opencascade/Graphic3d_AspectFillArea3d.hxx"
  Graphic3d_AspectFillArea3d();






  Graphic3d_AspectFillArea3d (const Aspect_InteriorStyle theInterior,
                                              const Quantity_Color& theInteriorColor,
                                              const Quantity_Color& theEdgeColor,
                                              const Aspect_TypeOfLine theEdgeLineType,
                                              const Standard_Real theEdgeWidth,
                                              const Graphic3d_MaterialAspect& theFrontMaterial,
                                              const Graphic3d_MaterialAspect& theBackMaterial);

public:

  __attribute__((deprecated("Deprecated method, ToDrawEdges() should be used instead")))
  bool Edge() const { return ToDrawEdges(); }

};

class Graphic3d_AspectFillArea3d; typedef opencascade::handle<Graphic3d_AspectFillArea3d> Handle_Graphic3d_AspectFillArea3d;
# 21 "/usr/include/opencascade/Graphic3d_PresentationAttributes.hxx" 2
# 1 "/usr/include/opencascade/Graphic3d_ZLayerId.hxx" 1
# 21 "/usr/include/opencascade/Graphic3d_ZLayerId.hxx"
typedef Standard_Integer Graphic3d_ZLayerId;




enum
{
  Graphic3d_ZLayerId_UNKNOWN = -1,
  Graphic3d_ZLayerId_Default = 0,
  Graphic3d_ZLayerId_Top = -2,
  Graphic3d_ZLayerId_Topmost = -3,
  Graphic3d_ZLayerId_TopOSD = -4,
  Graphic3d_ZLayerId_BotOSD = -5
};
# 22 "/usr/include/opencascade/Graphic3d_PresentationAttributes.hxx" 2





class Graphic3d_PresentationAttributes : public Standard_Transient
{
  public: typedef Standard_Transient base_type; static const char* get_type_name () { return "Graphic3d_PresentationAttributes"; using direct_base_classes = opencascade::direct_base_class_as_tuple<std::tr2::direct_bases<Graphic3d_PresentationAttributes>::type>::type; static_assert(opencascade::has_type<Standard_Transient, direct_base_classes>::type::value, "OCCT RTTI definition is incorrect: " "Standard_Transient" " is not direct base class of " "Graphic3d_PresentationAttributes"); static_assert(&get_type_name == &Graphic3d_PresentationAttributes::get_type_name, "OCCT RTTI definition is misplaced: current class is not " "Graphic3d_PresentationAttributes"); } static const opencascade::handle<Standard_Type>& get_type_descriptor (); virtual const opencascade::handle<Standard_Type>& DynamicType() const override;
public:


  Graphic3d_PresentationAttributes()
  : myBasicColor (Quantity_NOC_WHITE),
    myHiMethod (Aspect_TOHM_COLOR),
    myZLayer (Graphic3d_ZLayerId_Default),
    myDispMode (0)
  {

  }


  virtual ~Graphic3d_PresentationAttributes() {}


  Aspect_TypeOfHighlightMethod Method() const { return myHiMethod; }


  virtual void SetMethod (const Aspect_TypeOfHighlightMethod theMethod) { myHiMethod = theMethod; }


  const Quantity_ColorRGBA& ColorRGBA() const { return myBasicColor; }


  const Quantity_Color& Color() const { return myBasicColor.GetRGB(); }


  virtual void SetColor (const Quantity_Color& theColor)
  {
    myBasicColor.ChangeRGB() = theColor;
  }


  Standard_ShortReal Transparency() const { return 1.0f - myBasicColor.Alpha(); }


  virtual void SetTransparency (const Standard_ShortReal theTranspCoef)
  {
    myBasicColor.SetAlpha (1.0f - theTranspCoef);
  }



  Graphic3d_ZLayerId ZLayer() const { return myZLayer; }


  virtual void SetZLayer (const Graphic3d_ZLayerId theLayer) { myZLayer = theLayer; }



  Standard_Integer DisplayMode() const { return myDispMode; }


  virtual void SetDisplayMode (const Standard_Integer theMode) { myDispMode = theMode; }



  const opencascade::handle<Graphic3d_AspectFillArea3d>& BasicFillAreaAspect() const { return myBasicFillAreaAspect; }


  virtual void SetBasicFillAreaAspect (const opencascade::handle<Graphic3d_AspectFillArea3d>& theAspect) { myBasicFillAreaAspect = theAspect; }


  virtual void DumpJson (Standard_OStream& theOStream, Standard_Integer theDepth = -1) const;

protected:

  opencascade::handle<Graphic3d_AspectFillArea3d> myBasicFillAreaAspect;
  Quantity_ColorRGBA myBasicColor;
  Aspect_TypeOfHighlightMethod myHiMethod;
  Graphic3d_ZLayerId myZLayer;
  Standard_Integer myDispMode;

};

class Graphic3d_PresentationAttributes; typedef opencascade::handle<Graphic3d_PresentationAttributes> Handle_Graphic3d_PresentationAttributes;
# 26 "/usr/include/opencascade/Prs3d_Drawer.hxx" 2


# 1 "/usr/include/opencascade/Prs3d_VertexDrawMode.hxx" 1
# 24 "/usr/include/opencascade/Prs3d_VertexDrawMode.hxx"
enum Prs3d_VertexDrawMode
{
Prs3d_VDM_Isolated,
Prs3d_VDM_All,
Prs3d_VDM_Inherited
};
# 29 "/usr/include/opencascade/Prs3d_Drawer.hxx" 2
# 1 "/usr/include/opencascade/Prs3d_DimensionUnits.hxx" 1
# 24 "/usr/include/opencascade/Prs3d_DimensionUnits.hxx"
class Prs3d_DimensionUnits
{
public:



  Prs3d_DimensionUnits()
    : myLengthUnits ("m"),
      myAngleUnits ("rad")
  {}

  Prs3d_DimensionUnits (const Prs3d_DimensionUnits& theUnits)
    : myLengthUnits (theUnits.GetLengthUnits()),
      myAngleUnits (theUnits.GetAngleUnits())
  {}


  void SetAngleUnits (const TCollection_AsciiString& theUnits) { myAngleUnits = theUnits; }


  const TCollection_AsciiString& GetAngleUnits() const { return myAngleUnits; }


  void SetLengthUnits (const TCollection_AsciiString& theUnits) { myLengthUnits = theUnits; }


  const TCollection_AsciiString& GetLengthUnits() const { return myLengthUnits; }

private:

  TCollection_AsciiString myLengthUnits;
  TCollection_AsciiString myAngleUnits;

};
# 30 "/usr/include/opencascade/Prs3d_Drawer.hxx" 2
# 1 "/usr/include/opencascade/Prs3d_TypeOfHLR.hxx" 1
# 26 "/usr/include/opencascade/Prs3d_TypeOfHLR.hxx"
enum Prs3d_TypeOfHLR
{
Prs3d_TOH_NotSet,
Prs3d_TOH_PolyAlgo,
Prs3d_TOH_Algo
};
# 31 "/usr/include/opencascade/Prs3d_Drawer.hxx" 2

# 1 "/usr/include/opencascade/GeomAbs_Shape.hxx" 1
# 48 "/usr/include/opencascade/GeomAbs_Shape.hxx"
enum GeomAbs_Shape
{
GeomAbs_C0,
GeomAbs_G1,
GeomAbs_C1,
GeomAbs_G2,
GeomAbs_C2,
GeomAbs_C3,
GeomAbs_CN
};
# 33 "/usr/include/opencascade/Prs3d_Drawer.hxx" 2

class Prs3d_IsoAspect;
class Prs3d_LineAspect;
class Prs3d_TextAspect;
class Prs3d_ShadingAspect;
class Prs3d_PointAspect;
class Prs3d_PlaneAspect;
class Prs3d_ArrowAspect;
class Prs3d_DatumAspect;
class Prs3d_DimensionAspect;
class TCollection_AsciiString;

class Prs3d_Drawer; typedef opencascade::handle<Prs3d_Drawer> Handle_Prs3d_Drawer;




class Prs3d_Drawer : public Graphic3d_PresentationAttributes
{
  public: typedef Graphic3d_PresentationAttributes base_type; static const char* get_type_name () { return "Prs3d_Drawer"; using direct_base_classes = opencascade::direct_base_class_as_tuple<std::tr2::direct_bases<Prs3d_Drawer>::type>::type; static_assert(opencascade::has_type<Graphic3d_PresentationAttributes, direct_base_classes>::type::value, "OCCT RTTI definition is incorrect: " "Graphic3d_PresentationAttributes" " is not direct base class of " "Prs3d_Drawer"); static_assert(&get_type_name == &Prs3d_Drawer::get_type_name, "OCCT RTTI definition is misplaced: current class is not " "Prs3d_Drawer"); } static const opencascade::handle<Standard_Type>& get_type_descriptor (); virtual const opencascade::handle<Standard_Type>& DynamicType() const override;
public:


  Prs3d_Drawer();



  void SetTypeOfDeflection (const Aspect_TypeOfDeflection theTypeOfDeflection);



  Aspect_TypeOfDeflection TypeOfDeflection() const
  {
    return HasOwnTypeOfDeflection() || myLink.IsNull()
         ? myTypeOfDeflection
         : myLink->TypeOfDeflection();
  }


  Standard_Boolean HasOwnTypeOfDeflection() const { return myHasOwnTypeOfDeflection; }






  void SetMaximalChordialDeviation (const Standard_Real theChordialDeviation);



  Standard_Real MaximalChordialDeviation() const
  {
    return HasOwnMaximalChordialDeviation() || myLink.IsNull()
         ? myChordialDeviation
         : myLink->MaximalChordialDeviation();
  }


  Standard_Boolean HasOwnMaximalChordialDeviation() const { return myHasOwnChordialDeviation; }


  void SetTypeOfHLR (const Prs3d_TypeOfHLR theTypeOfHLR);


  Prs3d_TypeOfHLR TypeOfHLR();


  Standard_Boolean HasOwnTypeOfHLR() const { return (myTypeOfHLR != Prs3d_TOH_NotSet); }



  void SetMaximalParameterValue (const Standard_Real theValue);



  Standard_Real MaximalParameterValue() const
  {
    return HasOwnMaximalParameterValue() || myLink.IsNull()
         ? myMaximalParameterValue
         : myLink->MaximalParameterValue();
  }



  Standard_Boolean HasOwnMaximalParameterValue() const { return myHasOwnMaximalParameterValue; }


  void SetIsoOnPlane (const Standard_Boolean theIsEnabled);


  Standard_Boolean IsoOnPlane() const
  {
    return HasOwnIsoOnPlane() || myLink.IsNull()
         ? myIsoOnPlane
         : myLink->IsoOnPlane();
  }


  Standard_Boolean HasOwnIsoOnPlane() const { return myHasOwnIsoOnPlane; }


  Standard_Boolean IsoOnTriangulation() const
  {
    return HasOwnIsoOnTriangulation() || myLink.IsNull()
         ? myIsoOnTriangulation
         : myLink->IsoOnTriangulation();
  }


  Standard_Boolean HasOwnIsoOnTriangulation() const { return myHasOwnIsoOnTriangulation; }


  void SetIsoOnTriangulation (const Standard_Boolean theToEnable);


  void SetDiscretisation (const Standard_Integer theValue);


  Standard_Integer Discretisation() const
  {
    return HasOwnDiscretisation() || myLink.IsNull()
         ? myNbPoints
         : myLink->Discretisation();
  }


  Standard_Boolean HasOwnDiscretisation() const { return myHasOwnNbPoints; }



  void SetDeviationCoefficient (const Standard_Real theCoefficient);
# 181 "/usr/include/opencascade/Prs3d_Drawer.hxx"
  Standard_Real DeviationCoefficient() const
  {
    return HasOwnDeviationCoefficient() || myLink.IsNull()
         ? myDeviationCoefficient
         : myLink->DeviationCoefficient();
  }


  void SetDeviationCoefficient()
  {
    myHasOwnDeviationCoefficient = false;
  }



  Standard_Boolean HasOwnDeviationCoefficient() const { return myHasOwnDeviationCoefficient; }



  Standard_Real PreviousDeviationCoefficient() const
  {
    return myHasOwnDeviationCoefficient
         ? myPreviousDeviationCoefficient
         : 0.0;
  }


  void UpdatePreviousDeviationCoefficient()
  {
    if (myHasOwnDeviationCoefficient)
    {
      myPreviousDeviationCoefficient = DeviationCoefficient();
    }
  }



  void SetDeviationAngle (const Standard_Real theAngle);


  Standard_Real DeviationAngle() const
  {
    return HasOwnDeviationAngle() || myLink.IsNull()
         ? myDeviationAngle
         : myLink->DeviationAngle();
  }


  void SetDeviationAngle()
  {
    myHasOwnDeviationAngle = false;
  }



  Standard_Boolean HasOwnDeviationAngle() const { return myHasOwnDeviationAngle; }


  Standard_Real PreviousDeviationAngle() const
  {
    return myHasOwnDeviationAngle
         ? myPreviousDeviationAngle
         : 0.0;
  }


  void UpdatePreviousDeviationAngle()
  {
    if (myHasOwnDeviationAngle)
    {
      myPreviousDeviationAngle = DeviationAngle();
    }
  }





  void SetAutoTriangulation (const Standard_Boolean theIsEnabled);


  Standard_Boolean IsAutoTriangulation() const
  {
    return HasOwnIsAutoTriangulation() || myLink.IsNull()
         ? myIsAutoTriangulated
         : myLink->IsAutoTriangulation();
  }


  Standard_Boolean HasOwnIsAutoTriangulation() const { return myHasOwnIsAutoTriangulated; }
# 285 "/usr/include/opencascade/Prs3d_Drawer.hxx"
  const opencascade::handle<Prs3d_IsoAspect>& UIsoAspect();

  void SetUIsoAspect (const opencascade::handle<Prs3d_IsoAspect>& theAspect);



  Standard_Boolean HasOwnUIsoAspect() const { return myHasOwnUIsoAspect; }
# 306 "/usr/include/opencascade/Prs3d_Drawer.hxx"
  const opencascade::handle<Prs3d_IsoAspect>& VIsoAspect();


  void SetVIsoAspect (const opencascade::handle<Prs3d_IsoAspect>& theAspect);



  Standard_Boolean HasOwnVIsoAspect() const { return myHasOwnVIsoAspect; }
# 322 "/usr/include/opencascade/Prs3d_Drawer.hxx"
  const opencascade::handle<Prs3d_LineAspect>& WireAspect();


  void SetWireAspect (const opencascade::handle<Prs3d_LineAspect>& theAspect);



  Standard_Boolean HasOwnWireAspect() const { return myHasOwnWireAspect; }


  void SetWireDraw(const Standard_Boolean theIsEnabled);


  Standard_Boolean WireDraw() const
  {
    return HasOwnWireDraw() || myLink.IsNull()
         ? myWireDraw
         : myLink->WireDraw();
  }



  Standard_Boolean HasOwnWireDraw() const { return myHasOwnWireDraw; }






  const opencascade::handle<Prs3d_PointAspect>& PointAspect();


  void SetPointAspect (const opencascade::handle<Prs3d_PointAspect>& theAspect);



  Standard_Boolean HasOwnPointAspect() const { return myHasOwnPointAspect; }



  Standard_Boolean SetupOwnPointAspect (const opencascade::handle<Prs3d_Drawer>& theDefaults = opencascade::handle<Prs3d_Drawer>());
# 373 "/usr/include/opencascade/Prs3d_Drawer.hxx"
  const opencascade::handle<Prs3d_LineAspect>& LineAspect();


  void SetLineAspect (const opencascade::handle<Prs3d_LineAspect>& theAspect);



  Standard_Boolean HasOwnLineAspect() const { return myHasOwnLineAspect; }



  Standard_Boolean SetOwnLineAspects (const opencascade::handle<Prs3d_Drawer>& theDefaults = opencascade::handle<Prs3d_Drawer>());



  Standard_Boolean SetOwnDatumAspects (const opencascade::handle<Prs3d_Drawer>& theDefaults = opencascade::handle<Prs3d_Drawer>());




  const opencascade::handle<Prs3d_TextAspect>& TextAspect();


  void SetTextAspect (const opencascade::handle<Prs3d_TextAspect>& theAspect);



  Standard_Boolean HasOwnTextAspect() const { return myHasOwnTextAspect; }
# 411 "/usr/include/opencascade/Prs3d_Drawer.hxx"
  const opencascade::handle<Prs3d_ShadingAspect>& ShadingAspect();


  void SetShadingAspect (const opencascade::handle<Prs3d_ShadingAspect>& theAspect);



  Standard_Boolean HasOwnShadingAspect() const { return myHasOwnShadingAspect; }



  Standard_Boolean SetupOwnShadingAspect (const opencascade::handle<Prs3d_Drawer>& theDefaults = opencascade::handle<Prs3d_Drawer>());






  const opencascade::handle<Prs3d_LineAspect>& SeenLineAspect();


  void SetSeenLineAspect (const opencascade::handle<Prs3d_LineAspect>& theAspect);



  Standard_Boolean HasOwnSeenLineAspect() const { return myHasOwnSeenLineAspect; }


  const opencascade::handle<Prs3d_PlaneAspect>& PlaneAspect();


  void SetPlaneAspect (const opencascade::handle<Prs3d_PlaneAspect>& theAspect);



  Standard_Boolean HasOwnPlaneAspect() const { return myHasOwnPlaneAspect; }


  const opencascade::handle<Prs3d_ArrowAspect>& ArrowAspect();


  void SetArrowAspect (const opencascade::handle<Prs3d_ArrowAspect>& theAspect);



  Standard_Boolean HasOwnArrowAspect() const { return myHasOwnArrowAspect; }



  void SetLineArrowDraw (const Standard_Boolean theIsEnabled);



  Standard_Boolean LineArrowDraw() const
  {
    return HasOwnLineArrowDraw() || myLink.IsNull()
         ? myLineArrowDraw
         : myLink->LineArrowDraw();
  }



  Standard_Boolean HasOwnLineArrowDraw() const
  {
    return myHasOwnLineArrowDraw;
  }






  const opencascade::handle<Prs3d_LineAspect>& HiddenLineAspect();


  void SetHiddenLineAspect (const opencascade::handle<Prs3d_LineAspect>& theAspect);



  Standard_Boolean HasOwnHiddenLineAspect() const { return myHasOwnHiddenLineAspect; }



  Standard_Boolean DrawHiddenLine() const
  {
    return HasOwnDrawHiddenLine() || myLink.IsNull()
         ? myDrawHiddenLine
         : myLink->DrawHiddenLine();
  }


  void EnableDrawHiddenLine();


  void DisableDrawHiddenLine();



  Standard_Boolean HasOwnDrawHiddenLine() const { return myHasOwnDrawHiddenLine; }






  const opencascade::handle<Prs3d_LineAspect>& VectorAspect();


  void SetVectorAspect (const opencascade::handle<Prs3d_LineAspect>& theAspect);



  Standard_Boolean HasOwnVectorAspect() const { return myHasOwnVectorAspect; }







  void SetVertexDrawMode (const Prs3d_VertexDrawMode theMode);


  Prs3d_VertexDrawMode VertexDrawMode();




  Standard_Boolean HasOwnVertexDrawMode() const { return (myVertexDrawMode != Prs3d_VDM_Inherited); }






  const opencascade::handle<Prs3d_DatumAspect>& DatumAspect();


  void SetDatumAspect (const opencascade::handle<Prs3d_DatumAspect>& theAspect);



  Standard_Boolean HasOwnDatumAspect() const { return myHasOwnDatumAspect; }







  const opencascade::handle<Prs3d_LineAspect>& SectionAspect();


  void SetSectionAspect (const opencascade::handle<Prs3d_LineAspect>& theAspect);



  Standard_Boolean HasOwnSectionAspect() const { return myHasOwnSectionAspect; }




  void SetFreeBoundaryAspect (const opencascade::handle<Prs3d_LineAspect>& theAspect);
# 583 "/usr/include/opencascade/Prs3d_Drawer.hxx"
  const opencascade::handle<Prs3d_LineAspect>& FreeBoundaryAspect();



  Standard_Boolean HasOwnFreeBoundaryAspect() const { return myHasOwnFreeBoundaryAspect; }






  void SetFreeBoundaryDraw (const Standard_Boolean theIsEnabled);



  Standard_Boolean FreeBoundaryDraw() const
  {
    return HasOwnFreeBoundaryDraw() || myLink.IsNull()
         ? myFreeBoundaryDraw
         : myLink->FreeBoundaryDraw();
  }



  Standard_Boolean HasOwnFreeBoundaryDraw() const { return myHasOwnFreeBoundaryDraw; }




  void SetUnFreeBoundaryAspect (const opencascade::handle<Prs3d_LineAspect>& theAspect);
# 621 "/usr/include/opencascade/Prs3d_Drawer.hxx"
  const opencascade::handle<Prs3d_LineAspect>& UnFreeBoundaryAspect();



  Standard_Boolean HasOwnUnFreeBoundaryAspect() const { return myHasOwnUnFreeBoundaryAspect; }





  void SetUnFreeBoundaryDraw (const Standard_Boolean theIsEnabled);



  Standard_Boolean UnFreeBoundaryDraw() const
  {
    return HasOwnUnFreeBoundaryDraw() || myLink.IsNull()
         ? myUnFreeBoundaryDraw
         : myLink->UnFreeBoundaryDraw();
  }



  Standard_Boolean HasOwnUnFreeBoundaryDraw() const { return myHasOwnUnFreeBoundaryDraw; }





  void SetFaceBoundaryAspect (const opencascade::handle<Prs3d_LineAspect>& theAspect);


  const opencascade::handle<Prs3d_LineAspect>& FaceBoundaryAspect();



  Standard_Boolean HasOwnFaceBoundaryAspect() const { return myHasOwnFaceBoundaryAspect; }



  Standard_Boolean SetupOwnFaceBoundaryAspect (const opencascade::handle<Prs3d_Drawer>& theDefaults = opencascade::handle<Prs3d_Drawer>());





  void SetFaceBoundaryDraw (const Standard_Boolean theIsEnabled);


  Standard_Boolean FaceBoundaryDraw() const
  {
    return HasOwnFaceBoundaryDraw() || myLink.IsNull()
         ? myFaceBoundaryDraw
         : myLink->FaceBoundaryDraw();
  }



  Standard_Boolean HasOwnFaceBoundaryDraw() const { return myHasOwnFaceBoundaryDraw; }


  Standard_Boolean HasOwnFaceBoundaryUpperContinuity() const { return myFaceBoundaryUpperContinuity != -1; }


  GeomAbs_Shape FaceBoundaryUpperContinuity() const
  {
    return HasOwnFaceBoundaryUpperContinuity()
         ? (GeomAbs_Shape )myFaceBoundaryUpperContinuity
         : (!myLink.IsNull()
           ? myLink->FaceBoundaryUpperContinuity()
           : GeomAbs_CN);
  }


  void SetFaceBoundaryUpperContinuity (GeomAbs_Shape theMostAllowedEdgeClass) { myFaceBoundaryUpperContinuity = theMostAllowedEdgeClass; }


  void UnsetFaceBoundaryUpperContinuity() { myFaceBoundaryUpperContinuity = -1; }


  const opencascade::handle<Prs3d_DimensionAspect>& DimensionAspect();




  void SetDimensionAspect (const opencascade::handle<Prs3d_DimensionAspect>& theAspect);



  Standard_Boolean HasOwnDimensionAspect() const { return myHasOwnDimensionAspect; }




  void SetDimLengthModelUnits (const TCollection_AsciiString& theUnits);




  void SetDimAngleModelUnits (const TCollection_AsciiString& theUnits);


  const TCollection_AsciiString& DimLengthModelUnits() const
  {
    return HasOwnDimLengthModelUnits() || myLink.IsNull()
         ? myDimensionModelUnits.GetLengthUnits()
         : myLink->DimLengthModelUnits();
  }


  const TCollection_AsciiString& DimAngleModelUnits() const
  {
    return HasOwnDimAngleModelUnits() || myLink.IsNull()
         ? myDimensionModelUnits.GetAngleUnits()
         : myLink->DimAngleModelUnits();
  }



  Standard_Boolean HasOwnDimLengthModelUnits() const { return myHasOwnDimLengthModelUnits; }



  Standard_Boolean HasOwnDimAngleModelUnits() const { return myHasOwnDimAngleModelUnits; }




  void SetDimLengthDisplayUnits (const TCollection_AsciiString& theUnits);




  void SetDimAngleDisplayUnits (const TCollection_AsciiString& theUnits);


  const TCollection_AsciiString& DimLengthDisplayUnits() const
  {
    return HasOwnDimLengthDisplayUnits() || myLink.IsNull()
         ? myDimensionDisplayUnits.GetLengthUnits()
         : myLink->DimLengthDisplayUnits();
  }


  const TCollection_AsciiString& DimAngleDisplayUnits() const
  {
    return HasOwnDimAngleDisplayUnits() || myLink.IsNull()
         ? myDimensionDisplayUnits.GetAngleUnits()
         : myLink->DimAngleDisplayUnits();
  }




  Standard_Boolean HasOwnDimLengthDisplayUnits() const { return myHasOwnDimLengthDisplayUnits; }




  Standard_Boolean HasOwnDimAngleDisplayUnits() const { return myHasOwnDimAngleDisplayUnits; }


  const opencascade::handle<Prs3d_Drawer>& Link() { return myLink; }


  Standard_Boolean HasLink() const { return !myLink.IsNull(); }


  void Link (const opencascade::handle<Prs3d_Drawer>& theDrawer) { SetLink (theDrawer); }


  void SetLink (const opencascade::handle<Prs3d_Drawer>& theDrawer) { myLink = theDrawer; }


  void ClearLocalAttributes();







  bool SetShaderProgram (const opencascade::handle<Graphic3d_ShaderProgram>& theProgram,
                                         const Graphic3d_GroupAspect theAspect,
                                         const bool theToOverrideDefaults = false);


  bool SetShadingModel (Graphic3d_TypeOfShadingModel theModel,
                                        bool theToOverrideDefaults = false);


  virtual void DumpJson (Standard_OStream& theOStream, Standard_Integer theDepth = -1) const override;

public:

  __attribute__((deprecated("SetDeviationAngle() should be used instead")))
  void SetHLRAngle (const Standard_Real theAngle) { SetDeviationAngle (theAngle); }

  __attribute__((deprecated("DeviationAngle() should be used instead")))
  Standard_Real HLRAngle() const { return DeviationAngle(); }

  __attribute__((deprecated("SetDeviationAngle() should be used instead")))
  void SetHLRAngle() { SetDeviationAngle(); }

  __attribute__((deprecated("HasOwnDeviationAngle() should be used instead")))
  Standard_Boolean HasOwnHLRDeviationAngle() const { return HasOwnDeviationAngle(); }

  __attribute__((deprecated("PreviousDeviationAngle() should be used instead")))
  Standard_Real PreviousHLRDeviationAngle() const { return PreviousDeviationAngle(); }

protected:

  opencascade::handle<Prs3d_Drawer> myLink;

  Standard_Integer myNbPoints;
  Standard_Boolean myHasOwnNbPoints;
  Standard_Real myMaximalParameterValue;
  Standard_Boolean myHasOwnMaximalParameterValue;
  Standard_Real myChordialDeviation;
  Standard_Boolean myHasOwnChordialDeviation;
  Aspect_TypeOfDeflection myTypeOfDeflection;
  Standard_Boolean myHasOwnTypeOfDeflection;
  Prs3d_TypeOfHLR myTypeOfHLR;
  Standard_Real myDeviationCoefficient;
  Standard_Real myPreviousDeviationCoefficient;
  Standard_Boolean myHasOwnDeviationCoefficient;
  Standard_Real myDeviationAngle;
  Standard_Boolean myHasOwnDeviationAngle;
  Standard_Real myPreviousDeviationAngle;
  Standard_Boolean myIsoOnPlane;
  Standard_Boolean myHasOwnIsoOnPlane;
  Standard_Boolean myIsoOnTriangulation;
  Standard_Boolean myHasOwnIsoOnTriangulation;
  Standard_Boolean myIsAutoTriangulated;
  Standard_Boolean myHasOwnIsAutoTriangulated;

  opencascade::handle<Prs3d_IsoAspect> myUIsoAspect;
  Standard_Boolean myHasOwnUIsoAspect;
  opencascade::handle<Prs3d_IsoAspect> myVIsoAspect;
  Standard_Boolean myHasOwnVIsoAspect;
  opencascade::handle<Prs3d_LineAspect> myWireAspect;
  Standard_Boolean myHasOwnWireAspect;
  Standard_Boolean myWireDraw;
  Standard_Boolean myHasOwnWireDraw;
  opencascade::handle<Prs3d_PointAspect> myPointAspect;
  Standard_Boolean myHasOwnPointAspect;
  opencascade::handle<Prs3d_LineAspect> myLineAspect;
  Standard_Boolean myHasOwnLineAspect;
  opencascade::handle<Prs3d_TextAspect> myTextAspect;
  Standard_Boolean myHasOwnTextAspect;
  opencascade::handle<Prs3d_ShadingAspect> myShadingAspect;
  Standard_Boolean myHasOwnShadingAspect;
  opencascade::handle<Prs3d_PlaneAspect> myPlaneAspect;
  Standard_Boolean myHasOwnPlaneAspect;
  opencascade::handle<Prs3d_LineAspect> mySeenLineAspect;
  Standard_Boolean myHasOwnSeenLineAspect;
  opencascade::handle<Prs3d_ArrowAspect> myArrowAspect;
  Standard_Boolean myHasOwnArrowAspect;
  Standard_Boolean myLineArrowDraw;
  Standard_Boolean myHasOwnLineArrowDraw;
  opencascade::handle<Prs3d_LineAspect> myHiddenLineAspect;
  Standard_Boolean myHasOwnHiddenLineAspect;
  Standard_Boolean myDrawHiddenLine;
  Standard_Boolean myHasOwnDrawHiddenLine;
  opencascade::handle<Prs3d_LineAspect> myVectorAspect;
  Standard_Boolean myHasOwnVectorAspect;
  Prs3d_VertexDrawMode myVertexDrawMode;
  opencascade::handle<Prs3d_DatumAspect> myDatumAspect;
  Standard_Boolean myHasOwnDatumAspect;
  opencascade::handle<Prs3d_LineAspect> mySectionAspect;
  Standard_Boolean myHasOwnSectionAspect;

  opencascade::handle<Prs3d_LineAspect> myFreeBoundaryAspect;
  Standard_Boolean myHasOwnFreeBoundaryAspect;
  Standard_Boolean myFreeBoundaryDraw;
  Standard_Boolean myHasOwnFreeBoundaryDraw;
  opencascade::handle<Prs3d_LineAspect> myUnFreeBoundaryAspect;
  Standard_Boolean myHasOwnUnFreeBoundaryAspect;
  Standard_Boolean myUnFreeBoundaryDraw;
  Standard_Boolean myHasOwnUnFreeBoundaryDraw;
  opencascade::handle<Prs3d_LineAspect> myFaceBoundaryAspect;
  Standard_Integer myFaceBoundaryUpperContinuity;
  Standard_Boolean myHasOwnFaceBoundaryAspect;
  Standard_Boolean myFaceBoundaryDraw;
  Standard_Boolean myHasOwnFaceBoundaryDraw;

  opencascade::handle<Prs3d_DimensionAspect> myDimensionAspect;
  Standard_Boolean myHasOwnDimensionAspect;
  Prs3d_DimensionUnits myDimensionModelUnits;
  Standard_Boolean myHasOwnDimLengthModelUnits;
  Standard_Boolean myHasOwnDimAngleModelUnits;
  Prs3d_DimensionUnits myDimensionDisplayUnits;
  Standard_Boolean myHasOwnDimLengthDisplayUnits;
  Standard_Boolean myHasOwnDimAngleDisplayUnits;
};

__attribute__((deprecated("Class name is deprecated - use Prs3d_Drawer instead")))
typedef Prs3d_Drawer Graphic3d_HighlightStyle;
# 25 "/usr/include/opencascade/DsgPrs_FixPresentation.hxx" 2
# 1 "/usr/include/opencascade/Prs3d_Presentation.hxx" 1
# 20 "/usr/include/opencascade/Prs3d_Presentation.hxx"
# 1 "/usr/include/opencascade/Graphic3d_Structure.hxx" 1
# 20 "/usr/include/opencascade/Graphic3d_Structure.hxx"
# 1 "/usr/include/opencascade/Graphic3d_BndBox4f.hxx" 1
# 19 "/usr/include/opencascade/Graphic3d_BndBox4f.hxx"
# 1 "/usr/include/opencascade/BVH_Box.hxx" 1
# 19 "/usr/include/opencascade/BVH_Box.hxx"
# 1 "/usr/include/opencascade/BVH_Constants.hxx" 1
# 17 "/usr/include/opencascade/BVH_Constants.hxx"
enum
{


  BVH_Constants_MaxTreeDepth = 32,



  BVH_Constants_LeafNodeSizeSingle = 1,

  BVH_Constants_LeafNodeSizeAverage = 4,

  BVH_Constants_LeafNodeSizeDefault = 5,

  BVH_Constants_LeafNodeSizeSmall = 8,


  BVH_Constants_NbBinsOptimal = 32,

  BVH_Constants_NbBinsBest = 48,
};

namespace BVH
{

  const double THE_NODE_MIN_SIZE = 1e-5;
}
# 20 "/usr/include/opencascade/BVH_Box.hxx" 2
# 1 "/usr/include/opencascade/BVH_Types.hxx" 1
# 22 "/usr/include/opencascade/BVH_Types.hxx"
# 1 "/usr/include/c++/10.2.0/vector" 1 3
# 58 "/usr/include/c++/10.2.0/vector" 3
       
# 59 "/usr/include/c++/10.2.0/vector" 3







# 1 "/usr/include/c++/10.2.0/bits/stl_uninitialized.h" 1 3
# 69 "/usr/include/c++/10.2.0/bits/stl_uninitialized.h" 3

# 69 "/usr/include/c++/10.2.0/bits/stl_uninitialized.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{








  template<bool _TrivialValueTypes>
    struct __uninitialized_copy
    {
      template<typename _InputIterator, typename _ForwardIterator>
        static _ForwardIterator
        __uninit_copy(_InputIterator __first, _InputIterator __last,
        _ForwardIterator __result)
        {
   _ForwardIterator __cur = __result;
   try
     {
       for (; __first != __last; ++__first, (void)++__cur)
  std::_Construct(std::__addressof(*__cur), *__first);
       return __cur;
     }
   catch(...)
     {
       std::_Destroy(__result, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_copy<true>
    {
      template<typename _InputIterator, typename _ForwardIterator>
        static _ForwardIterator
        __uninit_copy(_InputIterator __first, _InputIterator __last,
        _ForwardIterator __result)
        { return std::copy(__first, __last, __result); }
    };
# 123 "/usr/include/c++/10.2.0/bits/stl_uninitialized.h" 3
  template<typename _InputIterator, typename _ForwardIterator>
    inline _ForwardIterator
    uninitialized_copy(_InputIterator __first, _InputIterator __last,
         _ForwardIterator __result)
    {
      typedef typename iterator_traits<_InputIterator>::value_type
 _ValueType1;
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType2;





      static_assert(is_constructible<_ValueType2, decltype(*__first)>::value,
   "result type must be constructible from value type of input range");

      typedef typename iterator_traits<_InputIterator>::reference _RefType1;
      typedef typename iterator_traits<_ForwardIterator>::reference _RefType2;


      const bool __assignable = is_assignable<_RefType2, _RefType1>::value;


      return std::__uninitialized_copy<__is_trivial(_ValueType1)
           && __is_trivial(_ValueType2)
           && __assignable>::
 __uninit_copy(__first, __last, __result);
    }



  template<bool _TrivialValueType>
    struct __uninitialized_fill
    {
      template<typename _ForwardIterator, typename _Tp>
        static void
        __uninit_fill(_ForwardIterator __first, _ForwardIterator __last,
        const _Tp& __x)
        {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __cur != __last; ++__cur)
  std::_Construct(std::__addressof(*__cur), __x);
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_fill<true>
    {
      template<typename _ForwardIterator, typename _Tp>
        static void
        __uninit_fill(_ForwardIterator __first, _ForwardIterator __last,
        const _Tp& __x)
        { std::fill(__first, __last, __x); }
    };
# 198 "/usr/include/c++/10.2.0/bits/stl_uninitialized.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline void
    uninitialized_fill(_ForwardIterator __first, _ForwardIterator __last,
         const _Tp& __x)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;





      static_assert(is_constructible<_ValueType, const _Tp&>::value,
   "result type must be constructible from input type");



      const bool __assignable = is_copy_assignable<_ValueType>::value;


      std::__uninitialized_fill<__is_trivial(_ValueType) && __assignable>::
 __uninit_fill(__first, __last, __x);
    }



  template<bool _TrivialValueType>
    struct __uninitialized_fill_n
    {
      template<typename _ForwardIterator, typename _Size, typename _Tp>
        static _ForwardIterator
        __uninit_fill_n(_ForwardIterator __first, _Size __n,
   const _Tp& __x)
        {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __n > 0; --__n, (void) ++__cur)
  std::_Construct(std::__addressof(*__cur), __x);
       return __cur;
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_fill_n<true>
    {
      template<typename _ForwardIterator, typename _Size, typename _Tp>
        static _ForwardIterator
        __uninit_fill_n(_ForwardIterator __first, _Size __n,
   const _Tp& __x)
        { return std::fill_n(__first, __n, __x); }
    };
# 270 "/usr/include/c++/10.2.0/bits/stl_uninitialized.h" 3
  template<typename _ForwardIterator, typename _Size, typename _Tp>
    inline _ForwardIterator
    uninitialized_fill_n(_ForwardIterator __first, _Size __n, const _Tp& __x)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;





      static_assert(is_constructible<_ValueType, const _Tp&>::value,
   "result type must be constructible from input type");



      const bool __assignable = is_copy_assignable<_ValueType>::value;

      return __uninitialized_fill_n<__is_trivial(_ValueType) && __assignable>::
 __uninit_fill_n(__first, __n, __x);
    }
# 300 "/usr/include/c++/10.2.0/bits/stl_uninitialized.h" 3
  template<typename _InputIterator, typename _ForwardIterator,
    typename _Allocator>
    _ForwardIterator
    __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result, _Allocator& __alloc)
    {
      _ForwardIterator __cur = __result;
      try
 {
   typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
   for (; __first != __last; ++__first, (void)++__cur)
     __traits::construct(__alloc, std::__addressof(*__cur), *__first);
   return __cur;
 }
      catch(...)
 {
   std::_Destroy(__result, __cur, __alloc);
   throw;
 }
    }

  template<typename _InputIterator, typename _ForwardIterator, typename _Tp>
    inline _ForwardIterator
    __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result, allocator<_Tp>&)
    { return std::uninitialized_copy(__first, __last, __result); }

  template<typename _InputIterator, typename _ForwardIterator,
    typename _Allocator>
    inline _ForwardIterator
    __uninitialized_move_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result, _Allocator& __alloc)
    {
      return std::__uninitialized_copy_a(std::make_move_iterator(__first),
      std::make_move_iterator(__last),
      __result, __alloc);
    }

  template<typename _InputIterator, typename _ForwardIterator,
    typename _Allocator>
    inline _ForwardIterator
    __uninitialized_move_if_noexcept_a(_InputIterator __first,
           _InputIterator __last,
           _ForwardIterator __result,
           _Allocator& __alloc)
    {
      return std::__uninitialized_copy_a
 (std::__make_move_if_noexcept_iterator(__first),
  std::__make_move_if_noexcept_iterator(__last), __result, __alloc);
    }

  template<typename _ForwardIterator, typename _Tp, typename _Allocator>
    void
    __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __x, _Allocator& __alloc)
    {
      _ForwardIterator __cur = __first;
      try
 {
   typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
   for (; __cur != __last; ++__cur)
     __traits::construct(__alloc, std::__addressof(*__cur), __x);
 }
      catch(...)
 {
   std::_Destroy(__first, __cur, __alloc);
   throw;
 }
    }

  template<typename _ForwardIterator, typename _Tp, typename _Tp2>
    inline void
    __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __x, allocator<_Tp2>&)
    { std::uninitialized_fill(__first, __last, __x); }

  template<typename _ForwardIterator, typename _Size, typename _Tp,
    typename _Allocator>
    _ForwardIterator
    __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n,
        const _Tp& __x, _Allocator& __alloc)
    {
      _ForwardIterator __cur = __first;
      try
 {
   typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
   for (; __n > 0; --__n, (void) ++__cur)
     __traits::construct(__alloc, std::__addressof(*__cur), __x);
   return __cur;
 }
      catch(...)
 {
   std::_Destroy(__first, __cur, __alloc);
   throw;
 }
    }

  template<typename _ForwardIterator, typename _Size, typename _Tp,
    typename _Tp2>
    inline _ForwardIterator
    __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n,
        const _Tp& __x, allocator<_Tp2>&)
    { return std::uninitialized_fill_n(__first, __n, __x); }
# 414 "/usr/include/c++/10.2.0/bits/stl_uninitialized.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _ForwardIterator, typename _Allocator>
    inline _ForwardIterator
    __uninitialized_copy_move(_InputIterator1 __first1,
         _InputIterator1 __last1,
         _InputIterator2 __first2,
         _InputIterator2 __last2,
         _ForwardIterator __result,
         _Allocator& __alloc)
    {
      _ForwardIterator __mid = std::__uninitialized_copy_a(__first1, __last1,
          __result,
          __alloc);
      try
 {
   return std::__uninitialized_move_a(__first2, __last2, __mid, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__result, __mid, __alloc);
   throw;
 }
    }





  template<typename _InputIterator1, typename _InputIterator2,
    typename _ForwardIterator, typename _Allocator>
    inline _ForwardIterator
    __uninitialized_move_copy(_InputIterator1 __first1,
         _InputIterator1 __last1,
         _InputIterator2 __first2,
         _InputIterator2 __last2,
         _ForwardIterator __result,
         _Allocator& __alloc)
    {
      _ForwardIterator __mid = std::__uninitialized_move_a(__first1, __last1,
          __result,
          __alloc);
      try
 {
   return std::__uninitialized_copy_a(__first2, __last2, __mid, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__result, __mid, __alloc);
   throw;
 }
    }




  template<typename _ForwardIterator, typename _Tp, typename _InputIterator,
    typename _Allocator>
    inline _ForwardIterator
    __uninitialized_fill_move(_ForwardIterator __result, _ForwardIterator __mid,
         const _Tp& __x, _InputIterator __first,
         _InputIterator __last, _Allocator& __alloc)
    {
      std::__uninitialized_fill_a(__result, __mid, __x, __alloc);
      try
 {
   return std::__uninitialized_move_a(__first, __last, __mid, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__result, __mid, __alloc);
   throw;
 }
    }




  template<typename _InputIterator, typename _ForwardIterator, typename _Tp,
    typename _Allocator>
    inline void
    __uninitialized_move_fill(_InputIterator __first1, _InputIterator __last1,
         _ForwardIterator __first2,
         _ForwardIterator __last2, const _Tp& __x,
         _Allocator& __alloc)
    {
      _ForwardIterator __mid2 = std::__uninitialized_move_a(__first1, __last1,
           __first2,
           __alloc);
      try
 {
   std::__uninitialized_fill_a(__mid2, __last2, __x, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__first2, __mid2, __alloc);
   throw;
 }
    }
# 521 "/usr/include/c++/10.2.0/bits/stl_uninitialized.h" 3
  template<bool _TrivialValueType>
    struct __uninitialized_default_1
    {
      template<typename _ForwardIterator>
        static void
        __uninit_default(_ForwardIterator __first, _ForwardIterator __last)
        {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __cur != __last; ++__cur)
  std::_Construct(std::__addressof(*__cur));
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_default_1<true>
    {
      template<typename _ForwardIterator>
        static void
        __uninit_default(_ForwardIterator __first, _ForwardIterator __last)
        {
   typedef typename iterator_traits<_ForwardIterator>::value_type
     _ValueType;

   std::fill(__first, __last, _ValueType());
 }
    };

  template<bool _TrivialValueType>
    struct __uninitialized_default_n_1
    {
      template<typename _ForwardIterator, typename _Size>
        static _ForwardIterator
        __uninit_default_n(_ForwardIterator __first, _Size __n)
        {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __n > 0; --__n, (void) ++__cur)
  std::_Construct(std::__addressof(*__cur));
       return __cur;
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_default_n_1<true>
    {
      template<typename _ForwardIterator, typename _Size>
        static _ForwardIterator
        __uninit_default_n(_ForwardIterator __first, _Size __n)
        {
   typedef typename iterator_traits<_ForwardIterator>::value_type
     _ValueType;

   return std::fill_n(__first, __n, _ValueType());
 }
    };




  template<typename _ForwardIterator>
    inline void
    __uninitialized_default(_ForwardIterator __first,
       _ForwardIterator __last)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;

      const bool __assignable = is_copy_assignable<_ValueType>::value;

      std::__uninitialized_default_1<__is_trivial(_ValueType)
         && __assignable>::
 __uninit_default(__first, __last);
    }



  template<typename _ForwardIterator, typename _Size>
    inline _ForwardIterator
    __uninitialized_default_n(_ForwardIterator __first, _Size __n)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;

      const bool __assignable = is_copy_assignable<_ValueType>::value;

      return __uninitialized_default_n_1<__is_trivial(_ValueType)
           && __assignable>::
 __uninit_default_n(__first, __n);
    }





  template<typename _ForwardIterator, typename _Allocator>
    void
    __uninitialized_default_a(_ForwardIterator __first,
         _ForwardIterator __last,
         _Allocator& __alloc)
    {
      _ForwardIterator __cur = __first;
      try
 {
   typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
   for (; __cur != __last; ++__cur)
     __traits::construct(__alloc, std::__addressof(*__cur));
 }
      catch(...)
 {
   std::_Destroy(__first, __cur, __alloc);
   throw;
 }
    }

  template<typename _ForwardIterator, typename _Tp>
    inline void
    __uninitialized_default_a(_ForwardIterator __first,
         _ForwardIterator __last,
         allocator<_Tp>&)
    { std::__uninitialized_default(__first, __last); }





  template<typename _ForwardIterator, typename _Size, typename _Allocator>
    _ForwardIterator
    __uninitialized_default_n_a(_ForwardIterator __first, _Size __n,
    _Allocator& __alloc)
    {
      _ForwardIterator __cur = __first;
      try
 {
   typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
   for (; __n > 0; --__n, (void) ++__cur)
     __traits::construct(__alloc, std::__addressof(*__cur));
   return __cur;
 }
      catch(...)
 {
   std::_Destroy(__first, __cur, __alloc);
   throw;
 }
    }

  template<typename _ForwardIterator, typename _Size, typename _Tp>
    inline _ForwardIterator
    __uninitialized_default_n_a(_ForwardIterator __first, _Size __n,
    allocator<_Tp>&)
    { return std::__uninitialized_default_n(__first, __n); }

  template<bool _TrivialValueType>
    struct __uninitialized_default_novalue_1
    {
      template<typename _ForwardIterator>
 static void
 __uninit_default_novalue(_ForwardIterator __first,
     _ForwardIterator __last)
 {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __cur != __last; ++__cur)
  std::_Construct_novalue(std::__addressof(*__cur));
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_default_novalue_1<true>
    {
      template<typename _ForwardIterator>
        static void
        __uninit_default_novalue(_ForwardIterator __first,
     _ForwardIterator __last)
 {
 }
    };

  template<bool _TrivialValueType>
    struct __uninitialized_default_novalue_n_1
    {
      template<typename _ForwardIterator, typename _Size>
 static _ForwardIterator
 __uninit_default_novalue_n(_ForwardIterator __first, _Size __n)
 {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __n > 0; --__n, (void) ++__cur)
  std::_Construct_novalue(std::__addressof(*__cur));
       return __cur;
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_default_novalue_n_1<true>
    {
      template<typename _ForwardIterator, typename _Size>
 static _ForwardIterator
 __uninit_default_novalue_n(_ForwardIterator __first, _Size __n)
 { return std::next(__first, __n); }
    };




  template<typename _ForwardIterator>
    inline void
    __uninitialized_default_novalue(_ForwardIterator __first,
        _ForwardIterator __last)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;

      std::__uninitialized_default_novalue_1<
 is_trivially_default_constructible<_ValueType>::value>::
 __uninit_default_novalue(__first, __last);
    }



  template<typename _ForwardIterator, typename _Size>
    inline _ForwardIterator
    __uninitialized_default_novalue_n(_ForwardIterator __first, _Size __n)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;

      return __uninitialized_default_novalue_n_1<
 is_trivially_default_constructible<_ValueType>::value>::
 __uninit_default_novalue_n(__first, __n);
    }

  template<typename _InputIterator, typename _Size,
    typename _ForwardIterator>
    _ForwardIterator
    __uninitialized_copy_n(_InputIterator __first, _Size __n,
      _ForwardIterator __result, input_iterator_tag)
    {
      _ForwardIterator __cur = __result;
      try
 {
   for (; __n > 0; --__n, (void) ++__first, ++__cur)
     std::_Construct(std::__addressof(*__cur), *__first);
   return __cur;
 }
      catch(...)
 {
   std::_Destroy(__result, __cur);
   throw;
 }
    }

  template<typename _RandomAccessIterator, typename _Size,
    typename _ForwardIterator>
    inline _ForwardIterator
    __uninitialized_copy_n(_RandomAccessIterator __first, _Size __n,
      _ForwardIterator __result,
      random_access_iterator_tag)
    { return std::uninitialized_copy(__first, __first + __n, __result); }

  template<typename _InputIterator, typename _Size,
    typename _ForwardIterator>
    pair<_InputIterator, _ForwardIterator>
    __uninitialized_copy_n_pair(_InputIterator __first, _Size __n,
      _ForwardIterator __result, input_iterator_tag)
    {
      _ForwardIterator __cur = __result;
      try
 {
   for (; __n > 0; --__n, (void) ++__first, ++__cur)
     std::_Construct(std::__addressof(*__cur), *__first);
   return {__first, __cur};
 }
      catch(...)
 {
   std::_Destroy(__result, __cur);
   throw;
 }
    }

  template<typename _RandomAccessIterator, typename _Size,
    typename _ForwardIterator>
    inline pair<_RandomAccessIterator, _ForwardIterator>
    __uninitialized_copy_n_pair(_RandomAccessIterator __first, _Size __n,
      _ForwardIterator __result,
      random_access_iterator_tag)
    {
      auto __second_res = uninitialized_copy(__first, __first + __n, __result);
      auto __first_res = std::next(__first, __n);
      return {__first_res, __second_res};
    }
# 852 "/usr/include/c++/10.2.0/bits/stl_uninitialized.h" 3
  template<typename _InputIterator, typename _Size, typename _ForwardIterator>
    inline _ForwardIterator
    uninitialized_copy_n(_InputIterator __first, _Size __n,
    _ForwardIterator __result)
    { return std::__uninitialized_copy_n(__first, __n, __result,
      std::__iterator_category(__first)); }


  template<typename _InputIterator, typename _Size, typename _ForwardIterator>
    inline pair<_InputIterator, _ForwardIterator>
    __uninitialized_copy_n_pair(_InputIterator __first, _Size __n,
         _ForwardIterator __result)
    {
      return
 std::__uninitialized_copy_n_pair(__first, __n, __result,
      std::__iterator_category(__first));
    }
# 966 "/usr/include/c++/10.2.0/bits/stl_uninitialized.h" 3
  template<typename _Tp, typename _Up, typename _Allocator>
    inline void
    __relocate_object_a(_Tp* __restrict __dest, _Up* __restrict __orig,
   _Allocator& __alloc)
    noexcept(noexcept(std::allocator_traits<_Allocator>::construct(__alloc,
    __dest, std::move(*__orig)))
      && noexcept(std::allocator_traits<_Allocator>::destroy(
       __alloc, std::__addressof(*__orig))))
    {
      typedef std::allocator_traits<_Allocator> __traits;
      __traits::construct(__alloc, __dest, std::move(*__orig));
      __traits::destroy(__alloc, std::__addressof(*__orig));
    }



  template<typename _Tp, typename = void>
    struct __is_bitwise_relocatable
    : is_trivial<_Tp> { };

  template <typename _Tp, typename _Up>
    inline __enable_if_t<std::__is_bitwise_relocatable<_Tp>::value, _Tp*>
    __relocate_a_1(_Tp* __first, _Tp* __last,
     _Tp* __result, allocator<_Up>&) noexcept
    {
      ptrdiff_t __count = __last - __first;
      if (__count > 0)
 __builtin_memmove(__result, __first, __count * sizeof(_Tp));
      return __result + __count;
    }

  template <typename _InputIterator, typename _ForwardIterator,
     typename _Allocator>
    inline _ForwardIterator
    __relocate_a_1(_InputIterator __first, _InputIterator __last,
     _ForwardIterator __result, _Allocator& __alloc)
    noexcept(noexcept(std::__relocate_object_a(std::addressof(*__result),
            std::addressof(*__first),
            __alloc)))
    {
      typedef typename iterator_traits<_InputIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType2;
      static_assert(std::is_same<_ValueType, _ValueType2>::value,
   "relocation is only possible for values of the same type");
      _ForwardIterator __cur = __result;
      for (; __first != __last; ++__first, (void)++__cur)
 std::__relocate_object_a(std::__addressof(*__cur),
     std::__addressof(*__first), __alloc);
      return __cur;
    }

  template <typename _InputIterator, typename _ForwardIterator,
     typename _Allocator>
    inline _ForwardIterator
    __relocate_a(_InputIterator __first, _InputIterator __last,
   _ForwardIterator __result, _Allocator& __alloc)
    noexcept(noexcept(__relocate_a_1(std::__niter_base(__first),
         std::__niter_base(__last),
         std::__niter_base(__result), __alloc)))
    {
      return __relocate_a_1(std::__niter_base(__first),
       std::__niter_base(__last),
       std::__niter_base(__result), __alloc);
    }







}
# 67 "/usr/include/c++/10.2.0/vector" 2 3
# 1 "/usr/include/c++/10.2.0/bits/stl_vector.h" 1 3
# 77 "/usr/include/c++/10.2.0/bits/stl_vector.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{




  template<typename _Tp, typename _Alloc>
    struct _Vector_base
    {
      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
 rebind<_Tp>::other _Tp_alloc_type;
      typedef typename __gnu_cxx::__alloc_traits<_Tp_alloc_type>::pointer
        pointer;

      struct _Vector_impl_data
      {
 pointer _M_start;
 pointer _M_finish;
 pointer _M_end_of_storage;

 _Vector_impl_data() noexcept
 : _M_start(), _M_finish(), _M_end_of_storage()
 { }


 _Vector_impl_data(_Vector_impl_data&& __x) noexcept
 : _M_start(__x._M_start), _M_finish(__x._M_finish),
   _M_end_of_storage(__x._M_end_of_storage)
 { __x._M_start = __x._M_finish = __x._M_end_of_storage = pointer(); }


 void
 _M_copy_data(_Vector_impl_data const& __x) noexcept
 {
   _M_start = __x._M_start;
   _M_finish = __x._M_finish;
   _M_end_of_storage = __x._M_end_of_storage;
 }

 void
 _M_swap_data(_Vector_impl_data& __x) noexcept
 {


   _Vector_impl_data __tmp;
   __tmp._M_copy_data(*this);
   _M_copy_data(__x);
   __x._M_copy_data(__tmp);
 }
      };

      struct _Vector_impl
 : public _Tp_alloc_type, public _Vector_impl_data
      {
 _Vector_impl() noexcept(is_nothrow_default_constructible<_Tp_alloc_type>::value)

 : _Tp_alloc_type()
 { }

 _Vector_impl(_Tp_alloc_type const& __a) noexcept
 : _Tp_alloc_type(__a)
 { }




 _Vector_impl(_Vector_impl&& __x) noexcept
 : _Tp_alloc_type(std::move(__x)), _Vector_impl_data(std::move(__x))
 { }

 _Vector_impl(_Tp_alloc_type&& __a) noexcept
 : _Tp_alloc_type(std::move(__a))
 { }

 _Vector_impl(_Tp_alloc_type&& __a, _Vector_impl&& __rv) noexcept
 : _Tp_alloc_type(std::move(__a)), _Vector_impl_data(std::move(__rv))
 { }
# 270 "/usr/include/c++/10.2.0/bits/stl_vector.h" 3
      };

    public:
      typedef _Alloc allocator_type;

      _Tp_alloc_type&
      _M_get_Tp_allocator() noexcept
      { return this->_M_impl; }

      const _Tp_alloc_type&
      _M_get_Tp_allocator() const noexcept
      { return this->_M_impl; }

      allocator_type
      get_allocator() const noexcept
      { return allocator_type(_M_get_Tp_allocator()); }


      _Vector_base() = default;




      _Vector_base(const allocator_type& __a) noexcept
      : _M_impl(__a) { }



      _Vector_base(size_t __n)
      : _M_impl()
      { _M_create_storage(__n); }


      _Vector_base(size_t __n, const allocator_type& __a)
      : _M_impl(__a)
      { _M_create_storage(__n); }


      _Vector_base(_Vector_base&&) = default;



      _Vector_base(_Tp_alloc_type&& __a) noexcept
      : _M_impl(std::move(__a)) { }

      _Vector_base(_Vector_base&& __x, const allocator_type& __a)
      : _M_impl(__a)
      {
 if (__x.get_allocator() == __a)
   this->_M_impl._M_swap_data(__x._M_impl);
 else
   {
     size_t __n = __x._M_impl._M_finish - __x._M_impl._M_start;
     _M_create_storage(__n);
   }
      }


      _Vector_base(const allocator_type& __a, _Vector_base&& __x)
      : _M_impl(_Tp_alloc_type(__a), std::move(__x._M_impl))
      { }


      ~_Vector_base() noexcept
      {
 _M_deallocate(_M_impl._M_start,
        _M_impl._M_end_of_storage - _M_impl._M_start);
      }

    public:
      _Vector_impl _M_impl;

      pointer
      _M_allocate(size_t __n)
      {
 typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
 return __n != 0 ? _Tr::allocate(_M_impl, __n) : pointer();
      }

      void
      _M_deallocate(pointer __p, size_t __n)
      {
 typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
 if (__p)
   _Tr::deallocate(_M_impl, __p, __n);
      }

    protected:
      void
      _M_create_storage(size_t __n)
      {
 this->_M_impl._M_start = this->_M_allocate(__n);
 this->_M_impl._M_finish = this->_M_impl._M_start;
 this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
      }
    };
# 388 "/usr/include/c++/10.2.0/bits/stl_vector.h" 3
  template<typename _Tp, typename _Alloc = std::allocator<_Tp> >
    class vector : protected _Vector_base<_Tp, _Alloc>
    {
# 401 "/usr/include/c++/10.2.0/bits/stl_vector.h" 3
      static_assert(is_same<typename remove_cv<_Tp>::type, _Tp>::value,
   "std::vector must have a non-const, non-volatile value_type");






      typedef _Vector_base<_Tp, _Alloc> _Base;
      typedef typename _Base::_Tp_alloc_type _Tp_alloc_type;
      typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Alloc_traits;

    public:
      typedef _Tp value_type;
      typedef typename _Base::pointer pointer;
      typedef typename _Alloc_traits::const_pointer const_pointer;
      typedef typename _Alloc_traits::reference reference;
      typedef typename _Alloc_traits::const_reference const_reference;
      typedef __gnu_cxx::__normal_iterator<pointer, vector> iterator;
      typedef __gnu_cxx::__normal_iterator<const_pointer, vector>
      const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Alloc allocator_type;

    private:

      static constexpr bool
      _S_nothrow_relocate(true_type)
      {
 return noexcept(std::__relocate_a(std::declval<pointer>(),
       std::declval<pointer>(),
       std::declval<pointer>(),
       std::declval<_Tp_alloc_type&>()));
      }

      static constexpr bool
      _S_nothrow_relocate(false_type)
      { return false; }

      static constexpr bool
      _S_use_relocate()
      {



 return _S_nothrow_relocate(__is_move_insertable<_Tp_alloc_type>{});
      }

      static pointer
      _S_do_relocate(pointer __first, pointer __last, pointer __result,
       _Tp_alloc_type& __alloc, true_type) noexcept
      {
 return std::__relocate_a(__first, __last, __result, __alloc);
      }

      static pointer
      _S_do_relocate(pointer, pointer, pointer __result,
       _Tp_alloc_type&, false_type) noexcept
      { return __result; }

      static pointer
      _S_relocate(pointer __first, pointer __last, pointer __result,
    _Tp_alloc_type& __alloc) noexcept
      {
 using __do_it = __bool_constant<_S_use_relocate()>;
 return _S_do_relocate(__first, __last, __result, __alloc, __do_it{});
      }


    protected:
      using _Base::_M_allocate;
      using _Base::_M_deallocate;
      using _Base::_M_impl;
      using _Base::_M_get_Tp_allocator;

    public:







      vector() = default;
# 496 "/usr/include/c++/10.2.0/bits/stl_vector.h" 3
      explicit
      vector(const allocator_type& __a) noexcept
      : _Base(__a) { }
# 509 "/usr/include/c++/10.2.0/bits/stl_vector.h" 3
      explicit
      vector(size_type __n, const allocator_type& __a = allocator_type())
      : _Base(_S_check_init_len(__n, __a), __a)
      { _M_default_initialize(__n); }
# 522 "/usr/include/c++/10.2.0/bits/stl_vector.h" 3
      vector(size_type __n, const value_type& __value,
      const allocator_type& __a = allocator_type())
      : _Base(_S_check_init_len(__n, __a), __a)
      { _M_fill_initialize(__n, __value); }
# 553 "/usr/include/c++/10.2.0/bits/stl_vector.h" 3
      vector(const vector& __x)
      : _Base(__x.size(),
 _Alloc_traits::_S_select_on_copy(__x._M_get_Tp_allocator()))
      {
 this->_M_impl._M_finish =
   std::__uninitialized_copy_a(__x.begin(), __x.end(),
          this->_M_impl._M_start,
          _M_get_Tp_allocator());
      }
# 572 "/usr/include/c++/10.2.0/bits/stl_vector.h" 3
      vector(vector&&) noexcept = default;


      vector(const vector& __x, const allocator_type& __a)
      : _Base(__x.size(), __a)
      {
 this->_M_impl._M_finish =
   std::__uninitialized_copy_a(__x.begin(), __x.end(),
          this->_M_impl._M_start,
          _M_get_Tp_allocator());
      }

    private:
      vector(vector&& __rv, const allocator_type& __m, true_type) noexcept
      : _Base(__m, std::move(__rv))
      { }

      vector(vector&& __rv, const allocator_type& __m, false_type)
      : _Base(__m)
      {
 if (__rv.get_allocator() == __m)
   this->_M_impl._M_swap_data(__rv._M_impl);
 else if (!__rv.empty())
   {
     this->_M_create_storage(__rv.size());
     this->_M_impl._M_finish =
       std::__uninitialized_move_a(__rv.begin(), __rv.end(),
       this->_M_impl._M_start,
       _M_get_Tp_allocator());
     __rv.clear();
   }
      }

    public:

      vector(vector&& __rv, const allocator_type& __m)
      noexcept( noexcept(
 vector(std::declval<vector&&>(), std::declval<const allocator_type&>(),
        std::declval<typename _Alloc_traits::is_always_equal>())) )
      : vector(std::move(__rv), __m, typename _Alloc_traits::is_always_equal{})
      { }
# 625 "/usr/include/c++/10.2.0/bits/stl_vector.h" 3
      vector(initializer_list<value_type> __l,
      const allocator_type& __a = allocator_type())
      : _Base(__a)
      {
 _M_range_initialize(__l.begin(), __l.end(),
       random_access_iterator_tag());
      }
# 651 "/usr/include/c++/10.2.0/bits/stl_vector.h" 3
      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
 vector(_InputIterator __first, _InputIterator __last,
        const allocator_type& __a = allocator_type())
 : _Base(__a)
 {
   _M_range_initialize(__first, __last,
         std::__iterator_category(__first));
 }
# 678 "/usr/include/c++/10.2.0/bits/stl_vector.h" 3
      ~vector() noexcept
      {
 std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
        _M_get_Tp_allocator());
 ;
      }
# 694 "/usr/include/c++/10.2.0/bits/stl_vector.h" 3
      vector&
      operator=(const vector& __x);
# 708 "/usr/include/c++/10.2.0/bits/stl_vector.h" 3
      vector&
      operator=(vector&& __x) noexcept(_Alloc_traits::_S_nothrow_move())
      {
 constexpr bool __move_storage =
   _Alloc_traits::_S_propagate_on_move_assign()
   || _Alloc_traits::_S_always_equal();
 _M_move_assign(std::move(__x), __bool_constant<__move_storage>());
 return *this;
      }
# 729 "/usr/include/c++/10.2.0/bits/stl_vector.h" 3
      vector&
      operator=(initializer_list<value_type> __l)
      {
 this->_M_assign_aux(__l.begin(), __l.end(),
       random_access_iterator_tag());
 return *this;
      }
# 748 "/usr/include/c++/10.2.0/bits/stl_vector.h" 3
      void
      assign(size_type __n, const value_type& __val)
      { _M_fill_assign(__n, __val); }
# 765 "/usr/include/c++/10.2.0/bits/stl_vector.h" 3
      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
 void
 assign(_InputIterator __first, _InputIterator __last)
 { _M_assign_dispatch(__first, __last, __false_type()); }
# 793 "/usr/include/c++/10.2.0/bits/stl_vector.h" 3
      void
      assign(initializer_list<value_type> __l)
      {
 this->_M_assign_aux(__l.begin(), __l.end(),
       random_access_iterator_tag());
      }



      using _Base::get_allocator;







      iterator
      begin() noexcept
      { return iterator(this->_M_impl._M_start); }






      const_iterator
      begin() const noexcept
      { return const_iterator(this->_M_impl._M_start); }






      iterator
      end() noexcept
      { return iterator(this->_M_impl._M_finish); }






      const_iterator
      end() const noexcept
      { return const_iterator(this->_M_impl._M_finish); }






      reverse_iterator
      rbegin() noexcept
      { return reverse_iterator(end()); }






      const_reverse_iterator
      rbegin() const noexcept
      { return const_reverse_iterator(end()); }






      reverse_iterator
      rend() noexcept
      { return reverse_iterator(begin()); }






      const_reverse_iterator
      rend() const noexcept
      { return const_reverse_iterator(begin()); }







      const_iterator
      cbegin() const noexcept
      { return const_iterator(this->_M_impl._M_start); }






      const_iterator
      cend() const noexcept
      { return const_iterator(this->_M_impl._M_finish); }






      const_reverse_iterator
      crbegin() const noexcept
      { return const_reverse_iterator(end()); }






      const_reverse_iterator
      crend() const noexcept
      { return const_reverse_iterator(begin()); }




      size_type
      size() const noexcept
      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }


      size_type
      max_size() const noexcept
      { return _S_max_size(_M_get_Tp_allocator()); }
# 936 "/usr/include/c++/10.2.0/bits/stl_vector.h" 3
      void
      resize(size_type __new_size)
      {
 if (__new_size > size())
   _M_default_append(__new_size - size());
 else if (__new_size < size())
   _M_erase_at_end(this->_M_impl._M_start + __new_size);
      }
# 956 "/usr/include/c++/10.2.0/bits/stl_vector.h" 3
      void
      resize(size_type __new_size, const value_type& __x)
      {
 if (__new_size > size())
   _M_fill_insert(end(), __new_size - size(), __x);
 else if (__new_size < size())
   _M_erase_at_end(this->_M_impl._M_start + __new_size);
      }
# 988 "/usr/include/c++/10.2.0/bits/stl_vector.h" 3
      void
      shrink_to_fit()
      { _M_shrink_to_fit(); }






      size_type
      capacity() const noexcept
      { return size_type(this->_M_impl._M_end_of_storage
    - this->_M_impl._M_start); }





      bool
      empty() const noexcept
      { return begin() == end(); }
# 1027 "/usr/include/c++/10.2.0/bits/stl_vector.h" 3
      void
      reserve(size_type __n);
# 1042 "/usr/include/c++/10.2.0/bits/stl_vector.h" 3
      reference
      operator[](size_type __n) noexcept
      {
 ;
 return *(this->_M_impl._M_start + __n);
      }
# 1060 "/usr/include/c++/10.2.0/bits/stl_vector.h" 3
      const_reference
      operator[](size_type __n) const noexcept
      {
 ;
 return *(this->_M_impl._M_start + __n);
      }

    protected:

      void
      _M_range_check(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range_fmt(("vector::_M_range_check: __n " "(which is %zu) >= this->size() " "(which is %zu)")

                            ,
       __n, this->size());
      }

    public:
# 1091 "/usr/include/c++/10.2.0/bits/stl_vector.h" 3
      reference
      at(size_type __n)
      {
 _M_range_check(__n);
 return (*this)[__n];
      }
# 1109 "/usr/include/c++/10.2.0/bits/stl_vector.h" 3
      const_reference
      at(size_type __n) const
      {
 _M_range_check(__n);
 return (*this)[__n];
      }





      reference
      front() noexcept
      {
 ;
 return *begin();
      }





      const_reference
      front() const noexcept
      {
 ;
 return *begin();
      }





      reference
      back() noexcept
      {
 ;
 return *(end() - 1);
      }





      const_reference
      back() const noexcept
      {
 ;
 return *(end() - 1);
      }
# 1167 "/usr/include/c++/10.2.0/bits/stl_vector.h" 3
      _Tp*
      data() noexcept
      { return _M_data_ptr(this->_M_impl._M_start); }

      const _Tp*
      data() const noexcept
      { return _M_data_ptr(this->_M_impl._M_start); }
# 1186 "/usr/include/c++/10.2.0/bits/stl_vector.h" 3
      void
      push_back(const value_type& __x)
      {
 if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
   {
     ;
     _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
         __x);
     ++this->_M_impl._M_finish;
     ;
   }
 else
   _M_realloc_insert(end(), __x);
      }


      void
      push_back(value_type&& __x)
      { emplace_back(std::move(__x)); }

      template<typename... _Args>



 void

 emplace_back(_Args&&... __args);
# 1224 "/usr/include/c++/10.2.0/bits/stl_vector.h" 3
      void
      pop_back() noexcept
      {
 ;
 --this->_M_impl._M_finish;
 _Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
 ;
      }
# 1246 "/usr/include/c++/10.2.0/bits/stl_vector.h" 3
      template<typename... _Args>
 iterator
 emplace(const_iterator __position, _Args&&... __args)
 { return _M_emplace_aux(__position, std::forward<_Args>(__args)...); }
# 1262 "/usr/include/c++/10.2.0/bits/stl_vector.h" 3
      iterator
      insert(const_iterator __position, const value_type& __x);
# 1292 "/usr/include/c++/10.2.0/bits/stl_vector.h" 3
      iterator
      insert(const_iterator __position, value_type&& __x)
      { return _M_insert_rval(__position, std::move(__x)); }
# 1309 "/usr/include/c++/10.2.0/bits/stl_vector.h" 3
      iterator
      insert(const_iterator __position, initializer_list<value_type> __l)
      {
 auto __offset = __position - cbegin();
 _M_range_insert(begin() + __offset, __l.begin(), __l.end(),
   std::random_access_iterator_tag());
 return begin() + __offset;
      }
# 1334 "/usr/include/c++/10.2.0/bits/stl_vector.h" 3
      iterator
      insert(const_iterator __position, size_type __n, const value_type& __x)
      {
 difference_type __offset = __position - cbegin();
 _M_fill_insert(begin() + __offset, __n, __x);
 return begin() + __offset;
      }
# 1376 "/usr/include/c++/10.2.0/bits/stl_vector.h" 3
      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
 iterator
 insert(const_iterator __position, _InputIterator __first,
        _InputIterator __last)
 {
   difference_type __offset = __position - cbegin();
   _M_insert_dispatch(begin() + __offset,
        __first, __last, __false_type());
   return begin() + __offset;
 }
# 1428 "/usr/include/c++/10.2.0/bits/stl_vector.h" 3
      iterator

      erase(const_iterator __position)
      { return _M_erase(begin() + (__position - cbegin())); }
# 1455 "/usr/include/c++/10.2.0/bits/stl_vector.h" 3
      iterator

      erase(const_iterator __first, const_iterator __last)
      {
 const auto __beg = begin();
 const auto __cbeg = cbegin();
 return _M_erase(__beg + (__first - __cbeg), __beg + (__last - __cbeg));
      }
# 1479 "/usr/include/c++/10.2.0/bits/stl_vector.h" 3
      void
      swap(vector& __x) noexcept
      {


                                                          ;

 this->_M_impl._M_swap_data(__x._M_impl);
 _Alloc_traits::_S_on_swap(_M_get_Tp_allocator(),
      __x._M_get_Tp_allocator());
      }







      void
      clear() noexcept
      { _M_erase_at_end(this->_M_impl._M_start); }

    protected:




      template<typename _ForwardIterator>
 pointer
 _M_allocate_and_copy(size_type __n,
        _ForwardIterator __first, _ForwardIterator __last)
 {
   pointer __result = this->_M_allocate(__n);
   try
     {
       std::__uninitialized_copy_a(__first, __last, __result,
       _M_get_Tp_allocator());
       return __result;
     }
   catch(...)
     {
       _M_deallocate(__result, __n);
       throw;
     }
 }
# 1556 "/usr/include/c++/10.2.0/bits/stl_vector.h" 3
      template<typename _InputIterator>
 void
 _M_range_initialize(_InputIterator __first, _InputIterator __last,
       std::input_iterator_tag)
 {
   try {
     for (; __first != __last; ++__first)

       emplace_back(*__first);



   } catch(...) {
     clear();
     throw;
   }
 }


      template<typename _ForwardIterator>
 void
 _M_range_initialize(_ForwardIterator __first, _ForwardIterator __last,
       std::forward_iterator_tag)
 {
   const size_type __n = std::distance(__first, __last);
   this->_M_impl._M_start
     = this->_M_allocate(_S_check_init_len(__n, _M_get_Tp_allocator()));
   this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
   this->_M_impl._M_finish =
     std::__uninitialized_copy_a(__first, __last,
     this->_M_impl._M_start,
     _M_get_Tp_allocator());
 }



      void
      _M_fill_initialize(size_type __n, const value_type& __value)
      {
 this->_M_impl._M_finish =
   std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value,
     _M_get_Tp_allocator());
      }



      void
      _M_default_initialize(size_type __n)
      {
 this->_M_impl._M_finish =
   std::__uninitialized_default_n_a(this->_M_impl._M_start, __n,
        _M_get_Tp_allocator());
      }
# 1618 "/usr/include/c++/10.2.0/bits/stl_vector.h" 3
      template<typename _Integer>
 void
 _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
 { _M_fill_assign(__n, __val); }


      template<typename _InputIterator>
 void
 _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
      __false_type)
 { _M_assign_aux(__first, __last, std::__iterator_category(__first)); }


      template<typename _InputIterator>
 void
 _M_assign_aux(_InputIterator __first, _InputIterator __last,
        std::input_iterator_tag);


      template<typename _ForwardIterator>
 void
 _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
        std::forward_iterator_tag);



      void
      _M_fill_assign(size_type __n, const value_type& __val);







      template<typename _Integer>
 void
 _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __val,
      __true_type)
 { _M_fill_insert(__pos, __n, __val); }


      template<typename _InputIterator>
 void
 _M_insert_dispatch(iterator __pos, _InputIterator __first,
      _InputIterator __last, __false_type)
 {
   _M_range_insert(__pos, __first, __last,
     std::__iterator_category(__first));
 }


      template<typename _InputIterator>
 void
 _M_range_insert(iterator __pos, _InputIterator __first,
   _InputIterator __last, std::input_iterator_tag);


      template<typename _ForwardIterator>
 void
 _M_range_insert(iterator __pos, _ForwardIterator __first,
   _ForwardIterator __last, std::forward_iterator_tag);



      void
      _M_fill_insert(iterator __pos, size_type __n, const value_type& __x);



      void
      _M_default_append(size_type __n);

      bool
      _M_shrink_to_fit();
# 1705 "/usr/include/c++/10.2.0/bits/stl_vector.h" 3
      struct _Temporary_value
      {
 template<typename... _Args>
   explicit
   _Temporary_value(vector* __vec, _Args&&... __args) : _M_this(__vec)
   {
     _Alloc_traits::construct(_M_this->_M_impl, _M_ptr(),
         std::forward<_Args>(__args)...);
   }

 ~_Temporary_value()
 { _Alloc_traits::destroy(_M_this->_M_impl, _M_ptr()); }

 value_type&
 _M_val() { return *_M_ptr(); }

      private:
 _Tp*
 _M_ptr() { return reinterpret_cast<_Tp*>(&__buf); }

 vector* _M_this;
 typename aligned_storage<sizeof(_Tp), alignof(_Tp)>::type __buf;
      };



      template<typename _Arg>
 void
 _M_insert_aux(iterator __position, _Arg&& __arg);

      template<typename... _Args>
 void
 _M_realloc_insert(iterator __position, _Args&&... __args);


      iterator
      _M_insert_rval(const_iterator __position, value_type&& __v);


      template<typename... _Args>
 iterator
 _M_emplace_aux(const_iterator __position, _Args&&... __args);


      iterator
      _M_emplace_aux(const_iterator __position, value_type&& __v)
      { return _M_insert_rval(__position, std::move(__v)); }



      size_type
      _M_check_len(size_type __n, const char* __s) const
      {
 if (max_size() - size() < __n)
   __throw_length_error((__s));

 const size_type __len = size() + (std::max)(size(), __n);
 return (__len < size() || __len > max_size()) ? max_size() : __len;
      }


      static size_type
      _S_check_init_len(size_type __n, const allocator_type& __a)
      {
 if (__n > _S_max_size(_Tp_alloc_type(__a)))
   __throw_length_error(
       ("cannot create std::vector larger than max_size()"));
 return __n;
      }

      static size_type
      _S_max_size(const _Tp_alloc_type& __a) noexcept
      {



 const size_t __diffmax
   = __gnu_cxx::__numeric_traits<ptrdiff_t>::__max / sizeof(_Tp);
 const size_t __allocmax = _Alloc_traits::max_size(__a);
 return (std::min)(__diffmax, __allocmax);
      }





      void
      _M_erase_at_end(pointer __pos) noexcept
      {
 if (size_type __n = this->_M_impl._M_finish - __pos)
   {
     std::_Destroy(__pos, this->_M_impl._M_finish,
     _M_get_Tp_allocator());
     this->_M_impl._M_finish = __pos;
     ;
   }
      }

      iterator
      _M_erase(iterator __position);

      iterator
      _M_erase(iterator __first, iterator __last);


    private:



      void
      _M_move_assign(vector&& __x, true_type) noexcept
      {
 vector __tmp(get_allocator());
 this->_M_impl._M_swap_data(__x._M_impl);
 __tmp._M_impl._M_swap_data(__x._M_impl);
 std::__alloc_on_move(_M_get_Tp_allocator(), __x._M_get_Tp_allocator());
      }



      void
      _M_move_assign(vector&& __x, false_type)
      {
 if (__x._M_get_Tp_allocator() == this->_M_get_Tp_allocator())
   _M_move_assign(std::move(__x), true_type());
 else
   {


     this->_M_assign_aux(std::make_move_iterator(__x.begin()),
           std::make_move_iterator(__x.end()),
    std::random_access_iterator_tag());
     __x.clear();
   }
      }


      template<typename _Up>
 _Up*
 _M_data_ptr(_Up* __ptr) const noexcept
 { return __ptr; }


      template<typename _Ptr>
 typename std::pointer_traits<_Ptr>::element_type*
 _M_data_ptr(_Ptr __ptr) const
 { return empty() ? nullptr : std::__to_address(__ptr); }
# 1868 "/usr/include/c++/10.2.0/bits/stl_vector.h" 3
    };
# 1890 "/usr/include/c++/10.2.0/bits/stl_vector.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator==(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return (__x.size() == __y.size()
       && std::equal(__x.begin(), __x.end(), __y.begin())); }
# 1928 "/usr/include/c++/10.2.0/bits/stl_vector.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator<(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return std::lexicographical_compare(__x.begin(), __x.end(),
       __y.begin(), __y.end()); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return __y < __x; }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator<=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__x < __y); }



  template<typename _Tp, typename _Alloc>
    inline void
    swap(vector<_Tp, _Alloc>& __x, vector<_Tp, _Alloc>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }


# 1982 "/usr/include/c++/10.2.0/bits/stl_vector.h" 3

}
# 68 "/usr/include/c++/10.2.0/vector" 2 3
# 1 "/usr/include/c++/10.2.0/bits/stl_bvector.h" 1 3
# 64 "/usr/include/c++/10.2.0/bits/stl_bvector.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  typedef unsigned long _Bit_type;
  enum { _S_word_bit = int(8 * sizeof(_Bit_type)) };

  struct _Bit_reference
  {
    _Bit_type * _M_p;
    _Bit_type _M_mask;

    _Bit_reference(_Bit_type * __x, _Bit_type __y)
    : _M_p(__x), _M_mask(__y) { }

    _Bit_reference() noexcept : _M_p(0), _M_mask(0) { }


    _Bit_reference(const _Bit_reference&) = default;


    operator bool() const noexcept
    { return !!(*_M_p & _M_mask); }

    _Bit_reference&
    operator=(bool __x) noexcept
    {
      if (__x)
 *_M_p |= _M_mask;
      else
 *_M_p &= ~_M_mask;
      return *this;
    }

    _Bit_reference&
    operator=(const _Bit_reference& __x) noexcept
    { return *this = bool(__x); }

    bool
    operator==(const _Bit_reference& __x) const
    { return bool(*this) == bool(__x); }

    bool
    operator<(const _Bit_reference& __x) const
    { return !bool(*this) && bool(__x); }

    void
    flip() noexcept
    { *_M_p ^= _M_mask; }
  };


  inline void
  swap(_Bit_reference __x, _Bit_reference __y) noexcept
  {
    bool __tmp = __x;
    __x = __y;
    __y = __tmp;
  }

  inline void
  swap(_Bit_reference __x, bool& __y) noexcept
  {
    bool __tmp = __x;
    __x = __y;
    __y = __tmp;
  }

  inline void
  swap(bool& __x, _Bit_reference __y) noexcept
  {
    bool __tmp = __x;
    __x = __y;
    __y = __tmp;
  }


  struct _Bit_iterator_base
  : public std::iterator<std::random_access_iterator_tag, bool>
  {
    _Bit_type * _M_p;
    unsigned int _M_offset;

    _Bit_iterator_base(_Bit_type * __x, unsigned int __y)
    : _M_p(__x), _M_offset(__y) { }

    void
    _M_bump_up()
    {
      if (_M_offset++ == int(_S_word_bit) - 1)
 {
   _M_offset = 0;
   ++_M_p;
 }
    }

    void
    _M_bump_down()
    {
      if (_M_offset-- == 0)
 {
   _M_offset = int(_S_word_bit) - 1;
   --_M_p;
 }
    }

    void
    _M_incr(ptrdiff_t __i)
    {
      difference_type __n = __i + _M_offset;
      _M_p += __n / int(_S_word_bit);
      __n = __n % int(_S_word_bit);
      if (__n < 0)
 {
   __n += int(_S_word_bit);
   --_M_p;
 }
      _M_offset = static_cast<unsigned int>(__n);
    }

    friend bool
    operator==(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y)
    { return __x._M_p == __y._M_p && __x._M_offset == __y._M_offset; }
# 199 "/usr/include/c++/10.2.0/bits/stl_bvector.h" 3
    friend bool
    operator<(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y)
    {
      return __x._M_p < __y._M_p
     || (__x._M_p == __y._M_p && __x._M_offset < __y._M_offset);
    }

    friend bool
    operator!=(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y)
    { return !(__x == __y); }

    friend bool
    operator>(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y)
    { return __y < __x; }

    friend bool
    operator<=(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y)
    { return !(__y < __x); }

    friend bool
    operator>=(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y)
    { return !(__x < __y); }


    friend ptrdiff_t
    operator-(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y)
    {
      return (int(_S_word_bit) * (__x._M_p - __y._M_p)
       + __x._M_offset - __y._M_offset);
    }
  };

  struct _Bit_iterator : public _Bit_iterator_base
  {
    typedef _Bit_reference reference;



    typedef _Bit_reference* pointer;

    typedef _Bit_iterator iterator;

    _Bit_iterator() : _Bit_iterator_base(0, 0) { }

    _Bit_iterator(_Bit_type * __x, unsigned int __y)
    : _Bit_iterator_base(__x, __y) { }

    iterator
    _M_const_cast() const
    { return *this; }

    reference
    operator*() const
    { return reference(_M_p, 1UL << _M_offset); }

    iterator&
    operator++()
    {
      _M_bump_up();
      return *this;
    }

    iterator
    operator++(int)
    {
      iterator __tmp = *this;
      _M_bump_up();
      return __tmp;
    }

    iterator&
    operator--()
    {
      _M_bump_down();
      return *this;
    }

    iterator
    operator--(int)
    {
      iterator __tmp = *this;
      _M_bump_down();
      return __tmp;
    }

    iterator&
    operator+=(difference_type __i)
    {
      _M_incr(__i);
      return *this;
    }

    iterator&
    operator-=(difference_type __i)
    {
      *this += -__i;
      return *this;
    }

    reference
    operator[](difference_type __i) const
    { return *(*this + __i); }

    friend iterator
    operator+(const iterator& __x, difference_type __n)
    {
      iterator __tmp = __x;
      __tmp += __n;
      return __tmp;
    }

    friend iterator
    operator+(difference_type __n, const iterator& __x)
    { return __x + __n; }

    friend iterator
    operator-(const iterator& __x, difference_type __n)
    {
      iterator __tmp = __x;
      __tmp -= __n;
      return __tmp;
    }
  };

  struct _Bit_const_iterator : public _Bit_iterator_base
  {
    typedef bool reference;
    typedef bool const_reference;



    typedef const bool* pointer;

    typedef _Bit_const_iterator const_iterator;

    _Bit_const_iterator() : _Bit_iterator_base(0, 0) { }

    _Bit_const_iterator(_Bit_type * __x, unsigned int __y)
    : _Bit_iterator_base(__x, __y) { }

    _Bit_const_iterator(const _Bit_iterator& __x)
    : _Bit_iterator_base(__x._M_p, __x._M_offset) { }

    _Bit_iterator
    _M_const_cast() const
    { return _Bit_iterator(_M_p, _M_offset); }

    const_reference
    operator*() const
    { return _Bit_reference(_M_p, 1UL << _M_offset); }

    const_iterator&
    operator++()
    {
      _M_bump_up();
      return *this;
    }

    const_iterator
    operator++(int)
    {
      const_iterator __tmp = *this;
      _M_bump_up();
      return __tmp;
    }

    const_iterator&
    operator--()
    {
      _M_bump_down();
      return *this;
    }

    const_iterator
    operator--(int)
    {
      const_iterator __tmp = *this;
      _M_bump_down();
      return __tmp;
    }

    const_iterator&
    operator+=(difference_type __i)
    {
      _M_incr(__i);
      return *this;
    }

    const_iterator&
    operator-=(difference_type __i)
    {
      *this += -__i;
      return *this;
    }

    const_reference
    operator[](difference_type __i) const
    { return *(*this + __i); }

    friend const_iterator
    operator+(const const_iterator& __x, difference_type __n)
    {
      const_iterator __tmp = __x;
      __tmp += __n;
      return __tmp;
    }

    friend const_iterator
    operator-(const const_iterator& __x, difference_type __n)
    {
      const_iterator __tmp = __x;
      __tmp -= __n;
      return __tmp;
    }

    friend const_iterator
    operator+(difference_type __n, const const_iterator& __x)
    { return __x + __n; }
  };

  inline void
  __fill_bvector(_Bit_type * __v,
   unsigned int __first, unsigned int __last, bool __x)
  {
    const _Bit_type __fmask = ~0ul << __first;
    const _Bit_type __lmask = ~0ul >> (_S_word_bit - __last);
    const _Bit_type __mask = __fmask & __lmask;

    if (__x)
      *__v |= __mask;
    else
      *__v &= ~__mask;
  }

  inline void
  fill(_Bit_iterator __first, _Bit_iterator __last, const bool& __x)
  {
    if (__first._M_p != __last._M_p)
      {
 _Bit_type* __first_p = __first._M_p;
 if (__first._M_offset != 0)
   __fill_bvector(__first_p++, __first._M_offset, _S_word_bit, __x);

 __builtin_memset(__first_p, __x ? ~0 : 0,
    (__last._M_p - __first_p) * sizeof(_Bit_type));

 if (__last._M_offset != 0)
   __fill_bvector(__last._M_p, 0, __last._M_offset, __x);
      }
    else if (__first._M_offset != __last._M_offset)
      __fill_bvector(__first._M_p, __first._M_offset, __last._M_offset, __x);
  }

  template<typename _Alloc>
    struct _Bvector_base
    {
      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
        rebind<_Bit_type>::other _Bit_alloc_type;
      typedef typename __gnu_cxx::__alloc_traits<_Bit_alloc_type>
 _Bit_alloc_traits;
      typedef typename _Bit_alloc_traits::pointer _Bit_pointer;

      struct _Bvector_impl_data
      {
 _Bit_iterator _M_start;
 _Bit_iterator _M_finish;
 _Bit_pointer _M_end_of_storage;

 _Bvector_impl_data() noexcept
 : _M_start(), _M_finish(), _M_end_of_storage()
 { }


 _Bvector_impl_data(_Bvector_impl_data&& __x) noexcept
 : _M_start(__x._M_start), _M_finish(__x._M_finish)
 , _M_end_of_storage(__x._M_end_of_storage)
 { __x._M_reset(); }

 void
 _M_move_data(_Bvector_impl_data&& __x) noexcept
 {
   this->_M_start = __x._M_start;
   this->_M_finish = __x._M_finish;
   this->_M_end_of_storage = __x._M_end_of_storage;
   __x._M_reset();
 }


 void
 _M_reset() noexcept
 {
   _M_start = _M_finish = _Bit_iterator();
   _M_end_of_storage = _Bit_pointer();
 }
      };

      struct _Bvector_impl
 : public _Bit_alloc_type, public _Bvector_impl_data
 {
 public:
   _Bvector_impl() noexcept(is_nothrow_default_constructible<_Bit_alloc_type>::value)

   : _Bit_alloc_type()
   { }

   _Bvector_impl(const _Bit_alloc_type& __a) noexcept
   : _Bit_alloc_type(__a)
   { }


 _Bvector_impl(_Bvector_impl&&) = default;


 _Bit_type*
 _M_end_addr() const noexcept
 {
   if (this->_M_end_of_storage)
     return std::__addressof(this->_M_end_of_storage[-1]) + 1;
   return 0;
 }
      };

    public:
      typedef _Alloc allocator_type;

      _Bit_alloc_type&
      _M_get_Bit_allocator() noexcept
      { return this->_M_impl; }

      const _Bit_alloc_type&
      _M_get_Bit_allocator() const noexcept
      { return this->_M_impl; }

      allocator_type
      get_allocator() const noexcept
      { return allocator_type(_M_get_Bit_allocator()); }


      _Bvector_base() = default;




      _Bvector_base(const allocator_type& __a)
      : _M_impl(__a) { }


      _Bvector_base(_Bvector_base&&) = default;


      ~_Bvector_base()
      { this->_M_deallocate(); }

    protected:
      _Bvector_impl _M_impl;

      _Bit_pointer
      _M_allocate(size_t __n)
      { return _Bit_alloc_traits::allocate(_M_impl, _S_nword(__n)); }

      void
      _M_deallocate()
      {
 if (_M_impl._M_start._M_p)
   {
     const size_t __n = _M_impl._M_end_addr() - _M_impl._M_start._M_p;
     _Bit_alloc_traits::deallocate(_M_impl,
       _M_impl._M_end_of_storage - __n,
       __n);
     _M_impl._M_reset();
   }
      }


      void
      _M_move_data(_Bvector_base&& __x) noexcept
      { _M_impl._M_move_data(std::move(__x._M_impl)); }


      static size_t
      _S_nword(size_t __n)
      { return (__n + int(_S_word_bit) - 1) / int(_S_word_bit); }
    };



}




namespace std __attribute__ ((__visibility__ ("default")))
{


# 614 "/usr/include/c++/10.2.0/bits/stl_bvector.h" 3
  template<typename _Alloc>
    class vector<bool, _Alloc> : protected _Bvector_base<_Alloc>
    {
      typedef _Bvector_base<_Alloc> _Base;
      typedef typename _Base::_Bit_pointer _Bit_pointer;
      typedef typename _Base::_Bit_alloc_traits _Bit_alloc_traits;


      friend struct std::hash<vector>;


    public:
      typedef bool value_type;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Bit_reference reference;
      typedef bool const_reference;
      typedef _Bit_reference* pointer;
      typedef const bool* const_pointer;
      typedef _Bit_iterator iterator;
      typedef _Bit_const_iterator const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef _Alloc allocator_type;

      allocator_type
      get_allocator() const
      { return _Base::get_allocator(); }

    protected:
      using _Base::_M_allocate;
      using _Base::_M_deallocate;
      using _Base::_S_nword;
      using _Base::_M_get_Bit_allocator;

    public:

      vector() = default;




      explicit
      vector(const allocator_type& __a)
      : _Base(__a) { }


      explicit
      vector(size_type __n, const allocator_type& __a = allocator_type())
      : vector(__n, false, __a)
      { }

      vector(size_type __n, const bool& __value,
      const allocator_type& __a = allocator_type())





      : _Base(__a)
      {
 _M_initialize(__n);
 _M_initialize_value(__value);
      }

      vector(const vector& __x)
      : _Base(_Bit_alloc_traits::_S_select_on_copy(__x._M_get_Bit_allocator()))
      {
 _M_initialize(__x.size());
 _M_copy_aligned(__x.begin(), __x.end(), this->_M_impl._M_start);
      }


      vector(vector&&) = default;

      vector(vector&& __x, const allocator_type& __a)
      noexcept(_Bit_alloc_traits::_S_always_equal())
      : _Base(__a)
      {
 if (__x.get_allocator() == __a)
   this->_M_move_data(std::move(__x));
 else
   {
     _M_initialize(__x.size());
     _M_copy_aligned(__x.begin(), __x.end(), begin());
     __x.clear();
   }
      }

      vector(const vector& __x, const allocator_type& __a)
      : _Base(__a)
      {
 _M_initialize(__x.size());
 _M_copy_aligned(__x.begin(), __x.end(), this->_M_impl._M_start);
      }

      vector(initializer_list<bool> __l,
      const allocator_type& __a = allocator_type())
      : _Base(__a)
      {
 _M_initialize_range(__l.begin(), __l.end(),
       random_access_iterator_tag());
      }



      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
 vector(_InputIterator __first, _InputIterator __last,
        const allocator_type& __a = allocator_type())
 : _Base(__a)
 { _M_initialize_dispatch(__first, __last, __false_type()); }
# 737 "/usr/include/c++/10.2.0/bits/stl_bvector.h" 3
      ~vector() noexcept { }

      vector&
      operator=(const vector& __x)
      {
 if (&__x == this)
   return *this;

 if (_Bit_alloc_traits::_S_propagate_on_copy_assign())
   {
     if (this->_M_get_Bit_allocator() != __x._M_get_Bit_allocator())
       {
  this->_M_deallocate();
  std::__alloc_on_copy(_M_get_Bit_allocator(),
         __x._M_get_Bit_allocator());
  _M_initialize(__x.size());
       }
     else
       std::__alloc_on_copy(_M_get_Bit_allocator(),
       __x._M_get_Bit_allocator());
   }

 if (__x.size() > capacity())
   {
     this->_M_deallocate();
     _M_initialize(__x.size());
   }
 this->_M_impl._M_finish = _M_copy_aligned(__x.begin(), __x.end(),
        begin());
 return *this;
      }


      vector&
      operator=(vector&& __x) noexcept(_Bit_alloc_traits::_S_nothrow_move())
      {
 if (_Bit_alloc_traits::_S_propagate_on_move_assign()
     || this->_M_get_Bit_allocator() == __x._M_get_Bit_allocator())
   {
     this->_M_deallocate();
     this->_M_move_data(std::move(__x));
     std::__alloc_on_move(_M_get_Bit_allocator(),
     __x._M_get_Bit_allocator());
   }
 else
   {
     if (__x.size() > capacity())
       {
  this->_M_deallocate();
  _M_initialize(__x.size());
       }
     this->_M_impl._M_finish = _M_copy_aligned(__x.begin(), __x.end(),
            begin());
     __x.clear();
   }
 return *this;
      }

      vector&
      operator=(initializer_list<bool> __l)
      {
 this->assign (__l.begin(), __l.end());
 return *this;
      }






      void
      assign(size_type __n, const bool& __x)
      { _M_fill_assign(__n, __x); }


      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
 void
 assign(_InputIterator __first, _InputIterator __last)
 { _M_assign_aux(__first, __last, std::__iterator_category(__first)); }
# 828 "/usr/include/c++/10.2.0/bits/stl_bvector.h" 3
      void
      assign(initializer_list<bool> __l)
      { _M_assign_aux(__l.begin(), __l.end(), random_access_iterator_tag()); }


      iterator
      begin() noexcept
      { return iterator(this->_M_impl._M_start._M_p, 0); }

      const_iterator
      begin() const noexcept
      { return const_iterator(this->_M_impl._M_start._M_p, 0); }

      iterator
      end() noexcept
      { return this->_M_impl._M_finish; }

      const_iterator
      end() const noexcept
      { return this->_M_impl._M_finish; }

      reverse_iterator
      rbegin() noexcept
      { return reverse_iterator(end()); }

      const_reverse_iterator
      rbegin() const noexcept
      { return const_reverse_iterator(end()); }

      reverse_iterator
      rend() noexcept
      { return reverse_iterator(begin()); }

      const_reverse_iterator
      rend() const noexcept
      { return const_reverse_iterator(begin()); }


      const_iterator
      cbegin() const noexcept
      { return const_iterator(this->_M_impl._M_start._M_p, 0); }

      const_iterator
      cend() const noexcept
      { return this->_M_impl._M_finish; }

      const_reverse_iterator
      crbegin() const noexcept
      { return const_reverse_iterator(end()); }

      const_reverse_iterator
      crend() const noexcept
      { return const_reverse_iterator(begin()); }


      size_type
      size() const noexcept
      { return size_type(end() - begin()); }

      size_type
      max_size() const noexcept
      {
 const size_type __isize =
   __gnu_cxx::__numeric_traits<difference_type>::__max
   - int(_S_word_bit) + 1;
 const size_type __asize
   = _Bit_alloc_traits::max_size(_M_get_Bit_allocator());
 return (__asize <= __isize / int(_S_word_bit)
  ? __asize * int(_S_word_bit) : __isize);
      }

      size_type
      capacity() const noexcept
      { return size_type(const_iterator(this->_M_impl._M_end_addr(), 0)
    - begin()); }

      bool
      empty() const noexcept
      { return begin() == end(); }

      reference
      operator[](size_type __n)
      {
 return *iterator(this->_M_impl._M_start._M_p
    + __n / int(_S_word_bit), __n % int(_S_word_bit));
      }

      const_reference
      operator[](size_type __n) const
      {
 return *const_iterator(this->_M_impl._M_start._M_p
        + __n / int(_S_word_bit), __n % int(_S_word_bit));
      }

    protected:
      void
      _M_range_check(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range_fmt(("vector<bool>::_M_range_check: __n " "(which is %zu) >= this->size() " "(which is %zu)")

                            ,
       __n, this->size());
      }

    public:
      reference
      at(size_type __n)
      { _M_range_check(__n); return (*this)[__n]; }

      const_reference
      at(size_type __n) const
      { _M_range_check(__n); return (*this)[__n]; }

      void
      reserve(size_type __n)
      {
 if (__n > max_size())
   __throw_length_error(("vector::reserve"));
 if (capacity() < __n)
   _M_reallocate(__n);
      }

      reference
      front()
      { return *begin(); }

      const_reference
      front() const
      { return *begin(); }

      reference
      back()
      { return *(end() - 1); }

      const_reference
      back() const
      { return *(end() - 1); }






      void
      data() noexcept { }

      void
      push_back(bool __x)
      {
 if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_addr())
   *this->_M_impl._M_finish++ = __x;
 else
   _M_insert_aux(end(), __x);
      }

      void
      swap(vector& __x) noexcept
      {
 std::swap(this->_M_impl._M_start, __x._M_impl._M_start);
 std::swap(this->_M_impl._M_finish, __x._M_impl._M_finish);
 std::swap(this->_M_impl._M_end_of_storage,
    __x._M_impl._M_end_of_storage);
 _Bit_alloc_traits::_S_on_swap(_M_get_Bit_allocator(),
          __x._M_get_Bit_allocator());
      }


      static void
      swap(reference __x, reference __y) noexcept
      {
 bool __tmp = __x;
 __x = __y;
 __y = __tmp;
      }

      iterator

      insert(const_iterator __position, const bool& __x = bool())



      {
 const difference_type __n = __position - begin();
 if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_addr()
     && __position == end())
   *this->_M_impl._M_finish++ = __x;
 else
   _M_insert_aux(__position._M_const_cast(), __x);
 return begin() + __n;
      }


      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
 iterator
 insert(const_iterator __position,
        _InputIterator __first, _InputIterator __last)
 {
   difference_type __offset = __position - cbegin();
   _M_insert_dispatch(__position._M_const_cast(),
        __first, __last, __false_type());
   return begin() + __offset;
 }
# 1044 "/usr/include/c++/10.2.0/bits/stl_bvector.h" 3
      iterator
      insert(const_iterator __position, size_type __n, const bool& __x)
      {
 difference_type __offset = __position - cbegin();
 _M_fill_insert(__position._M_const_cast(), __n, __x);
 return begin() + __offset;
      }







      iterator
      insert(const_iterator __p, initializer_list<bool> __l)
      { return this->insert(__p, __l.begin(), __l.end()); }


      void
      pop_back()
      { --this->_M_impl._M_finish; }

      iterator

      erase(const_iterator __position)



      { return _M_erase(__position._M_const_cast()); }

      iterator

      erase(const_iterator __first, const_iterator __last)



      { return _M_erase(__first._M_const_cast(), __last._M_const_cast()); }

      void
      resize(size_type __new_size, bool __x = bool())
      {
 if (__new_size < size())
   _M_erase_at_end(begin() + difference_type(__new_size));
 else
   insert(end(), __new_size - size(), __x);
      }


      void
      shrink_to_fit()
      { _M_shrink_to_fit(); }


      void
      flip() noexcept
      {
 _Bit_type * const __end = this->_M_impl._M_end_addr();
 for (_Bit_type * __p = this->_M_impl._M_start._M_p; __p != __end; ++__p)
   *__p = ~*__p;
      }

      void
      clear() noexcept
      { _M_erase_at_end(begin()); }


      template<typename... _Args>



 void

 emplace_back(_Args&&... __args)
 {
   push_back(bool(__args...));



 }

      template<typename... _Args>
 iterator
 emplace(const_iterator __pos, _Args&&... __args)
 { return insert(__pos, bool(__args...)); }


    protected:

      iterator
      _M_copy_aligned(const_iterator __first, const_iterator __last,
        iterator __result)
      {
 _Bit_type* __q = std::copy(__first._M_p, __last._M_p, __result._M_p);
 return std::copy(const_iterator(__last._M_p, 0), __last,
    iterator(__q, 0));
      }

      void
      _M_initialize(size_type __n)
      {
 if (__n)
   {
     _Bit_pointer __q = this->_M_allocate(__n);
     this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
     this->_M_impl._M_start = iterator(std::__addressof(*__q), 0);
   }
 else
   {
     this->_M_impl._M_end_of_storage = _Bit_pointer();
     this->_M_impl._M_start = iterator(0, 0);
   }
 this->_M_impl._M_finish = this->_M_impl._M_start + difference_type(__n);

      }

      void
      _M_initialize_value(bool __x)
      {
 if (_Bit_type* __p = this->_M_impl._M_start._M_p)
   __builtin_memset(__p, __x ? ~0 : 0,
      (this->_M_impl._M_end_addr() - __p)
      * sizeof(_Bit_type));
      }

      void
      _M_reallocate(size_type __n);


      bool
      _M_shrink_to_fit();






      template<typename _Integer>
 void
 _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type)
 {
   _M_initialize(static_cast<size_type>(__n));
   _M_initialize_value(__x);
 }

      template<typename _InputIterator>
 void
 _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
          __false_type)
 { _M_initialize_range(__first, __last,
         std::__iterator_category(__first)); }

      template<typename _InputIterator>
 void
 _M_initialize_range(_InputIterator __first, _InputIterator __last,
       std::input_iterator_tag)
 {
   for (; __first != __last; ++__first)
     push_back(*__first);
 }

      template<typename _ForwardIterator>
 void
 _M_initialize_range(_ForwardIterator __first, _ForwardIterator __last,
       std::forward_iterator_tag)
 {
   const size_type __n = std::distance(__first, __last);
   _M_initialize(__n);
   std::copy(__first, __last, this->_M_impl._M_start);
 }
# 1230 "/usr/include/c++/10.2.0/bits/stl_bvector.h" 3
      void
      _M_fill_assign(size_t __n, bool __x)
      {
 if (__n > size())
   {
     _M_initialize_value(__x);
     insert(end(), __n - size(), __x);
   }
 else
   {
     _M_erase_at_end(begin() + __n);
     _M_initialize_value(__x);
   }
      }

      template<typename _InputIterator>
 void
 _M_assign_aux(_InputIterator __first, _InputIterator __last,
        std::input_iterator_tag)
 {
   iterator __cur = begin();
   for (; __first != __last && __cur != end(); ++__cur, (void)++__first)
     *__cur = *__first;
   if (__first == __last)
     _M_erase_at_end(__cur);
   else
     insert(end(), __first, __last);
 }

      template<typename _ForwardIterator>
 void
 _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
        std::forward_iterator_tag)
 {
   const size_type __len = std::distance(__first, __last);
   if (__len < size())
     _M_erase_at_end(std::copy(__first, __last, begin()));
   else
     {
       _ForwardIterator __mid = __first;
       std::advance(__mid, size());
       std::copy(__first, __mid, begin());
       insert(end(), __mid, __last);
     }
 }





      template<typename _Integer>
 void
 _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __x,
      __true_type)
 { _M_fill_insert(__pos, __n, __x); }

      template<typename _InputIterator>
 void
 _M_insert_dispatch(iterator __pos,
      _InputIterator __first, _InputIterator __last,
      __false_type)
 { _M_insert_range(__pos, __first, __last,
     std::__iterator_category(__first)); }

      void
      _M_fill_insert(iterator __position, size_type __n, bool __x);

      template<typename _InputIterator>
 void
 _M_insert_range(iterator __pos, _InputIterator __first,
   _InputIterator __last, std::input_iterator_tag)
 {
   for (; __first != __last; ++__first)
     {
       __pos = insert(__pos, *__first);
       ++__pos;
     }
 }

      template<typename _ForwardIterator>
 void
 _M_insert_range(iterator __position, _ForwardIterator __first,
   _ForwardIterator __last, std::forward_iterator_tag);

      void
      _M_insert_aux(iterator __position, bool __x);

      size_type
      _M_check_len(size_type __n, const char* __s) const
      {
 if (max_size() - size() < __n)
   __throw_length_error((__s));

 const size_type __len = size() + std::max(size(), __n);
 return (__len < size() || __len > max_size()) ? max_size() : __len;
      }

      void
      _M_erase_at_end(iterator __pos)
      { this->_M_impl._M_finish = __pos; }

      iterator
      _M_erase(iterator __pos);

      iterator
      _M_erase(iterator __first, iterator __last);
  };



}



namespace std __attribute__ ((__visibility__ ("default")))
{




  template<typename _Alloc>
    struct hash<std::vector<bool, _Alloc>>
    : public __hash_base<size_t, std::vector<bool, _Alloc>>
    {
      size_t
      operator()(const std::vector<bool, _Alloc>&) const noexcept;
    };


}
# 69 "/usr/include/c++/10.2.0/vector" 2 3



# 1 "/usr/include/c++/10.2.0/bits/vector.tcc" 1 3
# 59 "/usr/include/c++/10.2.0/bits/vector.tcc" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    reserve(size_type __n)
    {
      if (__n > this->max_size())
 __throw_length_error(("vector::reserve"));
      if (this->capacity() < __n)
 {
   const size_type __old_size = size();
   pointer __tmp;

   if (_S_use_relocate())
     {
       __tmp = this->_M_allocate(__n);
       _S_relocate(this->_M_impl._M_start, this->_M_impl._M_finish,
     __tmp, _M_get_Tp_allocator());
     }
   else

     {
       __tmp = _M_allocate_and_copy(__n,
  std::__make_move_if_noexcept_iterator(this->_M_impl._M_start),
  std::__make_move_if_noexcept_iterator(this->_M_impl._M_finish));
       std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
       _M_get_Tp_allocator());
     }
   ;
   _M_deallocate(this->_M_impl._M_start,
   this->_M_impl._M_end_of_storage
   - this->_M_impl._M_start);
   this->_M_impl._M_start = __tmp;
   this->_M_impl._M_finish = __tmp + __old_size;
   this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
 }
    }


  template<typename _Tp, typename _Alloc>
    template<typename... _Args>



      void

      vector<_Tp, _Alloc>::
      emplace_back(_Args&&... __args)
      {
 if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
   {
     ;
     _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
         std::forward<_Args>(__args)...);
     ++this->_M_impl._M_finish;
     ;
   }
 else
   _M_realloc_insert(end(), std::forward<_Args>(__args)...);



      }


  template<typename _Tp, typename _Alloc>
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::

    insert(const_iterator __position, const value_type& __x)



    {
      const size_type __n = __position - begin();
      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
 if (__position == end())
   {
     ;
     _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
         __x);
     ++this->_M_impl._M_finish;
     ;
   }
 else
   {

     const auto __pos = begin() + (__position - cbegin());


     _Temporary_value __x_copy(this, __x);
     _M_insert_aux(__pos, std::move(__x_copy._M_val()));



   }
      else

 _M_realloc_insert(begin() + (__position - cbegin()), __x);




      return iterator(this->_M_impl._M_start + __n);
    }

  template<typename _Tp, typename _Alloc>
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::
    _M_erase(iterator __position)
    {
      if (__position + 1 != end())
 std::move(__position + 1, end(), __position);
      --this->_M_impl._M_finish;
      _Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
      ;
      return __position;
    }

  template<typename _Tp, typename _Alloc>
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::
    _M_erase(iterator __first, iterator __last)
    {
      if (__first != __last)
 {
   if (__last != end())
     std::move(__last, end(), __first);
   _M_erase_at_end(__first.base() + (end() - __last));
 }
      return __first;
    }

  template<typename _Tp, typename _Alloc>
    vector<_Tp, _Alloc>&
    vector<_Tp, _Alloc>::
    operator=(const vector<_Tp, _Alloc>& __x)
    {
      if (&__x != this)
 {
   ;

   if (_Alloc_traits::_S_propagate_on_copy_assign())
     {
       if (!_Alloc_traits::_S_always_equal()
           && _M_get_Tp_allocator() != __x._M_get_Tp_allocator())
         {

    this->clear();
    _M_deallocate(this->_M_impl._M_start,
    this->_M_impl._M_end_of_storage
    - this->_M_impl._M_start);
    this->_M_impl._M_start = nullptr;
    this->_M_impl._M_finish = nullptr;
    this->_M_impl._M_end_of_storage = nullptr;
  }
       std::__alloc_on_copy(_M_get_Tp_allocator(),
       __x._M_get_Tp_allocator());
     }

   const size_type __xlen = __x.size();
   if (__xlen > capacity())
     {
       pointer __tmp = _M_allocate_and_copy(__xlen, __x.begin(),
         __x.end());
       std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
       _M_get_Tp_allocator());
       _M_deallocate(this->_M_impl._M_start,
       this->_M_impl._M_end_of_storage
       - this->_M_impl._M_start);
       this->_M_impl._M_start = __tmp;
       this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __xlen;
     }
   else if (size() >= __xlen)
     {
       std::_Destroy(std::copy(__x.begin(), __x.end(), begin()),
       end(), _M_get_Tp_allocator());
     }
   else
     {
       std::copy(__x._M_impl._M_start, __x._M_impl._M_start + size(),
   this->_M_impl._M_start);
       std::__uninitialized_copy_a(__x._M_impl._M_start + size(),
       __x._M_impl._M_finish,
       this->_M_impl._M_finish,
       _M_get_Tp_allocator());
     }
   this->_M_impl._M_finish = this->_M_impl._M_start + __xlen;
 }
      return *this;
    }

  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    _M_fill_assign(size_t __n, const value_type& __val)
    {
      if (__n > capacity())
 {
   vector __tmp(__n, __val, _M_get_Tp_allocator());
   __tmp._M_impl._M_swap_data(this->_M_impl);
 }
      else if (__n > size())
 {
   std::fill(begin(), end(), __val);
   const size_type __add = __n - size();
   ;
   this->_M_impl._M_finish =
     std::__uninitialized_fill_n_a(this->_M_impl._M_finish,
       __add, __val, _M_get_Tp_allocator());
   ;
 }
      else
        _M_erase_at_end(std::fill_n(this->_M_impl._M_start, __n, __val));
    }

  template<typename _Tp, typename _Alloc>
    template<typename _InputIterator>
      void
      vector<_Tp, _Alloc>::
      _M_assign_aux(_InputIterator __first, _InputIterator __last,
      std::input_iterator_tag)
      {
 pointer __cur(this->_M_impl._M_start);
 for (; __first != __last && __cur != this->_M_impl._M_finish;
      ++__cur, (void)++__first)
   *__cur = *__first;
 if (__first == __last)
   _M_erase_at_end(__cur);
 else
   _M_range_insert(end(), __first, __last,
     std::__iterator_category(__first));
      }

  template<typename _Tp, typename _Alloc>
    template<typename _ForwardIterator>
      void
      vector<_Tp, _Alloc>::
      _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
      std::forward_iterator_tag)
      {
 const size_type __len = std::distance(__first, __last);

 if (__len > capacity())
   {
     _S_check_init_len(__len, _M_get_Tp_allocator());
     pointer __tmp(_M_allocate_and_copy(__len, __first, __last));
     std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
     _M_get_Tp_allocator());
     ;
     _M_deallocate(this->_M_impl._M_start,
     this->_M_impl._M_end_of_storage
     - this->_M_impl._M_start);
     this->_M_impl._M_start = __tmp;
     this->_M_impl._M_finish = this->_M_impl._M_start + __len;
     this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
   }
 else if (size() >= __len)
   _M_erase_at_end(std::copy(__first, __last, this->_M_impl._M_start));
 else
   {
     _ForwardIterator __mid = __first;
     std::advance(__mid, size());
     std::copy(__first, __mid, this->_M_impl._M_start);
     const size_type __attribute__((__unused__)) __n = __len - size();
     ;
     this->_M_impl._M_finish =
       std::__uninitialized_copy_a(__mid, __last,
       this->_M_impl._M_finish,
       _M_get_Tp_allocator());
     ;
   }
      }


  template<typename _Tp, typename _Alloc>
    auto
    vector<_Tp, _Alloc>::
    _M_insert_rval(const_iterator __position, value_type&& __v) -> iterator
    {
      const auto __n = __position - cbegin();
      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
 if (__position == cend())
   {
     ;
     _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
         std::move(__v));
     ++this->_M_impl._M_finish;
     ;
   }
 else
   _M_insert_aux(begin() + __n, std::move(__v));
      else
 _M_realloc_insert(begin() + __n, std::move(__v));

      return iterator(this->_M_impl._M_start + __n);
    }

  template<typename _Tp, typename _Alloc>
    template<typename... _Args>
      auto
      vector<_Tp, _Alloc>::
      _M_emplace_aux(const_iterator __position, _Args&&... __args)
      -> iterator
      {
 const auto __n = __position - cbegin();
 if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
   if (__position == cend())
     {
       ;
       _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
           std::forward<_Args>(__args)...);
       ++this->_M_impl._M_finish;
       ;
     }
   else
     {



       _Temporary_value __tmp(this, std::forward<_Args>(__args)...);
       _M_insert_aux(begin() + __n, std::move(__tmp._M_val()));
     }
 else
   _M_realloc_insert(begin() + __n, std::forward<_Args>(__args)...);

 return iterator(this->_M_impl._M_start + __n);
      }

  template<typename _Tp, typename _Alloc>
    template<typename _Arg>
      void
      vector<_Tp, _Alloc>::
      _M_insert_aux(iterator __position, _Arg&& __arg)






    {
      ;
      _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
          std::move(*(this->_M_impl._M_finish - 1)));
      ++this->_M_impl._M_finish;
      ;



      std::move_backward(__position.base(), this->_M_impl._M_finish - 2, this->_M_impl._M_finish - 1)

                                     ;



      *__position = std::forward<_Arg>(__arg);

    }


  template<typename _Tp, typename _Alloc>
    template<typename... _Args>
      void
      vector<_Tp, _Alloc>::
      _M_realloc_insert(iterator __position, _Args&&... __args)






    {
      const size_type __len =
 _M_check_len(size_type(1), "vector::_M_realloc_insert");
      pointer __old_start = this->_M_impl._M_start;
      pointer __old_finish = this->_M_impl._M_finish;
      const size_type __elems_before = __position - begin();
      pointer __new_start(this->_M_allocate(__len));
      pointer __new_finish(__new_start);
      try
 {





   _Alloc_traits::construct(this->_M_impl,
       __new_start + __elems_before,

       std::forward<_Args>(__args)...);



   __new_finish = pointer();


   if (_S_use_relocate())
     {
       __new_finish = _S_relocate(__old_start, __position.base(),
      __new_start, _M_get_Tp_allocator());

       ++__new_finish;

       __new_finish = _S_relocate(__position.base(), __old_finish,
      __new_finish, _M_get_Tp_allocator());
     }
   else

     {
       __new_finish
  = std::__uninitialized_move_if_noexcept_a
  (__old_start, __position.base(),
   __new_start, _M_get_Tp_allocator());

       ++__new_finish;

       __new_finish
  = std::__uninitialized_move_if_noexcept_a
  (__position.base(), __old_finish,
   __new_finish, _M_get_Tp_allocator());
     }
 }
      catch(...)
 {
   if (!__new_finish)
     _Alloc_traits::destroy(this->_M_impl,
       __new_start + __elems_before);
   else
     std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator());
   _M_deallocate(__new_start, __len);
   throw;
 }

      if (!_S_use_relocate())

 std::_Destroy(__old_start, __old_finish, _M_get_Tp_allocator());
      ;
      _M_deallocate(__old_start,
      this->_M_impl._M_end_of_storage - __old_start);
      this->_M_impl._M_start = __new_start;
      this->_M_impl._M_finish = __new_finish;
      this->_M_impl._M_end_of_storage = __new_start + __len;
    }

  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    _M_fill_insert(iterator __position, size_type __n, const value_type& __x)
    {
      if (__n != 0)
 {
   if (size_type(this->_M_impl._M_end_of_storage
   - this->_M_impl._M_finish) >= __n)
     {



       _Temporary_value __tmp(this, __x);
       value_type& __x_copy = __tmp._M_val();

       const size_type __elems_after = end() - __position;
       pointer __old_finish(this->_M_impl._M_finish);
       if (__elems_after > __n)
  {
    ;
    std::__uninitialized_move_a(this->_M_impl._M_finish - __n,
           this->_M_impl._M_finish,
           this->_M_impl._M_finish,
           _M_get_Tp_allocator());
    this->_M_impl._M_finish += __n;
    ;
    std::move_backward(__position.base(), __old_finish - __n, __old_finish)
                                        ;
    std::fill(__position.base(), __position.base() + __n,
       __x_copy);
  }
       else
  {
    ;
    this->_M_impl._M_finish =
      std::__uninitialized_fill_n_a(this->_M_impl._M_finish,
        __n - __elems_after,
        __x_copy,
        _M_get_Tp_allocator());
    ;
    std::__uninitialized_move_a(__position.base(), __old_finish,
           this->_M_impl._M_finish,
           _M_get_Tp_allocator());
    this->_M_impl._M_finish += __elems_after;
    ;
    std::fill(__position.base(), __old_finish, __x_copy);
  }
     }
   else
     {
       const size_type __len =
  _M_check_len(__n, "vector::_M_fill_insert");
       const size_type __elems_before = __position - begin();
       pointer __new_start(this->_M_allocate(__len));
       pointer __new_finish(__new_start);
       try
  {

    std::__uninitialized_fill_n_a(__new_start + __elems_before,
      __n, __x,
      _M_get_Tp_allocator());
    __new_finish = pointer();

    __new_finish
      = std::__uninitialized_move_if_noexcept_a
      (this->_M_impl._M_start, __position.base(),
       __new_start, _M_get_Tp_allocator());

    __new_finish += __n;

    __new_finish
      = std::__uninitialized_move_if_noexcept_a
      (__position.base(), this->_M_impl._M_finish,
       __new_finish, _M_get_Tp_allocator());
  }
       catch(...)
  {
    if (!__new_finish)
      std::_Destroy(__new_start + __elems_before,
      __new_start + __elems_before + __n,
      _M_get_Tp_allocator());
    else
      std::_Destroy(__new_start, __new_finish,
      _M_get_Tp_allocator());
    _M_deallocate(__new_start, __len);
    throw;
  }
       std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
       _M_get_Tp_allocator());
       ;
       _M_deallocate(this->_M_impl._M_start,
       this->_M_impl._M_end_of_storage
       - this->_M_impl._M_start);
       this->_M_impl._M_start = __new_start;
       this->_M_impl._M_finish = __new_finish;
       this->_M_impl._M_end_of_storage = __new_start + __len;
     }
 }
    }


  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    _M_default_append(size_type __n)
    {
      if (__n != 0)
 {
   const size_type __size = size();
   size_type __navail = size_type(this->_M_impl._M_end_of_storage
      - this->_M_impl._M_finish);

   if (__size > max_size() || __navail > max_size() - __size)
     __builtin_unreachable();

   if (__navail >= __n)
     {
       ;
       this->_M_impl._M_finish =
  std::__uninitialized_default_n_a(this->_M_impl._M_finish,
       __n, _M_get_Tp_allocator());
       ;
     }
   else
     {
       const size_type __len =
  _M_check_len(__n, "vector::_M_default_append");
       pointer __new_start(this->_M_allocate(__len));
       if (_S_use_relocate())
  {
    try
      {
        std::__uninitialized_default_n_a(__new_start + __size,
         __n, _M_get_Tp_allocator());
      }
    catch(...)
      {
        _M_deallocate(__new_start, __len);
        throw;
      }
    _S_relocate(this->_M_impl._M_start, this->_M_impl._M_finish,
         __new_start, _M_get_Tp_allocator());
  }
       else
  {
    pointer __destroy_from = pointer();
    try
      {
        std::__uninitialized_default_n_a(__new_start + __size,
         __n, _M_get_Tp_allocator());
        __destroy_from = __new_start + __size;
        std::__uninitialized_move_if_noexcept_a(
         this->_M_impl._M_start, this->_M_impl._M_finish,
         __new_start, _M_get_Tp_allocator());
      }
    catch(...)
      {
        if (__destroy_from)
   std::_Destroy(__destroy_from, __destroy_from + __n,
          _M_get_Tp_allocator());
        _M_deallocate(__new_start, __len);
        throw;
      }
    std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
    _M_get_Tp_allocator());
  }
       ;
       _M_deallocate(this->_M_impl._M_start,
       this->_M_impl._M_end_of_storage
       - this->_M_impl._M_start);
       this->_M_impl._M_start = __new_start;
       this->_M_impl._M_finish = __new_start + __size + __n;
       this->_M_impl._M_end_of_storage = __new_start + __len;
     }
 }
    }

  template<typename _Tp, typename _Alloc>
    bool
    vector<_Tp, _Alloc>::
    _M_shrink_to_fit()
    {
      if (capacity() == size())
 return false;
      ;
      return std::__shrink_to_fit_aux<vector>::_S_do_it(*this);
    }


  template<typename _Tp, typename _Alloc>
    template<typename _InputIterator>
      void
      vector<_Tp, _Alloc>::
      _M_range_insert(iterator __pos, _InputIterator __first,
        _InputIterator __last, std::input_iterator_tag)
      {
 if (__pos == end())
   {
     for (; __first != __last; ++__first)
       insert(end(), *__first);
   }
 else if (__first != __last)
   {
     vector __tmp(__first, __last, _M_get_Tp_allocator());
     insert(__pos,
     std::make_move_iterator(__tmp.begin()),
     std::make_move_iterator(__tmp.end()));
   }
      }

  template<typename _Tp, typename _Alloc>
    template<typename _ForwardIterator>
      void
      vector<_Tp, _Alloc>::
      _M_range_insert(iterator __position, _ForwardIterator __first,
        _ForwardIterator __last, std::forward_iterator_tag)
      {
 if (__first != __last)
   {
     const size_type __n = std::distance(__first, __last);
     if (size_type(this->_M_impl._M_end_of_storage
     - this->_M_impl._M_finish) >= __n)
       {
  const size_type __elems_after = end() - __position;
  pointer __old_finish(this->_M_impl._M_finish);
  if (__elems_after > __n)
    {
      ;
      std::__uninitialized_move_a(this->_M_impl._M_finish - __n,
      this->_M_impl._M_finish,
      this->_M_impl._M_finish,
      _M_get_Tp_allocator());
      this->_M_impl._M_finish += __n;
      ;
      std::move_backward(__position.base(), __old_finish - __n, __old_finish)
                                          ;
      std::copy(__first, __last, __position);
    }
  else
    {
      _ForwardIterator __mid = __first;
      std::advance(__mid, __elems_after);
      ;
      std::__uninitialized_copy_a(__mid, __last,
      this->_M_impl._M_finish,
      _M_get_Tp_allocator());
      this->_M_impl._M_finish += __n - __elems_after;
      ;
      std::__uninitialized_move_a(__position.base(),
      __old_finish,
      this->_M_impl._M_finish,
      _M_get_Tp_allocator());
      this->_M_impl._M_finish += __elems_after;
      ;
      std::copy(__first, __mid, __position);
    }
       }
     else
       {
  const size_type __len =
    _M_check_len(__n, "vector::_M_range_insert");
  pointer __new_start(this->_M_allocate(__len));
  pointer __new_finish(__new_start);
  try
    {
      __new_finish
        = std::__uninitialized_move_if_noexcept_a
        (this->_M_impl._M_start, __position.base(),
         __new_start, _M_get_Tp_allocator());
      __new_finish
        = std::__uninitialized_copy_a(__first, __last,
          __new_finish,
          _M_get_Tp_allocator());
      __new_finish
        = std::__uninitialized_move_if_noexcept_a
        (__position.base(), this->_M_impl._M_finish,
         __new_finish, _M_get_Tp_allocator());
    }
  catch(...)
    {
      std::_Destroy(__new_start, __new_finish,
      _M_get_Tp_allocator());
      _M_deallocate(__new_start, __len);
      throw;
    }
  std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
         _M_get_Tp_allocator());
  ;
  _M_deallocate(this->_M_impl._M_start,
         this->_M_impl._M_end_of_storage
         - this->_M_impl._M_start);
  this->_M_impl._M_start = __new_start;
  this->_M_impl._M_finish = __new_finish;
  this->_M_impl._M_end_of_storage = __new_start + __len;
       }
   }
      }



  template<typename _Alloc>
    void
    vector<bool, _Alloc>::
    _M_reallocate(size_type __n)
    {
      _Bit_pointer __q = this->_M_allocate(__n);
      iterator __start(std::__addressof(*__q), 0);
      iterator __finish(_M_copy_aligned(begin(), end(), __start));
      this->_M_deallocate();
      this->_M_impl._M_start = __start;
      this->_M_impl._M_finish = __finish;
      this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
    }

  template<typename _Alloc>
    void
    vector<bool, _Alloc>::
    _M_fill_insert(iterator __position, size_type __n, bool __x)
    {
      if (__n == 0)
 return;
      if (capacity() - size() >= __n)
 {
   std::copy_backward(__position, end(),
        this->_M_impl._M_finish + difference_type(__n));
   std::fill(__position, __position + difference_type(__n), __x);
   this->_M_impl._M_finish += difference_type(__n);
 }
      else
 {
   const size_type __len =
     _M_check_len(__n, "vector<bool>::_M_fill_insert");
   _Bit_pointer __q = this->_M_allocate(__len);
   iterator __start(std::__addressof(*__q), 0);
   iterator __i = _M_copy_aligned(begin(), __position, __start);
   std::fill(__i, __i + difference_type(__n), __x);
   iterator __finish = std::copy(__position, end(),
     __i + difference_type(__n));
   this->_M_deallocate();
   this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
   this->_M_impl._M_start = __start;
   this->_M_impl._M_finish = __finish;
 }
    }

  template<typename _Alloc>
    template<typename _ForwardIterator>
      void
      vector<bool, _Alloc>::
      _M_insert_range(iterator __position, _ForwardIterator __first,
        _ForwardIterator __last, std::forward_iterator_tag)
      {
 if (__first != __last)
   {
     size_type __n = std::distance(__first, __last);
     if (capacity() - size() >= __n)
       {
  std::copy_backward(__position, end(),
       this->_M_impl._M_finish
       + difference_type(__n));
  std::copy(__first, __last, __position);
  this->_M_impl._M_finish += difference_type(__n);
       }
     else
       {
  const size_type __len =
    _M_check_len(__n, "vector<bool>::_M_insert_range");
  _Bit_pointer __q = this->_M_allocate(__len);
  iterator __start(std::__addressof(*__q), 0);
  iterator __i = _M_copy_aligned(begin(), __position, __start);
  __i = std::copy(__first, __last, __i);
  iterator __finish = std::copy(__position, end(), __i);
  this->_M_deallocate();
  this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
  this->_M_impl._M_start = __start;
  this->_M_impl._M_finish = __finish;
       }
   }
      }

  template<typename _Alloc>
    void
    vector<bool, _Alloc>::
    _M_insert_aux(iterator __position, bool __x)
    {
      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_addr())
 {
   std::copy_backward(__position, this->_M_impl._M_finish,
        this->_M_impl._M_finish + 1);
   *__position = __x;
   ++this->_M_impl._M_finish;
 }
      else
 {
   const size_type __len =
     _M_check_len(size_type(1), "vector<bool>::_M_insert_aux");
   _Bit_pointer __q = this->_M_allocate(__len);
   iterator __start(std::__addressof(*__q), 0);
   iterator __i = _M_copy_aligned(begin(), __position, __start);
   *__i++ = __x;
   iterator __finish = std::copy(__position, end(), __i);
   this->_M_deallocate();
   this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
   this->_M_impl._M_start = __start;
   this->_M_impl._M_finish = __finish;
 }
    }

  template<typename _Alloc>
    typename vector<bool, _Alloc>::iterator
    vector<bool, _Alloc>::
    _M_erase(iterator __position)
    {
      if (__position + 1 != end())
        std::copy(__position + 1, end(), __position);
      --this->_M_impl._M_finish;
      return __position;
    }

  template<typename _Alloc>
    typename vector<bool, _Alloc>::iterator
    vector<bool, _Alloc>::
    _M_erase(iterator __first, iterator __last)
    {
      if (__first != __last)
 _M_erase_at_end(std::copy(__last, end(), __first));
      return __first;
    }


  template<typename _Alloc>
    bool
    vector<bool, _Alloc>::
    _M_shrink_to_fit()
    {
      if (capacity() - size() < int(_S_word_bit))
 return false;
      try
 {
   _M_reallocate(size());
   return true;
 }
      catch(...)
 { return false; }
    }




}



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Alloc>
    size_t
    hash<std::vector<bool, _Alloc>>::
    operator()(const std::vector<bool, _Alloc>& __b) const noexcept
    {
      size_t __hash = 0;
      using std::_S_word_bit;
      using std::_Bit_type;

      const size_t __words = __b.size() / _S_word_bit;
      if (__words)
 {
   const size_t __clength = __words * sizeof(_Bit_type);
   __hash = std::_Hash_impl::hash(__b._M_impl._M_start._M_p, __clength);
 }

      const size_t __extrabits = __b.size() % _S_word_bit;
      if (__extrabits)
 {
   _Bit_type __hiword = *__b._M_impl._M_finish._M_p;
   __hiword &= ~((~static_cast<_Bit_type>(0)) << __extrabits);

   const size_t __clength
     = (__extrabits + 8 - 1) / 8;
   if (__words)
     __hash = std::_Hash_impl::hash(&__hiword, __clength, __hash);
   else
     __hash = std::_Hash_impl::hash(&__hiword, __clength);
 }

      return __hash;
    }


}
# 73 "/usr/include/c++/10.2.0/vector" 2 3
# 23 "/usr/include/opencascade/BVH_Types.hxx" 2

# 1 "/usr/include/opencascade/Bnd_Box.hxx" 1
# 24 "/usr/include/opencascade/Bnd_Box.hxx"
# 1 "/usr/include/opencascade/gp_Pnt.hxx" 1
# 22 "/usr/include/opencascade/gp_Pnt.hxx"
# 1 "/usr/include/opencascade/gp_XYZ.hxx" 1
# 29 "/usr/include/opencascade/gp_XYZ.hxx"

# 29 "/usr/include/opencascade/gp_XYZ.hxx"
class Standard_ConstructionError;
class Standard_OutOfRange;
class gp_Mat;
# 41 "/usr/include/opencascade/gp_XYZ.hxx"
class gp_XYZ
{
public:

  void* operator new (size_t theSize) { return Standard::Allocate (theSize); } void operator delete (void* theAddress) { Standard::Free (theAddress); } void* operator new[] (size_t theSize) { return Standard::Allocate (theSize); } void operator delete[] (void* theAddress) { Standard::Free (theAddress); } void* operator new (size_t, void* theAddress) { return theAddress; } void operator delete (void*, void*) { }



    gp_XYZ();


    gp_XYZ(const Standard_Real X, const Standard_Real Y, const Standard_Real Z);



    void SetCoord (const Standard_Real X, const Standard_Real Y, const Standard_Real Z);







    void SetCoord (const Standard_Integer Index, const Standard_Real Xi);


    void SetX (const Standard_Real X);


    void SetY (const Standard_Real Y);


    void SetZ (const Standard_Real Z);
# 82 "/usr/include/opencascade/gp_XYZ.hxx"
    Standard_Real Coord (const Standard_Integer Index) const;

    Standard_Real& ChangeCoord (const Standard_Integer theIndex);

    void Coord (Standard_Real& X, Standard_Real& Y, Standard_Real& Z) const;




    inline const Standard_Real* GetData() const { return (&x); }




    inline Standard_Real* ChangeData() { return (&x); }


    Standard_Real X() const;


    Standard_Real Y() const;


    Standard_Real Z() const;


    Standard_Real Modulus() const;


    Standard_Real SquareModulus() const;
# 120 "/usr/include/opencascade/gp_XYZ.hxx"
  Standard_Boolean IsEqual (const gp_XYZ& Other, const Standard_Real Tolerance) const;





    void Add (const gp_XYZ& Other);
  void operator += (const gp_XYZ& Other)
{
  Add(Other);
}





  [[nodiscard]] gp_XYZ Added (const gp_XYZ& Other) const;
  [[nodiscard]] gp_XYZ operator + (const gp_XYZ& Other) const
{
  return Added(Other);
}





    void Cross (const gp_XYZ& Right);
  void operator ^= (const gp_XYZ& Right)
{
  Cross(Right);
}





  [[nodiscard]] gp_XYZ Crossed (const gp_XYZ& Right) const;
  [[nodiscard]] gp_XYZ operator ^ (const gp_XYZ& Right) const
{
  return Crossed(Right);
}




    Standard_Real CrossMagnitude (const gp_XYZ& Right) const;




    Standard_Real CrossSquareMagnitude (const gp_XYZ& Right) const;



    void CrossCross (const gp_XYZ& Coord1, const gp_XYZ& Coord2);



    [[nodiscard]] gp_XYZ CrossCrossed (const gp_XYZ& Coord1, const gp_XYZ& Coord2) const;


    void Divide (const Standard_Real Scalar);
  void operator /= (const Standard_Real Scalar)
{
  Divide(Scalar);
}


  [[nodiscard]] gp_XYZ Divided (const Standard_Real Scalar) const;
  [[nodiscard]] gp_XYZ operator / (const Standard_Real Scalar) const
{
  return Divided(Scalar);
}


    Standard_Real Dot (const gp_XYZ& Other) const;
  Standard_Real operator * (const gp_XYZ& Other) const
{
  return Dot(Other);
}


    Standard_Real DotCross (const gp_XYZ& Coord1, const gp_XYZ& Coord2) const;





    void Multiply (const Standard_Real Scalar);
  void operator *= (const Standard_Real Scalar)
{
  Multiply(Scalar);
}





    void Multiply (const gp_XYZ& Other);
  void operator *= (const gp_XYZ& Other)
{
  Multiply(Other);
}


    void Multiply (const gp_Mat& Matrix);
  void operator *= (const gp_Mat& Matrix)
{
  Multiply(Matrix);
}





  [[nodiscard]] gp_XYZ Multiplied (const Standard_Real Scalar) const;
  [[nodiscard]] gp_XYZ operator * (const Standard_Real Scalar) const
{
  return Multiplied(Scalar);
}





  [[nodiscard]] gp_XYZ Multiplied (const gp_XYZ& Other) const;


  [[nodiscard]] gp_XYZ Multiplied (const gp_Mat& Matrix) const;
  [[nodiscard]] gp_XYZ operator * (const gp_Mat& Matrix) const
{
  return Multiplied(Matrix);
}






    void Normalize();






    [[nodiscard]] gp_XYZ Normalized() const;





    void Reverse();





    [[nodiscard]] gp_XYZ Reversed() const;





    void Subtract (const gp_XYZ& Right);
  void operator -= (const gp_XYZ& Right)
{
  Subtract(Right);
}





  [[nodiscard]] gp_XYZ Subtracted (const gp_XYZ& Right) const;
  [[nodiscard]] gp_XYZ operator - (const gp_XYZ& Right) const
{
  return Subtracted(Right);
}




    void SetLinearForm (const Standard_Real A1, const gp_XYZ& XYZ1, const Standard_Real A2, const gp_XYZ& XYZ2, const Standard_Real A3, const gp_XYZ& XYZ3, const gp_XYZ& XYZ4);




    void SetLinearForm (const Standard_Real A1, const gp_XYZ& XYZ1, const Standard_Real A2, const gp_XYZ& XYZ2, const Standard_Real A3, const gp_XYZ& XYZ3);




    void SetLinearForm (const Standard_Real A1, const gp_XYZ& XYZ1, const Standard_Real A2, const gp_XYZ& XYZ2, const gp_XYZ& XYZ3);




    void SetLinearForm (const Standard_Real A1, const gp_XYZ& XYZ1, const Standard_Real A2, const gp_XYZ& XYZ2);




    void SetLinearForm (const Standard_Real A1, const gp_XYZ& XYZ1, const gp_XYZ& XYZ2);




    void SetLinearForm (const gp_XYZ& XYZ1, const gp_XYZ& XYZ2);



  void DumpJson (Standard_OStream& theOStream, Standard_Integer theDepth = -1) const;


  Standard_Boolean InitFromJson (const Standard_SStream& theSStream, Standard_Integer& theStreamPos);

protected:





private:



  Standard_Real x;
  Standard_Real y;
  Standard_Real z;


};


# 1 "/usr/include/opencascade/gp_XYZ.lxx" 1
# 17 "/usr/include/opencascade/gp_XYZ.lxx"
# 1 "/usr/include/opencascade/gp.hxx" 1
# 25 "/usr/include/opencascade/gp.hxx"
class gp_Pnt;
class gp_Dir;
class gp_Ax1;
class gp_Ax2;
class gp_Pnt2d;
class gp_Dir2d;
class gp_Ax2d;
class gp_XYZ;
class gp_Mat;
class gp_Quaternion;
class gp_Trsf;
class gp_GTrsf;
class gp_Pnt;
class gp_Vec;
class gp_Dir;
class gp_Ax1;
class gp_Ax2;
class gp_Ax3;
class gp_Lin;
class gp_Circ;
class gp_Elips;
class gp_Hypr;
class gp_Parab;
class gp_Pln;
class gp_Cylinder;
class gp_Sphere;
class gp_Torus;
class gp_Cone;
class gp_XY;
class gp_Mat2d;
class gp_Trsf2d;
class gp_GTrsf2d;
class gp_Pnt2d;
class gp_Vec2d;
class gp_Dir2d;
class gp_Ax2d;
class gp_Ax22d;
class gp_Lin2d;
class gp_Circ2d;
class gp_Elips2d;
class gp_Hypr2d;
class gp_Parab2d;
# 79 "/usr/include/opencascade/gp.hxx"
class gp
{
public:

  void* operator new (size_t theSize) { return Standard::Allocate (theSize); } void operator delete (void* theAddress) { Standard::Free (theAddress); } void* operator new[] (size_t theSize) { return Standard::Allocate (theSize); } void operator delete[] (void* theAddress) { Standard::Free (theAddress); } void* operator new (size_t, void* theAddress) { return theAddress; } void operator delete (void*, void*) { }
# 94 "/usr/include/opencascade/gp.hxx"
    static Standard_Real Resolution();


  static const gp_Pnt& Origin();


  static const gp_Dir& DX();


  static const gp_Dir& DY();


  static const gp_Dir& DZ();



  static const gp_Ax1& OX();



  static const gp_Ax1& OY();



  static const gp_Ax1& OZ();




  static const gp_Ax2& XOY();




  static const gp_Ax2& ZOX();





  static const gp_Ax2& YOZ();


  static const gp_Pnt2d& Origin2d();


  static const gp_Dir2d& DX2d();


  static const gp_Dir2d& DY2d();



  static const gp_Ax2d& OX2d();



  static const gp_Ax2d& OY2d();




protected:





private:




friend class gp_XYZ;
friend class gp_Mat;
friend class gp_Quaternion;
friend class gp_Trsf;
friend class gp_GTrsf;
friend class gp_Pnt;
friend class gp_Vec;
friend class gp_Dir;
friend class gp_Ax1;
friend class gp_Ax2;
friend class gp_Ax3;
friend class gp_Lin;
friend class gp_Circ;
friend class gp_Elips;
friend class gp_Hypr;
friend class gp_Parab;
friend class gp_Pln;
friend class gp_Cylinder;
friend class gp_Sphere;
friend class gp_Torus;
friend class gp_Cone;
friend class gp_XY;
friend class gp_Mat2d;
friend class gp_Trsf2d;
friend class gp_GTrsf2d;
friend class gp_Pnt2d;
friend class gp_Vec2d;
friend class gp_Dir2d;
friend class gp_Ax2d;
friend class gp_Ax22d;
friend class gp_Lin2d;
friend class gp_Circ2d;
friend class gp_Elips2d;
friend class gp_Hypr2d;
friend class gp_Parab2d;

};


# 1 "/usr/include/opencascade/gp.lxx" 1
# 16 "/usr/include/opencascade/gp.lxx"
inline Standard_Real gp::Resolution ()
{
  return RealSmall();
}
# 207 "/usr/include/opencascade/gp.hxx" 2
# 18 "/usr/include/opencascade/gp_XYZ.lxx" 2
# 1 "/usr/include/opencascade/gp_Mat.hxx" 1
# 25 "/usr/include/opencascade/gp_Mat.hxx"
class Standard_ConstructionError;
class Standard_OutOfRange;
class gp_XYZ;
class gp_Trsf;
class gp_GTrsf;





class gp_Mat
{
public:

  void* operator new (size_t theSize) { return Standard::Allocate (theSize); } void operator delete (void* theAddress) { Standard::Free (theAddress); } void* operator new[] (size_t theSize) { return Standard::Allocate (theSize); } void operator delete[] (void* theAddress) { Standard::Free (theAddress); } void* operator new (size_t, void* theAddress) { return theAddress; } void operator delete (void*, void*) { }



    gp_Mat();

    gp_Mat(const Standard_Real a11, const Standard_Real a12, const Standard_Real a13, const Standard_Real a21, const Standard_Real a22, const Standard_Real a23, const Standard_Real a31, const Standard_Real a32, const Standard_Real a33);



  gp_Mat(const gp_XYZ& Col1, const gp_XYZ& Col2, const gp_XYZ& Col3);




  void SetCol (const Standard_Integer Col, const gp_XYZ& Value);



  void SetCols (const gp_XYZ& Col1, const gp_XYZ& Col2, const gp_XYZ& Col3);
# 69 "/usr/include/opencascade/gp_Mat.hxx"
  void SetCross (const gp_XYZ& Ref);







    void SetDiagonal (const Standard_Real X1, const Standard_Real X2, const Standard_Real X3);







  void SetDot (const gp_XYZ& Ref);


    void SetIdentity();






  void SetRotation (const gp_XYZ& Axis, const Standard_Real Ang);



  void SetRow (const Standard_Integer Row, const gp_XYZ& Value);



  void SetRows (const gp_XYZ& Row1, const gp_XYZ& Row2, const gp_XYZ& Row3);







    void SetScale (const Standard_Real S);



    void SetValue (const Standard_Integer Row, const Standard_Integer Col, const Standard_Real Value);



  gp_XYZ Column (const Standard_Integer Col) const;


    Standard_Real Determinant() const;


  gp_XYZ Diagonal() const;



  gp_XYZ Row (const Standard_Integer Row) const;



    const Standard_Real& Value (const Standard_Integer Row, const Standard_Integer Col) const;
  const Standard_Real& operator() (const Standard_Integer Row, const Standard_Integer Col) const
{
  return Value(Row,Col);
}



    Standard_Real& ChangeValue (const Standard_Integer Row, const Standard_Integer Col);
  Standard_Real& operator() (const Standard_Integer Row, const Standard_Integer Col)
{
  return ChangeValue(Row,Col);
}





    Standard_Boolean IsSingular() const;

    void Add (const gp_Mat& Other);
  void operator += (const gp_Mat& Other)
{
  Add(Other);
}




  [[nodiscard]] gp_Mat Added (const gp_Mat& Other) const;
  [[nodiscard]] gp_Mat operator + (const gp_Mat& Other) const
{
  return Added(Other);
}

    void Divide (const Standard_Real Scalar);
  void operator /= (const Standard_Real Scalar)
{
  Divide(Scalar);
}


  [[nodiscard]] gp_Mat Divided (const Standard_Real Scalar) const;
  [[nodiscard]] gp_Mat operator / (const Standard_Real Scalar) const
{
  return Divided(Scalar);
}

  void Invert();
# 194 "/usr/include/opencascade/gp_Mat.hxx"
  [[nodiscard]] gp_Mat Inverted() const;



  [[nodiscard]] gp_Mat Multiplied (const gp_Mat& Other) const;
  [[nodiscard]] gp_Mat operator * (const gp_Mat& Other) const
{
  return Multiplied(Other);
}


    void Multiply (const gp_Mat& Other);
  void operator *= (const gp_Mat& Other)
{
  Multiply(Other);
}

    void PreMultiply (const gp_Mat& Other);

    [[nodiscard]] gp_Mat Multiplied (const Standard_Real Scalar) const;
  [[nodiscard]] gp_Mat operator * (const Standard_Real Scalar) const
{
  return Multiplied(Scalar);
}



    void Multiply (const Standard_Real Scalar);
  void operator *= (const Standard_Real Scalar)
{
  Multiply(Scalar);
}

  void Power (const Standard_Integer N);







  [[nodiscard]] gp_Mat Powered (const Standard_Integer N) const;

    void Subtract (const gp_Mat& Other);
  void operator -= (const gp_Mat& Other)
{
  Subtract(Other);
}




  [[nodiscard]] gp_Mat Subtracted (const gp_Mat& Other) const;
  [[nodiscard]] gp_Mat operator - (const gp_Mat& Other) const
{
  return Subtracted(Other);
}

    void Transpose();



    [[nodiscard]] gp_Mat Transposed() const;


  void DumpJson (Standard_OStream& theOStream, Standard_Integer theDepth = -1) const;


friend class gp_XYZ;
friend class gp_Trsf;
friend class gp_GTrsf;


protected:





private:



  Standard_Real matrix[3][3];


};


# 1 "/usr/include/opencascade/gp_Mat.lxx" 1
# 17 "/usr/include/opencascade/gp_Mat.lxx"
# 1 "/usr/include/opencascade/Standard_ConstructionError.hxx" 1
# 25 "/usr/include/opencascade/Standard_ConstructionError.hxx"
class Standard_ConstructionError;
class Standard_ConstructionError; typedef opencascade::handle<Standard_ConstructionError> Handle_Standard_ConstructionError;
# 35 "/usr/include/opencascade/Standard_ConstructionError.hxx"
class Standard_ConstructionError : public Standard_DomainError { void Throw () const override { throw *this; } public: Standard_ConstructionError() : Standard_DomainError() {} Standard_ConstructionError(const Standard_CString theMessage) : Standard_DomainError(theMessage) {} static void Raise(const Standard_CString theMessage = "") { opencascade::handle<Standard_ConstructionError> _E = new Standard_ConstructionError; _E->Reraise(theMessage); } static void Raise(Standard_SStream& theMessage) { opencascade::handle<Standard_ConstructionError> _E = new Standard_ConstructionError; _E->Reraise (theMessage); } static opencascade::handle<Standard_ConstructionError> NewInstance(const Standard_CString theMessage = "") { return new Standard_ConstructionError(theMessage); } public: typedef Standard_DomainError base_type; static const char* get_type_name () { return "Standard_ConstructionError"; using direct_base_classes = opencascade::direct_base_class_as_tuple<std::tr2::direct_bases<Standard_ConstructionError>::type>::type; static_assert(opencascade::has_type<Standard_DomainError, direct_base_classes>::type::value, "OCCT RTTI definition is incorrect: " "Standard_DomainError" " is not direct base class of " "Standard_ConstructionError"); static_assert(&get_type_name == &Standard_ConstructionError::get_type_name, "OCCT RTTI definition is misplaced: current class is not " "Standard_ConstructionError"); } static const opencascade::handle<Standard_Type>& get_type_descriptor () { return Standard_Type::Instance<Standard_ConstructionError>(); } virtual const opencascade::handle<Standard_Type>& DynamicType() const override { return get_type_descriptor (); } };
# 18 "/usr/include/opencascade/gp_Mat.lxx" 2
# 49 "/usr/include/opencascade/gp_Mat.lxx"
inline gp_Mat::gp_Mat () {
  matrix[0][0] =
    matrix[0][1] =
      matrix[0][2] =
 matrix[1][0] =
   matrix[1][1] =
     matrix[1][2] =
       matrix[2][0] =
  matrix[2][1] =
    matrix[2][2] = 0.0;
}

inline gp_Mat::gp_Mat (const Standard_Real a11,
         const Standard_Real a12,
         const Standard_Real a13,
         const Standard_Real a21,
         const Standard_Real a22,
         const Standard_Real a23,
         const Standard_Real a31,
         const Standard_Real a32,
         const Standard_Real a33) {

  matrix[0][0] = a11;
  matrix[0][1] = a12;
  matrix[0][2] = a13;
  matrix[1][0] = a21;
  matrix[1][1] = a22;
  matrix[1][2] = a23;
  matrix[2][0] = a31;
  matrix[2][1] = a32;
  matrix[2][2] = a33;
}

inline void gp_Mat::SetDiagonal (const Standard_Real X1,
     const Standard_Real X2,
     const Standard_Real X3)
{
  matrix[0][0] = X1; matrix[1][1] = X2; matrix[2][2] = X3;
}

inline void gp_Mat::SetIdentity ()
{
  matrix[0][0] = matrix[1][1] = matrix[2][2] = 1.0;
  matrix[0][1] = matrix[0][2] = matrix[1][0] = matrix[1][2] = matrix[2][0] = matrix[2][1] = 0.0;
 }

inline void gp_Mat::SetScale (const Standard_Real S)
{
  matrix[0][0] = matrix[1][1] = matrix[2][2] = S;
  matrix[0][1] = matrix[0][2] = matrix[1][0] = matrix[1][2] = matrix[2][0] = matrix[2][1] = 0.0;
}

inline void gp_Mat::SetValue (const Standard_Integer Row,
         const Standard_Integer Col,
         const Standard_Real Value)
{
 
#pragma GCC diagnostic push
# 105 "/usr/include/opencascade/gp_Mat.lxx"
 
#pragma GCC diagnostic ignored "-Wstrict-overflow"
# 105 "/usr/include/opencascade/gp_Mat.lxx"
  if (Row < 1 || Row > 3 || Col < 1 || Col > 3) throw Standard_OutOfRange(" ");
#pragma GCC diagnostic pop
# 105 "/usr/include/opencascade/gp_Mat.lxx"
 
                                                   ;
  matrix[Row-1][Col-1] = Value;
}

inline Standard_Real gp_Mat::Determinant () const
{
  return
    matrix[0][0] * (matrix[1][1] * matrix[2][2] - matrix[2][1] * matrix[1][2]) -
      matrix[0][1] * (matrix[1][0] * matrix[2][2] - matrix[2][0] * matrix[1][2]) +
 matrix[0][2] * (matrix[1][0] * matrix[2][1] - matrix[2][0] * matrix[1][1]);
}

inline const Standard_Real& gp_Mat::Value (const Standard_Integer Row,
        const Standard_Integer Col) const
{
 
#pragma GCC diagnostic push
# 121 "/usr/include/opencascade/gp_Mat.lxx"
 
#pragma GCC diagnostic ignored "-Wstrict-overflow"
# 121 "/usr/include/opencascade/gp_Mat.lxx"
  if (Row < 1 || Row > 3 || Col < 1 || Col > 3) throw Standard_OutOfRange(" ");
#pragma GCC diagnostic pop
# 121 "/usr/include/opencascade/gp_Mat.lxx"
 
                                                   ;
  return matrix[Row-1][Col-1];
}

inline Standard_Real& gp_Mat::ChangeValue (const Standard_Integer Row,
        const Standard_Integer Col)
{
 
#pragma GCC diagnostic push
# 129 "/usr/include/opencascade/gp_Mat.lxx"
 
#pragma GCC diagnostic ignored "-Wstrict-overflow"
# 129 "/usr/include/opencascade/gp_Mat.lxx"
  if (Row < 1 || Row > 3 || Col < 1 || Col > 3) throw Standard_OutOfRange(" ");
#pragma GCC diagnostic pop
# 129 "/usr/include/opencascade/gp_Mat.lxx"
 
                                                   ;
  return matrix[Row-1][Col-1];
}

inline Standard_Boolean gp_Mat::IsSingular () const
{

  Standard_Real val = Determinant();
  if (val < 0) val = - val;
  return val <= gp::Resolution();
}

inline void gp_Mat::Add (const gp_Mat& Other)
{
  matrix[0][0] = matrix[0][0] + Other.matrix[0][0];
  matrix[0][1] = matrix[0][1] + Other.matrix[0][1];
  matrix[0][2] = matrix[0][2] + Other.matrix[0][2];
  matrix[1][0] = matrix[1][0] + Other.matrix[1][0];
  matrix[1][1] = matrix[1][1] + Other.matrix[1][1];
  matrix[1][2] = matrix[1][2] + Other.matrix[1][2];
  matrix[2][0] = matrix[2][0] + Other.matrix[2][0];
  matrix[2][1] = matrix[2][1] + Other.matrix[2][1];
  matrix[2][2] = matrix[2][2] + Other.matrix[2][2];
}

inline gp_Mat gp_Mat::Added (const gp_Mat& Other) const
{
  gp_Mat NewMat;
  NewMat.matrix[0][0] = matrix[0][0] + Other.matrix[0][0];
  NewMat.matrix[0][1] = matrix[0][1] + Other.matrix[0][1];
  NewMat.matrix[0][2] = matrix[0][2] + Other.matrix[0][2];
  NewMat.matrix[1][0] = matrix[1][0] + Other.matrix[1][0];
  NewMat.matrix[1][1] = matrix[1][1] + Other.matrix[1][1];
  NewMat.matrix[1][2] = matrix[1][2] + Other.matrix[1][2];
  NewMat.matrix[2][0] = matrix[2][0] + Other.matrix[2][0];
  NewMat.matrix[2][1] = matrix[2][1] + Other.matrix[2][1];
  NewMat.matrix[2][2] = matrix[2][2] + Other.matrix[2][2];
  return NewMat;
}

inline void gp_Mat::Divide (const Standard_Real Scalar)
{
  Standard_Real val = Scalar;
  if (val < 0) val = - val;
  if (val <= gp::Resolution()) throw Standard_ConstructionError("gp_Mat : Divide by 0");
                                                      ;
  Standard_Real UnSurScalar = 1.0 / Scalar;
  matrix[0][0] *= UnSurScalar;
  matrix[0][1] *= UnSurScalar;
  matrix[0][2] *= UnSurScalar;
  matrix[1][0] *= UnSurScalar;
  matrix[1][1] *= UnSurScalar;
  matrix[1][2] *= UnSurScalar;
  matrix[2][0] *= UnSurScalar;
  matrix[2][1] *= UnSurScalar;
  matrix[2][2] *= UnSurScalar;
}

inline gp_Mat gp_Mat::Divided (const Standard_Real Scalar) const
{
  Standard_Real val = Scalar;
  if (val < 0) val = - val;
  if (val <= gp::Resolution()) throw Standard_ConstructionError("gp_Mat : Divide by 0");
                                                      ;
  gp_Mat NewMat;
  Standard_Real UnSurScalar = 1.0 / Scalar;
  NewMat.matrix[0][0] = matrix[0][0] * UnSurScalar;
  NewMat.matrix[0][1] = matrix[0][1] * UnSurScalar;
  NewMat.matrix[0][2] = matrix[0][2] * UnSurScalar;
  NewMat.matrix[1][0] = matrix[1][0] * UnSurScalar;
  NewMat.matrix[1][1] = matrix[1][1] * UnSurScalar;
  NewMat.matrix[1][2] = matrix[1][2] * UnSurScalar;
  NewMat.matrix[2][0] = matrix[2][0] * UnSurScalar;
  NewMat.matrix[2][1] = matrix[2][1] * UnSurScalar;
  NewMat.matrix[2][2] = matrix[2][2] * UnSurScalar;
  return NewMat;
}

inline gp_Mat gp_Mat::Multiplied (const gp_Mat& Other) const
{
  gp_Mat NewMat = *this;
  NewMat.Multiply(Other);
  return NewMat;
}

inline void gp_Mat::Multiply (const gp_Mat& Other)
{
  Standard_Real T00,T01,T02,T10,T11,T12,T20,T21,T22;
  T00 = matrix[0][0] * Other.matrix[0][0] + matrix[0][1] * Other.matrix[1][0] + matrix[0][2] * Other.matrix[2][0];
  T01 = matrix[0][0] * Other.matrix[0][1] + matrix[0][1] * Other.matrix[1][1] + matrix[0][2] * Other.matrix[2][1];
  T02 = matrix[0][0] * Other.matrix[0][2] + matrix[0][1] * Other.matrix[1][2] + matrix[0][2] * Other.matrix[2][2];
  T10 = matrix[1][0] * Other.matrix[0][0] + matrix[1][1] * Other.matrix[1][0] + matrix[1][2] * Other.matrix[2][0];
  T11 = matrix[1][0] * Other.matrix[0][1] + matrix[1][1] * Other.matrix[1][1] + matrix[1][2] * Other.matrix[2][1];
  T12 = matrix[1][0] * Other.matrix[0][2] + matrix[1][1] * Other.matrix[1][2] + matrix[1][2] * Other.matrix[2][2];
  T20 = matrix[2][0] * Other.matrix[0][0] + matrix[2][1] * Other.matrix[1][0] + matrix[2][2] * Other.matrix[2][0];
  T21 = matrix[2][0] * Other.matrix[0][1] + matrix[2][1] * Other.matrix[1][1] + matrix[2][2] * Other.matrix[2][1];
  T22 = matrix[2][0] * Other.matrix[0][2] + matrix[2][1] * Other.matrix[1][2] + matrix[2][2] * Other.matrix[2][2];
  matrix[0][0] = T00;
  matrix[0][1] = T01;
  matrix[0][2] = T02;
  matrix[1][0] = T10;
  matrix[1][1] = T11;
  matrix[1][2] = T12;
  matrix[2][0] = T20;
  matrix[2][1] = T21;
  matrix[2][2] = T22;
}

inline void gp_Mat::PreMultiply (const gp_Mat& Other)
{
  Standard_Real T00,T01,T02,T10,T11,T12,T20,T21,T22;
  T00 = Other.matrix[0][0] * matrix[0][0] + Other.matrix[0][1] * matrix[1][0] + Other.matrix[0][2] * matrix[2][0];
  T01 = Other.matrix[0][0] * matrix[0][1] + Other.matrix[0][1] * matrix[1][1] + Other.matrix[0][2] * matrix[2][1];
  T02 = Other.matrix[0][0] * matrix[0][2] + Other.matrix[0][1] * matrix[1][2] + Other.matrix[0][2] * matrix[2][2];
  T10 = Other.matrix[1][0] * matrix[0][0] + Other.matrix[1][1] * matrix[1][0] + Other.matrix[1][2] * matrix[2][0];
  T11 = Other.matrix[1][0] * matrix[0][1] + Other.matrix[1][1] * matrix[1][1] + Other.matrix[1][2] * matrix[2][1];
  T12 = Other.matrix[1][0] * matrix[0][2] + Other.matrix[1][1] * matrix[1][2] + Other.matrix[1][2] * matrix[2][2];
  T20 = Other.matrix[2][0] * matrix[0][0] + Other.matrix[2][1] * matrix[1][0] + Other.matrix[2][2] * matrix[2][0];
  T21 = Other.matrix[2][0] * matrix[0][1] + Other.matrix[2][1] * matrix[1][1] + Other.matrix[2][2] * matrix[2][1];
  T22 = Other.matrix[2][0] * matrix[0][2] + Other.matrix[2][1] * matrix[1][2] + Other.matrix[2][2] * matrix[2][2];
  matrix[0][0] = T00;
  matrix[0][1] = T01;
  matrix[0][2] = T02;
  matrix[1][0] = T10;
  matrix[1][1] = T11;
  matrix[1][2] = T12;
  matrix[2][0] = T20;
  matrix[2][1] = T21;
  matrix[2][2] = T22;
}

inline gp_Mat gp_Mat::Multiplied (const Standard_Real Scalar) const
{
  gp_Mat NewMat;
  NewMat.matrix[0][0] = Scalar * matrix[0][0];
  NewMat.matrix[0][1] = Scalar * matrix[0][1];
  NewMat.matrix[0][2] = Scalar * matrix[0][2];
  NewMat.matrix[1][0] = Scalar * matrix[1][0];
  NewMat.matrix[1][1] = Scalar * matrix[1][1];
  NewMat.matrix[1][2] = Scalar * matrix[1][2];
  NewMat.matrix[2][0] = Scalar * matrix[2][0];
  NewMat.matrix[2][1] = Scalar * matrix[2][1];
  NewMat.matrix[2][2] = Scalar * matrix[2][2];
  return NewMat;
}

inline void gp_Mat::Multiply (const Standard_Real Scalar)
{
  matrix[0][0] *= Scalar;
  matrix[0][1] *= Scalar;
  matrix[0][2] *= Scalar;
  matrix[1][0] *= Scalar;
  matrix[1][1] *= Scalar;
  matrix[1][2] *= Scalar;
  matrix[2][0] *= Scalar;
  matrix[2][1] *= Scalar;
  matrix[2][2] *= Scalar;
}

inline gp_Mat gp_Mat::Powered (const Standard_Integer N) const
{
   gp_Mat MatN = *this;
   MatN.Power (N);
   return MatN;
}

inline void gp_Mat::Subtract (const gp_Mat& Other)
{
  matrix[0][0] -= Other.matrix[0][0];
  matrix[0][1] -= Other.matrix[0][1];
  matrix[0][2] -= Other.matrix[0][2];
  matrix[1][0] -= Other.matrix[1][0];
  matrix[1][1] -= Other.matrix[1][1];
  matrix[1][2] -= Other.matrix[1][2];
  matrix[2][0] -= Other.matrix[2][0];
  matrix[2][1] -= Other.matrix[2][1];
  matrix[2][2] -= Other.matrix[2][2];
}

inline gp_Mat gp_Mat::Subtracted (const gp_Mat& Other) const
{
  gp_Mat NewMat;
  NewMat.matrix[0][0] = matrix[0][0] - Other.matrix[0][0];
  NewMat.matrix[0][1] = matrix[0][1] - Other.matrix[0][1];
  NewMat.matrix[0][2] = matrix[0][2] - Other.matrix[0][2];
  NewMat.matrix[1][0] = matrix[1][0] - Other.matrix[1][0];
  NewMat.matrix[1][1] = matrix[1][1] - Other.matrix[1][1];
  NewMat.matrix[1][2] = matrix[1][2] - Other.matrix[1][2];
  NewMat.matrix[2][0] = matrix[2][0] - Other.matrix[2][0];
  NewMat.matrix[2][1] = matrix[2][1] - Other.matrix[2][1];
  NewMat.matrix[2][2] = matrix[2][2] - Other.matrix[2][2];
  return NewMat;
}
# 332 "/usr/include/opencascade/gp_Mat.lxx"
inline void gp_Mat::Transpose ()
{
  Standard_Real Temp;
  Temp = matrix[0][1];
  matrix[0][1] = matrix[1][0];
  matrix[1][0] = Temp;
  Temp = matrix[0][2];
  matrix[0][2] = matrix[2][0];
  matrix[2][0] = Temp;
  Temp = matrix[1][2];
  matrix[1][2] = matrix[2][1];
  matrix[2][1] = Temp;
}

inline gp_Mat gp_Mat::Transposed () const
{
  gp_Mat NewMat = *this;
  NewMat.Transpose();
  return NewMat;
}

inline gp_Mat operator* (const Standard_Real Scalar, const gp_Mat& Mat3D)
{ return Mat3D.Multiplied (Scalar); }
# 284 "/usr/include/opencascade/gp_Mat.hxx" 2
# 19 "/usr/include/opencascade/gp_XYZ.lxx" 2



inline gp_XYZ::gp_XYZ () : x(0.), y(0.), z(0.) { }

inline gp_XYZ::gp_XYZ (const Standard_Real X,
         const Standard_Real Y,
         const Standard_Real Z) : x(X),y(Y),z(Z) { }

inline void gp_XYZ::SetCoord (const Standard_Real X,
         const Standard_Real Y,
         const Standard_Real Z)
{ x = X; y = Y; z = Z; }

inline void gp_XYZ::SetCoord (const Standard_Integer i,
         const Standard_Real X) {
 
# 35 "/usr/include/opencascade/gp_XYZ.lxx"
#pragma GCC diagnostic push
# 35 "/usr/include/opencascade/gp_XYZ.lxx"
 
# 35 "/usr/include/opencascade/gp_XYZ.lxx"
#pragma GCC diagnostic ignored "-Wstrict-overflow"
# 35 "/usr/include/opencascade/gp_XYZ.lxx"
  if (i < 1 || i > 3) throw Standard_OutOfRange(
# 35 "/usr/include/opencascade/gp_XYZ.lxx" 3 4
 __null
# 35 "/usr/include/opencascade/gp_XYZ.lxx"
 );
# 35 "/usr/include/opencascade/gp_XYZ.lxx"
#pragma GCC diagnostic pop
# 35 "/usr/include/opencascade/gp_XYZ.lxx"
  ;
  (&x)[i-1] = X;
}

inline void gp_XYZ::SetX (const Standard_Real X)
{ x = X; }

inline void gp_XYZ::SetY (const Standard_Real Y)
{ y = Y; }

inline void gp_XYZ::SetZ (const Standard_Real Z)
{ z = Z; }

inline Standard_Real gp_XYZ::Coord (const Standard_Integer i) const {
 
# 49 "/usr/include/opencascade/gp_XYZ.lxx"
#pragma GCC diagnostic push
# 49 "/usr/include/opencascade/gp_XYZ.lxx"
 
# 49 "/usr/include/opencascade/gp_XYZ.lxx"
#pragma GCC diagnostic ignored "-Wstrict-overflow"
# 49 "/usr/include/opencascade/gp_XYZ.lxx"
  if (i < 1 || i > 3) throw Standard_OutOfRange(
# 49 "/usr/include/opencascade/gp_XYZ.lxx" 3 4
 __null
# 49 "/usr/include/opencascade/gp_XYZ.lxx"
 );
# 49 "/usr/include/opencascade/gp_XYZ.lxx"
#pragma GCC diagnostic pop
# 49 "/usr/include/opencascade/gp_XYZ.lxx"
  ;
  return (&x)[i-1];
}

inline Standard_Real& gp_XYZ::ChangeCoord(const Standard_Integer theIndex)
{
 
# 55 "/usr/include/opencascade/gp_XYZ.lxx"
#pragma GCC diagnostic push
# 55 "/usr/include/opencascade/gp_XYZ.lxx"
 
# 55 "/usr/include/opencascade/gp_XYZ.lxx"
#pragma GCC diagnostic ignored "-Wstrict-overflow"
# 55 "/usr/include/opencascade/gp_XYZ.lxx"
  if (theIndex < 1 || theIndex > 3) throw Standard_OutOfRange(
# 55 "/usr/include/opencascade/gp_XYZ.lxx" 3 4
 __null
# 55 "/usr/include/opencascade/gp_XYZ.lxx"
 );
# 55 "/usr/include/opencascade/gp_XYZ.lxx"
#pragma GCC diagnostic pop
# 55 "/usr/include/opencascade/gp_XYZ.lxx"
  ;
  return (&x)[theIndex - 1];
}

inline void gp_XYZ::Coord (Standard_Real& X,
      Standard_Real& Y,
      Standard_Real& Z) const
{ X = x; Y = y; Z = z; }

inline Standard_Real gp_XYZ::X () const
{ return x; }

inline Standard_Real gp_XYZ::Y () const
{ return y; }

inline Standard_Real gp_XYZ::Z () const
{ return z; }

inline Standard_Real gp_XYZ::Modulus () const {
  return sqrt (x * x + y * y + z * z);
}

inline Standard_Real gp_XYZ::SquareModulus () const {
  return (x * x + y * y + z * z);
}

inline void gp_XYZ::Add (const gp_XYZ& Other)
{
  x += Other.x;
  y += Other.y;
  z += Other.z;
}

inline gp_XYZ gp_XYZ::Added (const gp_XYZ& Other) const {
  return gp_XYZ(x + Other.x,y + Other.y,z + Other.z);
}

inline void gp_XYZ::Cross (const gp_XYZ& Right)
{
  Standard_Real Xresult = y * Right.z - z * Right.y;
  Standard_Real Yresult = z * Right.x - x * Right.z;
  z = x * Right.y - y * Right.x;
  x = Xresult;
  y = Yresult;
}

inline gp_XYZ gp_XYZ::Crossed (const gp_XYZ& Right) const
{
  return gp_XYZ (y * Right.z - z * Right.y,
   z * Right.x - x * Right.z,
   x * Right.y - y * Right.x);
}

inline Standard_Real gp_XYZ::CrossMagnitude (const gp_XYZ& Right) const
{
  Standard_Real Xresult = y * Right.z - z * Right.y;
  Standard_Real Yresult = z * Right.x - x * Right.z;
  Standard_Real Zresult = x * Right.y - y * Right.x;
  return sqrt(Xresult * Xresult + Yresult * Yresult + Zresult * Zresult);
}

inline Standard_Real gp_XYZ::CrossSquareMagnitude (const gp_XYZ& Right) const
{
  Standard_Real Xresult = y * Right.z - z * Right.y;
  Standard_Real Yresult = z * Right.x - x * Right.z;
  Standard_Real Zresult = x * Right.y - y * Right.x;
  return Xresult * Xresult + Yresult * Yresult + Zresult * Zresult;
}

inline void gp_XYZ::CrossCross (const gp_XYZ& Coord1,
    const gp_XYZ& Coord2)
{
  Standard_Real Xresult =
    y * (Coord1.x * Coord2.y - Coord1.y * Coord2.x) -
      z * (Coord1.z * Coord2.x - Coord1.x * Coord2.z);
  Standard_Real Yresult =
    z * (Coord1.y * Coord2.z - Coord1.z * Coord2.y) -
      x * (Coord1.x * Coord2.y - Coord1.y * Coord2.x);
  z =
    x * (Coord1.z * Coord2.x - Coord1.x * Coord2.z) -
      y * (Coord1.y * Coord2.z - Coord1.z * Coord2.y);
  x = Xresult;
  y = Yresult;
}

inline gp_XYZ gp_XYZ::CrossCrossed (const gp_XYZ& Coord1,
        const gp_XYZ& Coord2) const
{
  gp_XYZ Coord0 = *this;
  Coord0.CrossCross (Coord1, Coord2);
  return Coord0;
}

inline void gp_XYZ::Divide (const Standard_Real Scalar)
{
  x /= Scalar;
  y /= Scalar;
  z /= Scalar;
}

inline gp_XYZ gp_XYZ::Divided (const Standard_Real Scalar) const {
  return gp_XYZ(x / Scalar,y / Scalar,z / Scalar);
}

inline Standard_Real gp_XYZ::Dot (const gp_XYZ& Other) const {
  return(x * Other.x + y * Other.y + z * Other.z);
}

inline Standard_Real gp_XYZ::DotCross (const gp_XYZ& Coord1,
           const gp_XYZ& Coord2) const
{
  Standard_Real Xresult = Coord1.y * Coord2.z - Coord1.z * Coord2.y;
  Standard_Real Yresult = Coord1.z * Coord2.x - Coord1.x * Coord2.z;
  Standard_Real Zresult = Coord1.x * Coord2.y - Coord1.y * Coord2.x;
  return ( x * Xresult + y * Yresult + z * Zresult);
}

inline void gp_XYZ::Multiply (const Standard_Real Scalar)
{
  x *= Scalar;
  y *= Scalar;
  z *= Scalar;
}

inline void gp_XYZ::Multiply (const gp_XYZ& Other)
{
  x *= Other.x;
  y *= Other.y;
  z *= Other.z;
}

inline void gp_XYZ::Multiply (const gp_Mat& Matrix)
{
  Standard_Real Xresult = Matrix.matrix[0][0] * x + Matrix.matrix[0][1] * y + Matrix.matrix[0][2] * z;
  Standard_Real Yresult = Matrix.matrix[1][0] * x + Matrix.matrix[1][1] * y + Matrix.matrix[1][2] * z;
  z = Matrix.matrix[2][0] * x + Matrix.matrix[2][1] * y + Matrix.matrix[2][2] * z;
  x = Xresult;
  y = Yresult;
}

inline gp_XYZ gp_XYZ::Multiplied (const Standard_Real Scalar) const {
  return gp_XYZ(x * Scalar,y * Scalar,z * Scalar);
}

inline gp_XYZ gp_XYZ::Multiplied (const gp_XYZ& Other) const {
  return gp_XYZ(x * Other.x, y * Other.y, z * Other.z);
}

inline gp_XYZ gp_XYZ::Multiplied (const gp_Mat& Matrix) const
{
  return gp_XYZ (Matrix.matrix[0][0] * x + Matrix.matrix[0][1] * y + Matrix.matrix[0][2] * z,
   Matrix.matrix[1][0] * x + Matrix.matrix[1][1] * y + Matrix.matrix[1][2] * z,
   Matrix.matrix[2][0] * x + Matrix.matrix[2][1] * y + Matrix.matrix[2][2] * z);
}

inline void gp_XYZ::Normalize ()
{
  Standard_Real D = Modulus();
  if (D <= gp::Resolution()) throw Standard_ConstructionError("gp_XYZ::Normalize() - vector has zero norm");
                                                                                    ;
  x = x / D; y = y / D; z = z / D;
}

inline gp_XYZ gp_XYZ::Normalized () const
{
  Standard_Real D = Modulus();
  if (D <= gp::Resolution()) throw Standard_ConstructionError("gp_XYZ::Normalized() - vector has zero norm");
                                                                                     ;
  return gp_XYZ (x / D, y / D, z / D);
}

inline void gp_XYZ::Reverse ()
{
  x = - x;
  y = - y;
  z = - z;
}

inline gp_XYZ gp_XYZ::Reversed () const
{
  return gp_XYZ(-x, -y, -z);
}

inline void gp_XYZ::Subtract (const gp_XYZ& Right)
{
  x-=Right.x;
  y-=Right.y;
  z-=Right.z;
}

inline gp_XYZ gp_XYZ::Subtracted (const gp_XYZ& Right) const
{
  return gp_XYZ(x - Right.x, y - Right.y, z - Right.z);
}

inline void gp_XYZ::SetLinearForm (const Standard_Real L,
       const gp_XYZ& Left,
       const Standard_Real R,
       const gp_XYZ& Right) {

  x = L * Left.x + R * Right.x;
  y = L * Left.y + R * Right.y;
  z = L * Left.z + R * Right.z;
}

inline void gp_XYZ::SetLinearForm(const Standard_Real L,
      const gp_XYZ& Left,
      const gp_XYZ& Right) {
  x = L * Left.x + Right.x;
  y = L * Left.y + Right.y;
  z = L * Left.z + Right.z;
}

inline void gp_XYZ::SetLinearForm (const gp_XYZ& Left, const gp_XYZ& Right) {
  x = Left.x + Right.x;
  y = Left.y + Right.y;
  z = Left.z + Right.z;
}

inline void gp_XYZ::SetLinearForm (const Standard_Real A1, const gp_XYZ& XYZ1,
       const Standard_Real A2, const gp_XYZ& XYZ2,
       const Standard_Real A3, const gp_XYZ& XYZ3) {

  x = A1 * XYZ1.x + A2 * XYZ2.x + A3 * XYZ3.x;
  y = A1 * XYZ1.y + A2 * XYZ2.y + A3 * XYZ3.y;
  z = A1 * XYZ1.z + A2 * XYZ2.z + A3 * XYZ3.z;
}

inline void gp_XYZ::SetLinearForm (const Standard_Real A1, const gp_XYZ& XYZ1,
       const Standard_Real A2, const gp_XYZ& XYZ2,
       const gp_XYZ& XYZ3) {
  x = A1 * XYZ1.x + A2 * XYZ2.x + XYZ3.x;
  y = A1 * XYZ1.y + A2 * XYZ2.y + XYZ3.y;
  z = A1 * XYZ1.z + A2 * XYZ2.z + XYZ3.z;
}

inline void gp_XYZ::SetLinearForm (const Standard_Real A1, const gp_XYZ& XYZ1,
       const Standard_Real A2, const gp_XYZ& XYZ2,
       const Standard_Real A3, const gp_XYZ& XYZ3,
       const gp_XYZ& XYZ4) {
  x = A1 * XYZ1.x + A2 * XYZ2.x + A3 * XYZ3.x + XYZ4.x;
  y = A1 * XYZ1.y + A2 * XYZ2.y + A3 * XYZ3.y + XYZ4.y;
  z = A1 * XYZ1.z + A2 * XYZ2.z + A3 * XYZ3.z + XYZ4.z;

}

inline gp_XYZ operator* (const gp_Mat& Matrix, const gp_XYZ& Coord1) {
  return Coord1.Multiplied (Matrix);
}

inline gp_XYZ operator* (const Standard_Real Scalar, const gp_XYZ& Coord1) {
  return Coord1.Multiplied (Scalar);
}
# 356 "/usr/include/opencascade/gp_XYZ.hxx" 2
# 23 "/usr/include/opencascade/gp_Pnt.hxx" 2



class Standard_OutOfRange;
class gp_XYZ;
class gp_Ax1;
class gp_Ax2;
class gp_Trsf;
class gp_Vec;



class gp_Pnt
{
public:

  void* operator new (size_t theSize) { return Standard::Allocate (theSize); } void operator delete (void* theAddress) { Standard::Free (theAddress); } void* operator new[] (size_t theSize) { return Standard::Allocate (theSize); } void operator delete[] (void* theAddress) { Standard::Free (theAddress); } void* operator new (size_t, void* theAddress) { return theAddress; } void operator delete (void*, void*) { }



    gp_Pnt();


    gp_Pnt(const gp_XYZ& Coord);



    gp_Pnt(const Standard_Real Xp, const Standard_Real Yp, const Standard_Real Zp);







    void SetCoord (const Standard_Integer Index, const Standard_Real Xi);


    void SetCoord (const Standard_Real Xp, const Standard_Real Yp, const Standard_Real Zp);


    void SetX (const Standard_Real X);


    void SetY (const Standard_Real Y);


    void SetZ (const Standard_Real Z);


    void SetXYZ (const gp_XYZ& Coord);
# 82 "/usr/include/opencascade/gp_Pnt.hxx"
    Standard_Real Coord (const Standard_Integer Index) const;


    void Coord (Standard_Real& Xp, Standard_Real& Yp, Standard_Real& Zp) const;


    Standard_Real X() const;


    Standard_Real Y() const;


    Standard_Real Z() const;


    const gp_XYZ& XYZ() const;


    const gp_XYZ& Coord() const;




    gp_XYZ& ChangeCoord();



    void BaryCenter (const Standard_Real Alpha, const gp_Pnt& P, const Standard_Real Beta);




    Standard_Boolean IsEqual (const gp_Pnt& Other, const Standard_Real LinearTolerance) const;


    Standard_Real Distance (const gp_Pnt& Other) const;


    Standard_Real SquareDistance (const gp_Pnt& Other) const;





  void Mirror (const gp_Pnt& P);





  [[nodiscard]] gp_Pnt Mirrored (const gp_Pnt& P) const;

  void Mirror (const gp_Ax1& A1);





  [[nodiscard]] gp_Pnt Mirrored (const gp_Ax1& A1) const;

  void Mirror (const gp_Ax2& A2);




  [[nodiscard]] gp_Pnt Mirrored (const gp_Ax2& A2) const;

    void Rotate (const gp_Ax1& A1, const Standard_Real Ang);


    [[nodiscard]] gp_Pnt Rotated (const gp_Ax1& A1, const Standard_Real Ang) const;

    void Scale (const gp_Pnt& P, const Standard_Real S);


    [[nodiscard]] gp_Pnt Scaled (const gp_Pnt& P, const Standard_Real S) const;

  void Transform (const gp_Trsf& T);




  [[nodiscard]] gp_Pnt Transformed (const gp_Trsf& T) const;

    void Translate (const gp_Vec& V);



    [[nodiscard]] gp_Pnt Translated (const gp_Vec& V) const;

    void Translate (const gp_Pnt& P1, const gp_Pnt& P2);

    [[nodiscard]] gp_Pnt Translated (const gp_Pnt& P1, const gp_Pnt& P2) const;



  void DumpJson (Standard_OStream& theOStream, Standard_Integer theDepth = -1) const;


  Standard_Boolean InitFromJson (const Standard_SStream& theSStream, Standard_Integer& theStreamPos);

protected:





private:



  gp_XYZ coord;


};


# 1 "/usr/include/opencascade/gp_Pnt.lxx" 1
# 19 "/usr/include/opencascade/gp_Pnt.lxx"
# 1 "/usr/include/opencascade/gp_Trsf.hxx" 1
# 18 "/usr/include/opencascade/gp_Trsf.hxx"
# 1 "/usr/include/opencascade/gp_TrsfForm.hxx" 1
# 21 "/usr/include/opencascade/gp_TrsfForm.hxx"
enum gp_TrsfForm
{
  gp_Identity,
  gp_Rotation,
  gp_Translation,
  gp_PntMirror,
  gp_Ax1Mirror,
  gp_Ax2Mirror,
  gp_Scale,
  gp_CompoundTrsf,
  gp_Other
};
# 19 "/usr/include/opencascade/gp_Trsf.hxx" 2
# 31 "/usr/include/opencascade/gp_Trsf.hxx"
class Standard_ConstructionError;
class Standard_OutOfRange;
class gp_Pnt;
class gp_Ax1;
class gp_Ax2;
class gp_Quaternion;
class gp_Ax3;
class gp_Vec;
# 64 "/usr/include/opencascade/gp_Trsf.hxx"
class gp_Trsf
{
public:

  void* operator new (size_t theSize) { return Standard::Allocate (theSize); } void operator delete (void* theAddress) { Standard::Free (theAddress); } void* operator new[] (size_t theSize) { return Standard::Allocate (theSize); } void operator delete[] (void* theAddress) { Standard::Free (theAddress); } void* operator new (size_t, void* theAddress) { return theAddress; } void operator delete (void*, void*) { }



    gp_Trsf();
# 90 "/usr/include/opencascade/gp_Trsf.hxx"
  gp_Trsf(const gp_Trsf2d& T);




    void SetMirror (const gp_Pnt& P);




  void SetMirror (const gp_Ax1& A1);






  void SetMirror (const gp_Ax2& A2);





  void SetRotation (const gp_Ax1& A1, const Standard_Real Ang);




  void SetRotation (const gp_Quaternion& R);


  void SetRotationPart (const gp_Quaternion& R);




  void SetScale (const gp_Pnt& P, const Standard_Real S);
# 149 "/usr/include/opencascade/gp_Trsf.hxx"
  void SetDisplacement (const gp_Ax3& FromSystem1, const gp_Ax3& ToSystem2);
# 169 "/usr/include/opencascade/gp_Trsf.hxx"
  void SetTransformation (const gp_Ax3& FromSystem1, const gp_Ax3& ToSystem2);
# 181 "/usr/include/opencascade/gp_Trsf.hxx"
  void SetTransformation (const gp_Ax3& ToSystem);



  void SetTransformation (const gp_Quaternion& R, const gp_Vec& T);




    void SetTranslation (const gp_Vec& V);




    void SetTranslation (const gp_Pnt& P1, const gp_Pnt& P2);


  void SetTranslationPart (const gp_Vec& V);



  void SetScaleFactor (const Standard_Real S);

  void SetForm (const gp_TrsfForm P);
# 217 "/usr/include/opencascade/gp_Trsf.hxx"
  void SetValues (const Standard_Real a11, const Standard_Real a12, const Standard_Real a13, const Standard_Real a14, const Standard_Real a21, const Standard_Real a22, const Standard_Real a23, const Standard_Real a24, const Standard_Real a31, const Standard_Real a32, const Standard_Real a33, const Standard_Real a34);



    Standard_Boolean IsNegative() const;






    gp_TrsfForm Form() const;


    Standard_Real ScaleFactor() const;



    const gp_XYZ& TranslationPart() const;
# 245 "/usr/include/opencascade/gp_Trsf.hxx"
  Standard_Boolean GetRotation (gp_XYZ& theAxis, Standard_Real& theAngle) const;



  gp_Quaternion GetRotation() const;




  gp_Mat VectorialPart() const;
# 263 "/usr/include/opencascade/gp_Trsf.hxx"
    const gp_Mat& HVectorialPart() const;






    Standard_Real Value (const Standard_Integer Row, const Standard_Integer Col) const;

  void Invert();
# 288 "/usr/include/opencascade/gp_Trsf.hxx"
  [[nodiscard]] gp_Trsf Inverted() const;

  [[nodiscard]] gp_Trsf Multiplied (const gp_Trsf& T) const;
  [[nodiscard]] gp_Trsf operator * (const gp_Trsf& T) const
{
  return Multiplied(T);
}




  void Multiply (const gp_Trsf& T);
void operator *= (const gp_Trsf& T)
{
  Multiply(T);
}




  void PreMultiply (const gp_Trsf& T);

  void Power (const Standard_Integer N);
# 320 "/usr/include/opencascade/gp_Trsf.hxx"
  [[nodiscard]] gp_Trsf Powered (const Standard_Integer N) const;

    void Transforms (Standard_Real& X, Standard_Real& Y, Standard_Real& Z) const;


    void Transforms (gp_XYZ& Coord) const;


  template<class T>
  void GetMat4 (NCollection_Mat4<T>& theMat) const
  {
    if (shape == gp_Identity)
    {
      theMat.InitIdentity();
      return;
    }

    theMat.SetValue (0, 0, static_cast<T> (Value (1, 1)));
    theMat.SetValue (0, 1, static_cast<T> (Value (1, 2)));
    theMat.SetValue (0, 2, static_cast<T> (Value (1, 3)));
    theMat.SetValue (0, 3, static_cast<T> (Value (1, 4)));
    theMat.SetValue (1, 0, static_cast<T> (Value (2, 1)));
    theMat.SetValue (1, 1, static_cast<T> (Value (2, 2)));
    theMat.SetValue (1, 2, static_cast<T> (Value (2, 3)));
    theMat.SetValue (1, 3, static_cast<T> (Value (2, 4)));
    theMat.SetValue (2, 0, static_cast<T> (Value (3, 1)));
    theMat.SetValue (2, 1, static_cast<T> (Value (3, 2)));
    theMat.SetValue (2, 2, static_cast<T> (Value (3, 3)));
    theMat.SetValue (2, 3, static_cast<T> (Value (3, 4)));
    theMat.SetValue (3, 0, static_cast<T> (0));
    theMat.SetValue (3, 1, static_cast<T> (0));
    theMat.SetValue (3, 2, static_cast<T> (0));
    theMat.SetValue (3, 3, static_cast<T> (1));
  }


  void DumpJson (Standard_OStream& theOStream, Standard_Integer theDepth = -1) const;


  Standard_Boolean InitFromJson (const Standard_SStream& theSStream, Standard_Integer& theStreamPos);

friend class gp_GTrsf;

protected:


  void Orthogonalize();

private:

  Standard_Real scale;
  gp_TrsfForm shape;
  gp_Mat matrix;
  gp_XYZ loc;

};

# 1 "/usr/include/opencascade/gp_Trsf.lxx" 1
# 20 "/usr/include/opencascade/gp_Trsf.lxx"
# 1 "/usr/include/opencascade/gp_Trsf2d.hxx" 1
# 24 "/usr/include/opencascade/gp_Trsf2d.hxx"
# 1 "/usr/include/opencascade/gp_Mat2d.hxx" 1
# 25 "/usr/include/opencascade/gp_Mat2d.hxx"
class Standard_ConstructionError;
class Standard_OutOfRange;
class gp_Trsf2d;
class gp_GTrsf2d;
class gp_XY;





class gp_Mat2d
{
public:

  void* operator new (size_t theSize) { return Standard::Allocate (theSize); } void operator delete (void* theAddress) { Standard::Free (theAddress); } void* operator new[] (size_t theSize) { return Standard::Allocate (theSize); } void operator delete[] (void* theAddress) { Standard::Free (theAddress); } void* operator new (size_t, void* theAddress) { return theAddress; } void operator delete (void*, void*) { }



    gp_Mat2d();



  gp_Mat2d(const gp_XY& Col1, const gp_XY& Col2);




  void SetCol (const Standard_Integer Col, const gp_XY& Value);


  void SetCols (const gp_XY& Col1, const gp_XY& Col2);






    void SetDiagonal (const Standard_Real X1, const Standard_Real X2);


    void SetIdentity();




    void SetRotation (const Standard_Real Ang);



  void SetRow (const Standard_Integer Row, const gp_XY& Value);


  void SetRows (const gp_XY& Row1, const gp_XY& Row2);






    void SetScale (const Standard_Real S);



    void SetValue (const Standard_Integer Row, const Standard_Integer Col, const Standard_Real Value);



  gp_XY Column (const Standard_Integer Col) const;


    Standard_Real Determinant() const;


  gp_XY Diagonal() const;



  gp_XY Row (const Standard_Integer Row) const;




    const Standard_Real& Value (const Standard_Integer Row, const Standard_Integer Col) const;
  const Standard_Real& operator() (const Standard_Integer Row, const Standard_Integer Col) const
{
  return Value(Row,Col);
}




    Standard_Real& ChangeValue (const Standard_Integer Row, const Standard_Integer Col);
  Standard_Real& operator() (const Standard_Integer Row, const Standard_Integer Col)
{
  return ChangeValue(Row,Col);
}






    Standard_Boolean IsSingular() const;

    void Add (const gp_Mat2d& Other);
  void operator += (const gp_Mat2d& Other)
{
  Add(Other);
}
# 142 "/usr/include/opencascade/gp_Mat2d.hxx"
  [[nodiscard]] gp_Mat2d Added (const gp_Mat2d& Other) const;
  [[nodiscard]] gp_Mat2d operator + (const gp_Mat2d& Other) const
{
  return Added(Other);
}

    void Divide (const Standard_Real Scalar);
  void operator /= (const Standard_Real Scalar)
{
  Divide(Scalar);
}



  [[nodiscard]] gp_Mat2d Divided (const Standard_Real Scalar) const;
  [[nodiscard]] gp_Mat2d operator / (const Standard_Real Scalar) const
{
  return Divided(Scalar);
}

  void Invert();




  [[nodiscard]] gp_Mat2d Inverted() const;

  [[nodiscard]] gp_Mat2d Multiplied (const gp_Mat2d& Other) const;
  [[nodiscard]] gp_Mat2d operator * (const gp_Mat2d& Other) const
{
  return Multiplied(Other);
}



    void Multiply (const gp_Mat2d& Other);



    void PreMultiply (const gp_Mat2d& Other);

    [[nodiscard]] gp_Mat2d Multiplied (const Standard_Real Scalar) const;
  [[nodiscard]] gp_Mat2d operator * (const Standard_Real Scalar) const
{
  return Multiplied(Scalar);
}



    void Multiply (const Standard_Real Scalar);
  void operator *= (const Standard_Real Scalar)
{
  Multiply(Scalar);
}

  void Power (const Standard_Integer N);







  [[nodiscard]] gp_Mat2d Powered (const Standard_Integer N) const;

    void Subtract (const gp_Mat2d& Other);
  void operator -= (const gp_Mat2d& Other)
{
  Subtract(Other);
}




  [[nodiscard]] gp_Mat2d Subtracted (const gp_Mat2d& Other) const;
  [[nodiscard]] gp_Mat2d operator - (const gp_Mat2d& Other) const
{
  return Subtracted(Other);
}

    void Transpose();



    [[nodiscard]] gp_Mat2d Transposed() const;


friend class gp_Trsf2d;
friend class gp_GTrsf2d;
friend class gp_XY;


protected:





private:



  Standard_Real matrix[2][2];


};


# 1 "/usr/include/opencascade/gp_Mat2d.lxx" 1
# 33 "/usr/include/opencascade/gp_Mat2d.lxx"
inline gp_Mat2d::gp_Mat2d ()
{
  const Standard_Address M = (Standard_Address)&(matrix[0][0]);
  ((Standard_Real*)M)[0] = ((Standard_Real*)M)[1] = ((Standard_Real*)M)[2] = ((Standard_Real*)M)[3] = 0.0;
}

inline void gp_Mat2d::SetDiagonal (const Standard_Real X1,
       const Standard_Real X2)
{
  const Standard_Address M = (Standard_Address)&(matrix[0][0]);
  ((Standard_Real*)M)[0] = X1; ((Standard_Real*)M)[3] = X2;
}

inline void gp_Mat2d::SetIdentity ()
{
  const Standard_Address M = (Standard_Address)&(matrix[0][0]);
  ((Standard_Real*)M)[0] = ((Standard_Real*)M)[3] = 1.0;
  ((Standard_Real*)M)[1] = ((Standard_Real*)M)[2] = 0.0;
}

inline void gp_Mat2d::SetRotation (const Standard_Real Ang)
{
  const Standard_Address M = (Standard_Address)&(matrix[0][0]);
  Standard_Real SinA = sin(Ang);
  Standard_Real CosA = cos(Ang);
  ((Standard_Real*)M)[0] = ((Standard_Real*)M)[3] = CosA;
  ((Standard_Real*)M)[1] = -SinA;
  ((Standard_Real*)M)[2] = SinA;
}

inline void gp_Mat2d::SetScale (const Standard_Real S)
{
  const Standard_Address M = (Standard_Address)&(matrix[0][0]);
  ((Standard_Real*)M)[0] = ((Standard_Real*)M)[3] = S;
  ((Standard_Real*)M)[1] = ((Standard_Real*)M)[2] = 0.0;
}

inline void gp_Mat2d::SetValue (const Standard_Integer Row,
    const Standard_Integer Col,
    const Standard_Real Value)
{
 
#pragma GCC diagnostic push
# 74 "/usr/include/opencascade/gp_Mat2d.lxx"
 
#pragma GCC diagnostic ignored "-Wstrict-overflow"
# 74 "/usr/include/opencascade/gp_Mat2d.lxx"
  if (Row < 1 || Row > 2 || Col < 1 || Col > 2) throw Standard_OutOfRange(" ");
#pragma GCC diagnostic pop
# 74 "/usr/include/opencascade/gp_Mat2d.lxx"
 
                                                   ;
  matrix[Row-1][Col-1] = Value;
}

inline Standard_Real gp_Mat2d::Determinant () const
{
  const Standard_Address M = (Standard_Address)&(matrix[0][0]);
  return ((Standard_Real*)M)[0] * ((Standard_Real*)M)[3] - ((Standard_Real*)M)[2] * ((Standard_Real*)M)[1];
}

inline const Standard_Real& gp_Mat2d::Value (const Standard_Integer Row,
          const Standard_Integer Col) const
{
 
#pragma GCC diagnostic push
# 88 "/usr/include/opencascade/gp_Mat2d.lxx"
 
#pragma GCC diagnostic ignored "-Wstrict-overflow"
# 88 "/usr/include/opencascade/gp_Mat2d.lxx"
  if (Row < 1 || Row > 2 || Col < 1 || Col > 2) throw Standard_OutOfRange(" ");
#pragma GCC diagnostic pop
# 88 "/usr/include/opencascade/gp_Mat2d.lxx"
 
                                                   ;
  return matrix[Row-1][Col-1];
}

inline Standard_Real&
gp_Mat2d::ChangeValue (const Standard_Integer Row,
         const Standard_Integer Col)
{
 
#pragma GCC diagnostic push
# 97 "/usr/include/opencascade/gp_Mat2d.lxx"
 
#pragma GCC diagnostic ignored "-Wstrict-overflow"
# 97 "/usr/include/opencascade/gp_Mat2d.lxx"
  if (Row < 1 || Row > 2 || Col < 1 || Col > 2) throw Standard_OutOfRange(" ");
#pragma GCC diagnostic pop
# 97 "/usr/include/opencascade/gp_Mat2d.lxx"
 
                                                   ;
  return matrix[Row-1][Col-1];
}

inline Standard_Boolean gp_Mat2d::IsSingular () const
{
  Standard_Real det = Determinant();
  if (det < 0) det = - det;
  return det <= gp::Resolution();
}

inline void gp_Mat2d::Add (const gp_Mat2d& Other)
{
  const Standard_Address M = (Standard_Address)&( matrix[0][0]);
  const Standard_Address O = (Standard_Address)&(Other.matrix[0][0]);
  ((Standard_Real*)M)[0] += ((Standard_Real*)O)[0];
  ((Standard_Real*)M)[1] += ((Standard_Real*)O)[1];
  ((Standard_Real*)M)[2] += ((Standard_Real*)O)[2];
  ((Standard_Real*)M)[3] += ((Standard_Real*)O)[3];
}

inline gp_Mat2d gp_Mat2d::Added (const gp_Mat2d& Other) const
{
  gp_Mat2d NewMat2d;
  const Standard_Address M = (Standard_Address)&( matrix[0][0]);
  const Standard_Address N = (Standard_Address)&(NewMat2d.matrix[0][0]);
  const Standard_Address O = (Standard_Address)&(Other .matrix[0][0]);
  ((Standard_Real*)N)[0] = ((Standard_Real*)M)[0] + ((Standard_Real*)O)[0];
  ((Standard_Real*)N)[1] = ((Standard_Real*)M)[1] + ((Standard_Real*)O)[1];
  ((Standard_Real*)N)[2] = ((Standard_Real*)M)[2] + ((Standard_Real*)O)[2];
  ((Standard_Real*)N)[3] = ((Standard_Real*)M)[3] + ((Standard_Real*)O)[3];
  return NewMat2d;
}

inline void gp_Mat2d::Divide (const Standard_Real Scalar)
{
  const Standard_Address M = (Standard_Address)&(matrix[0][0]);
  ((Standard_Real*)M)[0] /= Scalar;
  ((Standard_Real*)M)[1] /= Scalar;
  ((Standard_Real*)M)[2] /= Scalar;
  ((Standard_Real*)M)[3] /= Scalar;
}

inline gp_Mat2d gp_Mat2d::Divided (const Standard_Real Scalar) const
{
  gp_Mat2d NewMat2d;
  const Standard_Address M = (Standard_Address)&( matrix[0][0]);
  const Standard_Address N = (Standard_Address)&(NewMat2d.matrix[0][0]);
  ((Standard_Real*)N)[0] = ((Standard_Real*)M)[0] / Scalar;
  ((Standard_Real*)N)[1] = ((Standard_Real*)M)[1] / Scalar;
  ((Standard_Real*)N)[2] = ((Standard_Real*)M)[2] / Scalar;
  ((Standard_Real*)N)[3] = ((Standard_Real*)M)[3] / Scalar;
  return NewMat2d;
}

inline gp_Mat2d gp_Mat2d::Inverted () const
{
  gp_Mat2d NewMat = *this;
  NewMat.Invert();
  return NewMat;
}

inline gp_Mat2d gp_Mat2d::Multiplied (const gp_Mat2d& Other) const
{
  gp_Mat2d NewMat2d = *this;
  NewMat2d.Multiply(Other);
  return NewMat2d;
}

inline void gp_Mat2d::Multiply (const gp_Mat2d& Other)
{
  Standard_Real T00,T10;
  const Standard_Address M = (Standard_Address)&( matrix[0][0]);
  const Standard_Address O = (Standard_Address)&(Other.matrix[0][0]);
  T00 = ((Standard_Real*)M)[0] * ((Standard_Real*)O)[0] + ((Standard_Real*)M)[1] * ((Standard_Real*)O)[2];
  T10 = ((Standard_Real*)M)[2] * ((Standard_Real*)O)[0] + ((Standard_Real*)M)[3] * ((Standard_Real*)O)[2];
  ((Standard_Real*)M)[1] = ((Standard_Real*)M)[0] * ((Standard_Real*)O)[1] + ((Standard_Real*)M)[1] * ((Standard_Real*)O)[3];
  ((Standard_Real*)M)[3] = ((Standard_Real*)M)[2] * ((Standard_Real*)O)[1] + ((Standard_Real*)M)[3] * ((Standard_Real*)O)[3];
  ((Standard_Real*)M)[0] = T00;
  ((Standard_Real*)M)[2] = T10;
}

inline void gp_Mat2d::PreMultiply (const gp_Mat2d& Other)
{
  Standard_Real T00,T01;
  const Standard_Address M = (Standard_Address)&( matrix[0][0]);
  const Standard_Address O = (Standard_Address)&(Other.matrix[0][0]);
  T00 = ((Standard_Real*)O)[0] * ((Standard_Real*)M)[0] + ((Standard_Real*)O)[1] * ((Standard_Real*)M)[2];
  ((Standard_Real*)M)[2] = ((Standard_Real*)O)[2] * ((Standard_Real*)M)[0] + ((Standard_Real*)O)[3] * ((Standard_Real*)M)[2];
  T01 = ((Standard_Real*)O)[0] * ((Standard_Real*)M)[1] + ((Standard_Real*)O)[1] * ((Standard_Real*)M)[3];
  ((Standard_Real*)M)[3] = ((Standard_Real*)O)[2] * ((Standard_Real*)M)[1] + ((Standard_Real*)O)[3] * ((Standard_Real*)M)[3];
  ((Standard_Real*)M)[0] = T00;
  ((Standard_Real*)M)[1] = T01;
}

inline gp_Mat2d gp_Mat2d::Multiplied (const Standard_Real Scalar) const
{
  gp_Mat2d NewMat2d;
  const Standard_Address M = (Standard_Address)&( matrix[0][0]);
  const Standard_Address N = (Standard_Address)&(NewMat2d.matrix[0][0]);
  ((Standard_Real*)N)[0] = ((Standard_Real*)M)[0] * Scalar;
  ((Standard_Real*)N)[1] = ((Standard_Real*)M)[1] * Scalar;
  ((Standard_Real*)N)[2] = ((Standard_Real*)M)[2] * Scalar;
  ((Standard_Real*)N)[3] = ((Standard_Real*)M)[3] * Scalar;
  return NewMat2d;
}

inline void gp_Mat2d::Multiply (const Standard_Real Scalar)
{
  const Standard_Address M = (Standard_Address)&(matrix[0][0]);
  ((Standard_Real*)M)[0] *= Scalar;
  ((Standard_Real*)M)[1] *= Scalar;
  ((Standard_Real*)M)[2] *= Scalar;
  ((Standard_Real*)M)[3] *= Scalar;
}

inline gp_Mat2d gp_Mat2d::Powered (const Standard_Integer N) const
{
  gp_Mat2d Mat2dN = *this;
  Mat2dN.Power (N);
  return Mat2dN;
}

inline void gp_Mat2d::Subtract (const gp_Mat2d& Other)
{
  const Standard_Address M = (Standard_Address)&( matrix[0][0]);
  const Standard_Address O = (Standard_Address)&(Other.matrix[0][0]);
  ((Standard_Real*)M)[0] -= ((Standard_Real*)O)[0];
  ((Standard_Real*)M)[1] -= ((Standard_Real*)O)[1];
  ((Standard_Real*)M)[2] -= ((Standard_Real*)O)[2];
  ((Standard_Real*)M)[3] -= ((Standard_Real*)O)[3];
}

inline gp_Mat2d gp_Mat2d::Subtracted (const gp_Mat2d& Other) const
{
  gp_Mat2d NewMat2d;
  const Standard_Address M = (Standard_Address)&( matrix[0][0]);
  const Standard_Address N = (Standard_Address)&(NewMat2d.matrix[0][0]);
  const Standard_Address O = (Standard_Address)&(Other .matrix[0][0]);
  ((Standard_Real*)N)[0] = ((Standard_Real*)M)[0] - ((Standard_Real*)O)[0];
  ((Standard_Real*)N)[1] = ((Standard_Real*)M)[1] - ((Standard_Real*)O)[1];
  ((Standard_Real*)N)[2] = ((Standard_Real*)M)[2] - ((Standard_Real*)O)[2];
  ((Standard_Real*)N)[3] = ((Standard_Real*)M)[3] - ((Standard_Real*)O)[3];
  return NewMat2d;
}

inline void gp_Mat2d::Transpose ()
{
  const Standard_Address M = (Standard_Address)&(matrix[0][0]);
  Standard_Real Temp;
  Temp = ((Standard_Real*)M)[1];
  ((Standard_Real*)M)[1] = ((Standard_Real*)M)[2];
  ((Standard_Real*)M)[2] = Temp;
}

inline gp_Mat2d gp_Mat2d::Transposed () const
{
  gp_Mat2d NewMat2d;
  const Standard_Address M = (Standard_Address)&( matrix[0][0]);
  const Standard_Address N = (Standard_Address)&(NewMat2d.matrix[0][0]);
  ((Standard_Real*)N)[2] = ((Standard_Real*)M)[1];
  ((Standard_Real*)N)[1] = ((Standard_Real*)M)[2];
  ((Standard_Real*)N)[0] = ((Standard_Real*)M)[0];
  ((Standard_Real*)N)[3] = ((Standard_Real*)M)[3];
  return NewMat2d;
}

inline gp_Mat2d operator* (const Standard_Real Scalar,
      const gp_Mat2d& Mat2D)
{ return Mat2D.Multiplied (Scalar); }
# 251 "/usr/include/opencascade/gp_Mat2d.hxx" 2
# 25 "/usr/include/opencascade/gp_Trsf2d.hxx" 2
# 1 "/usr/include/opencascade/gp_XY.hxx" 1
# 25 "/usr/include/opencascade/gp_XY.hxx"
class Standard_ConstructionError;
class Standard_OutOfRange;
class gp_Mat2d;
# 37 "/usr/include/opencascade/gp_XY.hxx"
class gp_XY
{
public:

  void* operator new (size_t theSize) { return Standard::Allocate (theSize); } void operator delete (void* theAddress) { Standard::Free (theAddress); } void* operator new[] (size_t theSize) { return Standard::Allocate (theSize); } void operator delete[] (void* theAddress) { Standard::Free (theAddress); } void* operator new (size_t, void* theAddress) { return theAddress; } void operator delete (void*, void*) { }



    gp_XY();


    gp_XY(const Standard_Real X, const Standard_Real Y);






    void SetCoord (const Standard_Integer Index, const Standard_Real Xi);



    void SetCoord (const Standard_Real X, const Standard_Real Y);


    void SetX (const Standard_Real X);


    void SetY (const Standard_Real Y);






    Standard_Real Coord (const Standard_Integer Index) const;

    Standard_Real& ChangeCoord (const Standard_Integer theIndex);


    void Coord (Standard_Real& X, Standard_Real& Y) const;


    Standard_Real X() const;


    Standard_Real Y() const;


    Standard_Real Modulus() const;


    Standard_Real SquareModulus() const;
# 98 "/usr/include/opencascade/gp_XY.hxx"
  Standard_Boolean IsEqual (const gp_XY& Other, const Standard_Real Tolerance) const;




    void Add (const gp_XY& Other);
  void operator += (const gp_XY& Other)
{
  Add(Other);
}




  [[nodiscard]] gp_XY Added (const gp_XY& Other) const;
  [[nodiscard]] gp_XY operator + (const gp_XY& Other) const
{
  return Added(Other);
}



  [[nodiscard]] Standard_Real Crossed (const gp_XY& Right) const;
  [[nodiscard]] Standard_Real operator ^ (const gp_XY& Right) const
{
  return Crossed(Right);
}




    Standard_Real CrossMagnitude (const gp_XY& Right) const;




    Standard_Real CrossSquareMagnitude (const gp_XY& Right) const;


    void Divide (const Standard_Real Scalar);
  void operator /= (const Standard_Real Scalar)
{
  Divide(Scalar);
}


  [[nodiscard]] gp_XY Divided (const Standard_Real Scalar) const;
  [[nodiscard]] gp_XY operator / (const Standard_Real Scalar) const
{
  return Divided(Scalar);
}


    Standard_Real Dot (const gp_XY& Other) const;
  Standard_Real operator * (const gp_XY& Other) const
{
  return Dot(Other);
}




    void Multiply (const Standard_Real Scalar);
  void operator *= (const Standard_Real Scalar)
{
  Multiply(Scalar);
}




    void Multiply (const gp_XY& Other);
  void operator *= (const gp_XY& Other)
{
  Multiply(Other);
}


    void Multiply (const gp_Mat2d& Matrix);
  void operator *= (const gp_Mat2d& Matrix)
{
  Multiply(Matrix);
}




  [[nodiscard]] gp_XY Multiplied (const Standard_Real Scalar) const;
  [[nodiscard]] gp_XY operator * (const Standard_Real Scalar) const
{
  return Multiplied(Scalar);
}




  [[nodiscard]] gp_XY Multiplied (const gp_XY& Other) const;


  [[nodiscard]] gp_XY Multiplied (const gp_Mat2d& Matrix) const;
  [[nodiscard]] gp_XY operator * (const gp_Mat2d& Matrix) const
{
  return Multiplied(Matrix);
}





    void Normalize();





    [[nodiscard]] gp_XY Normalized() const;




    void Reverse();




    [[nodiscard]] gp_XY Reversed() const;
  [[nodiscard]] gp_XY operator -() const
{
  return Reversed();
}





    void SetLinearForm (const Standard_Real A1, const gp_XY& XY1, const Standard_Real A2, const gp_XY& XY2);





    void SetLinearForm (const Standard_Real A1, const gp_XY& XY1, const Standard_Real A2, const gp_XY& XY2, const gp_XY& XY3);





    void SetLinearForm (const Standard_Real A1, const gp_XY& XY1, const gp_XY& XY2);





    void SetLinearForm (const gp_XY& XY1, const gp_XY& XY2);




    void Subtract (const gp_XY& Right);
  void operator -= (const gp_XY& Right)
{
  Subtract(Right);
}




  [[nodiscard]] gp_XY Subtracted (const gp_XY& Right) const;
  [[nodiscard]] gp_XY operator - (const gp_XY& Right) const
{
  return Subtracted(Right);
}




protected:





private:



  Standard_Real x;
  Standard_Real y;


};


# 1 "/usr/include/opencascade/gp_XY.lxx" 1
# 22 "/usr/include/opencascade/gp_XY.lxx"
inline gp_XY::gp_XY () : x(0.), y(0.) { }

inline gp_XY::gp_XY (const Standard_Real X,
       const Standard_Real Y) : x (X), y (Y) { }

inline void gp_XY::SetCoord (const Standard_Integer i,
        const Standard_Real X)
{
 
# 30 "/usr/include/opencascade/gp_XY.lxx"
#pragma GCC diagnostic push
# 30 "/usr/include/opencascade/gp_XY.lxx"
 
# 30 "/usr/include/opencascade/gp_XY.lxx"
#pragma GCC diagnostic ignored "-Wstrict-overflow"
# 30 "/usr/include/opencascade/gp_XY.lxx"
  if (i < 1 || i > 2) throw Standard_OutOfRange(
# 30 "/usr/include/opencascade/gp_XY.lxx" 3 4
 __null
# 30 "/usr/include/opencascade/gp_XY.lxx"
 );
# 30 "/usr/include/opencascade/gp_XY.lxx"
#pragma GCC diagnostic pop
# 30 "/usr/include/opencascade/gp_XY.lxx"
  ;
  (&x)[i-1] = X;
}

inline void gp_XY::SetCoord (const Standard_Real X,
        const Standard_Real Y)
{ x = X; y = Y; }

inline void gp_XY::SetX (const Standard_Real X)
{ x = X; }

inline void gp_XY::SetY (const Standard_Real Y)
{ y = Y; }

inline Standard_Real gp_XY::Coord (const Standard_Integer i) const
{
 
# 46 "/usr/include/opencascade/gp_XY.lxx"
#pragma GCC diagnostic push
# 46 "/usr/include/opencascade/gp_XY.lxx"
 
# 46 "/usr/include/opencascade/gp_XY.lxx"
#pragma GCC diagnostic ignored "-Wstrict-overflow"
# 46 "/usr/include/opencascade/gp_XY.lxx"
  if (i < 1 || i > 2) throw Standard_OutOfRange(
# 46 "/usr/include/opencascade/gp_XY.lxx" 3 4
 __null
# 46 "/usr/include/opencascade/gp_XY.lxx"
 );
# 46 "/usr/include/opencascade/gp_XY.lxx"
#pragma GCC diagnostic pop
# 46 "/usr/include/opencascade/gp_XY.lxx"
  ;
  return (&x)[i-1];
}

inline Standard_Real& gp_XY::ChangeCoord (const Standard_Integer theIndex)
{
 
# 52 "/usr/include/opencascade/gp_XY.lxx"
#pragma GCC diagnostic push
# 52 "/usr/include/opencascade/gp_XY.lxx"
 
# 52 "/usr/include/opencascade/gp_XY.lxx"
#pragma GCC diagnostic ignored "-Wstrict-overflow"
# 52 "/usr/include/opencascade/gp_XY.lxx"
  if (theIndex < 1 || theIndex > 2) throw Standard_OutOfRange(
# 52 "/usr/include/opencascade/gp_XY.lxx" 3 4
 __null
# 52 "/usr/include/opencascade/gp_XY.lxx"
 );
# 52 "/usr/include/opencascade/gp_XY.lxx"
#pragma GCC diagnostic pop
# 52 "/usr/include/opencascade/gp_XY.lxx"
  ;
  return (&x)[theIndex - 1];
}

inline void gp_XY::Coord (Standard_Real& X,
     Standard_Real& Y) const
{ X = x; Y = y; }

inline Standard_Real gp_XY::X () const
{ return x; }

inline Standard_Real gp_XY::Y () const
{ return y; }

inline Standard_Real gp_XY::Modulus () const
{
  return sqrt (x * x + y * y);
}

inline Standard_Real gp_XY::SquareModulus () const
{
  return x * x + y * y;
}

inline void gp_XY::Add (const gp_XY& Other) {
  x += Other.x;
  y += Other.y;
}

inline gp_XY gp_XY::Added (const gp_XY& Other) const {
  return gp_XY(x + Other.X(),y + Other.Y());
}

inline Standard_Real gp_XY::Crossed (const gp_XY& Right) const {
  return x * Right.y - y * Right.x;
}

inline Standard_Real gp_XY::CrossMagnitude (const gp_XY& Right) const
{
  Standard_Real val = x * Right.y - y * Right.x;
  if (val < 0) val = - val;
  return val;
}

inline Standard_Real gp_XY::CrossSquareMagnitude (const gp_XY& Right) const {
  Standard_Real Zresult = x * Right.y - y * Right.x;
  return Zresult * Zresult;
}

inline void gp_XY::Divide (const Standard_Real Scalar)
{
  x /= Scalar;
  y /= Scalar;
}

inline gp_XY gp_XY::Divided (const Standard_Real Scalar) const {
  return gp_XY(x / Scalar,y / Scalar);
}

inline Standard_Real gp_XY::Dot (const gp_XY& Other) const
{
  return x * Other.x + y * Other.y;
}

inline void gp_XY::Multiply (const Standard_Real Scalar)
{
  x *= Scalar;
  y *= Scalar;
}

inline void gp_XY::Multiply (const gp_XY& Other)
{
  x *= Other.x;
  y *= Other.y;
}

inline void gp_XY::Multiply (const gp_Mat2d& Matrix)
{
  const Standard_Address M = (Standard_Address)&(Matrix.matrix[0][0]);
  Standard_Real Xresult = ((Standard_Real*)M)[0] * x + ((Standard_Real*)M)[1] * y;
  y = ((Standard_Real*)M)[2] * x + ((Standard_Real*)M)[3] * y;
  x = Xresult;
}

inline gp_XY gp_XY::Multiplied (const Standard_Real Scalar) const {
  return gp_XY(x * Scalar,y * Scalar);
}

inline gp_XY gp_XY::Multiplied (const gp_XY& Other) const {
  return(gp_XY(x * Other.X(),y * Other.Y()));
}

inline gp_XY gp_XY::Multiplied (const gp_Mat2d& Matrix) const
{
  const Standard_Address M = (Standard_Address)&(Matrix.matrix[0][0]);
  return gp_XY (((Standard_Real*)M)[0] * x + ((Standard_Real*)M)[1] * y,
  ((Standard_Real*)M)[2] * x + ((Standard_Real*)M)[3] * y);
}

inline void gp_XY::Normalize ()
{
  Standard_Real D = Modulus();
  if (D <= gp::Resolution()) throw Standard_ConstructionError("gp_XY::Normalize() - vector has zero norm");
                                                                                   ;
  x = x / D; y = y / D;
}

inline gp_XY gp_XY::Normalized () const
{
  Standard_Real D = Modulus();
  if (D <= gp::Resolution()) throw Standard_ConstructionError("gp_XY::Normalized() - vector has zero norm");
                                                                                    ;
  return gp_XY (x / D, y / D);
}

inline void gp_XY::Reverse ()
{ x = - x; y = - y; }

inline gp_XY gp_XY::Reversed () const
{
  gp_XY Coord2D = *this;
  Coord2D.Reverse();
  return Coord2D;
}

inline void gp_XY::SetLinearForm (const Standard_Real L,
      const gp_XY& Left,
      const Standard_Real R,
      const gp_XY& Right) {
  x = L * Left.x + R * Right.x;
  y = L * Left.y + R * Right.y;
}

inline void gp_XY::SetLinearForm (const Standard_Real L,
      const gp_XY& Left,
      const gp_XY& Right) {
  x = L * Left.x + Right.x;
  y = L * Left.y + Right.y;
}

inline void gp_XY::SetLinearForm (const gp_XY& Left,
      const gp_XY& Right) {
  x = Left.x + Right.x;
  y = Left.y + Right.y;
}

inline void gp_XY::SetLinearForm (const Standard_Real A1,
      const gp_XY& XY1,
      const Standard_Real A2,
      const gp_XY& XY2,
      const gp_XY& XY3) {
  x = A1 * XY1.x + A2 * XY2.x + XY3.x;
  y = A1 * XY1.y + A2 * XY2.y + XY3.y;
}

inline void gp_XY::Subtract (const gp_XY& Right)
{
  x -= Right.x;
  y -= Right.y;
}

inline gp_XY gp_XY::Subtracted (const gp_XY& Right) const
{
  gp_XY Coord2D = *this;
  Coord2D.Subtract(Right);
  return Coord2D;
}

inline gp_XY operator* (const gp_Mat2d& Matrix,
   const gp_XY& Coord1) {
  return Coord1.Multiplied(Matrix);
}

inline gp_XY operator* (const Standard_Real Scalar,
   const gp_XY& Coord1) {
  return Coord1.Multiplied(Scalar);
}
# 292 "/usr/include/opencascade/gp_XY.hxx" 2
# 26 "/usr/include/opencascade/gp_Trsf2d.hxx" 2


class Standard_ConstructionError;
class Standard_OutOfRange;
class gp_GTrsf2d;
class gp_Trsf;
class gp_Pnt2d;
class gp_Ax2d;
class gp_Vec2d;
class gp_XY;
class gp_Mat2d;
# 56 "/usr/include/opencascade/gp_Trsf2d.hxx"
class gp_Trsf2d
{
public:

  void* operator new (size_t theSize) { return Standard::Allocate (theSize); } void operator delete (void* theAddress) { Standard::Free (theAddress); } void* operator new[] (size_t theSize) { return Standard::Allocate (theSize); } void operator delete[] (void* theAddress) { Standard::Free (theAddress); } void* operator new (size_t, void* theAddress) { return theAddress; } void operator delete (void*, void*) { }



    gp_Trsf2d();



    gp_Trsf2d(const gp_Trsf& T);




    void SetMirror (const gp_Pnt2d& P);




  void SetMirror (const gp_Ax2d& A);





    void SetRotation (const gp_Pnt2d& P, const Standard_Real Ang);




    void SetScale (const gp_Pnt2d& P, const Standard_Real S);




  void SetTransformation (const gp_Ax2d& FromSystem1, const gp_Ax2d& ToSystem2);






  void SetTransformation (const gp_Ax2d& ToSystem);




    void SetTranslation (const gp_Vec2d& V);




    void SetTranslation (const gp_Pnt2d& P1, const gp_Pnt2d& P2);


  void SetTranslationPart (const gp_Vec2d& V);


  void SetScaleFactor (const Standard_Real S);



    Standard_Boolean IsNegative() const;






    gp_TrsfForm Form() const;


    Standard_Real ScaleFactor() const;



    const gp_XY& TranslationPart() const;




  gp_Mat2d VectorialPart() const;






    const gp_Mat2d& HVectorialPart() const;




  Standard_Real RotationPart() const;





    Standard_Real Value (const Standard_Integer Row, const Standard_Integer Col) const;

  void Invert();






  [[nodiscard]] gp_Trsf2d Inverted() const;

  [[nodiscard]] gp_Trsf2d Multiplied (const gp_Trsf2d& T) const;
  [[nodiscard]] gp_Trsf2d operator * (const gp_Trsf2d& T) const
{
  return Multiplied(T);
}




  void Multiply (const gp_Trsf2d& T);
void operator *= (const gp_Trsf2d& T)
{
  Multiply(T);
}




  void PreMultiply (const gp_Trsf2d& T);

  void Power (const Standard_Integer N);
# 199 "/usr/include/opencascade/gp_Trsf2d.hxx"
    gp_Trsf2d Powered (const Standard_Integer N);

    void Transforms (Standard_Real& X, Standard_Real& Y) const;


    void Transforms (gp_XY& Coord) const;
# 216 "/usr/include/opencascade/gp_Trsf2d.hxx"
  void SetValues (const Standard_Real a11, const Standard_Real a12, const Standard_Real a13, const Standard_Real a21, const Standard_Real a22, const Standard_Real a23);


friend class gp_GTrsf2d;


protected:



  void Orthogonalize();




private:



  Standard_Real scale;
  gp_TrsfForm shape;
  gp_Mat2d matrix;
  gp_XY loc;


};


# 1 "/usr/include/opencascade/gp_Trsf2d.lxx" 1
# 15 "/usr/include/opencascade/gp_Trsf2d.lxx"
# 1 "/usr/include/opencascade/gp_Trsf.hxx" 1
# 16 "/usr/include/opencascade/gp_Trsf2d.lxx" 2
# 1 "/usr/include/opencascade/gp_Pnt2d.hxx" 1
# 26 "/usr/include/opencascade/gp_Pnt2d.hxx"
class Standard_OutOfRange;
class gp_XY;
class gp_Ax2d;
class gp_Trsf2d;
class gp_Vec2d;



class gp_Pnt2d
{
public:

  void* operator new (size_t theSize) { return Standard::Allocate (theSize); } void operator delete (void* theAddress) { Standard::Free (theAddress); } void* operator new[] (size_t theSize) { return Standard::Allocate (theSize); } void operator delete[] (void* theAddress) { Standard::Free (theAddress); } void* operator new (size_t, void* theAddress) { return theAddress; } void operator delete (void*, void*) { }



    gp_Pnt2d();


    gp_Pnt2d(const gp_XY& Coord);



    gp_Pnt2d(const Standard_Real Xp, const Standard_Real Yp);






    void SetCoord (const Standard_Integer Index, const Standard_Real Xi);


    void SetCoord (const Standard_Real Xp, const Standard_Real Yp);


    void SetX (const Standard_Real X);


    void SetY (const Standard_Real Y);


    void SetXY (const gp_XY& Coord);






  Standard_Real Coord (const Standard_Integer Index) const;


    void Coord (Standard_Real& Xp, Standard_Real& Yp) const;


    Standard_Real X() const;


    Standard_Real Y() const;


    const gp_XY& XY() const;


    const gp_XY& Coord() const;




    gp_XY& ChangeCoord();




    Standard_Boolean IsEqual (const gp_Pnt2d& Other, const Standard_Real LinearTolerance) const;


    Standard_Real Distance (const gp_Pnt2d& Other) const;


    Standard_Real SquareDistance (const gp_Pnt2d& Other) const;





  void Mirror (const gp_Pnt2d& P);




  [[nodiscard]] gp_Pnt2d Mirrored (const gp_Pnt2d& P) const;

  void Mirror (const gp_Ax2d& A);




  [[nodiscard]] gp_Pnt2d Mirrored (const gp_Ax2d& A) const;

    void Rotate (const gp_Pnt2d& P, const Standard_Real Ang);


    [[nodiscard]] gp_Pnt2d Rotated (const gp_Pnt2d& P, const Standard_Real Ang) const;

    void Scale (const gp_Pnt2d& P, const Standard_Real S);


    [[nodiscard]] gp_Pnt2d Scaled (const gp_Pnt2d& P, const Standard_Real S) const;

  void Transform (const gp_Trsf2d& T);




  [[nodiscard]] gp_Pnt2d Transformed (const gp_Trsf2d& T) const;

    void Translate (const gp_Vec2d& V);



    [[nodiscard]] gp_Pnt2d Translated (const gp_Vec2d& V) const;

    void Translate (const gp_Pnt2d& P1, const gp_Pnt2d& P2);

    [[nodiscard]] gp_Pnt2d Translated (const gp_Pnt2d& P1, const gp_Pnt2d& P2) const;



  void DumpJson (Standard_OStream& theOStream, Standard_Integer theDepth = -1) const;



protected:





private:



  gp_XY coord;


};


# 1 "/usr/include/opencascade/gp_Pnt2d.lxx" 1
# 19 "/usr/include/opencascade/gp_Pnt2d.lxx"
# 1 "/usr/include/opencascade/gp_Vec2d.hxx" 1
# 26 "/usr/include/opencascade/gp_Vec2d.hxx"
class Standard_ConstructionError;
class Standard_OutOfRange;
class gp_VectorWithNullMagnitude;
class gp_Dir2d;
class gp_XY;
class gp_Pnt2d;
class gp_Ax2d;
class gp_Trsf2d;




class gp_Vec2d
{
public:

  void* operator new (size_t theSize) { return Standard::Allocate (theSize); } void operator delete (void* theAddress) { Standard::Free (theAddress); } void* operator new[] (size_t theSize) { return Standard::Allocate (theSize); } void operator delete[] (void* theAddress) { Standard::Free (theAddress); } void* operator new (size_t, void* theAddress) { return theAddress; } void operator delete (void*, void*) { }



    gp_Vec2d();


    gp_Vec2d(const gp_Dir2d& V);


    gp_Vec2d(const gp_XY& Coord);


    gp_Vec2d(const Standard_Real Xv, const Standard_Real Yv);




    gp_Vec2d(const gp_Pnt2d& P1, const gp_Pnt2d& P2);





    void SetCoord (const Standard_Integer Index, const Standard_Real Xi);



    void SetCoord (const Standard_Real Xv, const Standard_Real Yv);


    void SetX (const Standard_Real X);


    void SetY (const Standard_Real Y);


    void SetXY (const gp_XY& Coord);






    Standard_Real Coord (const Standard_Integer Index) const;


    void Coord (Standard_Real& Xv, Standard_Real& Yv) const;


    Standard_Real X() const;


    Standard_Real Y() const;


    const gp_XY& XY() const;





  Standard_Boolean IsEqual (const gp_Vec2d& Other, const Standard_Real LinearTolerance, const Standard_Real AngularTolerance) const;






    Standard_Boolean IsNormal (const gp_Vec2d& Other, const Standard_Real AngularTolerance) const;





  Standard_Boolean IsOpposite (const gp_Vec2d& Other, const Standard_Real AngularTolerance) const;







  Standard_Boolean IsParallel (const gp_Vec2d& Other, const Standard_Real AngularTolerance) const;
# 135 "/usr/include/opencascade/gp_Vec2d.hxx"
  Standard_Real Angle (const gp_Vec2d& Other) const;


    Standard_Real Magnitude() const;


    Standard_Real SquareMagnitude() const;

    void Add (const gp_Vec2d& Other);
    void operator += (const gp_Vec2d& Other)
    {
      Add(Other);
    }


    [[nodiscard]] gp_Vec2d Added (const gp_Vec2d& Other) const;
    [[nodiscard]] gp_Vec2d operator + (const gp_Vec2d& Other) const
    {
      return Added(Other);
    }


    [[nodiscard]] Standard_Real Crossed (const gp_Vec2d& Right) const;
    [[nodiscard]] Standard_Real operator ^ (const gp_Vec2d& Right) const
    {
      return Crossed(Right);
    }




    Standard_Real CrossMagnitude (const gp_Vec2d& Right) const;




    Standard_Real CrossSquareMagnitude (const gp_Vec2d& Right) const;

    void Divide (const Standard_Real Scalar);
    void operator /= (const Standard_Real Scalar)
    {
      Divide(Scalar);
    }


    [[nodiscard]] gp_Vec2d Divided (const Standard_Real Scalar) const;
    [[nodiscard]] gp_Vec2d operator / (const Standard_Real Scalar) const
    {
      return Divided(Scalar);
    }


    Standard_Real Dot (const gp_Vec2d& Other) const;
    Standard_Real operator * (const gp_Vec2d& Other) const
    {
      return Dot(Other);
    }

    gp_Vec2d GetNormal() const;

    void Multiply (const Standard_Real Scalar);
    void operator *= (const Standard_Real Scalar)
    {
      Multiply(Scalar);
    }




    [[nodiscard]] gp_Vec2d Multiplied (const Standard_Real Scalar) const;
    [[nodiscard]] gp_Vec2d operator * (const Standard_Real Scalar) const
    {
      return Multiplied(Scalar);
    }

    void Normalize();





    [[nodiscard]] gp_Vec2d Normalized() const;

    void Reverse();


    [[nodiscard]] gp_Vec2d Reversed() const;
    [[nodiscard]] gp_Vec2d operator -() const
    {
      return Reversed();
    }


    void Subtract (const gp_Vec2d& Right);
    void operator -= (const gp_Vec2d& Right)
    {
      Subtract(Right);
    }


    [[nodiscard]] gp_Vec2d Subtracted (const gp_Vec2d& Right) const;
    [[nodiscard]] gp_Vec2d operator - (const gp_Vec2d& Right) const
    {
      return Subtracted(Right);
    }




    void SetLinearForm (const Standard_Real A1, const gp_Vec2d& V1, const Standard_Real A2, const gp_Vec2d& V2, const gp_Vec2d& V3);



    void SetLinearForm (const Standard_Real A1, const gp_Vec2d& V1, const Standard_Real A2, const gp_Vec2d& V2);



    void SetLinearForm (const Standard_Real A1, const gp_Vec2d& V1, const gp_Vec2d& V2);



    void SetLinearForm (const gp_Vec2d& Left, const gp_Vec2d& Right);





  void Mirror (const gp_Vec2d& V);





  [[nodiscard]] gp_Vec2d Mirrored (const gp_Vec2d& V) const;





  void Mirror (const gp_Ax2d& A1);





  [[nodiscard]] gp_Vec2d Mirrored (const gp_Ax2d& A1) const;

    void Rotate (const Standard_Real Ang);




    [[nodiscard]] gp_Vec2d Rotated (const Standard_Real Ang) const;

    void Scale (const Standard_Real S);


    [[nodiscard]] gp_Vec2d Scaled (const Standard_Real S) const;

  void Transform (const gp_Trsf2d& T);


  [[nodiscard]] gp_Vec2d Transformed (const gp_Trsf2d& T) const;




protected:





private:



  gp_XY coord;


};


# 1 "/usr/include/opencascade/gp_Vec2d.lxx" 1
# 18 "/usr/include/opencascade/gp_Vec2d.lxx"
# 1 "/usr/include/opencascade/gp_Dir2d.hxx" 1
# 26 "/usr/include/opencascade/gp_Dir2d.hxx"
class Standard_ConstructionError;
class Standard_DomainError;
class Standard_OutOfRange;
class gp_Vec2d;
class gp_XY;
class gp_Ax2d;
class gp_Trsf2d;
# 43 "/usr/include/opencascade/gp_Dir2d.hxx"
class gp_Dir2d
{
public:

  void* operator new (size_t theSize) { return Standard::Allocate (theSize); } void operator delete (void* theAddress) { Standard::Free (theAddress); } void* operator new[] (size_t theSize) { return Standard::Allocate (theSize); } void operator delete[] (void* theAddress) { Standard::Free (theAddress); } void* operator new (size_t, void* theAddress) { return theAddress; } void operator delete (void*, void*) { }



    gp_Dir2d();


    gp_Dir2d(const gp_Vec2d& V);


    gp_Dir2d(const gp_XY& Coord);


    gp_Dir2d(const Standard_Real Xv, const Standard_Real Yv);
# 79 "/usr/include/opencascade/gp_Dir2d.hxx"
    void SetCoord (const Standard_Integer Index, const Standard_Real Xi);
# 96 "/usr/include/opencascade/gp_Dir2d.hxx"
    void SetCoord (const Standard_Real Xv, const Standard_Real Yv);
# 111 "/usr/include/opencascade/gp_Dir2d.hxx"
    void SetX (const Standard_Real X);
# 126 "/usr/include/opencascade/gp_Dir2d.hxx"
    void SetY (const Standard_Real Y);
# 142 "/usr/include/opencascade/gp_Dir2d.hxx"
    void SetXY (const gp_XY& Coord);






    Standard_Real Coord (const Standard_Integer Index) const;



    void Coord (Standard_Real& Xv, Standard_Real& Yv) const;


    Standard_Real X() const;


    Standard_Real Y() const;




    const gp_XY& XY() const;





    Standard_Boolean IsEqual (const gp_Dir2d& Other, const Standard_Real AngularTolerance) const;





    Standard_Boolean IsNormal (const gp_Dir2d& Other, const Standard_Real AngularTolerance) const;





    Standard_Boolean IsOpposite (const gp_Dir2d& Other, const Standard_Real AngularTolerance) const;






    Standard_Boolean IsParallel (const gp_Dir2d& Other, const Standard_Real AngularTolerance) const;




  Standard_Real Angle (const gp_Dir2d& Other) const;



  [[nodiscard]] Standard_Real Crossed (const gp_Dir2d& Right) const;
  [[nodiscard]] Standard_Real operator ^ (const gp_Dir2d& Right) const
{
  return Crossed(Right);
}


    Standard_Real Dot (const gp_Dir2d& Other) const;
  Standard_Real operator * (const gp_Dir2d& Other) const
{
  return Dot(Other);
}

    void Reverse();


    [[nodiscard]] gp_Dir2d Reversed() const;
  [[nodiscard]] gp_Dir2d operator -() const
{
  return Reversed();
}

  void Mirror (const gp_Dir2d& V);





  [[nodiscard]] gp_Dir2d Mirrored (const gp_Dir2d& V) const;

  void Mirror (const gp_Ax2d& A);





  [[nodiscard]] gp_Dir2d Mirrored (const gp_Ax2d& A) const;

    void Rotate (const Standard_Real Ang);




    [[nodiscard]] gp_Dir2d Rotated (const Standard_Real Ang) const;

  void Transform (const gp_Trsf2d& T);






  [[nodiscard]] gp_Dir2d Transformed (const gp_Trsf2d& T) const;


  void DumpJson (Standard_OStream& theOStream, Standard_Integer theDepth = -1) const;




protected:





private:



  gp_XY coord;


};


# 1 "/usr/include/opencascade/gp_Dir2d.lxx" 1
# 20 "/usr/include/opencascade/gp_Dir2d.lxx"
# 1 "/usr/include/opencascade/gp_Ax2d.hxx" 1
# 22 "/usr/include/opencascade/gp_Ax2d.hxx"
# 1 "/usr/include/opencascade/gp_Pnt2d.hxx" 1
# 23 "/usr/include/opencascade/gp_Ax2d.hxx" 2
# 1 "/usr/include/opencascade/gp_Dir2d.hxx" 1
# 24 "/usr/include/opencascade/gp_Ax2d.hxx" 2


class gp_Pnt2d;
class gp_Dir2d;
class gp_Trsf2d;
class gp_Vec2d;
# 51 "/usr/include/opencascade/gp_Ax2d.hxx"
class gp_Ax2d
{
public:

  void* operator new (size_t theSize) { return Standard::Allocate (theSize); } void operator delete (void* theAddress) { Standard::Free (theAddress); } void* operator new[] (size_t theSize) { return Standard::Allocate (theSize); } void operator delete[] (void* theAddress) { Standard::Free (theAddress); } void* operator new (size_t, void* theAddress) { return theAddress; } void operator delete (void*, void*) { }




    gp_Ax2d();





    gp_Ax2d(const gp_Pnt2d& P, const gp_Dir2d& V);


    void SetLocation (const gp_Pnt2d& Locat);


    void SetDirection (const gp_Dir2d& V);


    const gp_Pnt2d& Location() const;


    const gp_Dir2d& Direction() const;
# 88 "/usr/include/opencascade/gp_Ax2d.hxx"
  Standard_Boolean IsCoaxial (const gp_Ax2d& Other, const Standard_Real AngularTolerance, const Standard_Real LinearTolerance) const;




    Standard_Boolean IsNormal (const gp_Ax2d& Other, const Standard_Real AngularTolerance) const;





    Standard_Boolean IsOpposite (const gp_Ax2d& Other, const Standard_Real AngularTolerance) const;





    Standard_Boolean IsParallel (const gp_Ax2d& Other, const Standard_Real AngularTolerance) const;




    Standard_Real Angle (const gp_Ax2d& Other) const;


    void Reverse();




  [[nodiscard]] gp_Ax2d Reversed() const;

  void Mirror (const gp_Pnt2d& P);





  [[nodiscard]] gp_Ax2d Mirrored (const gp_Pnt2d& P) const;

  void Mirror (const gp_Ax2d& A);





  [[nodiscard]] gp_Ax2d Mirrored (const gp_Ax2d& A) const;

    void Rotate (const gp_Pnt2d& P, const Standard_Real Ang);





    [[nodiscard]] gp_Ax2d Rotated (const gp_Pnt2d& P, const Standard_Real Ang) const;

  void Scale (const gp_Pnt2d& P, const Standard_Real S);





  [[nodiscard]] gp_Ax2d Scaled (const gp_Pnt2d& P, const Standard_Real S) const;

    void Transform (const gp_Trsf2d& T);


    [[nodiscard]] gp_Ax2d Transformed (const gp_Trsf2d& T) const;

    void Translate (const gp_Vec2d& V);




    [[nodiscard]] gp_Ax2d Translated (const gp_Vec2d& V) const;

    void Translate (const gp_Pnt2d& P1, const gp_Pnt2d& P2);




    [[nodiscard]] gp_Ax2d Translated (const gp_Pnt2d& P1, const gp_Pnt2d& P2) const;


  void DumpJson (Standard_OStream& theOStream, Standard_Integer theDepth = -1) const;




protected:





private:



  gp_Pnt2d loc;
  gp_Dir2d vdir;


};


# 1 "/usr/include/opencascade/gp_Ax2d.lxx" 1
# 18 "/usr/include/opencascade/gp_Ax2d.lxx"
# 1 "/usr/include/opencascade/gp_Ax2d.hxx" 1
# 19 "/usr/include/opencascade/gp_Ax2d.lxx" 2

inline gp_Ax2d::gp_Ax2d()
  :
  loc(0.,0.)

{ }

inline gp_Ax2d::gp_Ax2d (const gp_Pnt2d& P,
    const gp_Dir2d& V) : loc(P), vdir(V)
{ }

inline void gp_Ax2d::SetLocation(const gp_Pnt2d& P)
{ loc = P; }

inline void gp_Ax2d::SetDirection(const gp_Dir2d& V)
{ vdir = V; }

inline const gp_Pnt2d& gp_Ax2d::Location () const
{ return loc; }

inline const gp_Dir2d& gp_Ax2d::Direction () const
{ return vdir; }

inline Standard_Boolean gp_Ax2d::IsNormal
(const gp_Ax2d& Other,
 const Standard_Real AngularTolerance) const
{ return vdir.IsNormal(Other.vdir, AngularTolerance); }

inline Standard_Boolean gp_Ax2d::IsOpposite
(const gp_Ax2d& Other,
 const Standard_Real AngularTolerance) const
{ return vdir.IsOpposite (Other.vdir, AngularTolerance); }

inline Standard_Boolean gp_Ax2d::IsParallel
(const gp_Ax2d& Other,
 const Standard_Real AngularTolerance) const
{ return vdir.IsParallel(Other.vdir, AngularTolerance); }

inline Standard_Real gp_Ax2d::Angle (const gp_Ax2d& Other) const
{ return vdir.Angle (Other.vdir); }

inline void gp_Ax2d::Reverse()
{ vdir.Reverse(); }

inline gp_Ax2d gp_Ax2d::Reversed() const
{
  gp_Ax2d Temp = *this;
  Temp.Reverse ();
  return Temp;
}

inline void gp_Ax2d::Rotate (const gp_Pnt2d& P,
        const Standard_Real Ang)
{
  loc.Rotate (P, Ang);
  vdir.Rotate (Ang);
}

inline gp_Ax2d gp_Ax2d::Rotated (const gp_Pnt2d& P,
     const Standard_Real Ang) const
{
  gp_Ax2d A = *this;
  A.Rotate (P, Ang);
  return A;
}

inline gp_Ax2d gp_Ax2d::Scaled (const gp_Pnt2d& P,
    const Standard_Real S) const
{
  gp_Ax2d A = *this;
  A.Scale (P, S);
  return A;
}

inline void gp_Ax2d::Transform (const gp_Trsf2d& T)
{
  loc.Transform (T);
  vdir.Transform (T);
}

inline gp_Ax2d gp_Ax2d::Transformed (const gp_Trsf2d& T) const
{
  gp_Ax2d A = *this;
  A.Transform (T);
  return A;
}

inline void gp_Ax2d::Translate (const gp_Vec2d& V)
{ loc.Translate (V); }

inline gp_Ax2d gp_Ax2d::Translated (const gp_Vec2d& V) const
{
  gp_Ax2d A = *this;
  (A.loc).Translate (V);
  return A;
}

inline void gp_Ax2d::Translate (const gp_Pnt2d& P1,
    const gp_Pnt2d& P2)
{ loc.Translate (P1,P2); }

inline gp_Ax2d gp_Ax2d::Translated (const gp_Pnt2d& P1,
        const gp_Pnt2d& P2) const
{
  gp_Ax2d A = *this;
  (A.loc).Translate( gp_Vec2d (P1, P2));
  return A;
}
# 195 "/usr/include/opencascade/gp_Ax2d.hxx" 2
# 21 "/usr/include/opencascade/gp_Dir2d.lxx" 2
# 1 "/usr/include/opencascade/gp_Trsf2d.hxx" 1
# 22 "/usr/include/opencascade/gp_Dir2d.lxx" 2

inline gp_Dir2d::gp_Dir2d() : coord (1.,0.)
{
}

inline gp_Dir2d::gp_Dir2d (const gp_Vec2d& V)
{
  const gp_XY& XY = V.XY();
  Standard_Real X = XY.X();
  Standard_Real Y = XY.Y();
  Standard_Real D = sqrt(X * X + Y * Y);
  if (D <= gp::Resolution()) throw Standard_ConstructionError("gp_Dir2d() - input vector has zero norm");;
  coord.SetX(X / D);
  coord.SetY(Y / D);
}

inline gp_Dir2d::gp_Dir2d (const gp_XY& XY)
{
  Standard_Real X = XY.X();
  Standard_Real Y = XY.Y();
  Standard_Real D = sqrt(X * X + Y * Y);
  if (D <= gp::Resolution()) throw Standard_ConstructionError("gp_Dir2d() - input vector has zero norm");;
  coord.SetX(X / D);
  coord.SetY(Y / D);
}

inline gp_Dir2d::gp_Dir2d (const Standard_Real Xv,
      const Standard_Real Yv)
{
  Standard_Real D = sqrt (Xv * Xv + Yv * Yv);
  if (D <= gp::Resolution()) throw Standard_ConstructionError("gp_Dir2d() - input vector has zero norm");;
  coord.SetX(Xv / D);
  coord.SetY(Yv / D);
}

inline void gp_Dir2d::SetCoord (const Standard_Integer Index,
    const Standard_Real Xi)
{
  Standard_Real X = coord.X();
  Standard_Real Y = coord.Y();
 
# 62 "/usr/include/opencascade/gp_Dir2d.lxx"
#pragma GCC diagnostic push
# 62 "/usr/include/opencascade/gp_Dir2d.lxx"
 
# 62 "/usr/include/opencascade/gp_Dir2d.lxx"
#pragma GCC diagnostic ignored "-Wstrict-overflow"
# 62 "/usr/include/opencascade/gp_Dir2d.lxx"
  if (Index < 1 || Index > 2) throw Standard_OutOfRange("gp_Dir2d::SetCoord() - index is out of range [1, 2]");
# 62 "/usr/include/opencascade/gp_Dir2d.lxx"
#pragma GCC diagnostic pop
# 62 "/usr/include/opencascade/gp_Dir2d.lxx"
  ;
  if (Index == 1) X = Xi;
  else Y = Xi;
  Standard_Real D = sqrt (X * X + Y * Y);
  if (D <= gp::Resolution()) throw Standard_ConstructionError("gp_Dir2d::SetCoord() - result vector has zero norm");;
  coord.SetX(X / D);
  coord.SetY(Y / D);
}

inline void gp_Dir2d::SetCoord (const Standard_Real Xv,
    const Standard_Real Yv)
{
  Standard_Real D = sqrt (Xv * Xv + Yv * Yv);
  if (D <= gp::Resolution()) throw Standard_ConstructionError("gp_Dir2d::SetCoord() - result vector has zero norm");;
  coord.SetX(Xv / D);
  coord.SetY(Yv / D);
}

inline void gp_Dir2d::SetX (const Standard_Real X)
{
  Standard_Real Y = coord.Y();
  Standard_Real D = sqrt (X * X + Y * Y);
  if (D <= gp::Resolution()) throw Standard_ConstructionError("gp_Dir2d::SetX() - result vector has zero norm");;
  coord.SetX(X / D);
  coord.SetY(Y / D);
}

inline void gp_Dir2d::SetY (const Standard_Real Y)
{
  Standard_Real X = coord.X();
  Standard_Real D = sqrt (X * X + Y * Y);
  if (D <= gp::Resolution()) throw Standard_ConstructionError("gp_Dir2d::SetY() - result vector has zero norm");;
  coord.SetX(X / D);
  coord.SetY(Y / D);
}

inline void gp_Dir2d::SetXY (const gp_XY& XY)
{
  Standard_Real X = XY.X();
  Standard_Real Y = XY.Y();
  Standard_Real D = sqrt(X * X + Y * Y);
  if (D <= gp::Resolution()) throw Standard_ConstructionError("gp_Dir2d::SetZ() - result vector has zero norm");;
  coord.SetX(X / D);
  coord.SetY(Y / D);
}

inline Standard_Real gp_Dir2d::Coord (const Standard_Integer Index) const
{ return coord.Coord(Index); }

inline void gp_Dir2d::Coord(Standard_Real& Xv, Standard_Real& Yv) const
{ coord.Coord (Xv, Yv); }

inline Standard_Real gp_Dir2d::X() const
{ return coord.X() ; }

inline Standard_Real gp_Dir2d::Y() const
{ return coord.Y() ; }

inline const gp_XY& gp_Dir2d::XY () const
{ return coord; }

inline Standard_Boolean gp_Dir2d::IsEqual
(const gp_Dir2d& Other,
 const Standard_Real AngularTolerance) const
{
  Standard_Real Ang = Angle(Other);
  if (Ang < 0) Ang = - Ang;
  return Ang <= AngularTolerance;
}

inline Standard_Boolean gp_Dir2d::IsNormal
(const gp_Dir2d& Other,
 const Standard_Real AngularTolerance) const
{
  Standard_Real Ang = Angle(Other);
  if (Ang < 0) Ang = - Ang;
  Ang = 
# 138 "/usr/include/opencascade/gp_Dir2d.lxx" 3 4
       3.14159265358979323846 
# 138 "/usr/include/opencascade/gp_Dir2d.lxx"
            / 2.0 - Ang;
  if (Ang < 0) Ang = - Ang;
  return Ang <= AngularTolerance;
}

inline Standard_Boolean gp_Dir2d::IsOpposite
(const gp_Dir2d& Other,
 const Standard_Real AngularTolerance) const
{
  Standard_Real Ang = Angle(Other);
  if (Ang < 0) Ang = - Ang;
  return 
# 149 "/usr/include/opencascade/gp_Dir2d.lxx" 3 4
        3.14159265358979323846 
# 149 "/usr/include/opencascade/gp_Dir2d.lxx"
             - Ang <= AngularTolerance;
}

inline Standard_Boolean gp_Dir2d::IsParallel
(const gp_Dir2d& Other,
 const Standard_Real AngularTolerance) const
{
  Standard_Real Ang = Angle(Other);
  if (Ang < 0) Ang = - Ang;
  return Ang <= AngularTolerance || 
# 158 "/usr/include/opencascade/gp_Dir2d.lxx" 3 4
                                     3.14159265358979323846 
# 158 "/usr/include/opencascade/gp_Dir2d.lxx"
                                          - Ang <= AngularTolerance;
}

inline Standard_Real gp_Dir2d::Crossed (const gp_Dir2d& Right) const
{ return coord.Crossed (Right.coord); }

inline Standard_Real gp_Dir2d::Dot (const gp_Dir2d& Other) const
{ return coord.Dot (Other.coord); }

inline void gp_Dir2d::Reverse()
{ coord.Reverse(); }

inline gp_Dir2d gp_Dir2d::Reversed() const
{
  gp_Dir2d V = *this;
  V.coord.Reverse ();
  return V;
}

inline void gp_Dir2d::Rotate (const Standard_Real Ang)
{
  gp_Trsf2d T;
  T.SetRotation (gp_Pnt2d (0.0, 0.0), Ang);
  coord.Multiply (T.HVectorialPart());
}

inline gp_Dir2d gp_Dir2d::Rotated (const Standard_Real Ang) const
{
  gp_Dir2d V = *this;
  V.Rotate (Ang);
  return V;
}

inline gp_Dir2d gp_Dir2d::Transformed (const gp_Trsf2d& T) const
{
  gp_Dir2d V = *this;
  V.Transform (T);
  return V;
}
# 275 "/usr/include/opencascade/gp_Dir2d.hxx" 2
# 19 "/usr/include/opencascade/gp_Vec2d.lxx" 2



inline gp_Vec2d::gp_Vec2d()
{}

inline gp_Vec2d::gp_Vec2d (const gp_Dir2d& V)
{ coord = V.XY(); }

inline gp_Vec2d::gp_Vec2d (const gp_XY& Coord) : coord(Coord)
{}

inline gp_Vec2d::gp_Vec2d (const Standard_Real Xv,
      const Standard_Real Yv) : coord (Xv, Yv)
{ }

inline gp_Vec2d::gp_Vec2d (const gp_Pnt2d& P1,
      const gp_Pnt2d& P2)
{ coord = P2.XY().Subtracted (P1.XY()); }

inline void gp_Vec2d::SetCoord (const Standard_Integer Index,
    const Standard_Real Xi)
{ coord.SetCoord (Index, Xi); }

inline void gp_Vec2d::SetCoord (const Standard_Real Xv,
    const Standard_Real Yv)
{ coord.SetCoord (Xv, Yv); }

inline void gp_Vec2d::SetX (const Standard_Real X)
{ coord.SetX (X); }

inline void gp_Vec2d::SetY (const Standard_Real Y)
{ coord.SetY (Y); }

inline void gp_Vec2d::SetXY (const gp_XY& Coord)
{ coord = Coord; }

inline Standard_Real gp_Vec2d::Coord (const Standard_Integer Index) const
{ return coord.Coord(Index); }

inline void gp_Vec2d::Coord(Standard_Real& Xv,
       Standard_Real& Yv) const
{ coord.Coord(Xv, Yv); }

inline Standard_Real gp_Vec2d::X() const
{ return coord.X(); }

inline Standard_Real gp_Vec2d::Y() const
{ return coord.Y(); }

inline const gp_XY& gp_Vec2d::XY () const
{ return coord; }

inline Standard_Boolean gp_Vec2d::IsNormal
(const gp_Vec2d& theOther,
 const Standard_Real theAngularTolerance) const
{
  const Standard_Real anAng = Abs(
# 76 "/usr/include/opencascade/gp_Vec2d.lxx" 3 4
                                 1.57079632679489661923 
# 76 "/usr/include/opencascade/gp_Vec2d.lxx"
                                        - Abs(Angle(theOther)));
  return !(anAng > theAngularTolerance);
}

inline Standard_Boolean gp_Vec2d::IsOpposite
(const gp_Vec2d& Other,
 const Standard_Real AngularTolerance) const
{
  Standard_Real Ang = Angle(Other);
  if (Ang < 0) Ang = - Ang;
  return 
# 86 "/usr/include/opencascade/gp_Vec2d.lxx" 3 4
        3.14159265358979323846 
# 86 "/usr/include/opencascade/gp_Vec2d.lxx"
             - Ang <= AngularTolerance;
}

inline Standard_Boolean gp_Vec2d::IsParallel
(const gp_Vec2d& Other,
 const Standard_Real AngularTolerance) const
{
  Standard_Real Ang = Angle(Other);
  if (Ang < 0) Ang = - Ang;
  return Ang <= AngularTolerance || 
# 95 "/usr/include/opencascade/gp_Vec2d.lxx" 3 4
                                     3.14159265358979323846 
# 95 "/usr/include/opencascade/gp_Vec2d.lxx"
                                          - Ang <= AngularTolerance;
}

inline Standard_Real gp_Vec2d::Magnitude() const
{ return coord.Modulus(); }

inline Standard_Real gp_Vec2d::SquareMagnitude() const
{ return coord.SquareModulus(); }

inline void gp_Vec2d::Add (const gp_Vec2d& Other)
{ coord.Add (Other.coord); }

inline gp_Vec2d gp_Vec2d::Added (const gp_Vec2d& Other) const
{
  gp_Vec2d V = *this;
  V.coord.Add (Other.coord);
  return V;
}

inline Standard_Real gp_Vec2d::Crossed (const gp_Vec2d& Right) const
{ return coord.Crossed (Right.coord); }

inline Standard_Real gp_Vec2d::CrossMagnitude (const gp_Vec2d& Right) const
{ return coord.CrossMagnitude (Right.coord); }

inline Standard_Real gp_Vec2d::CrossSquareMagnitude
(const gp_Vec2d& Right) const
{ return coord.CrossSquareMagnitude (Right.coord); }

inline void gp_Vec2d::Divide (const Standard_Real Scalar)
{ coord.Divide (Scalar); }

inline gp_Vec2d gp_Vec2d::Divided (const Standard_Real Scalar) const
{
  gp_Vec2d V = *this;
  V.coord.Divide(Scalar);
  return V;
}

inline Standard_Real gp_Vec2d::Dot (const gp_Vec2d& Other) const
{ return coord.Dot (Other.coord); }

inline void gp_Vec2d::Multiply (const Standard_Real Scalar)
{ coord.Multiply (Scalar); }

inline gp_Vec2d gp_Vec2d::Multiplied (const Standard_Real Scalar) const
{
  gp_Vec2d V = *this;
  V.coord.Multiply(Scalar);
  return V;
}

inline void gp_Vec2d::Normalize()
{
  Standard_Real D = coord.Modulus();
  if (D <= gp::Resolution()) throw Standard_ConstructionError("gp_Vec2d::Normalize() - vector has zero norm");
                                                                                      ;
  coord.Divide (D);
}

inline gp_Vec2d gp_Vec2d::Normalized() const
{
  Standard_Real D = coord.Modulus();
  if (D <= gp::Resolution()) throw Standard_ConstructionError("gp_Vec2d::Normalized() - vector has zero norm");
                                                                                       ;
  gp_Vec2d V = *this;
  V.coord.Divide (D);
  return V;
}

inline void gp_Vec2d::Reverse()
{ coord.Reverse(); }

inline gp_Vec2d gp_Vec2d::Reversed() const
{
  gp_Vec2d V = *this;
  V.coord.Reverse();
  return V;
}

inline void gp_Vec2d::Subtract (const gp_Vec2d& Right)
{ coord.Subtract (Right.coord); }

inline gp_Vec2d gp_Vec2d::Subtracted (const gp_Vec2d& Right) const
{
  gp_Vec2d V = *this;
  V.coord.Subtract (Right.coord);
  return V;
}

inline void gp_Vec2d::SetLinearForm (const Standard_Real L,
         const gp_Vec2d& Left,
         const Standard_Real R,
         const gp_Vec2d& Right)
{ coord.SetLinearForm (L, Left.coord, R, Right.coord); }

inline void gp_Vec2d::SetLinearForm (const Standard_Real L,
         const gp_Vec2d& Left,
         const gp_Vec2d& Right)
{ coord.SetLinearForm (L, Left.coord, Right.coord); }

inline void gp_Vec2d::SetLinearForm (const gp_Vec2d& Left,
         const gp_Vec2d& Right)
{ coord.SetLinearForm (Left.coord, Right.coord); }

inline void gp_Vec2d::SetLinearForm (const Standard_Real A1,
         const gp_Vec2d& V1,
         const Standard_Real A2,
         const gp_Vec2d& V2,
         const gp_Vec2d& V3)
{ coord.SetLinearForm (A1, V1.coord, A2, V2.coord, V3.coord); }

inline void gp_Vec2d::Rotate (const Standard_Real Ang)
{
  gp_Trsf2d T;
  T.SetRotation (gp_Pnt2d (0.0, 0.0), Ang);
  coord.Multiply (T.VectorialPart ());
}

inline gp_Vec2d gp_Vec2d::Rotated (const Standard_Real Ang) const
{
  gp_Vec2d V = *this;
  V.Rotate (Ang);
  return V;
}

inline void gp_Vec2d::Scale (const Standard_Real S)
{ coord.Multiply (S); }

inline gp_Vec2d gp_Vec2d::Scaled (const Standard_Real S) const
{
  gp_Vec2d V = *this;
  V.coord.Multiply (S);
  return V;
}

inline gp_Vec2d gp_Vec2d::Transformed (const gp_Trsf2d& T) const
{
  gp_Vec2d V = *this;
  V.Transform(T);
  return V;
}

inline gp_Vec2d operator* (const Standard_Real Scalar,
      const gp_Vec2d& V)
{ return V.Multiplied(Scalar); }

inline gp_Vec2d gp_Vec2d::GetNormal() const
{
  return gp_Vec2d(this->Y(), (-1)*this->X());
}
# 319 "/usr/include/opencascade/gp_Vec2d.hxx" 2
# 20 "/usr/include/opencascade/gp_Pnt2d.lxx" 2



inline gp_Pnt2d::gp_Pnt2d (const gp_XY& Coordinates) : coord (Coordinates)
{ }

inline gp_Pnt2d::gp_Pnt2d (const Standard_Real Xp,
      const Standard_Real Yp) : coord (Xp, Yp)
{ }

inline gp_Pnt2d::gp_Pnt2d() { }

inline Standard_Real gp_Pnt2d::Coord(const Standard_Integer Index) const { return coord.Coord(Index); }

inline void gp_Pnt2d::SetX (const Standard_Real X)
{ coord.SetX (X); }

inline void gp_Pnt2d::SetY (const Standard_Real Y)
{ coord.SetY (Y); }

inline void gp_Pnt2d::SetXY (const gp_XY& Coordinates)
{ coord = Coordinates; }

inline void gp_Pnt2d::SetCoord (const Standard_Real Xp,
    const Standard_Real Yp)
{ coord.SetCoord (Xp, Yp);}

inline void gp_Pnt2d::SetCoord (const Standard_Integer Index,
    const Standard_Real Xi)
{ coord.SetCoord (Index, Xi); }

inline void gp_Pnt2d::Coord (Standard_Real& Xp,
        Standard_Real& Yp) const
{ coord.Coord (Xp, Yp); }

inline Standard_Real gp_Pnt2d::X() const
{ return coord.X(); }

inline Standard_Real gp_Pnt2d::Y() const
{ return coord.Y(); }

inline const gp_XY& gp_Pnt2d::XY () const
{ return coord; }

inline const gp_XY& gp_Pnt2d::Coord () const
{ return coord; }

inline gp_XY& gp_Pnt2d::ChangeCoord ()
{ return coord; }

inline Standard_Boolean gp_Pnt2d::IsEqual
(const gp_Pnt2d& Other,
 const Standard_Real LinearTolerance) const
{ return Distance (Other) <= LinearTolerance; }

inline Standard_Real gp_Pnt2d::Distance (const gp_Pnt2d& Other) const
{
  const gp_XY& XY = Other.coord;
  Standard_Real X = coord.X() - XY.X();
  Standard_Real Y = coord.Y() - XY.Y();
  return sqrt (X * X + Y * Y);
}

inline Standard_Real gp_Pnt2d::SquareDistance (const gp_Pnt2d& Other) const
{
  const gp_XY& XY = Other.coord;
  Standard_Real X = coord.X() - XY.X();
  Standard_Real Y = coord.Y() - XY.Y();
  return (X * X + Y * Y);
}

inline void gp_Pnt2d::Rotate (const gp_Pnt2d& P,
         const Standard_Real Ang)
{
  gp_Trsf2d T;
  T.SetRotation (P, Ang);
  T.Transforms (coord);
}

inline gp_Pnt2d gp_Pnt2d::Rotated (const gp_Pnt2d& P,
       const Standard_Real Ang) const
{
  gp_Pnt2d Pres = *this;
  Pres.Rotate (P, Ang);
  return Pres;
}

inline void gp_Pnt2d::Scale (const gp_Pnt2d& P,
        const Standard_Real S)
{
  gp_XY XY = P.coord;
  XY.Multiply (1.0 - S);
  coord.Multiply (S);
  coord.Add (XY);
}

inline gp_Pnt2d gp_Pnt2d::Scaled (const gp_Pnt2d& P,
      const Standard_Real S) const
{
  gp_Pnt2d Pres = *this;
  Pres.Scale (P, S);
  return Pres;
}

inline gp_Pnt2d gp_Pnt2d::Transformed (const gp_Trsf2d& T) const
{
  gp_Pnt2d Pres = *this;
  Pres.Transform (T);
  return Pres;
}

inline void gp_Pnt2d::Translate (const gp_Vec2d& V)
{ coord.Add (V.XY()); }

inline gp_Pnt2d gp_Pnt2d::Translated (const gp_Vec2d& V) const
{
  gp_Pnt2d P = *this;
  P.coord.Add (V.XY ());
  return P;
}

inline void gp_Pnt2d::Translate (const gp_Pnt2d& P1,
     const gp_Pnt2d& P2)
{
  coord.Add (P2.coord);
  coord.Subtract (P1.coord);
}

inline gp_Pnt2d gp_Pnt2d::Translated (const gp_Pnt2d& P1,
          const gp_Pnt2d& P2) const
{
  gp_Pnt2d P = *this;
  P.Translate (P1, P2);
  return P;
}
# 176 "/usr/include/opencascade/gp_Pnt2d.hxx" 2
# 17 "/usr/include/opencascade/gp_Trsf2d.lxx" 2

inline gp_Trsf2d::gp_Trsf2d () {
  shape = gp_Identity;
  scale = 1.0;
  matrix.SetIdentity ();
  loc.SetCoord (0.0, 0.0);
}

inline gp_Trsf2d::gp_Trsf2d (const gp_Trsf& T) :
scale(T.ScaleFactor()),
shape(T.Form()),
loc(T.TranslationPart().X(),T.TranslationPart().Y())
{
  const gp_Mat& M = T.HVectorialPart();
  matrix(1,1) = M(1,1);
  matrix(1,2) = M(1,2);
  matrix(2,1) = M(2,1);
  matrix(2,2) = M(2,2);
}

inline void gp_Trsf2d::SetMirror(const gp_Pnt2d& P)
{
  shape = gp_PntMirror;
  scale = -1.0;
  matrix.SetIdentity ();
  loc = P.XY();
  loc.Multiply (2.0);
}

inline void gp_Trsf2d::SetRotation (const gp_Pnt2d& P,
        const Standard_Real Ang)
{
  shape = gp_Rotation;
  scale = 1.0;
  loc = P.XY ();
  loc.Reverse ();
  matrix.SetRotation (Ang);
  loc.Multiply (matrix);
  loc.Add (P.XY());
}

inline void gp_Trsf2d::SetScale (const gp_Pnt2d& P,
     const Standard_Real S)
{
  shape = gp_Scale;
  scale = S;
  matrix.SetIdentity ();
  loc = P.XY ();
  loc.Multiply (1.0 - S);
}

inline void gp_Trsf2d::SetTranslation(const gp_Vec2d& V)
{
  shape = gp_Translation;
  scale = 1.0;
  matrix.SetIdentity ();
  loc = V.XY ();
}

inline void gp_Trsf2d::SetTranslation (const gp_Pnt2d& P1,
           const gp_Pnt2d& P2)
{
  shape = gp_Translation;
  scale = 1.0;
  matrix.SetIdentity ();
  loc = (P2.XY()).Subtracted (P1.XY());
}

inline Standard_Boolean gp_Trsf2d::IsNegative() const
{ return (matrix.Determinant() < 0.0); }

inline const gp_XY& gp_Trsf2d::TranslationPart () const
{ return loc; }

inline const gp_Mat2d& gp_Trsf2d::HVectorialPart () const
{ return matrix; }

inline Standard_Real gp_Trsf2d::Value (const Standard_Integer Row,
           const Standard_Integer Col) const
{
 
#pragma GCC diagnostic push
# 97 "/usr/include/opencascade/gp_Trsf2d.lxx"
 
#pragma GCC diagnostic ignored "-Wstrict-overflow"
# 97 "/usr/include/opencascade/gp_Trsf2d.lxx"
  if (Row < 1 || Row > 2 || Col < 1 || Col > 3) throw Standard_OutOfRange(" ");
#pragma GCC diagnostic pop
# 97 "/usr/include/opencascade/gp_Trsf2d.lxx"
 
                                                   ;
  if (Col < 3) return scale * matrix.Value (Row, Col);
  else return loc.Coord (Row);
}

inline gp_TrsfForm gp_Trsf2d::Form() const
{ return shape; }

inline Standard_Real gp_Trsf2d::ScaleFactor() const
{ return scale; }

inline gp_Trsf2d gp_Trsf2d::Inverted() const
{
  gp_Trsf2d T = *this;
  T.Invert();
  return T;
}

inline gp_Trsf2d gp_Trsf2d::Multiplied (const gp_Trsf2d& T) const {
  gp_Trsf2d Tresult(*this);
  Tresult.Multiply(T);
  return Tresult;
}

inline gp_Trsf2d gp_Trsf2d::Powered (const Standard_Integer N)
{
  gp_Trsf2d T = *this;
  T.Power (N);
  return T;
}

inline void gp_Trsf2d::Transforms (Standard_Real& X,
       Standard_Real& Y) const
{
  gp_XY Doublet (X, Y);
  Doublet.Multiply (matrix);
  if (scale != 1.0) Doublet.Multiply (scale);
  Doublet.Add(loc);
  Doublet.Coord (X, Y);
}

inline void gp_Trsf2d::Transforms (gp_XY& Coord) const
{
  Coord.Multiply (matrix);
  if (scale != 1.0) Coord.Multiply (scale);
  Coord.Add(loc);
}
# 245 "/usr/include/opencascade/gp_Trsf2d.hxx" 2
# 21 "/usr/include/opencascade/gp_Trsf.lxx" 2
# 1 "/usr/include/opencascade/gp_Vec.hxx" 1
# 26 "/usr/include/opencascade/gp_Vec.hxx"
class Standard_ConstructionError;
class Standard_DomainError;
class Standard_OutOfRange;
class gp_VectorWithNullMagnitude;
class gp_Dir;
class gp_XYZ;
class gp_Pnt;
class gp_Ax1;
class gp_Ax2;
class gp_Trsf;




class gp_Vec
{
public:

  void* operator new (size_t theSize) { return Standard::Allocate (theSize); } void operator delete (void* theAddress) { Standard::Free (theAddress); } void* operator new[] (size_t theSize) { return Standard::Allocate (theSize); } void operator delete[] (void* theAddress) { Standard::Free (theAddress); } void* operator new (size_t, void* theAddress) { return theAddress; } void operator delete (void*, void*) { }



    gp_Vec();


    gp_Vec(const gp_Dir& V);


    gp_Vec(const gp_XYZ& Coord);


    gp_Vec(const Standard_Real Xv, const Standard_Real Yv, const Standard_Real Zv);




    gp_Vec(const gp_Pnt& P1, const gp_Pnt& P2);






    void SetCoord (const Standard_Integer Index, const Standard_Real Xi);



    void SetCoord (const Standard_Real Xv, const Standard_Real Yv, const Standard_Real Zv);


    void SetX (const Standard_Real X);


    void SetY (const Standard_Real Y);


    void SetZ (const Standard_Real Z);


    void SetXYZ (const gp_XYZ& Coord);







    Standard_Real Coord (const Standard_Integer Index) const;


    void Coord (Standard_Real& Xv, Standard_Real& Yv, Standard_Real& Zv) const;


    Standard_Real X() const;


    Standard_Real Y() const;


    Standard_Real Z() const;



    const gp_XYZ& XYZ() const;





  Standard_Boolean IsEqual (const gp_Vec& Other, const Standard_Real LinearTolerance, const Standard_Real AngularTolerance) const;





    Standard_Boolean IsNormal (const gp_Vec& Other, const Standard_Real AngularTolerance) const;





    Standard_Boolean IsOpposite (const gp_Vec& Other, const Standard_Real AngularTolerance) const;
# 136 "/usr/include/opencascade/gp_Vec.hxx"
    Standard_Boolean IsParallel (const gp_Vec& Other, const Standard_Real AngularTolerance) const;







    Standard_Real Angle (const gp_Vec& Other) const;
# 160 "/usr/include/opencascade/gp_Vec.hxx"
    Standard_Real AngleWithRef (const gp_Vec& Other, const gp_Vec& VRef) const;


    Standard_Real Magnitude() const;


    Standard_Real SquareMagnitude() const;


    void Add (const gp_Vec& Other);
  void operator += (const gp_Vec& Other)
{
  Add(Other);
}


  [[nodiscard]] gp_Vec Added (const gp_Vec& Other) const;
  [[nodiscard]] gp_Vec operator + (const gp_Vec& Other) const
{
  return Added(Other);
}


    void Subtract (const gp_Vec& Right);
  void operator -= (const gp_Vec& Right)
{
  Subtract(Right);
}


  [[nodiscard]] gp_Vec Subtracted (const gp_Vec& Right) const;
  [[nodiscard]] gp_Vec operator - (const gp_Vec& Right) const
{
  return Subtracted(Right);
}


    void Multiply (const Standard_Real Scalar);
  void operator *= (const Standard_Real Scalar)
{
  Multiply(Scalar);
}


  [[nodiscard]] gp_Vec Multiplied (const Standard_Real Scalar) const;
  [[nodiscard]] gp_Vec operator * (const Standard_Real Scalar) const
{
  return Multiplied(Scalar);
}


    void Divide (const Standard_Real Scalar);
  void operator /= (const Standard_Real Scalar)
{
  Divide(Scalar);
}


  [[nodiscard]] gp_Vec Divided (const Standard_Real Scalar) const;
  [[nodiscard]] gp_Vec operator / (const Standard_Real Scalar) const
{
  return Divided(Scalar);
}


    void Cross (const gp_Vec& Right);
  void operator ^= (const gp_Vec& Right)
{
  Cross(Right);
}


  [[nodiscard]] gp_Vec Crossed (const gp_Vec& Right) const;
  [[nodiscard]] gp_Vec operator ^ (const gp_Vec& Right) const
{
  return Crossed(Right);
}





    Standard_Real CrossMagnitude (const gp_Vec& Right) const;





    Standard_Real CrossSquareMagnitude (const gp_Vec& Right) const;



    void CrossCross (const gp_Vec& V1, const gp_Vec& V2);



    [[nodiscard]] gp_Vec CrossCrossed (const gp_Vec& V1, const gp_Vec& V2) const;


    Standard_Real Dot (const gp_Vec& Other) const;
  Standard_Real operator * (const gp_Vec& Other) const
{
  return Dot(Other);
}


    Standard_Real DotCross (const gp_Vec& V1, const gp_Vec& V2) const;




    void Normalize();




    [[nodiscard]] gp_Vec Normalized() const;


    void Reverse();


    [[nodiscard]] gp_Vec Reversed() const;
  [[nodiscard]] gp_Vec operator -() const
{
  return Reversed();
}




    void SetLinearForm (const Standard_Real A1, const gp_Vec& V1, const Standard_Real A2, const gp_Vec& V2, const Standard_Real A3, const gp_Vec& V3, const gp_Vec& V4);




    void SetLinearForm (const Standard_Real A1, const gp_Vec& V1, const Standard_Real A2, const gp_Vec& V2, const Standard_Real A3, const gp_Vec& V3);




    void SetLinearForm (const Standard_Real A1, const gp_Vec& V1, const Standard_Real A2, const gp_Vec& V2, const gp_Vec& V3);




    void SetLinearForm (const Standard_Real A1, const gp_Vec& V1, const Standard_Real A2, const gp_Vec& V2);



    void SetLinearForm (const Standard_Real A1, const gp_Vec& V1, const gp_Vec& V2);



    void SetLinearForm (const gp_Vec& V1, const gp_Vec& V2);

  void Mirror (const gp_Vec& V);





  [[nodiscard]] gp_Vec Mirrored (const gp_Vec& V) const;

  void Mirror (const gp_Ax1& A1);





  [[nodiscard]] gp_Vec Mirrored (const gp_Ax1& A1) const;

  void Mirror (const gp_Ax2& A2);





  [[nodiscard]] gp_Vec Mirrored (const gp_Ax2& A2) const;

    void Rotate (const gp_Ax1& A1, const Standard_Real Ang);




    [[nodiscard]] gp_Vec Rotated (const gp_Ax1& A1, const Standard_Real Ang) const;

    void Scale (const Standard_Real S);


    [[nodiscard]] gp_Vec Scaled (const Standard_Real S) const;


  void Transform (const gp_Trsf& T);


  [[nodiscard]] gp_Vec Transformed (const gp_Trsf& T) const;


  void DumpJson (Standard_OStream& theOStream, Standard_Integer theDepth = -1) const;




protected:





private:



  gp_XYZ coord;


};


# 1 "/usr/include/opencascade/gp_Vec.lxx" 1
# 19 "/usr/include/opencascade/gp_Vec.lxx"
# 1 "/usr/include/opencascade/gp_Dir.hxx" 1
# 26 "/usr/include/opencascade/gp_Dir.hxx"
class Standard_ConstructionError;
class Standard_DomainError;
class Standard_OutOfRange;
class gp_Vec;
class gp_XYZ;
class gp_Ax1;
class gp_Ax2;
class gp_Trsf;
# 44 "/usr/include/opencascade/gp_Dir.hxx"
class gp_Dir
{
public:

  void* operator new (size_t theSize) { return Standard::Allocate (theSize); } void operator delete (void* theAddress) { Standard::Free (theAddress); } void* operator new[] (size_t theSize) { return Standard::Allocate (theSize); } void operator delete[] (void* theAddress) { Standard::Free (theAddress); } void* operator new (size_t, void* theAddress) { return theAddress; } void operator delete (void*, void*) { }



    gp_Dir();


    gp_Dir(const gp_Vec& V);


    gp_Dir(const gp_XYZ& Coord);







    gp_Dir(const Standard_Real Xv, const Standard_Real Yv, const Standard_Real Zv);
# 85 "/usr/include/opencascade/gp_Dir.hxx"
    void SetCoord (const Standard_Integer Index, const Standard_Real Xi);




    void SetCoord (const Standard_Real Xv, const Standard_Real Yv, const Standard_Real Zv);


    void SetX (const Standard_Real X);


    void SetY (const Standard_Real Y);


    void SetZ (const Standard_Real Z);


    void SetXYZ (const gp_XYZ& Coord);
# 111 "/usr/include/opencascade/gp_Dir.hxx"
    Standard_Real Coord (const Standard_Integer Index) const;


    void Coord (Standard_Real& Xv, Standard_Real& Yv, Standard_Real& Zv) const;


    Standard_Real X() const;


    Standard_Real Y() const;


    Standard_Real Z() const;


    const gp_XYZ& XYZ() const;




    Standard_Boolean IsEqual (const gp_Dir& Other, const Standard_Real AngularTolerance) const;



    Standard_Boolean IsNormal (const gp_Dir& Other, const Standard_Real AngularTolerance) const;



    Standard_Boolean IsOpposite (const gp_Dir& Other, const Standard_Real AngularTolerance) const;





    Standard_Boolean IsParallel (const gp_Dir& Other, const Standard_Real AngularTolerance) const;





  Standard_Real Angle (const gp_Dir& Other) const;
# 162 "/usr/include/opencascade/gp_Dir.hxx"
  Standard_Real AngleWithRef (const gp_Dir& Other, const gp_Dir& VRef) const;





    void Cross (const gp_Dir& Right);
  void operator ^= (const gp_Dir& Right)
{
  Cross(Right);
}






  [[nodiscard]] gp_Dir Crossed (const gp_Dir& Right) const;
  [[nodiscard]] gp_Dir operator ^ (const gp_Dir& Right) const
{
  return Crossed(Right);
}

    void CrossCross (const gp_Dir& V1, const gp_Dir& V2);
# 195 "/usr/include/opencascade/gp_Dir.hxx"
    [[nodiscard]] gp_Dir CrossCrossed (const gp_Dir& V1, const gp_Dir& V2) const;


    Standard_Real Dot (const gp_Dir& Other) const;
  Standard_Real operator * (const gp_Dir& Other) const
{
  return Dot(Other);
}







    Standard_Real DotCross (const gp_Dir& V1, const gp_Dir& V2) const;

    void Reverse();






    [[nodiscard]] gp_Dir Reversed() const;
  [[nodiscard]] gp_Dir operator -() const
{
  return Reversed();
}

  void Mirror (const gp_Dir& V);





  [[nodiscard]] gp_Dir Mirrored (const gp_Dir& V) const;

  void Mirror (const gp_Ax1& A1);





  [[nodiscard]] gp_Dir Mirrored (const gp_Ax1& A1) const;

  void Mirror (const gp_Ax2& A2);





  [[nodiscard]] gp_Dir Mirrored (const gp_Ax2& A2) const;

    void Rotate (const gp_Ax1& A1, const Standard_Real Ang);




    [[nodiscard]] gp_Dir Rotated (const gp_Ax1& A1, const Standard_Real Ang) const;

  void Transform (const gp_Trsf& T);






  [[nodiscard]] gp_Dir Transformed (const gp_Trsf& T) const;



  void DumpJson (Standard_OStream& theOStream, Standard_Integer theDepth = -1) const;


  Standard_Boolean InitFromJson (const Standard_SStream& theSStream, Standard_Integer& theStreamPos);


protected:





private:



  gp_XYZ coord;


};


# 1 "/usr/include/opencascade/gp_Dir.lxx" 1
# 15 "/usr/include/opencascade/gp_Dir.lxx"
# 1 "/usr/include/opencascade/gp_Vec.hxx" 1
# 16 "/usr/include/opencascade/gp_Dir.lxx" 2




inline gp_Dir::gp_Dir () : coord(1.,0.,0.)
{
}

inline gp_Dir::gp_Dir (const gp_Vec& V)
{
  const gp_XYZ& XYZ = V.XYZ();
  Standard_Real X = XYZ.X();
  Standard_Real Y = XYZ.Y();
  Standard_Real Z = XYZ.Z();
  Standard_Real D = sqrt(X * X + Y * Y + Z * Z);
  if (D <= gp::Resolution()) throw Standard_ConstructionError("gp_Dir() - input vector has zero norm");;
  coord.SetX(X / D);
  coord.SetY(Y / D);
  coord.SetZ(Z / D);
}

inline gp_Dir::gp_Dir (const gp_XYZ& XYZ)
{
  Standard_Real X = XYZ.X();
  Standard_Real Y = XYZ.Y();
  Standard_Real Z = XYZ.Z();
  Standard_Real D = sqrt(X * X + Y * Y + Z * Z);
  if (D <= gp::Resolution()) throw Standard_ConstructionError("gp_Dir() - input vector has zero norm");;
  coord.SetX(X / D);
  coord.SetY(Y / D);
  coord.SetZ(Z / D);
}

inline gp_Dir::gp_Dir (const Standard_Real Xv,
         const Standard_Real Yv,
         const Standard_Real Zv)
{
  Standard_Real D = sqrt (Xv * Xv + Yv * Yv + Zv * Zv);
  if (D <= gp::Resolution()) throw Standard_ConstructionError("gp_Dir() - input vector has zero norm");;
  coord.SetX(Xv / D);
  coord.SetY(Yv / D);
  coord.SetZ(Zv / D);
}

inline void gp_Dir::SetCoord (const Standard_Integer Index,
         const Standard_Real Xi)
{
  Standard_Real X = coord.X();
  Standard_Real Y = coord.Y();
  Standard_Real Z = coord.Z();
 
# 66 "/usr/include/opencascade/gp_Dir.lxx"
#pragma GCC diagnostic push
# 66 "/usr/include/opencascade/gp_Dir.lxx"
 
# 66 "/usr/include/opencascade/gp_Dir.lxx"
#pragma GCC diagnostic ignored "-Wstrict-overflow"
# 66 "/usr/include/opencascade/gp_Dir.lxx"
  if (Index < 1 || Index > 3) throw Standard_OutOfRange("gp_Dir::SetCoord() - index is out of range [1, 3]");
# 66 "/usr/include/opencascade/gp_Dir.lxx"
#pragma GCC diagnostic pop
# 66 "/usr/include/opencascade/gp_Dir.lxx"
  ;
  if (Index == 1) X = Xi;
  else if (Index == 2) Y = Xi;
  else Z = Xi;
  Standard_Real D = sqrt (X * X + Y * Y + Z * Z);
  if (D <= gp::Resolution()) throw Standard_ConstructionError("gp_Dir::SetCoord() - result vector has zero norm");;
  coord.SetX(X / D);
  coord.SetY(Y / D);
  coord.SetZ(Z / D);
}

inline void gp_Dir::SetCoord (const Standard_Real Xv,
         const Standard_Real Yv,
         const Standard_Real Zv) {
  Standard_Real D = sqrt(Xv * Xv + Yv * Yv + Zv * Zv);
  if (D <= gp::Resolution()) throw Standard_ConstructionError("gp_Dir::SetCoord() - input vector has zero norm");;
  coord.SetX(Xv / D);
  coord.SetY(Yv / D);
  coord.SetZ(Zv / D);
}

inline void gp_Dir::SetX (const Standard_Real X)
{
  Standard_Real Y = coord.Y();
  Standard_Real Z = coord.Z();
  Standard_Real D = sqrt (X * X + Y * Y + Z * Z);
  if (D <= gp::Resolution()) throw Standard_ConstructionError("gp_Dir::SetX() - result vector has zero norm");;
  coord.SetX(X / D);
  coord.SetY(Y / D);
  coord.SetZ(Z / D);
}

inline void gp_Dir::SetY (const Standard_Real Y)
{
  Standard_Real Z = coord.Z();
  Standard_Real X = coord.X();
  Standard_Real D = sqrt (X * X + Y * Y + Z * Z);
  if (D <= gp::Resolution()) throw Standard_ConstructionError("gp_Dir::SetY() - result vector has zero norm");;
  coord.SetX(X / D);
  coord.SetY(Y / D);
  coord.SetZ(Z / D);
}

inline void gp_Dir::SetZ (const Standard_Real Z)
{
  Standard_Real X = coord.X();
  Standard_Real Y = coord.Y();
  Standard_Real D = sqrt (X * X + Y * Y + Z * Z);
  if (D <= gp::Resolution()) throw Standard_ConstructionError("gp_Dir::SetZ() - result vector has zero norm");;
  coord.SetX(X / D);
  coord.SetY(Y / D);
  coord.SetZ(Z / D);
}

inline void gp_Dir::SetXYZ (const gp_XYZ& XYZ)
{
  Standard_Real X = XYZ.X();
  Standard_Real Y = XYZ.Y();
  Standard_Real Z = XYZ.Z();
  Standard_Real D = sqrt(X * X + Y * Y + Z * Z);
  if (D <= gp::Resolution()) throw Standard_ConstructionError("gp_Dir::SetX() - input vector has zero norm");;
  coord.SetX(X / D);
  coord.SetY(Y / D);
  coord.SetZ(Z / D);
}

inline Standard_Real gp_Dir::Coord (const Standard_Integer Index) const
{ return coord.Coord (Index);}

inline void gp_Dir::Coord (Standard_Real& Xv,
       Standard_Real& Yv,
       Standard_Real& Zv) const
{ coord.Coord (Xv, Yv, Zv); }

inline Standard_Real gp_Dir::X() const
{ return coord.X() ; }

inline Standard_Real gp_Dir::Y() const
{ return coord.Y() ; }

inline Standard_Real gp_Dir::Z() const
{ return coord.Z() ; }

inline const gp_XYZ& gp_Dir::XYZ () const
{ return coord; }

inline Standard_Boolean gp_Dir::IsEqual
(const gp_Dir& Other,
 const Standard_Real AngularTolerance) const
{ return Angle (Other) <= AngularTolerance; }

inline Standard_Boolean gp_Dir::IsNormal
(const gp_Dir& Other,
 const Standard_Real AngularTolerance) const
{
  Standard_Real Ang = 
# 161 "/usr/include/opencascade/gp_Dir.lxx" 3 4
                     3.14159265358979323846 
# 161 "/usr/include/opencascade/gp_Dir.lxx"
                          / 2.0 - Angle (Other);
  if (Ang < 0) Ang = - Ang;
  return Ang <= AngularTolerance;
}

inline Standard_Boolean gp_Dir::IsOpposite
(const gp_Dir& Other,
 const Standard_Real AngularTolerance) const
{ return 
# 169 "/usr/include/opencascade/gp_Dir.lxx" 3 4
        3.14159265358979323846 
# 169 "/usr/include/opencascade/gp_Dir.lxx"
             - Angle (Other) <= AngularTolerance; }

inline Standard_Boolean gp_Dir::IsParallel
(const gp_Dir& Other,
 const Standard_Real AngularTolerance) const
{
  Standard_Real Ang = Angle (Other);
  return Ang <= AngularTolerance || 
# 176 "/usr/include/opencascade/gp_Dir.lxx" 3 4
                                   3.14159265358979323846 
# 176 "/usr/include/opencascade/gp_Dir.lxx"
                                        - Ang <= AngularTolerance;
}

inline void gp_Dir::Cross (const gp_Dir& Right)
{
  coord.Cross (Right.coord);
  Standard_Real D = coord.Modulus ();
  if (D <= gp::Resolution()) throw Standard_ConstructionError("gp_Dir::Cross() - result vector has zero norm");;
  coord.Divide (D);
}

inline gp_Dir gp_Dir::Crossed (const gp_Dir& Right) const
{
  gp_Dir V = *this;
  V.coord.Cross (Right.coord);
  Standard_Real D = V.coord.Modulus();
  if (D <= gp::Resolution()) throw Standard_ConstructionError("gp_Dir::Crossed() - result vector has zero norm");;
  V.coord.Divide (D);
  return V;
}

inline void gp_Dir::CrossCross (const gp_Dir& V1,
    const gp_Dir& V2)
{
  coord.CrossCross (V1.coord, V2.coord);
  Standard_Real D = coord.Modulus();
  if (D <= gp::Resolution()) throw Standard_ConstructionError("gp_Dir::CrossCross() - result vector has zero norm");;
  coord.Divide(D);
}

inline gp_Dir gp_Dir::CrossCrossed (const gp_Dir& V1,
        const gp_Dir& V2) const
{
  gp_Dir V = *this;
  (V.coord).CrossCross (V1.coord, V2.coord);
  Standard_Real D = V.coord.Modulus();
  if (D <= gp::Resolution()) throw Standard_ConstructionError("gp_Dir::CrossCrossed() - result vector has zero norm");;
  V.coord.Divide(D);
  return V;
}

inline Standard_Real gp_Dir::Dot (const gp_Dir& Other) const
{ return coord.Dot (Other.coord); }

inline Standard_Real gp_Dir::DotCross (const gp_Dir& V1,
           const gp_Dir& V2) const
{ return coord.Dot (V1.coord.Crossed (V2.coord)); }

inline void gp_Dir::Reverse ()
{ coord.Reverse(); }

inline gp_Dir gp_Dir::Reversed () const {
  gp_Dir V = *this;
  V.coord.Reverse ();
  return V;
}

inline void gp_Dir::Rotate (const gp_Ax1& A1, const Standard_Real Ang)
{
  gp_Trsf T;
  T.SetRotation (A1, Ang);
  coord.Multiply (T.HVectorialPart ());
}

inline gp_Dir gp_Dir::Rotated (const gp_Ax1& A1,
          const Standard_Real Ang) const
{
  gp_Dir V = *this;
  V.Rotate (A1, Ang);
  return V;
}

inline gp_Dir gp_Dir::Transformed (const gp_Trsf& T) const
{
  gp_Dir V = *this;
  V.Transform (T);
  return V;
}
# 290 "/usr/include/opencascade/gp_Dir.hxx" 2
# 20 "/usr/include/opencascade/gp_Vec.lxx" 2
# 1 "/usr/include/opencascade/gp_Pnt.hxx" 1
# 21 "/usr/include/opencascade/gp_Vec.lxx" 2

# 1 "/usr/include/opencascade/gp_VectorWithNullMagnitude.hxx" 1
# 25 "/usr/include/opencascade/gp_VectorWithNullMagnitude.hxx"
class gp_VectorWithNullMagnitude;
class gp_VectorWithNullMagnitude; typedef opencascade::handle<gp_VectorWithNullMagnitude> Handle_gp_VectorWithNullMagnitude;
# 35 "/usr/include/opencascade/gp_VectorWithNullMagnitude.hxx"
class gp_VectorWithNullMagnitude : public Standard_DomainError { void Throw () const override { throw *this; } public: gp_VectorWithNullMagnitude() : Standard_DomainError() {} gp_VectorWithNullMagnitude(const Standard_CString theMessage) : Standard_DomainError(theMessage) {} static void Raise(const Standard_CString theMessage = "") { opencascade::handle<gp_VectorWithNullMagnitude> _E = new gp_VectorWithNullMagnitude; _E->Reraise(theMessage); } static void Raise(Standard_SStream& theMessage) { opencascade::handle<gp_VectorWithNullMagnitude> _E = new gp_VectorWithNullMagnitude; _E->Reraise (theMessage); } static opencascade::handle<gp_VectorWithNullMagnitude> NewInstance(const Standard_CString theMessage = "") { return new gp_VectorWithNullMagnitude(theMessage); } public: typedef Standard_DomainError base_type; static const char* get_type_name () { return "gp_VectorWithNullMagnitude"; using direct_base_classes = opencascade::direct_base_class_as_tuple<std::tr2::direct_bases<gp_VectorWithNullMagnitude>::type>::type; static_assert(opencascade::has_type<Standard_DomainError, direct_base_classes>::type::value, "OCCT RTTI definition is incorrect: " "Standard_DomainError" " is not direct base class of " "gp_VectorWithNullMagnitude"); static_assert(&get_type_name == &gp_VectorWithNullMagnitude::get_type_name, "OCCT RTTI definition is misplaced: current class is not " "gp_VectorWithNullMagnitude"); } static const opencascade::handle<Standard_Type>& get_type_descriptor () { return Standard_Type::Instance<gp_VectorWithNullMagnitude>(); } virtual const opencascade::handle<Standard_Type>& DynamicType() const override { return get_type_descriptor (); } };
# 23 "/usr/include/opencascade/gp_Vec.lxx" 2


inline gp_Vec::gp_Vec() { }

inline gp_Vec::gp_Vec (const gp_Dir& V) { coord = V.XYZ(); }

inline gp_Vec::gp_Vec (const gp_XYZ& Coord) : coord(Coord) { }

inline gp_Vec::gp_Vec (const Standard_Real Xv,
         const Standard_Real Yv,
         const Standard_Real Zv)
               : coord (Xv, Yv, Zv) { }

inline gp_Vec::gp_Vec (const gp_Pnt& P1,
         const gp_Pnt& P2)
{ coord = P2.XYZ().Subtracted(P1.XYZ()); }

inline void gp_Vec::SetCoord (const Standard_Integer Index,
         const Standard_Real Xi)
{ coord.SetCoord (Index, Xi); }

inline void gp_Vec::SetCoord (const Standard_Real Xv,
         const Standard_Real Yv,
         const Standard_Real Zv)
{
  coord.SetX(Xv);
  coord.SetY(Yv);
  coord.SetZ(Zv);
}

inline void gp_Vec::SetX (const Standard_Real X)
{ coord.SetX (X); }

inline void gp_Vec::SetY (const Standard_Real Y)
{ coord.SetY (Y); }

inline void gp_Vec::SetZ (const Standard_Real Z)
{ coord.SetZ (Z); }

inline void gp_Vec::SetXYZ (const gp_XYZ& Coord)
{ coord = Coord; }

inline Standard_Real gp_Vec::Coord (const Standard_Integer Index) const
{ return coord.Coord (Index); }

inline void gp_Vec::Coord(Standard_Real& Xv,
     Standard_Real& Yv,
     Standard_Real& Zv) const
{
  Xv = coord.X();
  Yv = coord.Y();
  Zv = coord.Z();
}

inline Standard_Real gp_Vec::X() const
{ return coord.X(); }

inline Standard_Real gp_Vec::Y() const
{ return coord.Y(); }

inline Standard_Real gp_Vec::Z() const
{ return coord.Z(); }

inline const gp_XYZ& gp_Vec::XYZ () const
{ return coord; }

inline Standard_Boolean gp_Vec::IsNormal
(const gp_Vec& Other,
 const Standard_Real AngularTolerance) const
{
  Standard_Real Ang = 
# 93 "/usr/include/opencascade/gp_Vec.lxx" 3 4
                     3.14159265358979323846 
# 93 "/usr/include/opencascade/gp_Vec.lxx"
                          / 2.0 - Angle(Other);
  if (Ang < 0) Ang = - Ang;
  return Ang <= AngularTolerance;
}

inline Standard_Boolean gp_Vec::IsOpposite
(const gp_Vec& Other,
 const Standard_Real AngularTolerance) const
{
  Standard_Real Ang = 
# 102 "/usr/include/opencascade/gp_Vec.lxx" 3 4
                     3.14159265358979323846 
# 102 "/usr/include/opencascade/gp_Vec.lxx"
                          - Angle(Other);
  return Ang <= AngularTolerance;
}

inline Standard_Boolean gp_Vec::IsParallel
(const gp_Vec& Other,
 const Standard_Real AngularTolerance) const
{
  Standard_Real Ang = Angle (Other);
  return Ang <= AngularTolerance || 
# 111 "/usr/include/opencascade/gp_Vec.lxx" 3 4
                                     3.14159265358979323846 
# 111 "/usr/include/opencascade/gp_Vec.lxx"
                                          - Ang <= AngularTolerance;
}

inline Standard_Real gp_Vec::Angle (const gp_Vec& Other) const
{
# 124 "/usr/include/opencascade/gp_Vec.lxx"
  if (coord.Modulus() <= gp::Resolution() || Other.coord.Modulus() <= gp::Resolution()) throw gp_VectorWithNullMagnitude(" ");

                                                    ;
  return (gp_Dir(coord)).Angle(Other);
}

inline Standard_Real gp_Vec::AngleWithRef (const gp_Vec& Other,
        const gp_Vec& Vref) const
{
  if (coord.Modulus() <= gp::Resolution() || Vref.coord.Modulus () <= gp::Resolution() || Other.coord.Modulus() <= gp::Resolution()) throw gp_VectorWithNullMagnitude(" ");


                                                    ;
  return (gp_Dir(coord)).AngleWithRef(Other,Vref);
}

inline Standard_Real gp_Vec::Magnitude() const
{ return coord.Modulus(); }

inline Standard_Real gp_Vec::SquareMagnitude() const
{ return coord.SquareModulus(); }

inline void gp_Vec::Add (const gp_Vec& Other)
{ coord.Add (Other.coord); }

inline gp_Vec gp_Vec::Added (const gp_Vec& Other) const
{
  gp_Vec V = *this;
  V.coord.Add (Other.coord);
  return V;
}

inline void gp_Vec::Subtract (const gp_Vec& Right)
{ coord.Subtract (Right.coord); }

inline gp_Vec gp_Vec::Subtracted (const gp_Vec& Right) const
{
  gp_Vec V = *this;
   V.coord.Subtract(Right.coord);
   return V;
}

inline void gp_Vec::Multiply (const Standard_Real Scalar)
{ coord.Multiply(Scalar); }

inline gp_Vec gp_Vec::Multiplied (const Standard_Real Scalar) const
{
  gp_Vec V = *this;
  V.coord.Multiply (Scalar);
  return V;
}

inline void gp_Vec::Divide (const Standard_Real Scalar)
{ coord.Divide (Scalar); }

inline gp_Vec gp_Vec::Divided (const Standard_Real Scalar) const
{
  gp_Vec V = *this;
  V.coord.Divide (Scalar);
  return V;
}

inline void gp_Vec::Cross (const gp_Vec& Right)
{ coord.Cross (Right.coord); }

inline gp_Vec gp_Vec::Crossed (const gp_Vec& Right) const
{
  gp_Vec V = *this;
  V.coord.Cross (Right.coord);
  return V;
}

inline Standard_Real gp_Vec::CrossMagnitude
(const gp_Vec& Right) const
{ return coord.CrossMagnitude (Right.coord); }

inline Standard_Real gp_Vec::CrossSquareMagnitude
(const gp_Vec& Right) const
{ return coord.CrossSquareMagnitude (Right.coord); }

inline void gp_Vec::CrossCross (const gp_Vec& V1,
    const gp_Vec& V2)
{ coord.CrossCross(V1.coord, V2.coord); }

inline gp_Vec gp_Vec::CrossCrossed (const gp_Vec& V1,
        const gp_Vec& V2) const
{
  gp_Vec V = *this;
  V.coord.CrossCross(V1.coord, V2.coord);
  return V;
}

inline Standard_Real gp_Vec::Dot (const gp_Vec& Other) const
{ return coord.Dot (Other.coord); }

inline Standard_Real gp_Vec::DotCross (const gp_Vec& V1,
           const gp_Vec& V2) const
{ return coord.DotCross (V1.coord, V2.coord); }

inline void gp_Vec::Normalize()
{
  Standard_Real D = coord.Modulus();
  if (D <= gp::Resolution()) throw Standard_ConstructionError("gp_Vec::Normalize() - vector has zero norm");
                                                                                    ;
  coord.Divide (D);
}

inline gp_Vec gp_Vec::Normalized() const
{
  Standard_Real D = coord.Modulus();
  if (D <= gp::Resolution()) throw Standard_ConstructionError("gp_Vec::Normalized() - vector has zero norm");
                                                                                     ;
  gp_Vec V = *this;
  V.coord.Divide (D);
  return V;
}

inline void gp_Vec::Reverse()
{ coord.Reverse(); }

inline gp_Vec gp_Vec::Reversed () const
{
  gp_Vec V = *this;
  V.coord.Reverse();
  return V;
}

inline void gp_Vec::SetLinearForm
(const Standard_Real L,
 const gp_Vec& Left,
 const Standard_Real R,
 const gp_Vec& Right)
{ coord.SetLinearForm (L, Left.coord, R, Right.coord); }

inline void gp_Vec::SetLinearForm
(const Standard_Real L,
 const gp_Vec& Left,
 const gp_Vec& Right)
{ coord.SetLinearForm (L, Left.coord, Right.coord); }

inline void gp_Vec::SetLinearForm
(const gp_Vec& Left,
 const gp_Vec& Right)
{ coord.SetLinearForm (Left.coord, Right.coord); }

inline void gp_Vec::SetLinearForm
(const Standard_Real A1, const gp_Vec& V1,
 const Standard_Real A2, const gp_Vec& V2,
 const Standard_Real A3, const gp_Vec& V3)
{ coord.SetLinearForm (A1, V1.coord, A2, V2.coord, A3, V3.coord); }

inline void gp_Vec::SetLinearForm
(const Standard_Real A1, const gp_Vec& V1,
 const Standard_Real A2, const gp_Vec& V2,
 const gp_Vec& V3)
{ coord.SetLinearForm (A1, V1.coord, A2, V2.coord, V3.coord); }

inline void gp_Vec::SetLinearForm
(const Standard_Real A1, const gp_Vec& V1,
 const Standard_Real A2, const gp_Vec& V2,
 const Standard_Real A3, const gp_Vec& V3,
 const gp_Vec& V4)
{ coord.SetLinearForm(A1,V1.coord,A2,V2.coord,A3,V3.coord,V4.coord); }

inline void gp_Vec::Rotate (const gp_Ax1& A1,
       const Standard_Real Ang)
{
  gp_Trsf T;
  T.SetRotation (A1, Ang);
  coord.Multiply (T.VectorialPart());
}

inline gp_Vec gp_Vec::Rotated (const gp_Ax1& A1,
          const Standard_Real Ang) const
{
  gp_Vec Vres = *this;
  Vres.Rotate (A1, Ang);
  return Vres;
}

inline void gp_Vec::Scale (const Standard_Real S)
{ coord.Multiply (S); }

inline gp_Vec gp_Vec::Scaled (const Standard_Real S) const
{
  gp_Vec V = *this;
  V.coord.Multiply(S);
  return V;
}

inline gp_Vec gp_Vec::Transformed (const gp_Trsf& T) const
{
  gp_Vec V = *this;
  V.Transform(T);
  return V;
}

inline gp_Vec operator* (const Standard_Real Scalar, const gp_Vec& V) {
 return V.Multiplied(Scalar);
}
# 381 "/usr/include/opencascade/gp_Vec.hxx" 2
# 22 "/usr/include/opencascade/gp_Trsf.lxx" 2


inline gp_Trsf::gp_Trsf () :
scale(1.0),
shape(gp_Identity),
matrix(1,0,0, 0,1,0, 0,0,1),
loc(0.0, 0.0, 0.0)
{}

inline void gp_Trsf::SetMirror (const gp_Pnt& P)
{
  shape = gp_PntMirror;
  scale = -1.0;
  loc = P.XYZ();
  matrix.SetIdentity ();
  loc.Multiply(2.0);
}

inline void gp_Trsf::SetTranslation (const gp_Vec& V)
{
  shape = gp_Translation;
  scale = 1.;
  matrix.SetIdentity ();
  loc = V.XYZ();
}

inline void gp_Trsf::SetTranslation(const gp_Pnt& P1,
        const gp_Pnt& P2)
{
  shape = gp_Translation;
  scale = 1.0;
  matrix.SetIdentity ();
  loc = (P2.XYZ()).Subtracted (P1.XYZ());
}

inline void gp_Trsf::SetForm(const gp_TrsfForm P)
{
  shape = P;
}

inline Standard_Boolean gp_Trsf::IsNegative() const
{ return (scale < 0.0); }

inline const gp_XYZ& gp_Trsf::TranslationPart () const
{ return loc; }

inline const gp_Mat& gp_Trsf::HVectorialPart () const
{ return matrix; }

inline Standard_Real gp_Trsf::Value (const Standard_Integer Row,
         const Standard_Integer Col) const
{
 
#pragma GCC diagnostic push
# 74 "/usr/include/opencascade/gp_Trsf.lxx"
 
#pragma GCC diagnostic ignored "-Wstrict-overflow"
# 74 "/usr/include/opencascade/gp_Trsf.lxx"
  if (Row < 1 || Row > 3 || Col < 1 || Col > 4) throw Standard_OutOfRange(" ");
#pragma GCC diagnostic pop
# 74 "/usr/include/opencascade/gp_Trsf.lxx"
 
                                                   ;
  if (Col < 4) return scale * matrix.Value (Row, Col);
  else return loc.Coord (Row);
}

inline gp_TrsfForm gp_Trsf::Form () const
{ return shape; }

inline Standard_Real gp_Trsf::ScaleFactor () const
{ return scale; }

inline gp_Trsf gp_Trsf::Inverted() const
{
  gp_Trsf T = *this;
  T.Invert();
  return T;
}

inline gp_Trsf gp_Trsf::Multiplied (const gp_Trsf& T) const
{
  gp_Trsf Tresult(*this);
  Tresult.Multiply(T);
  return Tresult;
}

inline gp_Trsf gp_Trsf::Powered (const Standard_Integer N) const
{
  gp_Trsf T = *this;
  T.Power (N);
  return T;
}

inline void gp_Trsf::Transforms (Standard_Real& X,
     Standard_Real& Y,
     Standard_Real& Z) const
{
  gp_XYZ Triplet (X, Y, Z);
  Triplet.Multiply (matrix);
  if (scale != 1.0) Triplet.Multiply (scale);
  Triplet.Add(loc);
  X = Triplet.X();
  Y = Triplet.Y();
  Z = Triplet.Z();
}

inline void gp_Trsf::Transforms (gp_XYZ& Coord) const
{
  Coord.Multiply (matrix);
  if (scale != 1.0) Coord.Multiply (scale);
  Coord.Add(loc);
}
# 378 "/usr/include/opencascade/gp_Trsf.hxx" 2
# 20 "/usr/include/opencascade/gp_Pnt.lxx" 2


inline gp_Pnt::gp_Pnt() { }

inline gp_Pnt::gp_Pnt (const gp_XYZ& Coordinates) : coord (Coordinates)
{ }

inline gp_Pnt::gp_Pnt (const Standard_Real Xp,
         const Standard_Real Yp,
         const Standard_Real Zp) : coord(Xp, Yp,Zp)
{ }

inline void gp_Pnt::SetCoord (const Standard_Integer Index,
         const Standard_Real Xi)
{ coord.SetCoord (Index, Xi); }

inline void gp_Pnt::SetCoord (const Standard_Real Xp,
         const Standard_Real Yp,
         const Standard_Real Zp) {
  coord.SetCoord (Xp, Yp, Zp);
}

inline void gp_Pnt::SetX (const Standard_Real X)
{ coord.SetX (X); }

inline void gp_Pnt::SetY (const Standard_Real Y)
{ coord.SetY (Y); }

inline void gp_Pnt::SetZ (const Standard_Real Z)
{ coord.SetZ (Z); }

inline void gp_Pnt::SetXYZ (const gp_XYZ& Coordinates)
{ coord = Coordinates; }

inline Standard_Real gp_Pnt::Coord (const Standard_Integer Index) const
{ return coord.Coord(Index); }

inline void gp_Pnt::Coord (Standard_Real& Xp,
      Standard_Real& Yp,
      Standard_Real& Zp) const {
        coord.Coord (Xp, Yp, Zp);
      }

inline Standard_Real gp_Pnt::X() const
{ return coord.X(); }

inline Standard_Real gp_Pnt::Y() const
{ return coord.Y(); }

inline Standard_Real gp_Pnt::Z() const
{ return coord.Z(); }

inline const gp_XYZ& gp_Pnt::XYZ () const
{ return coord; }

inline const gp_XYZ& gp_Pnt::Coord () const
{ return coord; }

inline gp_XYZ& gp_Pnt::ChangeCoord ()
{ return coord; }

inline void gp_Pnt::BaryCenter(const Standard_Real A,
          const gp_Pnt& P,
          const Standard_Real B)
{
  coord.SetLinearForm(A,coord,B,P.coord);
  coord.Divide(A + B);
}

inline Standard_Boolean gp_Pnt::IsEqual
(const gp_Pnt& Other,
 const Standard_Real LinearTolerance) const
{ return Distance (Other) <= LinearTolerance; }

inline Standard_Real gp_Pnt::Distance (const gp_Pnt& Other) const
{
  Standard_Real d=0,dd;
  const gp_XYZ& XYZ = Other.coord;
  dd = coord.X(); dd -= XYZ.X(); dd *= dd; d += dd;
  dd = coord.Y(); dd -= XYZ.Y(); dd *= dd; d += dd;
  dd = coord.Z(); dd -= XYZ.Z(); dd *= dd; d += dd;
  return(sqrt(d));
}

inline Standard_Real gp_Pnt::SquareDistance (const gp_Pnt& Other) const
{
  Standard_Real d=0,dd;
  const gp_XYZ& XYZ = Other.coord;
  dd = coord.X(); dd -= XYZ.X(); dd *= dd; d += dd;
  dd = coord.Y(); dd -= XYZ.Y(); dd *= dd; d += dd;
  dd = coord.Z(); dd -= XYZ.Z(); dd *= dd; d += dd;
  return(d);
}

inline void gp_Pnt::Rotate (const gp_Ax1& A1,
       const Standard_Real Ang)
{
  gp_Trsf T;
  T.SetRotation (A1, Ang);
  T.Transforms (coord);
}

inline gp_Pnt gp_Pnt::Rotated (const gp_Ax1& A1,
          const Standard_Real Ang) const
{
  gp_Pnt P = *this;
  P.Rotate (A1, Ang);
  return P;
}

inline void gp_Pnt::Scale (const gp_Pnt& P,
      const Standard_Real S)
{
  gp_XYZ XYZ = P.coord;
  XYZ.Multiply (1.0 - S);
  coord.Multiply (S);
  coord.Add (XYZ);
}

inline gp_Pnt gp_Pnt::Scaled (const gp_Pnt& P,
         const Standard_Real S) const
{
  gp_Pnt Pres = *this;
  Pres.Scale (P, S);
  return Pres;
}

inline gp_Pnt gp_Pnt::Transformed (const gp_Trsf& T) const
{
  gp_Pnt P = *this;
  P.Transform (T);
  return P;
}

inline void gp_Pnt::Translate (const gp_Vec& V)
{ coord.Add (V.XYZ()); }

inline gp_Pnt gp_Pnt::Translated (const gp_Vec& V) const
{
  gp_Pnt P = *this;
  P.coord.Add (V.XYZ());
  return P;
}

inline void gp_Pnt::Translate (const gp_Pnt& P1,
          const gp_Pnt& P2)
{
  coord.Add (P2.coord);
  coord.Subtract (P1.coord);
}

inline gp_Pnt gp_Pnt::Translated (const gp_Pnt& P1,
      const gp_Pnt& P2) const
{
  gp_Pnt P = *this;
  P.Translate (P1 , P2);
  return P;
}
# 200 "/usr/include/opencascade/gp_Pnt.hxx" 2
# 25 "/usr/include/opencascade/Bnd_Box.hxx" 2



class Standard_ConstructionError;
class gp_Pnt;
class gp_Dir;
class gp_Trsf;
class gp_Lin;
class gp_Pln;
# 62 "/usr/include/opencascade/Bnd_Box.hxx"
class Bnd_Box
{
public:

  void* operator new (size_t theSize) { return Standard::Allocate (theSize); } void operator delete (void* theAddress) { Standard::Free (theAddress); } void* operator new[] (size_t theSize) { return Standard::Allocate (theSize); } void operator delete[] (void* theAddress) { Standard::Free (theAddress); } void* operator new (size_t, void* theAddress) { return theAddress; } void operator delete (void*, void*) { }




  Bnd_Box();




  Bnd_Box (const gp_Pnt theMin, const gp_Pnt theMax);



  void SetWhole() { Flags = WholeMask; }


  void SetVoid()
  {
    Xmin = RealLast();
    Xmax = -RealLast();
    Ymin = RealLast();
    Ymax = -RealLast();
    Zmin = RealLast();
    Zmax = -RealLast();
    Flags = VoidMask;
    Gap = 0.0;
  }




  void Set (const gp_Pnt& P);






  void Set (const gp_Pnt& P, const gp_Dir& D);






  void Update (const Standard_Real aXmin, const Standard_Real aYmin, const Standard_Real aZmin, const Standard_Real aXmax, const Standard_Real aYmax, const Standard_Real aZmax);


  void Update (const Standard_Real X, const Standard_Real Y, const Standard_Real Z);


  Standard_Real GetGap() const;


  void SetGap (const Standard_Real Tol);







  void Enlarge (const Standard_Real Tol);






  void Get (Standard_Real& theXmin, Standard_Real& theYmin, Standard_Real& theZmin, Standard_Real& theXmax, Standard_Real& theYmax, Standard_Real& theZmax) const;






  gp_Pnt CornerMin() const;






  gp_Pnt CornerMax() const;



  void OpenXmin() { Flags |= XminMask; }



  void OpenXmax() { Flags |= XmaxMask; }



  void OpenYmin() { Flags |= YminMask; }



  void OpenYmax() { Flags |= YmaxMask; }



  void OpenZmin() { Flags |= ZminMask; }



  void OpenZmax() { Flags |= ZmaxMask; }


  Standard_Boolean IsOpen() const { return (Flags & WholeMask) != 0; }


  Standard_Boolean IsOpenXmin() const { return (Flags & XminMask) != 0; }


  Standard_Boolean IsOpenXmax() const { return (Flags & XmaxMask) != 0; }


  Standard_Boolean IsOpenYmin() const { return (Flags & YminMask) != 0; }


  Standard_Boolean IsOpenYmax() const { return (Flags & YmaxMask) != 0; }


  Standard_Boolean IsOpenZmin() const { return (Flags & ZminMask) != 0; }


  Standard_Boolean IsOpenZmax() const { return (Flags & ZmaxMask) != 0; }


  Standard_Boolean IsWhole() const { return (Flags & WholeMask) == WholeMask; }


  Standard_Boolean IsVoid() const { return (Flags & VoidMask) != 0; }


  Standard_Boolean IsXThin (const Standard_Real tol) const;


  Standard_Boolean IsYThin (const Standard_Real tol) const;


  Standard_Boolean IsZThin (const Standard_Real tol) const;



  Standard_Boolean IsThin (const Standard_Real tol) const;







  [[nodiscard]] Bnd_Box Transformed (const gp_Trsf& T) const;


  void Add (const Bnd_Box& Other);


  void Add (const gp_Pnt& P);


  void Add (const gp_Pnt& P, const gp_Dir& D);




  void Add (const gp_Dir& D);


  Standard_Boolean IsOut (const gp_Pnt& P) const;


  Standard_Boolean IsOut (const gp_Lin& L) const;


  Standard_Boolean IsOut (const gp_Pln& P) const;


  Standard_Boolean IsOut (const Bnd_Box& Other) const;



  Standard_Boolean IsOut (const Bnd_Box& Other, const gp_Trsf& T) const;



  Standard_Boolean IsOut (const gp_Trsf& T1, const Bnd_Box& Other, const gp_Trsf& T2) const;




  Standard_Boolean IsOut (const gp_Pnt& P1, const gp_Pnt& P2, const gp_Dir& D) const;


  Standard_Real Distance (const Bnd_Box& Other) const;

  void Dump() const;


  Standard_Real SquareExtent() const
  {
    if (IsVoid())
    {
      return 0.0;
    }

    const Standard_Real aDx = Xmax - Xmin + Gap + Gap;
    const Standard_Real aDy = Ymax - Ymin + Gap + Gap;
    const Standard_Real aDz = Zmax - Zmin + Gap + Gap;
    return aDx * aDx + aDy * aDy + aDz * aDz;
  }




  Bnd_Box FinitePart() const
  {
    if (!HasFinitePart())
    {
      return Bnd_Box();
    }

    Bnd_Box aBox;
    aBox.Update (Xmin, Ymin, Zmin, Xmax, Ymax, Zmax);
    aBox.SetGap (Gap);
    return aBox;
  }


  Standard_Boolean HasFinitePart() const
  {
    return !IsVoid()
         && Xmax >= Xmin;
  }


  void DumpJson (Standard_OStream& theOStream, Standard_Integer theDepth = -1) const;


  Standard_Boolean InitFromJson (const Standard_SStream& theSStream, Standard_Integer& theStreamPos);

protected:


  enum MaskFlags
  {
    VoidMask = 0x01,
    XminMask = 0x02,
    XmaxMask = 0x04,
    YminMask = 0x08,
    YmaxMask = 0x10,
    ZminMask = 0x20,
    ZmaxMask = 0x40,
    WholeMask = 0x7e
  };

private:

  Standard_Real Xmin;
  Standard_Real Xmax;
  Standard_Real Ymin;
  Standard_Real Ymax;
  Standard_Real Zmin;
  Standard_Real Zmax;
  Standard_Real Gap;
  Standard_Integer Flags;

};
# 25 "/usr/include/opencascade/BVH_Types.hxx" 2



# 1 "/usr/include/opencascade/NCollection_Vector.hxx" 1
# 19 "/usr/include/opencascade/NCollection_Vector.hxx"
# 1 "/usr/include/opencascade/NCollection_BaseVector.hxx" 1
# 24 "/usr/include/opencascade/NCollection_BaseVector.hxx"
# 1 "/usr/lib/gcc/x86_64-pc-linux-gnu/10.2.0/include/stddef.h" 1 3 4
# 25 "/usr/include/opencascade/NCollection_BaseVector.hxx" 2



inline Standard_Integer GetCapacity (const Standard_Integer theIncrement)
{
  return Max(theIncrement/8, 1);
}


class NCollection_BaseVector
{
public:

  void* operator new (size_t theSize) { return Standard::Allocate (theSize); } void operator delete (void* theAddress) { Standard::Free (theAddress); } void* operator new[] (size_t theSize) { return Standard::Allocate (theSize); } void operator delete[] (void* theAddress) { Standard::Free (theAddress); } void* operator new (size_t, void* theAddress) { return theAddress; } void operator delete (void*, void*) { }
  void* operator new (size_t theSize, const opencascade::handle<NCollection_BaseAllocator>& theAllocator) { return theAllocator->Allocate(theSize); } void operator delete (void* theAddress, const opencascade::handle<NCollection_BaseAllocator>& theAllocator) { theAllocator->Free(theAddress); }

protected:


  struct MemBlock
  {

  public:




    void* findV (const Standard_Integer theIndex,
                 const size_t theItemSize) const
    {
      return (char* )DataPtr + size_t(theIndex) * theItemSize;
    }

  public:

    void* DataPtr;
    Standard_Integer FirstIndex;
    Standard_Integer Length;
    Standard_Integer Size;

  };


  class Iterator
  {
  protected:
    Iterator()
    : myICurBlock (0),
      myIEndBlock (0),
      myCurIndex (0),
      myEndIndex (0) {}

    Iterator (const NCollection_BaseVector& theVector, Standard_Boolean theToEnd = false)
    {
      initV (theVector, theToEnd);
    }

    void initV (const NCollection_BaseVector& theVector, Standard_Boolean theToEnd = false);

    Standard_Boolean moreV() const
    {
      return (myICurBlock < myIEndBlock || myCurIndex < myEndIndex);
    }

    void nextV()
    {
      if (++myCurIndex >= myVector->myData[myICurBlock].Length
       && myICurBlock < myIEndBlock)
      {
        ++myICurBlock;
        myCurIndex = 0;
      }
    }

    void prevV()
    {
      if (--myCurIndex < 0 && myICurBlock > 0)
      {
        --myICurBlock;
        myCurIndex = myVector->myData[myICurBlock].Length - 1;
      }
    }

    void offsetV (Standard_Integer theOffset)
    {
      const Standard_Integer anIndex = myCurIndex + myICurBlock * myVector->myIncrement + theOffset;
      myICurBlock = anIndex / myVector->myIncrement;
      myCurIndex = anIndex % myVector->myIncrement;
      if (myICurBlock > myIEndBlock)
      {


        --myICurBlock;
        myCurIndex += myVector->myIncrement;
      }
    }

    Standard_Integer differV (const Iterator& theOther) const
    {
      return (myCurIndex - theOther.myCurIndex) + (myICurBlock - theOther.myICurBlock) * myVector->myIncrement;
    }

    const MemBlock* curBlockV() const
    {
      return &myVector->myData[myICurBlock];
    }

  protected:
    const NCollection_BaseVector* myVector;
    Standard_Integer myICurBlock;
    Standard_Integer myIEndBlock;
    Standard_Integer myCurIndex;
    Standard_Integer myEndIndex;
  };

protected:

  typedef void (*initMemBlocks_t) (NCollection_BaseVector& theVector,
                                   MemBlock& theBlock,
                                   const Standard_Integer theFirst,
                                   const Standard_Integer theSize);





  MemBlock* allocMemBlocks (const Standard_Integer theCapacity,
                                            MemBlock* theSource = 
# 152 "/usr/include/opencascade/NCollection_BaseVector.hxx" 3 4
                                                                                  __null
# 152 "/usr/include/opencascade/NCollection_BaseVector.hxx"
                                                                                      ,
                                            const Standard_Integer theSourceSize = 0);

protected:


  NCollection_BaseVector (const opencascade::handle<NCollection_BaseAllocator>& theAllocator,
                          initMemBlocks_t theInitBlocks,
                          const size_t theSize,
                          const Standard_Integer theInc)
  : myItemSize (theSize),
    myIncrement (theInc),
    myLength (0),
    myCapacity (GetCapacity (myIncrement)),
    myNBlocks (0),
    myInitBlocks (theInitBlocks)
  {
    myAllocator = (theAllocator.IsNull() ? NCollection_BaseAllocator::CommonBaseAllocator() : theAllocator);
    myData = allocMemBlocks (myCapacity);
  }


  NCollection_BaseVector (const opencascade::handle<NCollection_BaseAllocator>& theAllocator,
                          initMemBlocks_t theInitBlocks,
                          const NCollection_BaseVector& theOther)
  : myItemSize (theOther.myItemSize),
    myIncrement (theOther.myIncrement),
    myLength (theOther.myLength),
    myCapacity (GetCapacity(myIncrement) + theOther.myLength / theOther.myIncrement),
    myNBlocks (theOther.myLength == 0 ? 0 : 1 + (theOther.myLength - 1)/theOther.myIncrement),
    myInitBlocks (theInitBlocks)
  {
    myAllocator = (theAllocator.IsNull() ? NCollection_BaseAllocator::CommonBaseAllocator() : theAllocator);
    myData = allocMemBlocks (myCapacity);
  }


  virtual ~NCollection_BaseVector() {}


  void* expandV (const Standard_Integer theIndex);


  inline void* findV (const Standard_Integer theIndex) const
  {
   
#pragma GCC diagnostic push
# 197 "/usr/include/opencascade/NCollection_BaseVector.hxx"
   
#pragma GCC diagnostic ignored "-Wstrict-overflow"
# 197 "/usr/include/opencascade/NCollection_BaseVector.hxx"
    if (theIndex < 0 || theIndex >= myLength) throw Standard_OutOfRange("NCollection_BaseVector::findV");
#pragma GCC diagnostic pop
# 197 "/usr/include/opencascade/NCollection_BaseVector.hxx"
   
                                                                  ;
    const Standard_Integer aBlock = theIndex / myIncrement;
    return myData[aBlock].findV (theIndex - aBlock * myIncrement, myItemSize);
  }

public:


  void Clear();

  void SetIncrement(const Standard_Integer aIncrement) {
    if (aIncrement > 0) {
      if (!myIncrement) {
        myIncrement=aIncrement;
      }
    }
  }


  const opencascade::handle<NCollection_BaseAllocator>& Allocator() const
  {
    return myAllocator;
  }

protected:

  opencascade::handle<NCollection_BaseAllocator> myAllocator;
  size_t myItemSize;
  Standard_Integer myIncrement;
  Standard_Integer myLength;
  Standard_Integer myCapacity;
  Standard_Integer myNBlocks;
  MemBlock* myData;
  initMemBlocks_t myInitBlocks;

protected:

  friend class Iterator;
};
# 20 "/usr/include/opencascade/NCollection_Vector.hxx" 2
# 43 "/usr/include/opencascade/NCollection_Vector.hxx"
template <class TheItemType>
class NCollection_Vector : public NCollection_BaseVector
{
public:

  typedef TheItemType value_type;

public:


  class Iterator : public NCollection_BaseVector::Iterator
  {
  public:


    Iterator() {}


    Iterator (const NCollection_Vector& theVector, Standard_Boolean theToEnd = false)
    : NCollection_BaseVector::Iterator (theVector, theToEnd) {}


    void Init (const NCollection_Vector& theVector)
    {
      initV (theVector);
    }


    Standard_Boolean More() const
    {
      return moreV();
    }


    void Next()
    {
      nextV();
    }


    void Previous()
    {
      prevV();
    }


    void Offset (ptrdiff_t theOffset)
    {
      offsetV (static_cast<int>(theOffset));
    }
# 104 "/usr/include/opencascade/NCollection_Vector.hxx"
    ptrdiff_t Differ (const Iterator& theOther) const
    {
      return differV (theOther);
    }


    const TheItemType& Value() const
    {
      return ((const TheItemType* )curBlockV()->DataPtr)[myCurIndex];
    }


    TheItemType& ChangeValue() const
    {
      return ((TheItemType* )curBlockV()->DataPtr)[myCurIndex];
    }


    Standard_Boolean IsEqual (const Iterator& theOther) const
    {
      return myVector == theOther.myVector
          && myCurIndex == theOther.myCurIndex
          && myEndIndex == theOther.myEndIndex
          && myICurBlock == theOther.myICurBlock
          && myIEndBlock == theOther.myIEndBlock;
    }
  };


  typedef NCollection_StlIterator<std::random_access_iterator_tag, Iterator, TheItemType, false> iterator;


  typedef NCollection_StlIterator<std::random_access_iterator_tag, Iterator, TheItemType, true> const_iterator;


  iterator begin() const { return Iterator (*this, false); }


  iterator end() const { return Iterator (*this, true); }


  const_iterator cbegin() const { return Iterator (*this, false); }


  const_iterator cend() const { return Iterator (*this, true); }

public:


  explicit NCollection_Vector (const Standard_Integer theIncrement = 256,
                               const opencascade::handle<NCollection_BaseAllocator>& theAlloc = 
# 154 "/usr/include/opencascade/NCollection_Vector.hxx" 3 4
                                                                                  __null
# 154 "/usr/include/opencascade/NCollection_Vector.hxx"
                                                                                      ) :
    NCollection_BaseVector (theAlloc, initMemBlocks, sizeof(TheItemType), theIncrement)
  {}


  NCollection_Vector (const NCollection_Vector& theOther) :
    NCollection_BaseVector (theOther.myAllocator, initMemBlocks, theOther)
  {
    copyData (theOther);
  }


  virtual ~NCollection_Vector()
  {
    for (Standard_Integer anItemIter = 0; anItemIter < myCapacity; ++anItemIter)
    {
      initMemBlocks (*this, myData[anItemIter], 0, 0);
    }
    this->myAllocator->Free (myData);
  }


  Standard_Integer Length() const
  {
    return myLength;
  }


  Standard_Integer Size() const
  {
    return myLength;
  }



  Standard_Integer Lower() const
  {
    return 0;
  }



  Standard_Integer Upper() const
  {
    return myLength - 1;
  }


  Standard_Boolean IsEmpty() const
  {
    return (myLength == 0);
  }


  inline void Assign (const NCollection_Vector& theOther,
                      const Standard_Boolean theOwnAllocator = true);


  NCollection_Vector& operator= (const NCollection_Vector& theOther)
  {
    Assign (theOther, false);
    return *this;
  }


  TheItemType& Append (const TheItemType& theValue)
  {
    TheItemType& anAppended = *(TheItemType* )expandV (myLength);
    anAppended = theValue;
    return anAppended;
  }


  TheItemType& Appended ()
  {
    TheItemType& anAppended = *(TheItemType* )expandV (myLength);
    return anAppended;
  }


  const TheItemType& operator() (const Standard_Integer theIndex) const
  {
    return Value (theIndex);
  }


  const TheItemType& operator[] (Standard_Integer theIndex) const { return Value (theIndex); }

  const TheItemType& Value (const Standard_Integer theIndex) const
  {
    return *(const TheItemType* )findV (theIndex);
  }


  const TheItemType& First() const
  {
    return *(const TheItemType* )findV (Lower());
  }


  TheItemType& ChangeFirst()
  {
    return *(TheItemType* )findV (Lower());
  }


  const TheItemType& Last() const
  {
    return *(const TheItemType* )findV (Upper());
  }


  TheItemType& ChangeLast()
  {
    return *(TheItemType* )findV (Upper());
  }


  TheItemType& operator() (const Standard_Integer theIndex)
  {
    return ChangeValue (theIndex);
  }


  TheItemType& operator[] ( Standard_Integer theIndex) { return ChangeValue (theIndex); }

  TheItemType& ChangeValue (const Standard_Integer theIndex)
  {
    return *(TheItemType* )findV (theIndex);
  }


  TheItemType& SetValue (const Standard_Integer theIndex,
                         const TheItemType& theValue)
  {
   
# 289 "/usr/include/opencascade/NCollection_Vector.hxx"
#pragma GCC diagnostic push
# 289 "/usr/include/opencascade/NCollection_Vector.hxx"
   
# 289 "/usr/include/opencascade/NCollection_Vector.hxx"
#pragma GCC diagnostic ignored "-Wstrict-overflow"
# 289 "/usr/include/opencascade/NCollection_Vector.hxx"
    if (theIndex < 0) throw Standard_OutOfRange("NCollection_Vector::SetValue");
# 289 "/usr/include/opencascade/NCollection_Vector.hxx"
#pragma GCC diagnostic pop
# 289 "/usr/include/opencascade/NCollection_Vector.hxx"
    ;
    TheItemType* const aVecValue = (TheItemType* )(theIndex < myLength ? findV (theIndex) : expandV (theIndex));
    *aVecValue = theValue;
    return *aVecValue;
  }

private:

  void copyData (const NCollection_Vector& theOther)
  {
    Standard_Integer iBlock = 0;
                            Iterator anIter (theOther);
    for (Standard_Integer aLength = 0; aLength < myLength; aLength += myIncrement)
    {
      MemBlock& aBlock = myData[iBlock];
      initMemBlocks (*this, aBlock, aLength, myIncrement);
      Standard_Integer anItemIter = 0;
      for (; anItemIter < myIncrement; ++anItemIter)
      {
        if (!anIter.More())
        {
          break;
        }

        ((TheItemType* )aBlock.DataPtr)[anItemIter] = anIter.Value();
        anIter.Next();
      }
      aBlock.Length = anItemIter;
      iBlock++;
    }
  }


  static void initMemBlocks (NCollection_BaseVector& theVector,
                             NCollection_BaseVector::MemBlock& theBlock,
                             const Standard_Integer theFirst,
                             const Standard_Integer theSize)
  {
    NCollection_Vector& aSelf = static_cast<NCollection_Vector&> (theVector);
    opencascade::handle<NCollection_BaseAllocator>& anAllocator = aSelf.myAllocator;


    if (theBlock.DataPtr != 
# 331 "/usr/include/opencascade/NCollection_Vector.hxx" 3 4
                           __null
# 331 "/usr/include/opencascade/NCollection_Vector.hxx"
                               )
    {
      for (Standard_Integer anItemIter = 0; anItemIter < theBlock.Size; ++anItemIter)
      {
        ((TheItemType* )theBlock.DataPtr)[anItemIter].~TheItemType();
      }
      anAllocator->Free (theBlock.DataPtr);
      theBlock.DataPtr = 
# 338 "/usr/include/opencascade/NCollection_Vector.hxx" 3 4
                        __null
# 338 "/usr/include/opencascade/NCollection_Vector.hxx"
                            ;
    }


    if (theSize > 0)
    {
      theBlock.DataPtr = anAllocator->Allocate (theSize * sizeof(TheItemType));
      for (Standard_Integer anItemIter = 0; anItemIter < theSize; ++anItemIter)
      {
        new (&((TheItemType* )theBlock.DataPtr)[anItemIter]) TheItemType;
      }
    }
    theBlock.FirstIndex = theFirst;
    theBlock.Size = theSize;
    theBlock.Length = 0;
  }

  friend class Iterator;

};


template <class TheItemType> inline
void NCollection_Vector<TheItemType>::Assign (const NCollection_Vector& theOther,
                                              const Standard_Boolean theOwnAllocator)
{
  if (this == &theOther)
  {
    return;
  }


  for (Standard_Integer anItemIter = 0; anItemIter < myCapacity; ++anItemIter)
  {
    initMemBlocks (*this, myData[anItemIter], 0, 0);
  }
  this->myAllocator->Free (myData);


  if (!theOwnAllocator)
  {
    this->myAllocator = theOther.myAllocator;
  }
  myIncrement = theOther.myIncrement;
  myLength = theOther.myLength;
  myNBlocks = (myLength == 0) ? 0 : (1 + (myLength - 1)/myIncrement);
  myCapacity = GetCapacity (myIncrement) + myLength / myIncrement;
  myData = allocMemBlocks (myCapacity);


  copyData (theOther);
}
# 29 "/usr/include/opencascade/BVH_Types.hxx" 2
# 37 "/usr/include/opencascade/BVH_Types.hxx"
namespace BVH
{



  template<class T, int N> struct VectorType
  {

  };

  template<class T> struct VectorType<T, 1>
  {
    typedef T Type;
  };

  template<class T> struct VectorType<T, 2>
  {
    typedef NCollection_Vec2<T> Type;
  };

  template<class T> struct VectorType<T, 3>
  {
    typedef NCollection_Vec3<T> Type;
  };

  template<class T> Bnd_Box ToBndBox (const T& theMin, const T& theMax)
  {
    return Bnd_Box (gp_Pnt (theMin, 0., 0.), gp_Pnt (theMax, 0., 0.));
  }

  template<class T> Bnd_Box ToBndBox (const NCollection_Vec2<T>& theMin,
                                      const NCollection_Vec2<T>& theMax)
  {
    return Bnd_Box (gp_Pnt (theMin.x(), theMin.y(), 0.),
                    gp_Pnt (theMax.x(), theMax.y(), 0.));
  }

  template<class T> Bnd_Box ToBndBox (const NCollection_Vec3<T>& theMin,
                                      const NCollection_Vec3<T>& theMax)
  {
    return Bnd_Box (gp_Pnt (theMin.x(), theMin.y(), theMin.z()),
                    gp_Pnt (theMax.x(), theMax.y(), theMax.z()));
  }

  template<class T> Bnd_Box ToBndBox (const NCollection_Vec4<T>& theMin,
                                      const NCollection_Vec4<T>& theMax)
  {
    return Bnd_Box (gp_Pnt (theMin.x(), theMin.y(), theMin.z()),
                    gp_Pnt (theMax.x(), theMax.y(), theMax.z()));
  }

  template<class T> struct VectorType<T, 4>
  {
    typedef NCollection_Vec4<T> Type;
  };




  template<class T, int N> struct MatrixType
  {

  };

  template<class T> struct MatrixType<T, 4>
  {
    typedef NCollection_Mat4<T> Type;
  };




  template<class T, int N = 1> struct ArrayType
  {



    typedef std::vector<typename VectorType<T, N>::Type> Type;

  };
}


typedef BVH::VectorType<Standard_Integer, 2>::Type BVH_Vec2i;

typedef BVH::VectorType<Standard_Integer, 3>::Type BVH_Vec3i;

typedef BVH::VectorType<Standard_Integer, 4>::Type BVH_Vec4i;


typedef BVH::ArrayType<Standard_Integer, 2>::Type BVH_Array2i;

typedef BVH::ArrayType<Standard_Integer, 3>::Type BVH_Array3i;

typedef BVH::ArrayType<Standard_Integer, 4>::Type BVH_Array4i;


typedef BVH::VectorType<Standard_ShortReal, 2>::Type BVH_Vec2f;

typedef BVH::VectorType<Standard_ShortReal, 3>::Type BVH_Vec3f;

typedef BVH::VectorType<Standard_ShortReal, 4>::Type BVH_Vec4f;


typedef BVH::ArrayType<Standard_ShortReal, 2>::Type BVH_Array2f;

typedef BVH::ArrayType<Standard_ShortReal, 3>::Type BVH_Array3f;

typedef BVH::ArrayType<Standard_ShortReal, 4>::Type BVH_Array4f;


typedef BVH::VectorType<Standard_Real, 2>::Type BVH_Vec2d;

typedef BVH::VectorType<Standard_Real, 3>::Type BVH_Vec3d;

typedef BVH::VectorType<Standard_Real, 4>::Type BVH_Vec4d;


typedef BVH::ArrayType<Standard_Real, 2>::Type BVH_Array2d;

typedef BVH::ArrayType<Standard_Real, 3>::Type BVH_Array3d;

typedef BVH::ArrayType<Standard_Real, 4>::Type BVH_Array4d;


typedef BVH::MatrixType<Standard_ShortReal, 4>::Type BVH_Mat4f;


typedef BVH::MatrixType<Standard_Real, 4>::Type BVH_Mat4d;

namespace BVH
{



  template<class T, int N> struct VecComp
  {

  };

  template<class T> struct VecComp<T, 2>
  {
    typedef typename BVH::VectorType<T, 2>::Type BVH_Vec2t;

    static T Get (const BVH_Vec2t& theVec, const Standard_Integer theAxis)
    {
      return theAxis == 0 ? theVec.x() : theVec.y();
    }
  };

  template<class T> struct VecComp<T, 3>
  {
    typedef typename BVH::VectorType<T, 3>::Type BVH_Vec3t;

    static T Get (const BVH_Vec3t& theVec, const Standard_Integer theAxis)
    {
      return theAxis == 0 ? theVec.x() : ( theAxis == 1 ? theVec.y() : theVec.z() );
    }
  };

  template<class T> struct VecComp<T, 4>
  {
    typedef typename BVH::VectorType<T, 4>::Type BVH_Vec4t;

    static T Get (const BVH_Vec4t& theVec, const Standard_Integer theAxis)
    {
      return theAxis == 0 ? theVec.x() :
        (theAxis == 1 ? theVec.y() : ( theAxis == 2 ? theVec.z() : theVec.w() ));
    }
  };





  template<class T, int N = 1> struct Array
  {
    typedef typename BVH::ArrayType<T, N>::Type BVH_ArrayNt;


    static inline const typename BVH::VectorType<T, N>::Type& Value (
        const BVH_ArrayNt& theArray, const Standard_Integer theIndex)
    {

      return theArray[theIndex];



    }


    static inline typename BVH::VectorType<T, N>::Type& ChangeValue (
      BVH_ArrayNt& theArray, const Standard_Integer theIndex)
    {

      return theArray[theIndex];



    }


    static inline void Append (BVH_ArrayNt& theArray,
      const typename BVH::VectorType<T, N>::Type& theElement)
    {

      theArray.push_back (theElement);



    }


    static inline Standard_Integer Size (const BVH_ArrayNt& theArray)
    {

      return static_cast<Standard_Integer> (theArray.size());



    }


    static inline void Clear (BVH_ArrayNt& theArray)
    {

      theArray.clear();



    }




    static inline void Reserve (BVH_ArrayNt& theArray, const Standard_Integer theCount)
    {

      if (Size (theArray) == theCount)
      {
# 287 "/usr/include/opencascade/BVH_Types.hxx"
      }
      else
      {
        theArray.reserve (theCount);
      }



    }
  };

  template<class T>
  static inline Standard_Integer IntFloor (const T theValue)
  {
    const Standard_Integer aRes = static_cast<Standard_Integer> (theValue);

    return aRes - static_cast<Standard_Integer> (aRes > theValue);
  }
}
# 21 "/usr/include/opencascade/BVH_Box.hxx" 2




# 1 "/usr/include/c++/10.2.0/limits" 1 3
# 40 "/usr/include/c++/10.2.0/limits" 3
       
# 41 "/usr/include/c++/10.2.0/limits" 3
# 158 "/usr/include/c++/10.2.0/limits" 3

# 158 "/usr/include/c++/10.2.0/limits" 3
namespace std __attribute__ ((__visibility__ ("default")))
{







  enum float_round_style
  {
    round_indeterminate = -1,
    round_toward_zero = 0,
    round_to_nearest = 1,
    round_toward_infinity = 2,
    round_toward_neg_infinity = 3
  };







  enum float_denorm_style
  {

    denorm_indeterminate = -1,

    denorm_absent = 0,

    denorm_present = 1
  };
# 202 "/usr/include/c++/10.2.0/limits" 3
  struct __numeric_limits_base
  {


    static constexpr bool is_specialized = false;




    static constexpr int digits = 0;


    static constexpr int digits10 = 0;




    static constexpr int max_digits10 = 0;



    static constexpr bool is_signed = false;


    static constexpr bool is_integer = false;




    static constexpr bool is_exact = false;



    static constexpr int radix = 0;



    static constexpr int min_exponent = 0;



    static constexpr int min_exponent10 = 0;




    static constexpr int max_exponent = 0;



    static constexpr int max_exponent10 = 0;


    static constexpr bool has_infinity = false;



    static constexpr bool has_quiet_NaN = false;



    static constexpr bool has_signaling_NaN = false;


    static constexpr float_denorm_style has_denorm = denorm_absent;



    static constexpr bool has_denorm_loss = false;



    static constexpr bool is_iec559 = false;




    static constexpr bool is_bounded = false;
# 288 "/usr/include/c++/10.2.0/limits" 3
    static constexpr bool is_modulo = false;


    static constexpr bool traps = false;


    static constexpr bool tinyness_before = false;




    static constexpr float_round_style round_style =
          round_toward_zero;
  };
# 311 "/usr/include/c++/10.2.0/limits" 3
  template<typename _Tp>
    struct numeric_limits : public __numeric_limits_base
    {


      static constexpr _Tp
      min() noexcept { return _Tp(); }


      static constexpr _Tp
      max() noexcept { return _Tp(); }




      static constexpr _Tp
      lowest() noexcept { return _Tp(); }




      static constexpr _Tp
      epsilon() noexcept { return _Tp(); }


      static constexpr _Tp
      round_error() noexcept { return _Tp(); }


      static constexpr _Tp
      infinity() noexcept { return _Tp(); }



      static constexpr _Tp
      quiet_NaN() noexcept { return _Tp(); }



      static constexpr _Tp
      signaling_NaN() noexcept { return _Tp(); }




      static constexpr _Tp
      denorm_min() noexcept { return _Tp(); }
    };




  template<typename _Tp>
    struct numeric_limits<const _Tp>
    : public numeric_limits<_Tp> { };

  template<typename _Tp>
    struct numeric_limits<volatile _Tp>
    : public numeric_limits<_Tp> { };

  template<typename _Tp>
    struct numeric_limits<const volatile _Tp>
    : public numeric_limits<_Tp> { };
# 383 "/usr/include/c++/10.2.0/limits" 3
  template<>
    struct numeric_limits<bool>
    {
      static constexpr bool is_specialized = true;

      static constexpr bool
      min() noexcept { return false; }

      static constexpr bool
      max() noexcept { return true; }


      static constexpr bool
      lowest() noexcept { return min(); }

      static constexpr int digits = 1;
      static constexpr int digits10 = 0;

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr bool
      epsilon() noexcept { return false; }

      static constexpr bool
      round_error() noexcept { return false; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr bool
      infinity() noexcept { return false; }

      static constexpr bool
      quiet_NaN() noexcept { return false; }

      static constexpr bool
      signaling_NaN() noexcept { return false; }

      static constexpr bool
      denorm_min() noexcept { return false; }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;




      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<char>
    {
      static constexpr bool is_specialized = true;

      static constexpr char
      min() noexcept { return (((char)(-1) < 0) ? -(((char)(-1) < 0) ? (((((char)1 << ((sizeof(char) * 8 - ((char)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char)0) - 1 : (char)0); }

      static constexpr char
      max() noexcept { return (((char)(-1) < 0) ? (((((char)1 << ((sizeof(char) * 8 - ((char)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char)0); }


      static constexpr char
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(char) * 8 - ((char)(-1) < 0));
      static constexpr int digits10 = ((sizeof(char) * 8 - ((char)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = ((char)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr char
      epsilon() noexcept { return 0; }

      static constexpr char
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr
      char infinity() noexcept { return char(); }

      static constexpr char
      quiet_NaN() noexcept { return char(); }

      static constexpr char
      signaling_NaN() noexcept { return char(); }

      static constexpr char
      denorm_min() noexcept { return static_cast<char>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<signed char>
    {
      static constexpr bool is_specialized = true;

      static constexpr signed char
      min() noexcept { return -0x7f - 1; }

      static constexpr signed char
      max() noexcept { return 0x7f; }


      static constexpr signed char
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(signed char) * 8 - ((signed char)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(signed char) * 8 - ((signed char)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr signed char
      epsilon() noexcept { return 0; }

      static constexpr signed char
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr signed char
      infinity() noexcept { return static_cast<signed char>(0); }

      static constexpr signed char
      quiet_NaN() noexcept { return static_cast<signed char>(0); }

      static constexpr signed char
      signaling_NaN() noexcept
      { return static_cast<signed char>(0); }

      static constexpr signed char
      denorm_min() noexcept
      { return static_cast<signed char>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned char>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned char
      min() noexcept { return 0; }

      static constexpr unsigned char
      max() noexcept { return 0x7f * 2U + 1; }


      static constexpr unsigned char
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned char
      epsilon() noexcept { return 0; }

      static constexpr unsigned char
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned char
      infinity() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr unsigned char
      quiet_NaN() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr unsigned char
      signaling_NaN() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr unsigned char
      denorm_min() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<wchar_t>
    {
      static constexpr bool is_specialized = true;

      static constexpr wchar_t
      min() noexcept { return (((wchar_t)(-1) < 0) ? -(((wchar_t)(-1) < 0) ? (((((wchar_t)1 << ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(wchar_t)0) - 1 : (wchar_t)0); }

      static constexpr wchar_t
      max() noexcept { return (((wchar_t)(-1) < 0) ? (((((wchar_t)1 << ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(wchar_t)0); }


      static constexpr wchar_t
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = ((wchar_t)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr wchar_t
      epsilon() noexcept { return 0; }

      static constexpr wchar_t
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr wchar_t
      infinity() noexcept { return wchar_t(); }

      static constexpr wchar_t
      quiet_NaN() noexcept { return wchar_t(); }

      static constexpr wchar_t
      signaling_NaN() noexcept { return wchar_t(); }

      static constexpr wchar_t
      denorm_min() noexcept { return wchar_t(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };
# 796 "/usr/include/c++/10.2.0/limits" 3
  template<>
    struct numeric_limits<char16_t>
    {
      static constexpr bool is_specialized = true;

      static constexpr char16_t
      min() noexcept { return (((char16_t)(-1) < 0) ? -(((char16_t)(-1) < 0) ? (((((char16_t)1 << ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char16_t)0) - 1 : (char16_t)0); }

      static constexpr char16_t
      max() noexcept { return (((char16_t)(-1) < 0) ? (((((char16_t)1 << ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char16_t)0); }

      static constexpr char16_t
      lowest() noexcept { return min(); }

      static constexpr int digits = (sizeof(char16_t) * 8 - ((char16_t)(-1) < 0));
      static constexpr int digits10 = ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) * 643L / 2136);
      static constexpr int max_digits10 = 0;
      static constexpr bool is_signed = ((char16_t)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr char16_t
      epsilon() noexcept { return 0; }

      static constexpr char16_t
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr char16_t
      infinity() noexcept { return char16_t(); }

      static constexpr char16_t
      quiet_NaN() noexcept { return char16_t(); }

      static constexpr char16_t
      signaling_NaN() noexcept { return char16_t(); }

      static constexpr char16_t
      denorm_min() noexcept { return char16_t(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<char32_t>
    {
      static constexpr bool is_specialized = true;

      static constexpr char32_t
      min() noexcept { return (((char32_t)(-1) < 0) ? -(((char32_t)(-1) < 0) ? (((((char32_t)1 << ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char32_t)0) - 1 : (char32_t)0); }

      static constexpr char32_t
      max() noexcept { return (((char32_t)(-1) < 0) ? (((((char32_t)1 << ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char32_t)0); }

      static constexpr char32_t
      lowest() noexcept { return min(); }

      static constexpr int digits = (sizeof(char32_t) * 8 - ((char32_t)(-1) < 0));
      static constexpr int digits10 = ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) * 643L / 2136);
      static constexpr int max_digits10 = 0;
      static constexpr bool is_signed = ((char32_t)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr char32_t
      epsilon() noexcept { return 0; }

      static constexpr char32_t
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr char32_t
      infinity() noexcept { return char32_t(); }

      static constexpr char32_t
      quiet_NaN() noexcept { return char32_t(); }

      static constexpr char32_t
      signaling_NaN() noexcept { return char32_t(); }

      static constexpr char32_t
      denorm_min() noexcept { return char32_t(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style = round_toward_zero;
    };



  template<>
    struct numeric_limits<short>
    {
      static constexpr bool is_specialized = true;

      static constexpr short
      min() noexcept { return -0x7fff - 1; }

      static constexpr short
      max() noexcept { return 0x7fff; }


      static constexpr short
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(short) * 8 - ((short)(-1) < 0));
      static constexpr int digits10 = ((sizeof(short) * 8 - ((short)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr short
      epsilon() noexcept { return 0; }

      static constexpr short
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr short
      infinity() noexcept { return short(); }

      static constexpr short
      quiet_NaN() noexcept { return short(); }

      static constexpr short
      signaling_NaN() noexcept { return short(); }

      static constexpr short
      denorm_min() noexcept { return short(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned short>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned short
      min() noexcept { return 0; }

      static constexpr unsigned short
      max() noexcept { return 0x7fff * 2U + 1; }


      static constexpr unsigned short
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned short
      epsilon() noexcept { return 0; }

      static constexpr unsigned short
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned short
      infinity() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr unsigned short
      quiet_NaN() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr unsigned short
      signaling_NaN() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr unsigned short
      denorm_min() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<int>
    {
      static constexpr bool is_specialized = true;

      static constexpr int
      min() noexcept { return -0x7fffffff - 1; }

      static constexpr int
      max() noexcept { return 0x7fffffff; }


      static constexpr int
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(int) * 8 - ((int)(-1) < 0));
      static constexpr int digits10 = ((sizeof(int) * 8 - ((int)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr int
      epsilon() noexcept { return 0; }

      static constexpr int
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr int
      infinity() noexcept { return static_cast<int>(0); }

      static constexpr int
      quiet_NaN() noexcept { return static_cast<int>(0); }

      static constexpr int
      signaling_NaN() noexcept { return static_cast<int>(0); }

      static constexpr int
      denorm_min() noexcept { return static_cast<int>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned int>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned int
      min() noexcept { return 0; }

      static constexpr unsigned int
      max() noexcept { return 0x7fffffff * 2U + 1; }


      static constexpr unsigned int
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned int
      epsilon() noexcept { return 0; }

      static constexpr unsigned int
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned int
      infinity() noexcept { return static_cast<unsigned int>(0); }

      static constexpr unsigned int
      quiet_NaN() noexcept
      { return static_cast<unsigned int>(0); }

      static constexpr unsigned int
      signaling_NaN() noexcept
      { return static_cast<unsigned int>(0); }

      static constexpr unsigned int
      denorm_min() noexcept
      { return static_cast<unsigned int>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<long>
    {
      static constexpr bool is_specialized = true;

      static constexpr long
      min() noexcept { return -0x7fffffffffffffffL - 1; }

      static constexpr long
      max() noexcept { return 0x7fffffffffffffffL; }


      static constexpr long
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(long) * 8 - ((long)(-1) < 0));
      static constexpr int digits10 = ((sizeof(long) * 8 - ((long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr long
      epsilon() noexcept { return 0; }

      static constexpr long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr long
      infinity() noexcept { return static_cast<long>(0); }

      static constexpr long
      quiet_NaN() noexcept { return static_cast<long>(0); }

      static constexpr long
      signaling_NaN() noexcept { return static_cast<long>(0); }

      static constexpr long
      denorm_min() noexcept { return static_cast<long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned long>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned long
      min() noexcept { return 0; }

      static constexpr unsigned long
      max() noexcept { return 0x7fffffffffffffffL * 2UL + 1; }


      static constexpr unsigned long
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned long
      epsilon() noexcept { return 0; }

      static constexpr unsigned long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned long
      infinity() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr unsigned long
      quiet_NaN() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr unsigned long
      signaling_NaN() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr unsigned long
      denorm_min() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<long long>
    {
      static constexpr bool is_specialized = true;

      static constexpr long long
      min() noexcept { return -0x7fffffffffffffffLL - 1; }

      static constexpr long long
      max() noexcept { return 0x7fffffffffffffffLL; }


      static constexpr long long
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(long long) * 8 - ((long long)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(long long) * 8 - ((long long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr long long
      epsilon() noexcept { return 0; }

      static constexpr long long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr long long
      infinity() noexcept { return static_cast<long long>(0); }

      static constexpr long long
      quiet_NaN() noexcept { return static_cast<long long>(0); }

      static constexpr long long
      signaling_NaN() noexcept
      { return static_cast<long long>(0); }

      static constexpr long long
      denorm_min() noexcept { return static_cast<long long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned long long>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned long long
      min() noexcept { return 0; }

      static constexpr unsigned long long
      max() noexcept { return 0x7fffffffffffffffLL * 2ULL + 1; }


      static constexpr unsigned long long
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned long long
      epsilon() noexcept { return 0; }

      static constexpr unsigned long long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned long long
      infinity() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr unsigned long long
      quiet_NaN() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr unsigned long long
      signaling_NaN() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr unsigned long long
      denorm_min() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };
# 1636 "/usr/include/c++/10.2.0/limits" 3
  template<> struct numeric_limits<__int128> { static constexpr bool is_specialized = true; static constexpr __int128 min() noexcept { return (((__int128)(-1) < 0) ? -(((__int128)(-1) < 0) ? (((((__int128)1 << ((128 - ((__int128)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(__int128)0) - 1 : (__int128)0); } static constexpr __int128 max() noexcept { return (((__int128)(-1) < 0) ? (((((__int128)1 << ((128 - ((__int128)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(__int128)0); } static constexpr int digits = 128 - 1; static constexpr int digits10 = (128 - 1) * 643L / 2136; static constexpr bool is_signed = true; static constexpr bool is_integer = true; static constexpr bool is_exact = true; static constexpr int radix = 2; static constexpr __int128 epsilon() noexcept { return 0; } static constexpr __int128 round_error() noexcept { return 0; } static constexpr __int128 lowest() noexcept { return min(); } static constexpr int max_digits10 = 0; static constexpr int min_exponent = 0; static constexpr int min_exponent10 = 0; static constexpr int max_exponent = 0; static constexpr int max_exponent10 = 0; static constexpr bool has_infinity = false; static constexpr bool has_quiet_NaN = false; static constexpr bool has_signaling_NaN = false; static constexpr float_denorm_style has_denorm = denorm_absent; static constexpr bool has_denorm_loss = false; static constexpr __int128 infinity() noexcept { return static_cast<__int128>(0); } static constexpr __int128 quiet_NaN() noexcept { return static_cast<__int128>(0); } static constexpr __int128 signaling_NaN() noexcept { return static_cast<__int128>(0); } static constexpr __int128 denorm_min() noexcept { return static_cast<__int128>(0); } static constexpr bool is_iec559 = false; static constexpr bool is_bounded = true; static constexpr bool is_modulo = false; static constexpr bool traps = true; static constexpr bool tinyness_before = false; static constexpr float_round_style round_style = round_toward_zero; }; template<> struct numeric_limits<unsigned __int128> { static constexpr bool is_specialized = true; static constexpr unsigned __int128 min() noexcept { return 0; } static constexpr unsigned __int128 max() noexcept { return (((unsigned __int128)(-1) < 0) ? (((((unsigned __int128)1 << ((128 - ((unsigned __int128)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(unsigned __int128)0); } static constexpr unsigned __int128 lowest() noexcept { return min(); } static constexpr int max_digits10 = 0; static constexpr int digits = 128; static constexpr int digits10 = 128 * 643L / 2136; static constexpr bool is_signed = false; static constexpr bool is_integer = true; static constexpr bool is_exact = true; static constexpr int radix = 2; static constexpr unsigned __int128 epsilon() noexcept { return 0; } static constexpr unsigned __int128 round_error() noexcept { return 0; } static constexpr int min_exponent = 0; static constexpr int min_exponent10 = 0; static constexpr int max_exponent = 0; static constexpr int max_exponent10 = 0; static constexpr bool has_infinity = false; static constexpr bool has_quiet_NaN = false; static constexpr bool has_signaling_NaN = false; static constexpr float_denorm_style has_denorm = denorm_absent; static constexpr bool has_denorm_loss = false; static constexpr unsigned __int128 infinity() noexcept { return static_cast<unsigned __int128>(0); } static constexpr unsigned __int128 quiet_NaN() noexcept { return static_cast<unsigned __int128>(0); } static constexpr unsigned __int128 signaling_NaN() noexcept { return static_cast<unsigned __int128>(0); } static constexpr unsigned __int128 denorm_min() noexcept { return static_cast<unsigned __int128>(0); } static constexpr bool is_iec559 = false; static constexpr bool is_bounded = true; static constexpr bool is_modulo = true; static constexpr bool traps = true; static constexpr bool tinyness_before = false; static constexpr float_round_style round_style = round_toward_zero; };
# 1659 "/usr/include/c++/10.2.0/limits" 3
  template<>
    struct numeric_limits<float>
    {
      static constexpr bool is_specialized = true;

      static constexpr float
      min() noexcept { return 1.17549435082228750796873653722224568e-38F; }

      static constexpr float
      max() noexcept { return 3.40282346638528859811704183484516925e+38F; }


      static constexpr float
      lowest() noexcept { return -3.40282346638528859811704183484516925e+38F; }


      static constexpr int digits = 24;
      static constexpr int digits10 = 6;

      static constexpr int max_digits10
  = (2 + (24) * 643L / 2136);

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = false;
      static constexpr bool is_exact = false;
      static constexpr int radix = 2;

      static constexpr float
      epsilon() noexcept { return 1.19209289550781250000000000000000000e-7F; }

      static constexpr float
      round_error() noexcept { return 0.5F; }

      static constexpr int min_exponent = (-125);
      static constexpr int min_exponent10 = (-37);
      static constexpr int max_exponent = 128;
      static constexpr int max_exponent10 = 38;

      static constexpr bool has_infinity = 1;
      static constexpr bool has_quiet_NaN = 1;
      static constexpr bool has_signaling_NaN = has_quiet_NaN;
      static constexpr float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static constexpr bool has_denorm_loss
       = false;

      static constexpr float
      infinity() noexcept { return __builtin_huge_valf(); }

      static constexpr float
      quiet_NaN() noexcept { return __builtin_nanf(""); }

      static constexpr float
      signaling_NaN() noexcept { return __builtin_nansf(""); }

      static constexpr float
      denorm_min() noexcept { return 1.40129846432481707092372958328991613e-45F; }

      static constexpr bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = false;
      static constexpr bool tinyness_before
       = false;
      static constexpr float_round_style round_style
       = round_to_nearest;
    };






  template<>
    struct numeric_limits<double>
    {
      static constexpr bool is_specialized = true;

      static constexpr double
      min() noexcept { return double(2.22507385850720138309023271733240406e-308L); }

      static constexpr double
      max() noexcept { return double(1.79769313486231570814527423731704357e+308L); }


      static constexpr double
      lowest() noexcept { return -double(1.79769313486231570814527423731704357e+308L); }


      static constexpr int digits = 53;
      static constexpr int digits10 = 15;

      static constexpr int max_digits10
  = (2 + (53) * 643L / 2136);

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = false;
      static constexpr bool is_exact = false;
      static constexpr int radix = 2;

      static constexpr double
      epsilon() noexcept { return double(2.22044604925031308084726333618164062e-16L); }

      static constexpr double
      round_error() noexcept { return 0.5; }

      static constexpr int min_exponent = (-1021);
      static constexpr int min_exponent10 = (-307);
      static constexpr int max_exponent = 1024;
      static constexpr int max_exponent10 = 308;

      static constexpr bool has_infinity = 1;
      static constexpr bool has_quiet_NaN = 1;
      static constexpr bool has_signaling_NaN = has_quiet_NaN;
      static constexpr float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static constexpr bool has_denorm_loss
        = false;

      static constexpr double
      infinity() noexcept { return __builtin_huge_val(); }

      static constexpr double
      quiet_NaN() noexcept { return __builtin_nan(""); }

      static constexpr double
      signaling_NaN() noexcept { return __builtin_nans(""); }

      static constexpr double
      denorm_min() noexcept { return double(4.94065645841246544176568792868221372e-324L); }

      static constexpr bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = false;
      static constexpr bool tinyness_before
       = false;
      static constexpr float_round_style round_style
       = round_to_nearest;
    };






  template<>
    struct numeric_limits<long double>
    {
      static constexpr bool is_specialized = true;

      static constexpr long double
      min() noexcept { return 3.36210314311209350626267781732175260e-4932L; }

      static constexpr long double
      max() noexcept { return 1.18973149535723176502126385303097021e+4932L; }


      static constexpr long double
      lowest() noexcept { return -1.18973149535723176502126385303097021e+4932L; }


      static constexpr int digits = 64;
      static constexpr int digits10 = 18;

      static constexpr int max_digits10
  = (2 + (64) * 643L / 2136);

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = false;
      static constexpr bool is_exact = false;
      static constexpr int radix = 2;

      static constexpr long double
      epsilon() noexcept { return 1.08420217248550443400745280086994171e-19L; }

      static constexpr long double
      round_error() noexcept { return 0.5L; }

      static constexpr int min_exponent = (-16381);
      static constexpr int min_exponent10 = (-4931);
      static constexpr int max_exponent = 16384;
      static constexpr int max_exponent10 = 4932;

      static constexpr bool has_infinity = 1;
      static constexpr bool has_quiet_NaN = 1;
      static constexpr bool has_signaling_NaN = has_quiet_NaN;
      static constexpr float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static constexpr bool has_denorm_loss
 = false;

      static constexpr long double
      infinity() noexcept { return __builtin_huge_vall(); }

      static constexpr long double
      quiet_NaN() noexcept { return __builtin_nanl(""); }

      static constexpr long double
      signaling_NaN() noexcept { return __builtin_nansl(""); }

      static constexpr long double
      denorm_min() noexcept { return 3.64519953188247460252840593361941982e-4951L; }

      static constexpr bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = false;
      static constexpr bool tinyness_before =
      false;
      static constexpr float_round_style round_style =
            round_to_nearest;
    };






}
# 26 "/usr/include/opencascade/BVH_Box.hxx" 2






# 31 "/usr/include/opencascade/BVH_Box.hxx"
template <class T, int N, template <class , int > class TheDerivedBox>
class BVH_BaseBox {};


template <class T, int N> class BVH_Box;


template <class T>
class BVH_BaseBox<T, 3, BVH_Box>
{
public:


  void Transform (const NCollection_Mat4<T>& theTransform)
  {
    if (theTransform.IsIdentity())
    {
      return;
    }

    BVH_Box<T, 3> *aThis = static_cast<BVH_Box<T, 3>*>(this);
    if (!aThis->IsValid())
    {
      return;
    }

    BVH_Box<T, 3> aBox = Transformed (theTransform);

    aThis->CornerMin() = aBox.CornerMin();
    aThis->CornerMax() = aBox.CornerMax();
  }



  BVH_Box<T, 3> Transformed (const NCollection_Mat4<T>& theTransform) const
  {
    BVH_Box<T, 3> aResultBox;

    if (theTransform.IsIdentity())
    {
      return aResultBox;
    }

    const BVH_Box<T, 3> *aThis = static_cast<const BVH_Box<T, 3>*>(this);
    if (!aThis->IsValid())
    {
      return aResultBox;
    }

    for (size_t aX = 0; aX <= 1; ++aX)
    {
      for (size_t aY = 0; aY <= 1; ++aY)
      {
        for (size_t aZ = 0; aZ <= 1; ++aZ)
        {
          typename BVH::VectorType<T, 4>::Type aPnt =
            theTransform * typename BVH::VectorType<T, 4>::Type (aX ? aThis->CornerMax().x() : aThis->CornerMin().x(),
                                                                 aY ? aThis->CornerMax().y() : aThis->CornerMin().y(),
                                                                 aZ ? aThis->CornerMax().z() : aThis->CornerMin().z(),
                                                                 static_cast<T> (1.0));

          aResultBox.Add (aPnt.xyz());
        }
      }
    }
    return aResultBox;
  }
};




template<class T, int N>
class BVH_Box : public BVH_BaseBox<T, N, BVH_Box>
{
public:

  typedef typename BVH::VectorType<T, N>::Type BVH_VecNt;

public:


  BVH_Box() : myIsInited (false) {}


  BVH_Box (const BVH_VecNt& thePoint)
  : myMinPoint (thePoint),
    myMaxPoint (thePoint),
    myIsInited (true) {}


  BVH_Box (const BVH_VecNt& theMinPoint,
           const BVH_VecNt& theMaxPoint)
  : myMinPoint (theMinPoint),
    myMaxPoint (theMaxPoint),
    myIsInited (true) {}

public:


  void Clear() { myIsInited = false; }


  Standard_Boolean IsValid() const { return myIsInited; }


  void Add (const BVH_VecNt& thePoint)
  {
    if (!myIsInited)
    {
      myMinPoint = thePoint;
      myMaxPoint = thePoint;
      myIsInited = true;
    }
    else
    {
      myMinPoint = myMinPoint.cwiseMin (thePoint);
      myMaxPoint = myMaxPoint.cwiseMax (thePoint);
    }
  }


  void Combine (const BVH_Box& theBox);


  const BVH_VecNt& CornerMin() const { return myMinPoint; }


  const BVH_VecNt& CornerMax() const { return myMaxPoint; }


  BVH_VecNt& CornerMin() { return myMinPoint; }


  BVH_VecNt& CornerMax() { return myMaxPoint; }



  T Area() const;


  BVH_VecNt Size() const { return myMaxPoint - myMinPoint; }


  BVH_VecNt Center() const { return (myMinPoint + myMaxPoint) * static_cast<T> (0.5); }


  T Center (const Standard_Integer theAxis) const;


  void DumpJson (Standard_OStream& theOStream, Standard_Integer theDepth = -1) const
  {
    (void)theDepth;
    { TCollection_AsciiString aName = Standard_Dump::DumpFieldToName ("myIsInited"); Standard_Dump::AddValuesSeparator (theOStream); theOStream << "\"" << aName << "\": " << myIsInited; }

    int n = Min (N, 3);
    if (n == 1)
    {
      { TCollection_AsciiString aName = Standard_Dump::DumpFieldToName ("myMinPoint[0]"); Standard_Dump::AddValuesSeparator (theOStream); theOStream << "\"" << aName << "\": " << myMinPoint[0]; }
      { TCollection_AsciiString aName = Standard_Dump::DumpFieldToName ("myMinPoint[0]"); Standard_Dump::AddValuesSeparator (theOStream); theOStream << "\"" << aName << "\": " << myMinPoint[0]; }
    }
    else if (n == 2)
    {
      { Standard_Dump::AddValuesSeparator (theOStream); theOStream << "\"" << "MinPoint" << "\": ["; Standard_Dump::DumpRealValues (theOStream, n, myMinPoint[0], myMinPoint[1]); theOStream << "]"; }
      { Standard_Dump::AddValuesSeparator (theOStream); theOStream << "\"" << "MaxPoint" << "\": ["; Standard_Dump::DumpRealValues (theOStream, n, myMaxPoint[0], myMaxPoint[1]); theOStream << "]"; }
    }
    else if (n == 3)
    {
      { Standard_Dump::AddValuesSeparator (theOStream); theOStream << "\"" << "MinPoint" << "\": ["; Standard_Dump::DumpRealValues (theOStream, n, myMinPoint[0], myMinPoint[1], myMinPoint[2]); theOStream << "]"; }
      { Standard_Dump::AddValuesSeparator (theOStream); theOStream << "\"" << "MaxPoint" << "\": ["; Standard_Dump::DumpRealValues (theOStream, n, myMaxPoint[0], myMaxPoint[1], myMaxPoint[2]); theOStream << "]"; }
    }
  }


  Standard_Boolean InitFromJson (const Standard_SStream& theSStream, Standard_Integer& theStreamPos)
  {
    Standard_Integer aPos = theStreamPos;

    Standard_Integer anIsInited = 0;
    TCollection_AsciiString aStreamStr = Standard_Dump::Text (theSStream);

    { Standard_Integer aStreamPos = aPos; if (!Standard_Dump::ProcessFieldName (aStreamStr, "anIsInited", aStreamPos)) return false; TCollection_AsciiString aValueText; if (!Standard_Dump::InitValue (aStreamStr, aStreamPos, aValueText) || !aValueText.IsIntegerValue()) return false; anIsInited = aValueText.IntegerValue(); aPos = aStreamPos; };
    myIsInited = anIsInited != 0;

    int n = Min (N, 3);
    if (n == 1)
    {
      Standard_Real aValue;
      { Standard_Integer aStreamPos = aPos; if (!Standard_Dump::ProcessFieldName (aStreamStr, "aValue", aStreamPos)) return false; TCollection_AsciiString aValueText; if (!Standard_Dump::InitValue (aStreamStr, aStreamPos, aValueText) || !aValueText.IsRealValue()) return false; aValue = aValueText.RealValue(); aPos = aStreamPos; };
      myMinPoint[0] = (T)aValue;
    }
    else if (n == 2)
    {
      Standard_Real aValue1, aValue2;
      { Standard_Integer aStreamPos = aPos; if (!Standard_Dump::ProcessStreamName (aStreamStr, "MinPoint", aStreamPos)) return false; if (!Standard_Dump::InitRealValues (aStreamStr, aStreamPos, n, &aValue1, &aValue2)) return false; aPos = aStreamPos; };
      myMinPoint[0] = (T)aValue1;
      myMinPoint[1] = (T)aValue2;

      { Standard_Integer aStreamPos = aPos; if (!Standard_Dump::ProcessStreamName (aStreamStr, "MaxPoint", aStreamPos)) return false; if (!Standard_Dump::InitRealValues (aStreamStr, aStreamPos, n, &aValue1, &aValue2)) return false; aPos = aStreamPos; };
      myMaxPoint[0] = (T)aValue1;
      myMaxPoint[1] = (T)aValue2;
    }
    else if (n == 3)
    {
      Standard_Real aValue1, aValue2, aValue3;
      { Standard_Integer aStreamPos = aPos; if (!Standard_Dump::ProcessStreamName (aStreamStr, "MinPoint", aStreamPos)) return false; if (!Standard_Dump::InitRealValues (aStreamStr, aStreamPos, n, &aValue1, &aValue2, &aValue3)) return false; aPos = aStreamPos; };
      myMinPoint[0] = (T)aValue1;
      myMinPoint[1] = (T)aValue2;
      myMinPoint[2] = (T)aValue3;

      { Standard_Integer aStreamPos = aPos; if (!Standard_Dump::ProcessStreamName (aStreamStr, "MaxPoint", aStreamPos)) return false; if (!Standard_Dump::InitRealValues (aStreamStr, aStreamPos, n, &aValue1, &aValue2, &aValue3)) return false; aPos = aStreamPos; };
      myMaxPoint[0] = (T)aValue1;
      myMaxPoint[1] = (T)aValue2;
      myMaxPoint[2] = (T)aValue3;
    }

    theStreamPos = aPos;
    return true;
  }

public:


  Standard_Boolean IsOut (const BVH_Box<T, N>& theOther) const
  {
    if (!theOther.IsValid())
      return true;

    return IsOut (theOther.myMinPoint, theOther.myMaxPoint);
  }


  Standard_Boolean IsOut (const BVH_VecNt& theMinPoint,
                          const BVH_VecNt& theMaxPoint) const
  {
    if (!IsValid())
      return true;

    int n = Min (N, 3);
    for (int i = 0; i < n; ++i)
    {
      if (myMinPoint[i] > theMaxPoint[i] ||
          myMaxPoint[i] < theMinPoint[i])
        return true;
    }
    return false;
  }


  Standard_Boolean Contains (const BVH_Box<T, N>& theOther,
                             Standard_Boolean& hasOverlap) const
  {
    hasOverlap = false;
    if (!theOther.IsValid())
      return false;

    return Contains (theOther.myMinPoint, theOther.myMaxPoint, hasOverlap);
  }


  Standard_Boolean Contains (const BVH_VecNt& theMinPoint,
                             const BVH_VecNt& theMaxPoint,
                             Standard_Boolean& hasOverlap) const
  {
    hasOverlap = false;
    if (!IsValid())
      return false;

    Standard_Boolean isInside = true;

    int n = Min (N, 3);
    for (int i = 0; i < n; ++i)
    {
      hasOverlap = (myMinPoint[i] <= theMaxPoint[i] &&
                    myMaxPoint[i] >= theMinPoint[i]);
      if (!hasOverlap)
        return false;

      isInside = isInside && (myMinPoint[i] <= theMinPoint[i] &&
                              myMaxPoint[i] >= theMaxPoint[i]);
    }
    return isInside;
  }


  Standard_Boolean IsOut (const BVH_VecNt& thePoint) const
  {
    if (!IsValid())
      return true;

    int n = Min (N, 3);
    for (int i = 0; i < n; ++i)
    {
      if (thePoint[i] < myMinPoint[i] ||
          thePoint[i] > myMaxPoint[i])
        return true;
    }
    return false;
  }


protected:

  BVH_VecNt myMinPoint;
  BVH_VecNt myMaxPoint;
  Standard_Boolean myIsInited;

};

namespace BVH
{



  template<class T, int N>
  struct CenterAxis
  {

  };

  template<class T>
  struct CenterAxis<T, 2>
  {
    static T Center (const BVH_Box<T, 2>& theBox, const Standard_Integer theAxis)
    {
      if (theAxis == 0)
      {
        return (theBox.CornerMin().x() + theBox.CornerMax().x()) * static_cast<T> (0.5);
      }
      else if (theAxis == 1)
      {
        return (theBox.CornerMin().y() + theBox.CornerMax().y()) * static_cast<T> (0.5);
      }
      return static_cast<T> (0.0);
    }
  };

  template<class T>
  struct CenterAxis<T, 3>
  {
    static T Center (const BVH_Box<T, 3>& theBox, const Standard_Integer theAxis)
    {
      if (theAxis == 0)
      {
        return (theBox.CornerMin().x() + theBox.CornerMax().x()) * static_cast<T> (0.5);
      }
      else if (theAxis == 1)
      {
        return (theBox.CornerMin().y() + theBox.CornerMax().y()) * static_cast<T> (0.5);
      }
      else if (theAxis == 2)
      {
        return (theBox.CornerMin().z() + theBox.CornerMax().z()) * static_cast<T> (0.5);
      }
      return static_cast<T> (0.0);
    }
  };

  template<class T>
  struct CenterAxis<T, 4>
  {
    static T Center (const BVH_Box<T, 4>& theBox, const Standard_Integer theAxis)
    {
      if (theAxis == 0)
      {
        return (theBox.CornerMin().x() + theBox.CornerMax().x()) * static_cast<T> (0.5);
      }
      else if (theAxis == 1)
      {
        return (theBox.CornerMin().y() + theBox.CornerMax().y()) * static_cast<T> (0.5);
      }
      else if (theAxis == 2)
      {
        return (theBox.CornerMin().z() + theBox.CornerMax().z()) * static_cast<T> (0.5);
      }
      return static_cast<T> (0.0);
    }
  };




  template<class T, int N>
  struct SurfaceCalculator
  {

  };

  template<class T>
  struct SurfaceCalculator<T, 2>
  {
    static T Area (const typename BVH_Box<T, 2>::BVH_VecNt& theSize)
    {
      const T anArea = theSize.x() * theSize.y();

      if (anArea < std::numeric_limits<T>::epsilon())
      {
        return theSize.x() + theSize.y();
      }

      return anArea;
    }
  };

  template<class T>
  struct SurfaceCalculator<T, 3>
  {
    static T Area (const typename BVH_Box<T, 3>::BVH_VecNt& theSize)
    {
      const T anArea = ( theSize.x() * theSize.y() +
                         theSize.x() * theSize.z() +
                         theSize.z() * theSize.y() ) * static_cast<T> (2.0);

      if (anArea < std::numeric_limits<T>::epsilon())
      {
        return theSize.x() +
               theSize.y() +
               theSize.z();
      }

      return anArea;
    }
  };

  template<class T>
  struct SurfaceCalculator<T, 4>
  {
    static T Area (const typename BVH_Box<T, 4>::BVH_VecNt& theSize)
    {
      const T anArea = ( theSize.x() * theSize.y() +
                         theSize.x() * theSize.z() +
                         theSize.z() * theSize.y() ) * static_cast<T> (2.0);

      if (anArea < std::numeric_limits<T>::epsilon())
      {
        return theSize.x() +
               theSize.y() +
               theSize.z();
      }

      return anArea;
    }
  };





  template<class T, int N>
  struct BoxMinMax
  {
    typedef typename BVH::VectorType<T, N>::Type BVH_VecNt;

    static void CwiseMin (BVH_VecNt& theVec1, const BVH_VecNt& theVec2)
    {
      theVec1.x() = Min (theVec1.x(), theVec2.x());
      theVec1.y() = Min (theVec1.y(), theVec2.y());
      theVec1.z() = Min (theVec1.z(), theVec2.z());
    }

    static void CwiseMax (BVH_VecNt& theVec1, const BVH_VecNt& theVec2)
    {
      theVec1.x() = Max (theVec1.x(), theVec2.x());
      theVec1.y() = Max (theVec1.y(), theVec2.y());
      theVec1.z() = Max (theVec1.z(), theVec2.z());
    }
  };

  template<class T>
  struct BoxMinMax<T, 2>
  {
    typedef typename BVH::VectorType<T, 2>::Type BVH_VecNt;

    static void CwiseMin (BVH_VecNt& theVec1, const BVH_VecNt& theVec2)
    {
      theVec1.x() = Min (theVec1.x(), theVec2.x());
      theVec1.y() = Min (theVec1.y(), theVec2.y());
    }

    static void CwiseMax (BVH_VecNt& theVec1, const BVH_VecNt& theVec2)
    {
      theVec1.x() = Max (theVec1.x(), theVec2.x());
      theVec1.y() = Max (theVec1.y(), theVec2.y());
    }
  };
}





template<class T, int N>
void BVH_Box<T, N>::Combine (const BVH_Box& theBox)
{
  if (theBox.myIsInited)
  {
    if (!myIsInited)
    {
      myMinPoint = theBox.myMinPoint;
      myMaxPoint = theBox.myMaxPoint;
      myIsInited = true;
    }
    else
    {
      BVH::BoxMinMax<T, N>::CwiseMin (myMinPoint, theBox.myMinPoint);
      BVH::BoxMinMax<T, N>::CwiseMax (myMaxPoint, theBox.myMaxPoint);
    }
  }
}





template<class T, int N>
T BVH_Box<T, N>::Area() const
{
  return !myIsInited ? static_cast<T> (0.0) : BVH::SurfaceCalculator<T, N>::Area (myMaxPoint - myMinPoint);
}





template<class T, int N>
T BVH_Box<T, N>::Center (const Standard_Integer theAxis) const
{
  return BVH::CenterAxis<T, N>::Center (*this, theAxis);
}
# 20 "/usr/include/opencascade/Graphic3d_BndBox4f.hxx" 2




typedef BVH_Box<Standard_ShortReal, 4> Graphic3d_BndBox4f;
# 21 "/usr/include/opencascade/Graphic3d_Structure.hxx" 2
# 1 "/usr/include/opencascade/Graphic3d_BndBox4d.hxx" 1
# 21 "/usr/include/opencascade/Graphic3d_BndBox4d.hxx"
typedef BVH_Box<Standard_Real, 4> Graphic3d_BndBox4d;
# 22 "/usr/include/opencascade/Graphic3d_Structure.hxx" 2
# 1 "/usr/include/opencascade/Graphic3d_CStructure.hxx" 1
# 18 "/usr/include/opencascade/Graphic3d_CStructure.hxx"
# 1 "/usr/include/opencascade/Graphic3d_BndBox3d.hxx" 1
# 20 "/usr/include/opencascade/Graphic3d_BndBox3d.hxx"
typedef BVH_Box<Standard_Real, 3> Graphic3d_BndBox3d;
# 19 "/usr/include/opencascade/Graphic3d_CStructure.hxx" 2
# 1 "/usr/include/opencascade/Graphic3d_Group.hxx" 1
# 21 "/usr/include/opencascade/Graphic3d_Group.hxx"
# 1 "/usr/include/opencascade/Graphic3d_AspectLine3d.hxx" 1
# 23 "/usr/include/opencascade/Graphic3d_AspectLine3d.hxx"
class Graphic3d_AspectLine3d : public Graphic3d_Aspects
{
  public: typedef Graphic3d_Aspects base_type; static const char* get_type_name () { return "Graphic3d_AspectLine3d"; using direct_base_classes = opencascade::direct_base_class_as_tuple<std::tr2::direct_bases<Graphic3d_AspectLine3d>::type>::type; static_assert(opencascade::has_type<Graphic3d_Aspects, direct_base_classes>::type::value, "OCCT RTTI definition is incorrect: " "Graphic3d_Aspects" " is not direct base class of " "Graphic3d_AspectLine3d"); static_assert(&get_type_name == &Graphic3d_AspectLine3d::get_type_name, "OCCT RTTI definition is misplaced: current class is not " "Graphic3d_AspectLine3d"); } static const opencascade::handle<Standard_Type>& get_type_descriptor (); virtual const opencascade::handle<Standard_Type>& DynamicType() const override;
public:







  Graphic3d_AspectLine3d();






  Graphic3d_AspectLine3d (const Quantity_Color& theColor,
                                          Aspect_TypeOfLine theType,
                                          Standard_Real theWidth);


  Aspect_TypeOfLine Type() const { return myLineType; }


  void SetType (const Aspect_TypeOfLine theType) { SetLineType (theType); }


  Standard_ShortReal Width() const { return myLineWidth; }



  void SetWidth (const Standard_Real theWidth) { SetWidth ((float )theWidth); }



  void SetWidth (Standard_ShortReal theWidth)
  {
    SetLineWidth (theWidth);
  }

};

class Graphic3d_AspectLine3d; typedef opencascade::handle<Graphic3d_AspectLine3d> Handle_Graphic3d_AspectLine3d;
# 22 "/usr/include/opencascade/Graphic3d_Group.hxx" 2

# 1 "/usr/include/opencascade/Graphic3d_AspectText3d.hxx" 1
# 22 "/usr/include/opencascade/Graphic3d_AspectText3d.hxx"
class Graphic3d_AspectText3d : public Graphic3d_Aspects
{
  public: typedef Graphic3d_Aspects base_type; static const char* get_type_name () { return "Graphic3d_AspectText3d"; using direct_base_classes = opencascade::direct_base_class_as_tuple<std::tr2::direct_bases<Graphic3d_AspectText3d>::type>::type; static_assert(opencascade::has_type<Graphic3d_Aspects, direct_base_classes>::type::value, "OCCT RTTI definition is incorrect: " "Graphic3d_Aspects" " is not direct base class of " "Graphic3d_AspectText3d"); static_assert(&get_type_name == &Graphic3d_AspectText3d::get_type_name, "OCCT RTTI definition is misplaced: current class is not " "Graphic3d_AspectText3d"); } static const opencascade::handle<Standard_Type>& get_type_descriptor (); virtual const opencascade::handle<Standard_Type>& DynamicType() const override;
public:






  Graphic3d_AspectText3d();
# 41 "/usr/include/opencascade/Graphic3d_AspectText3d.hxx"
  Graphic3d_AspectText3d (const Quantity_Color& theColor,
                                          Standard_CString theFont,
                                          Standard_Real theExpansionFactor,
                                          Standard_Real theSpace,
                                          Aspect_TypeOfStyleText theStyle = Aspect_TOST_NORMAL,
                                          Aspect_TypeOfDisplayText theDisplayType = Aspect_TODT_NORMAL);


  const Quantity_Color& Color() const { return myInteriorColor.GetRGB(); }


  const Quantity_ColorRGBA& ColorRGBA() const { return myInteriorColor; }


  void SetColor (const Quantity_Color& theColor) { myInteriorColor.SetRGB (theColor); }


  void SetColor (const Quantity_ColorRGBA& theColor) { myInteriorColor = theColor; }


  const TCollection_AsciiString& Font() const
  {
    if (myTextFont.IsNull())
    {
      static const TCollection_AsciiString anEmpty;
      return anEmpty;
    }
    return myTextFont->String();
  }


  void SetFont (const TCollection_AsciiString& theFont)
  {
    if (!theFont.IsEmpty())
    {
      myTextFont = new TCollection_HAsciiString (theFont);
    }
    else
    {
      myTextFont.Nullify();
    }
  }


  void SetFont (const Standard_CString theFont)
  {
    SetFont (TCollection_AsciiString (theFont));
  }


  Aspect_TypeOfStyleText Style() const { return myTextStyle; }


  void SetStyle (Aspect_TypeOfStyleText theStyle) { myTextStyle = theStyle; }


  Aspect_TypeOfDisplayText DisplayType() const { return myTextDisplayType; }


  void SetDisplayType (Aspect_TypeOfDisplayText theDisplayType) { myTextDisplayType = theDisplayType; }


  bool GetTextZoomable() const { return myIsTextZoomable; }


  Standard_ShortReal GetTextAngle() const { return myTextAngle; }


  void SetTextAngle (const Standard_Real theAngle) { myTextAngle = (Standard_ShortReal )theAngle; }


  Font_FontAspect GetTextFontAspect() const { return myTextFontAspect; }


  virtual void DumpJson (Standard_OStream& theOStream, Standard_Integer theDepth = -1) const override;

};

class Graphic3d_AspectText3d; typedef opencascade::handle<Graphic3d_AspectText3d> Handle_Graphic3d_AspectText3d;
# 24 "/usr/include/opencascade/Graphic3d_Group.hxx" 2
# 1 "/usr/include/opencascade/Graphic3d_AspectMarker3d.hxx" 1
# 23 "/usr/include/opencascade/Graphic3d_AspectMarker3d.hxx"
class Graphic3d_AspectMarker3d : public Graphic3d_Aspects
{
  public: typedef Graphic3d_Aspects base_type; static const char* get_type_name () { return "Graphic3d_AspectMarker3d"; using direct_base_classes = opencascade::direct_base_class_as_tuple<std::tr2::direct_bases<Graphic3d_AspectMarker3d>::type>::type; static_assert(opencascade::has_type<Graphic3d_Aspects, direct_base_classes>::type::value, "OCCT RTTI definition is incorrect: " "Graphic3d_Aspects" " is not direct base class of " "Graphic3d_AspectMarker3d"); static_assert(&get_type_name == &Graphic3d_AspectMarker3d::get_type_name, "OCCT RTTI definition is misplaced: current class is not " "Graphic3d_AspectMarker3d"); } static const opencascade::handle<Standard_Type>& get_type_descriptor (); virtual const opencascade::handle<Standard_Type>& DynamicType() const override;
public:







  Graphic3d_AspectMarker3d();

  Graphic3d_AspectMarker3d(const Aspect_TypeOfMarker theType, const Quantity_Color& theColor, const Standard_Real theScale);



  Graphic3d_AspectMarker3d(const Quantity_Color& theColor, const Standard_Integer theWidth, const Standard_Integer theHeight, const opencascade::handle<TColStd_HArray1OfByte>& theTextureBitmap);



  Graphic3d_AspectMarker3d(const opencascade::handle<Image_PixMap>& theTextureImage);


  Standard_ShortReal Scale() const { return myMarkerScale; }





  void SetScale (const Standard_ShortReal theScale)
  {
    SetMarkerScale (theScale);
  }


  void SetScale (const Standard_Real theScale) { SetScale ((float )theScale); }


  Aspect_TypeOfMarker Type() const { return myMarkerType; }


  void SetType (const Aspect_TypeOfMarker theType) { myMarkerType = theType; }


  void GetTextureSize (Standard_Integer& theWidth, Standard_Integer& theHeight) const;



  const opencascade::handle<Graphic3d_MarkerImage>& GetMarkerImage() const { return myMarkerImage; }

  void SetBitMap (const Standard_Integer theWidth, const Standard_Integer theHeight, const opencascade::handle<TColStd_HArray1OfByte>& theTexture);

};

class Graphic3d_AspectMarker3d; typedef opencascade::handle<Graphic3d_AspectMarker3d> Handle_Graphic3d_AspectMarker3d;
# 25 "/usr/include/opencascade/Graphic3d_Group.hxx" 2
# 1 "/usr/include/opencascade/Graphic3d_MapOfAspectsToAspects.hxx" 1
# 17 "/usr/include/opencascade/Graphic3d_MapOfAspectsToAspects.hxx"
# 1 "/usr/include/opencascade/NCollection_DataMap.hxx" 1
# 45 "/usr/include/opencascade/NCollection_DataMap.hxx"
template < class TheKeyType,
           class TheItemType,
           class Hasher = NCollection_DefaultHasher<TheKeyType> >
class NCollection_DataMap : public NCollection_BaseMap
{
public:

  typedef TheKeyType key_type;

  typedef TheItemType value_type;

public:

  class DataMapNode : public NCollection_TListNode<TheItemType>
  {
  public:

    DataMapNode (const TheKeyType& theKey,
                 const TheItemType& theItem,
                 NCollection_ListNode* theNext) :
      NCollection_TListNode<TheItemType> (theItem, theNext),
      myKey(theKey)
    {}


    const TheKeyType& Key (void) const
    { return myKey; }


    static void delNode (NCollection_ListNode * theNode,
                         opencascade::handle<NCollection_BaseAllocator>& theAl)
    {
      ((DataMapNode *) theNode)->~DataMapNode();
      theAl->Free(theNode);
    }

  private:
    TheKeyType myKey;
  };

 public:

  class Iterator : public NCollection_BaseMap::Iterator
  {
  public:

    Iterator (void) :
      NCollection_BaseMap::Iterator() {}

    Iterator (const NCollection_DataMap& theMap) :
      NCollection_BaseMap::Iterator(theMap) {}

    Standard_Boolean More(void) const
    { return PMore(); }

    void Next(void)
    { PNext(); }

    const TheItemType& Value(void) const
    {
      if (!More()) throw Standard_NoSuchObject("NCollection_DataMap::Iterator::Value");;
      return ((DataMapNode *) myNode)->Value();
    }

    TheItemType& ChangeValue(void) const
    {
      if (!More()) throw Standard_NoSuchObject("NCollection_DataMap::Iterator::ChangeValue");;
      return ((DataMapNode *) myNode)->ChangeValue();
    }

    const TheKeyType& Key (void) const
    {
      if (!More()) throw Standard_NoSuchObject("NCollection_DataMap::Iterator::Key");;
      return ((DataMapNode *) myNode)->Key();
    }
  };


  typedef NCollection_StlIterator<std::forward_iterator_tag, Iterator, TheItemType, false> iterator;


  typedef NCollection_StlIterator<std::forward_iterator_tag, Iterator, TheItemType, true> const_iterator;


  iterator begin() const { return Iterator (*this); }


  iterator end() const { return Iterator(); }


  const_iterator cbegin() const { return Iterator (*this); }


  const_iterator cend() const { return Iterator(); }

 public:



  NCollection_DataMap() : NCollection_BaseMap (1, true, opencascade::handle<NCollection_BaseAllocator>()) {}


  explicit NCollection_DataMap (const Standard_Integer theNbBuckets,
                                const opencascade::handle<NCollection_BaseAllocator>& theAllocator = 0L)
  : NCollection_BaseMap (theNbBuckets, true, theAllocator) {}


  NCollection_DataMap (const NCollection_DataMap& theOther)
    : NCollection_BaseMap (theOther.NbBuckets(), true, theOther.myAllocator)
  { *this = theOther; }



  void Exchange (NCollection_DataMap& theOther)
  {
    this->exchangeMapsData (theOther);
  }



  NCollection_DataMap& Assign (const NCollection_DataMap& theOther)
  {
    if (this == &theOther)
      return *this;

    Clear();
    Standard_Integer anExt = theOther.Extent();
    if (anExt)
    {
      ReSize (anExt-1);
      Iterator anIter(theOther);
      for (; anIter.More(); anIter.Next())
        Bind (anIter.Key(), anIter.Value());
    }
    return *this;
  }


  NCollection_DataMap& operator= (const NCollection_DataMap& theOther)
  {
    return Assign (theOther);
  }


  void ReSize (const Standard_Integer N)
  {
    NCollection_ListNode** newdata = 
# 191 "/usr/include/opencascade/NCollection_DataMap.hxx" 3 4
                                    __null
# 191 "/usr/include/opencascade/NCollection_DataMap.hxx"
                                        ;
    NCollection_ListNode** dummy = 
# 192 "/usr/include/opencascade/NCollection_DataMap.hxx" 3 4
                                    __null
# 192 "/usr/include/opencascade/NCollection_DataMap.hxx"
                                        ;
    Standard_Integer newBuck;
    if (BeginResize (N, newBuck, newdata, dummy))
    {
      if (myData1)
      {
        DataMapNode** olddata = (DataMapNode**) myData1;
        DataMapNode *p, *q;
        Standard_Integer i,k;
        for (i = 0; i <= NbBuckets(); i++)
        {
          if (olddata[i])
          {
            p = olddata[i];
            while (p)
            {
              k = Hasher::HashCode(p->Key(),newBuck);
              q = (DataMapNode*) p->Next();
              p->Next() = newdata[k];
              newdata[k] = p;
              p = q;
            }
          }
        }
      }
      EndResize (N, newBuck, newdata, dummy);
    }
  }





  Standard_Boolean Bind (const TheKeyType& theKey, const TheItemType& theItem)
  {
    if (Resizable())
      ReSize(Extent());
    DataMapNode** data = (DataMapNode**)myData1;
    Standard_Integer k = Hasher::HashCode (theKey, NbBuckets());
    DataMapNode* p = data[k];
    while (p)
    {
      if (Hasher::IsEqual(p->Key(), theKey))
      {
        p->ChangeValue() = theItem;
        return false;
      }
      p = (DataMapNode *) p->Next();
    }
    data[k] = new (this->myAllocator) DataMapNode (theKey, theItem, data[k]);
    Increment();
    return true;
  }


  TheItemType* Bound (const TheKeyType& theKey, const TheItemType& theItem)
  {
    if (Resizable())
      ReSize(Extent());
    DataMapNode** data = (DataMapNode**)myData1;
    Standard_Integer k = Hasher::HashCode (theKey, NbBuckets());
    DataMapNode* p = data[k];
    while (p)
    {
      if (Hasher::IsEqual(p->Key(), theKey))
      {
        p->ChangeValue() = theItem;
        return &p->ChangeValue();
      }
      p = (DataMapNode*)p->Next();
    }
    data[k] = new (this->myAllocator) DataMapNode (theKey, theItem, data[k]);
    Increment();
    return &data[k]->ChangeValue();
  }


  Standard_Boolean IsBound(const TheKeyType& theKey) const
  {
    DataMapNode* p;
    return lookup(theKey, p);
  }


  Standard_Boolean UnBind(const TheKeyType& theKey)
  {
    if (IsEmpty())
      return false;
    DataMapNode** data = (DataMapNode**) myData1;
    Standard_Integer k = Hasher::HashCode(theKey,NbBuckets());
    DataMapNode* p = data[k];
    DataMapNode* q = 
# 283 "/usr/include/opencascade/NCollection_DataMap.hxx" 3 4
                    __null
# 283 "/usr/include/opencascade/NCollection_DataMap.hxx"
                        ;
    while (p)
    {
      if (Hasher::IsEqual(p->Key(), theKey))
      {
        Decrement();
        if (q)
          q->Next() = p->Next();
        else
          data[k] = (DataMapNode*) p->Next();
        p->~DataMapNode();
        this->myAllocator->Free(p);
        return true;
      }
      q = p;
      p = (DataMapNode*) p->Next();
    }
    return false;
  }



  const TheItemType* Seek(const TheKeyType& theKey) const
  {
    DataMapNode* p = 0;
    if (!lookup(theKey, p))
      return 0L;
    return &p->Value();
  }


  const TheItemType& Find(const TheKeyType& theKey) const
  {
    DataMapNode* p = 0;
    if (!lookup(theKey, p))
      throw Standard_NoSuchObject("NCollection_DataMap::Find");
    return p->Value();
  }



  Standard_Boolean Find (const TheKeyType& theKey,
                         TheItemType& theValue) const
  {
    DataMapNode* p = 0;
    if (!lookup(theKey, p))
      return false;

    theValue = p->Value();
    return true;
  }


  const TheItemType& operator() (const TheKeyType& theKey) const
  { return Find(theKey); }



  TheItemType* ChangeSeek(const TheKeyType& theKey)
  {
    DataMapNode* p = 0;
    if (!lookup(theKey, p))
      return 0L;
    return &p->ChangeValue();
  }


  TheItemType& ChangeFind (const TheKeyType& theKey)
  {
    DataMapNode* p = 0;
    if (!lookup(theKey, p))
      throw Standard_NoSuchObject("NCollection_DataMap::Find");
    return p->ChangeValue();
  }


  TheItemType& operator() (const TheKeyType& theKey)
  { return ChangeFind(theKey); }



  void Clear(const Standard_Boolean doReleaseMemory = true)
  { Destroy (DataMapNode::delNode, doReleaseMemory); }


  void Clear (const opencascade::handle<NCollection_BaseAllocator>& theAllocator)
  {
    Clear();
    this->myAllocator = ( ! theAllocator.IsNull() ? theAllocator :
                    NCollection_BaseAllocator::CommonBaseAllocator() );
  }


  virtual ~NCollection_DataMap (void)
  { Clear(); }


  Standard_Integer Size(void) const
  { return Extent(); }


 protected:




  Standard_Boolean lookup(const TheKeyType& theKey,DataMapNode*& thepNode) const
  {
    if (IsEmpty())
      return false;
    for (thepNode = (DataMapNode*)myData1[Hasher::HashCode(theKey, NbBuckets())];
         thepNode; thepNode = (DataMapNode*)thepNode->Next())
    {
      if (Hasher::IsEqual(thepNode->Key(), theKey))
        return true;
    }
    return false;
  }

};
# 18 "/usr/include/opencascade/Graphic3d_MapOfAspectsToAspects.hxx" 2


class Graphic3d_Aspects;
typedef NCollection_DataMap<opencascade::handle<Graphic3d_Aspects>, opencascade::handle<Graphic3d_Aspects> > Graphic3d_MapOfAspectsToAspects;
# 26 "/usr/include/opencascade/Graphic3d_Group.hxx" 2

# 1 "/usr/include/opencascade/Graphic3d_Vertex.hxx" 1
# 26 "/usr/include/opencascade/Graphic3d_Vertex.hxx"
class Graphic3d_Vertex
{
public:

  void* operator new (size_t theSize) { return Standard::Allocate (theSize); } void operator delete (void* theAddress) { Standard::Free (theAddress); } void* operator new[] (size_t theSize) { return Standard::Allocate (theSize); } void operator delete[] (void* theAddress) { Standard::Free (theAddress); } void* operator new (size_t, void* theAddress) { return theAddress; } void operator delete (void*, void*) { }


  Graphic3d_Vertex()
  {
    SetCoord (0.0f, 0.0f, 0.0f);
  }


  Graphic3d_Vertex (const Standard_ShortReal theX,
                    const Standard_ShortReal theY,
                    const Standard_ShortReal theZ)
  {
    SetCoord (theX, theY, theZ);
  }


  Graphic3d_Vertex (const Standard_Real theX,
                    const Standard_Real theY,
                    const Standard_Real theZ)
  {
    SetCoord (theX, theY, theZ);
  }


  void SetCoord (const Standard_ShortReal theX,
                 const Standard_ShortReal theY,
                 const Standard_ShortReal theZ)
  {
    xyz[0] = theX;
    xyz[1] = theY;
    xyz[2] = theZ;
  }


  void SetCoord (const Standard_Real theX,
                 const Standard_Real theY,
                 const Standard_Real theZ)
  {
    xyz[0] = Standard_ShortReal (theX);
    xyz[1] = Standard_ShortReal (theY);
    xyz[2] = Standard_ShortReal (theZ);
  }


  void Coord (Standard_ShortReal& theX,
              Standard_ShortReal& theY,
              Standard_ShortReal& theZ) const
  {
    theX = xyz[0];
    theY = xyz[1];
    theZ = xyz[2];
  }


  void Coord (Standard_Real& theX,
              Standard_Real& theY,
              Standard_Real& theZ) const
  {
    theX = xyz[0];
    theY = xyz[1];
    theZ = xyz[2];
  }


  Standard_ShortReal X() const { return xyz[0]; }


  Standard_ShortReal Y() const { return xyz[1]; }


  Standard_ShortReal Z() const { return xyz[2]; }


  Standard_ShortReal Distance (const Graphic3d_Vertex& theOther) const;


  void DumpJson (Standard_OStream& theOStream, Standard_Integer theDepth = -1) const;

  float xyz[3];

};
# 28 "/usr/include/opencascade/Graphic3d_Group.hxx" 2
# 1 "/usr/include/opencascade/Graphic3d_TextPath.hxx" 1
# 21 "/usr/include/opencascade/Graphic3d_TextPath.hxx"
enum Graphic3d_TextPath
{
Graphic3d_TP_UP,
Graphic3d_TP_DOWN,
Graphic3d_TP_LEFT,
Graphic3d_TP_RIGHT
};
# 29 "/usr/include/opencascade/Graphic3d_Group.hxx" 2
# 1 "/usr/include/opencascade/Graphic3d_HorizontalTextAlignment.hxx" 1
# 22 "/usr/include/opencascade/Graphic3d_HorizontalTextAlignment.hxx"
enum Graphic3d_HorizontalTextAlignment
{
Graphic3d_HTA_LEFT,
Graphic3d_HTA_CENTER,
Graphic3d_HTA_RIGHT
};
# 30 "/usr/include/opencascade/Graphic3d_Group.hxx" 2
# 1 "/usr/include/opencascade/Graphic3d_VerticalTextAlignment.hxx" 1
# 22 "/usr/include/opencascade/Graphic3d_VerticalTextAlignment.hxx"
enum Graphic3d_VerticalTextAlignment
{
Graphic3d_VTA_BOTTOM,
Graphic3d_VTA_CENTER,
Graphic3d_VTA_TOP,
Graphic3d_VTA_TOPFIRSTLINE
};
# 31 "/usr/include/opencascade/Graphic3d_Group.hxx" 2
# 1 "/usr/include/opencascade/Graphic3d_TypeOfPrimitiveArray.hxx" 1
# 21 "/usr/include/opencascade/Graphic3d_TypeOfPrimitiveArray.hxx"
enum Graphic3d_TypeOfPrimitiveArray
{
  Graphic3d_TOPA_UNDEFINED,

  Graphic3d_TOPA_POINTS,
  Graphic3d_TOPA_SEGMENTS,
  Graphic3d_TOPA_POLYLINES,
  Graphic3d_TOPA_TRIANGLES,
  Graphic3d_TOPA_TRIANGLESTRIPS,
  Graphic3d_TOPA_TRIANGLEFANS,

  Graphic3d_TOPA_LINES_ADJACENCY,

  Graphic3d_TOPA_LINE_STRIP_ADJACENCY,

  Graphic3d_TOPA_TRIANGLES_ADJACENCY,

  Graphic3d_TOPA_TRIANGLE_STRIP_ADJACENCY,

  Graphic3d_TOPA_QUADRANGLES,

  Graphic3d_TOPA_QUADRANGLESTRIPS,

  Graphic3d_TOPA_POLYGONS

};
# 32 "/usr/include/opencascade/Graphic3d_Group.hxx" 2
# 1 "/usr/include/opencascade/Graphic3d_IndexBuffer.hxx" 1
# 17 "/usr/include/opencascade/Graphic3d_IndexBuffer.hxx"
# 1 "/usr/include/opencascade/Graphic3d_Buffer.hxx" 1
# 17 "/usr/include/opencascade/Graphic3d_Buffer.hxx"
# 1 "/usr/include/opencascade/Graphic3d_BufferRange.hxx" 1
# 21 "/usr/include/opencascade/Graphic3d_BufferRange.hxx"
struct Graphic3d_BufferRange
{
  Standard_Integer Start;
  Standard_Integer Length;


  Graphic3d_BufferRange() : Start (0), Length (0) {}


  Graphic3d_BufferRange (Standard_Integer theStart, Standard_Integer theLength) : Start (theStart), Length (theLength) {}


  Standard_Boolean IsEmpty() const { return Length == 0; }


  Standard_Integer Upper() const { return Start + Length - 1; }


  void Clear()
  {
    Start = 0;
    Length = 0;
  }


  void Unite (const Graphic3d_BufferRange& theRange)
  {
    if (IsEmpty())
    {
      *this = theRange;
      return;
    }
    else if (theRange.IsEmpty())
    {
      return;
    }

    const Standard_Integer aStart = Min (Start, theRange.Start);
    const Standard_Integer aLast = Max (Upper(), theRange.Upper());
    Start = aStart;
    Length = aLast - aStart + 1;
  }
};
# 18 "/usr/include/opencascade/Graphic3d_Buffer.hxx" 2



# 1 "/usr/include/opencascade/Standard_NotImplemented.hxx" 1
# 25 "/usr/include/opencascade/Standard_NotImplemented.hxx"
class Standard_NotImplemented;
class Standard_NotImplemented; typedef opencascade::handle<Standard_NotImplemented> Handle_Standard_NotImplemented;
# 35 "/usr/include/opencascade/Standard_NotImplemented.hxx"
class Standard_NotImplemented : public Standard_ProgramError { void Throw () const override { throw *this; } public: Standard_NotImplemented() : Standard_ProgramError() {} Standard_NotImplemented(const Standard_CString theMessage) : Standard_ProgramError(theMessage) {} static void Raise(const Standard_CString theMessage = "") { opencascade::handle<Standard_NotImplemented> _E = new Standard_NotImplemented; _E->Reraise(theMessage); } static void Raise(Standard_SStream& theMessage) { opencascade::handle<Standard_NotImplemented> _E = new Standard_NotImplemented; _E->Reraise (theMessage); } static opencascade::handle<Standard_NotImplemented> NewInstance(const Standard_CString theMessage = "") { return new Standard_NotImplemented(theMessage); } public: typedef Standard_ProgramError base_type; static const char* get_type_name () { return "Standard_NotImplemented"; using direct_base_classes = opencascade::direct_base_class_as_tuple<std::tr2::direct_bases<Standard_NotImplemented>::type>::type; static_assert(opencascade::has_type<Standard_ProgramError, direct_base_classes>::type::value, "OCCT RTTI definition is incorrect: " "Standard_ProgramError" " is not direct base class of " "Standard_NotImplemented"); static_assert(&get_type_name == &Standard_NotImplemented::get_type_name, "OCCT RTTI definition is misplaced: current class is not " "Standard_NotImplemented"); } static const opencascade::handle<Standard_Type>& get_type_descriptor () { return Standard_Type::Instance<Standard_NotImplemented>(); } virtual const opencascade::handle<Standard_Type>& DynamicType() const override { return get_type_descriptor (); } };
# 22 "/usr/include/opencascade/Graphic3d_Buffer.hxx" 2


enum Graphic3d_TypeOfAttribute
{
  Graphic3d_TOA_POS = 0,
  Graphic3d_TOA_NORM,
  Graphic3d_TOA_UV,
  Graphic3d_TOA_COLOR,
  Graphic3d_TOA_CUSTOM,
};


enum Graphic3d_TypeOfData
{
  Graphic3d_TOD_USHORT,
  Graphic3d_TOD_UINT,
  Graphic3d_TOD_VEC2,
  Graphic3d_TOD_VEC3,
  Graphic3d_TOD_VEC4,
  Graphic3d_TOD_VEC4UB,
  Graphic3d_TOD_FLOAT,
};


struct Graphic3d_Attribute
{
  Graphic3d_TypeOfAttribute Id;
  Graphic3d_TypeOfData DataType;

  Standard_Integer Stride() const { return Stride (DataType); }


  static Standard_Integer Stride (const Graphic3d_TypeOfData theType)
  {
    switch (theType)
    {
      case Graphic3d_TOD_USHORT: return sizeof(unsigned short);
      case Graphic3d_TOD_UINT: return sizeof(unsigned int);
      case Graphic3d_TOD_VEC2: return sizeof(Graphic3d_Vec2);
      case Graphic3d_TOD_VEC3: return sizeof(Graphic3d_Vec3);
      case Graphic3d_TOD_VEC4: return sizeof(Graphic3d_Vec4);
      case Graphic3d_TOD_VEC4UB: return sizeof(Graphic3d_Vec4ub);
      case Graphic3d_TOD_FLOAT: return sizeof(float);
    }
    return 0;
  }

};

typedef NCollection_Array1<Graphic3d_Attribute> Graphic3d_Array1OfAttribute;


class Graphic3d_Buffer : public NCollection_Buffer
{
  public: typedef NCollection_Buffer base_type; static const char* get_type_name () { return "Graphic3d_Buffer"; using direct_base_classes = opencascade::direct_base_class_as_tuple<std::tr2::direct_bases<Graphic3d_Buffer>::type>::type; static_assert(opencascade::has_type<NCollection_Buffer, direct_base_classes>::type::value, "OCCT RTTI definition is incorrect: " "NCollection_Buffer" " is not direct base class of " "Graphic3d_Buffer"); static_assert(&get_type_name == &Graphic3d_Buffer::get_type_name, "OCCT RTTI definition is misplaced: current class is not " "Graphic3d_Buffer"); } static const opencascade::handle<Standard_Type>& get_type_descriptor (); virtual const opencascade::handle<Standard_Type>& DynamicType() const override;
public:


  Graphic3d_Buffer (const opencascade::handle<NCollection_BaseAllocator>& theAlloc)
  : NCollection_Buffer (theAlloc),
    Stride (0),
    NbElements (0),
    NbAttributes (0)
  {

  }



  Standard_Integer NbMaxElements() const { return Stride != 0 ? Standard_Integer(mySize / size_t(Stride)) : 0; }


  const Graphic3d_Attribute* AttributesArray() const
  {
    return (Graphic3d_Attribute* )(myData + mySize);
  }


  const Graphic3d_Attribute& Attribute (const Standard_Integer theAttribIndex) const
  {
    return AttributesArray()[theAttribIndex];
  }


  Graphic3d_Attribute& ChangeAttribute (const Standard_Integer theAttribIndex)
  {
    return *((Graphic3d_Attribute* )(myData + mySize) + theAttribIndex);
  }




  Standard_Integer FindAttribute (Graphic3d_TypeOfAttribute theAttrib) const
  {
    for (Standard_Integer anAttribIter = 0; anAttribIter < NbAttributes; ++anAttribIter)
    {
      const Graphic3d_Attribute& anAttrib = Attribute (anAttribIter);
      if (anAttrib.Id == theAttrib)
      {
        return anAttribIter;
      }
    }
    return -1;
  }


public:


  Standard_Integer AttributeOffset (const Standard_Integer theAttribIndex) const
  {
    Standard_Integer anOffset = 0;
    for (Standard_Integer anAttribIter = 0; anAttribIter < theAttribIndex; ++anAttribIter)
    {
      anOffset += Graphic3d_Attribute::Stride (Attribute (anAttribIter).DataType);
    }
    return anOffset;
  }


  const Standard_Byte* Data (const Standard_Integer theAttribIndex) const
  {
    return myData + AttributeOffset (theAttribIndex);
  }


  Standard_Byte* ChangeData (const Standard_Integer theAttribIndex)
  {
    return myData + AttributeOffset (theAttribIndex);
  }


  inline const Standard_Byte* value (const Standard_Integer theElem) const
  {
    return myData + Stride * size_t(theElem);
  }


  inline Standard_Byte* changeValue (const Standard_Integer theElem)
  {
    return myData + Stride * size_t(theElem);
  }


  template <typename Type_t>
  inline const Type_t& Value (const Standard_Integer theElem) const
  {
    return *reinterpret_cast<const Type_t*>(value (theElem));
  }


  template <typename Type_t>
  inline Type_t& ChangeValue (const Standard_Integer theElem)
  {
    return *reinterpret_cast<Type_t* >(changeValue (theElem));
  }


public:

  using NCollection_Buffer::Data;
  using NCollection_Buffer::ChangeData;





  Standard_Byte* ChangeAttributeData (Graphic3d_TypeOfAttribute theAttrib,
                                      Standard_Integer& theAttribIndex,
                                      Standard_Size& theAttribStride)
  {
    return (Standard_Byte* )AttributeData (theAttrib, theAttribIndex, theAttribStride);
  }





  const Standard_Byte* AttributeData (Graphic3d_TypeOfAttribute theAttrib,
                                      Standard_Integer& theAttribIndex,
                                      Standard_Size& theAttribStride) const
  {
    const Standard_Byte* aDataPtr = Data();
    if (IsInterleaved())
    {
      for (Standard_Integer anAttribIter = 0; anAttribIter < NbAttributes; ++anAttribIter)
      {
        const Graphic3d_Attribute& anAttrib = Attribute (anAttribIter);
        const Standard_Size anAttribStride = Graphic3d_Attribute::Stride (anAttrib.DataType);
        if (anAttrib.Id == theAttrib)
        {
          theAttribIndex = anAttribIter;
          theAttribStride = Stride;
          return aDataPtr;
        }

        aDataPtr += anAttribStride;
      }
    }
    else
    {
      const Standard_Integer aNbMaxVerts = NbMaxElements();
      for (Standard_Integer anAttribIter = 0; anAttribIter < NbAttributes; ++anAttribIter)
      {
        const Graphic3d_Attribute& anAttrib = Attribute (anAttribIter);
        const Standard_Size anAttribStride = Graphic3d_Attribute::Stride (anAttrib.DataType);
        if (anAttrib.Id == theAttrib)
        {
          theAttribIndex = anAttribIter;
          theAttribStride = anAttribStride;
          return aDataPtr;
        }

        aDataPtr += anAttribStride * aNbMaxVerts;
      }
    }
    return 
# 238 "/usr/include/opencascade/Graphic3d_Buffer.hxx" 3 4
          __null
# 238 "/usr/include/opencascade/Graphic3d_Buffer.hxx"
              ;
  }

public:


  void release()
  {
    Free();
    Stride = 0;
    NbElements = 0;
    NbAttributes = 0;
  }


  bool Init (const Standard_Integer theNbElems,
             const Graphic3d_Attribute* theAttribs,
             const Standard_Integer theNbAttribs)
  {
    release();
    Standard_Integer aStride = 0;
    for (Standard_Integer anAttribIter = 0; anAttribIter < theNbAttribs; ++anAttribIter)
    {
      const Graphic3d_Attribute& anAttrib = theAttribs[anAttribIter];
      aStride += anAttrib.Stride();
    }
    if (aStride == 0)
    {
      return false;
    }

    Stride = aStride;
    NbElements = theNbElems;
    NbAttributes = theNbAttribs;
    if (NbElements != 0)
    {
      const size_t aDataSize = size_t(Stride) * size_t(NbElements);
      if (!Allocate (aDataSize + sizeof(Graphic3d_Attribute) * NbAttributes))
      {
        release();
        return false;
      }

      mySize = aDataSize;
      for (Standard_Integer anAttribIter = 0; anAttribIter < theNbAttribs; ++anAttribIter)
      {
        ChangeAttribute (anAttribIter) = theAttribs[anAttribIter];
      }
    }
    return true;
  }


  bool Init (const Standard_Integer theNbElems,
             const Graphic3d_Array1OfAttribute& theAttribs)
  {
    return Init (theNbElems, &theAttribs.First(), theAttribs.Size());
  }

public:



  virtual Standard_Boolean IsInterleaved() const { return true; }



  virtual Standard_Boolean IsMutable() const { return false; }



  virtual Graphic3d_BufferRange InvalidatedRange() const { return Graphic3d_BufferRange(); }



  virtual void Validate() {}


  virtual void Invalidate() {}


  virtual void DumpJson (Standard_OStream& theOStream, Standard_Integer theDepth = -1) const override;

public:

  Standard_Integer Stride;
  Standard_Integer NbElements;
  Standard_Integer NbAttributes;

};

class Graphic3d_Buffer; typedef opencascade::handle<Graphic3d_Buffer> Handle_Graphic3d_Buffer;
# 18 "/usr/include/opencascade/Graphic3d_IndexBuffer.hxx" 2


class Graphic3d_IndexBuffer : public Graphic3d_Buffer
{
  public: typedef Graphic3d_Buffer base_type; static const char* get_type_name () { return "Graphic3d_IndexBuffer"; using direct_base_classes = opencascade::direct_base_class_as_tuple<std::tr2::direct_bases<Graphic3d_IndexBuffer>::type>::type; static_assert(opencascade::has_type<Graphic3d_Buffer, direct_base_classes>::type::value, "OCCT RTTI definition is incorrect: " "Graphic3d_Buffer" " is not direct base class of " "Graphic3d_IndexBuffer"); static_assert(&get_type_name == &Graphic3d_IndexBuffer::get_type_name, "OCCT RTTI definition is misplaced: current class is not " "Graphic3d_IndexBuffer"); } static const opencascade::handle<Standard_Type>& get_type_descriptor (); virtual const opencascade::handle<Standard_Type>& DynamicType() const override;
public:


  Graphic3d_IndexBuffer (const opencascade::handle<NCollection_BaseAllocator>& theAlloc)
  : Graphic3d_Buffer (theAlloc) {}


  template<typename IndexType_t>
  bool Init (const Standard_Integer theNbElems)
  {
    release();
    Stride = sizeof(IndexType_t);
    if (Stride != sizeof(unsigned short)
     && Stride != sizeof(unsigned int))
    {
      return false;
    }

    NbElements = theNbElems;
    NbAttributes = 0;
    if (NbElements != 0
    && !Allocate (size_t(Stride) * size_t(NbElements)))
    {
      release();
      return false;
    }
    return true;
  }


  bool InitInt32 (const Standard_Integer theNbElems)
  {
    return Init<int> (theNbElems);
  }


  Standard_Integer Index (const Standard_Integer theIndex) const
  {
    return Stride == sizeof(unsigned short)
         ? Standard_Integer(Value<unsigned short> (theIndex))
         : Standard_Integer(Value<unsigned int> (theIndex));
  }


  void SetIndex (const Standard_Integer theIndex,
                 const Standard_Integer theValue)
  {
    if (Stride == sizeof(unsigned short))
    {
      ChangeValue<unsigned short> (theIndex) = (unsigned short )theValue;
    }
    else
    {
      ChangeValue<unsigned int> (theIndex) = (unsigned int )theValue;
    }
  }


  virtual void DumpJson (Standard_OStream& theOStream, Standard_Integer theDepth = -1) const override
  {
    { const char* className = get_type_name(); { TCollection_AsciiString aName = Standard_Dump::DumpFieldToName ("className"); Standard_Dump::AddValuesSeparator (theOStream); theOStream << "\"" << aName << "\": \"" << className << "\""; } }
    { if (theDepth != 0) { Standard_Dump::AddValuesSeparator (theOStream); Graphic3d_Buffer::DumpJson (theOStream, theDepth - 1); } }
  }

};

class Graphic3d_IndexBuffer; typedef opencascade::handle<Graphic3d_IndexBuffer> Handle_Graphic3d_IndexBuffer;
# 33 "/usr/include/opencascade/Graphic3d_Group.hxx" 2

# 1 "/usr/include/opencascade/Graphic3d_BoundBuffer.hxx" 1
# 20 "/usr/include/opencascade/Graphic3d_BoundBuffer.hxx"
class Graphic3d_BoundBuffer : public NCollection_Buffer
{
  public: typedef NCollection_Buffer base_type; static const char* get_type_name () { return "Graphic3d_BoundBuffer"; using direct_base_classes = opencascade::direct_base_class_as_tuple<std::tr2::direct_bases<Graphic3d_BoundBuffer>::type>::type; static_assert(opencascade::has_type<NCollection_Buffer, direct_base_classes>::type::value, "OCCT RTTI definition is incorrect: " "NCollection_Buffer" " is not direct base class of " "Graphic3d_BoundBuffer"); static_assert(&get_type_name == &Graphic3d_BoundBuffer::get_type_name, "OCCT RTTI definition is misplaced: current class is not " "Graphic3d_BoundBuffer"); } static const opencascade::handle<Standard_Type>& get_type_descriptor (); virtual const opencascade::handle<Standard_Type>& DynamicType() const override;
public:


  Graphic3d_BoundBuffer (const opencascade::handle<NCollection_BaseAllocator>& theAlloc)
  : NCollection_Buffer (theAlloc),
    Colors (
# 28 "/usr/include/opencascade/Graphic3d_BoundBuffer.hxx" 3 4
             __null
# 28 "/usr/include/opencascade/Graphic3d_BoundBuffer.hxx"
                 ),
    Bounds (
# 29 "/usr/include/opencascade/Graphic3d_BoundBuffer.hxx" 3 4
             __null
# 29 "/usr/include/opencascade/Graphic3d_BoundBuffer.hxx"
                 ),
    NbBounds (0),
    NbMaxBounds (0) {}


  bool Init (const Standard_Integer theNbBounds,
             const Standard_Boolean theHasColors)
  {
    Colors = 
# 37 "/usr/include/opencascade/Graphic3d_BoundBuffer.hxx" 3 4
              __null
# 37 "/usr/include/opencascade/Graphic3d_BoundBuffer.hxx"
                  ;
    Bounds = 
# 38 "/usr/include/opencascade/Graphic3d_BoundBuffer.hxx" 3 4
              __null
# 38 "/usr/include/opencascade/Graphic3d_BoundBuffer.hxx"
                  ;
    NbBounds = 0;
    NbMaxBounds = 0;
    Free();
    if (theNbBounds < 1)
    {
      return false;
    }

    const size_t aBoundsSize = sizeof(Standard_Integer) * theNbBounds;
    const size_t aColorsSize = theHasColors
                             ? sizeof(Graphic3d_Vec4) * theNbBounds
                             : 0;
    if (!Allocate (aColorsSize + aBoundsSize))
    {
      Free();
      return false;
    }

    NbBounds = theNbBounds;
    NbMaxBounds = theNbBounds;
    Colors = theHasColors ? reinterpret_cast<Graphic3d_Vec4* >(myData) : 
# 59 "/usr/include/opencascade/Graphic3d_BoundBuffer.hxx" 3 4
                                                                          __null
# 59 "/usr/include/opencascade/Graphic3d_BoundBuffer.hxx"
                                                                              ;
    Bounds = reinterpret_cast<Standard_Integer* >(theHasColors ? (myData + aColorsSize) : myData);
    return true;
  }


  virtual void DumpJson (Standard_OStream& theOStream, Standard_Integer theDepth = -1) const override
  {
    { const char* className = get_type_name(); { TCollection_AsciiString aName = Standard_Dump::DumpFieldToName ("className"); Standard_Dump::AddValuesSeparator (theOStream); theOStream << "\"" << aName << "\": \"" << className << "\""; } }
    { if (theDepth != 0) { Standard_Dump::AddValuesSeparator (theOStream); NCollection_Buffer::DumpJson (theOStream, theDepth - 1); } }

    { TCollection_AsciiString aName = Standard_Dump::DumpFieldToName ("Colors"); Standard_Dump::AddValuesSeparator (theOStream); theOStream << "\"" << aName << "\": \"" << Standard_Dump::GetPointerInfo (Colors) << "\""; }
    { TCollection_AsciiString aName = Standard_Dump::DumpFieldToName ("Bounds"); Standard_Dump::AddValuesSeparator (theOStream); theOStream << "\"" << aName << "\": \"" << Standard_Dump::GetPointerInfo (Bounds) << "\""; }

    { TCollection_AsciiString aName = Standard_Dump::DumpFieldToName ("NbBounds"); Standard_Dump::AddValuesSeparator (theOStream); theOStream << "\"" << aName << "\": " << NbBounds; }
    { TCollection_AsciiString aName = Standard_Dump::DumpFieldToName ("NbMaxBounds"); Standard_Dump::AddValuesSeparator (theOStream); theOStream << "\"" << aName << "\": " << NbMaxBounds; }
  }

public:

  Graphic3d_Vec4* Colors;
  Standard_Integer* Bounds;
  Standard_Integer NbBounds;
  Standard_Integer NbMaxBounds;

};

class Graphic3d_BoundBuffer; typedef opencascade::handle<Graphic3d_BoundBuffer> Handle_Graphic3d_BoundBuffer;
# 35 "/usr/include/opencascade/Graphic3d_Group.hxx" 2
# 1 "/usr/include/opencascade/gp_Ax2.hxx" 1
# 22 "/usr/include/opencascade/gp_Ax2.hxx"
# 1 "/usr/include/opencascade/gp_Ax1.hxx" 1
# 26 "/usr/include/opencascade/gp_Ax1.hxx"
class gp_Pnt;
class gp_Dir;
class gp_Ax2;
class gp_Trsf;
class gp_Vec;
# 45 "/usr/include/opencascade/gp_Ax1.hxx"
class gp_Ax1
{
public:

  void* operator new (size_t theSize) { return Standard::Allocate (theSize); } void operator delete (void* theAddress) { Standard::Free (theAddress); } void* operator new[] (size_t theSize) { return Standard::Allocate (theSize); } void operator delete[] (void* theAddress) { Standard::Free (theAddress); } void* operator new (size_t, void* theAddress) { return theAddress; } void operator delete (void*, void*) { }




    gp_Ax1();



    gp_Ax1(const gp_Pnt& P, const gp_Dir& V);


    void SetDirection (const gp_Dir& V);


    void SetLocation (const gp_Pnt& P);


    const gp_Dir& Direction() const;


    const gp_Pnt& Location() const;
# 80 "/usr/include/opencascade/gp_Ax1.hxx"
  Standard_Boolean IsCoaxial (const gp_Ax1& Other, const Standard_Real AngularTolerance, const Standard_Real LinearTolerance) const;






    Standard_Boolean IsNormal (const gp_Ax1& Other, const Standard_Real AngularTolerance) const;






    Standard_Boolean IsOpposite (const gp_Ax1& Other, const Standard_Real AngularTolerance) const;







    Standard_Boolean IsParallel (const gp_Ax1& Other, const Standard_Real AngularTolerance) const;





    Standard_Real Angle (const gp_Ax1& Other) const;



    void Reverse();


    [[nodiscard]] gp_Ax1 Reversed() const;





  void Mirror (const gp_Pnt& P);




  [[nodiscard]] gp_Ax1 Mirrored (const gp_Pnt& P) const;





  void Mirror (const gp_Ax1& A1);





  [[nodiscard]] gp_Ax1 Mirrored (const gp_Ax1& A1) const;






  void Mirror (const gp_Ax2& A2);






  [[nodiscard]] gp_Ax1 Mirrored (const gp_Ax2& A2) const;



    void Rotate (const gp_Ax1& A1, const Standard_Real Ang);



    [[nodiscard]] gp_Ax1 Rotated (const gp_Ax1& A1, const Standard_Real Ang) const;





    void Scale (const gp_Pnt& P, const Standard_Real S);





    [[nodiscard]] gp_Ax1 Scaled (const gp_Pnt& P, const Standard_Real S) const;



    void Transform (const gp_Trsf& T);






    [[nodiscard]] gp_Ax1 Transformed (const gp_Trsf& T) const;




    void Translate (const gp_Vec& V);




    [[nodiscard]] gp_Ax1 Translated (const gp_Vec& V) const;





    void Translate (const gp_Pnt& P1, const gp_Pnt& P2);





    [[nodiscard]] gp_Ax1 Translated (const gp_Pnt& P1, const gp_Pnt& P2) const;



  void DumpJson (Standard_OStream& theOStream, Standard_Integer theDepth = -1) const;


  Standard_Boolean InitFromJson (const Standard_SStream& theSStream, Standard_Integer& theStreamPos);

protected:





private:



  gp_Pnt loc;
  gp_Dir vdir;


};


# 1 "/usr/include/opencascade/gp_Ax1.lxx" 1
# 17 "/usr/include/opencascade/gp_Ax1.lxx"
inline gp_Ax1::gp_Ax1() : loc(0.,0.,0.), vdir(0.,0.,1.)
{ }

inline gp_Ax1::gp_Ax1 (const gp_Pnt& P,
         const gp_Dir& V) : loc(P), vdir(V)
{ }

inline void gp_Ax1::SetDirection (const gp_Dir& V)
{ vdir = V; }

inline void gp_Ax1::SetLocation (const gp_Pnt& P)
{ loc = P; }

inline const gp_Dir& gp_Ax1::Direction () const
{ return vdir; }

inline const gp_Pnt& gp_Ax1::Location () const
{ return loc; }

inline Standard_Boolean gp_Ax1::IsNormal
(const gp_Ax1& Other,
 const Standard_Real AngularTolerance) const
{ return vdir.IsNormal(Other.vdir, AngularTolerance); }

inline Standard_Boolean gp_Ax1::IsOpposite
(const gp_Ax1& Other,
 const Standard_Real AngularTolerance) const
{ return vdir.IsOpposite(Other.vdir, AngularTolerance); }

inline Standard_Boolean gp_Ax1::IsParallel
(const gp_Ax1& Other,
 const Standard_Real AngularTolerance) const
{ return vdir.IsParallel(Other.vdir, AngularTolerance); }

inline Standard_Real gp_Ax1::Angle (const gp_Ax1& Other) const
{ return vdir.Angle (Other.vdir); }

inline void gp_Ax1::Reverse ()
{ vdir.Reverse(); }

inline gp_Ax1 gp_Ax1::Reversed () const
{
  gp_Dir D = vdir.Reversed();
  return gp_Ax1(loc, D);
}

inline void gp_Ax1::Rotate (const gp_Ax1& A1, const Standard_Real Ang)
{
  loc.Rotate(A1, Ang);
  vdir.Rotate(A1 , Ang);
}

inline gp_Ax1 gp_Ax1::Rotated (const gp_Ax1& A1,
   const Standard_Real Ang) const
{
  gp_Ax1 A = *this;
  A.Rotate (A1, Ang);
  return A;
}

inline void gp_Ax1::Scale (const gp_Pnt& P,
      const Standard_Real S)
{
  loc.Scale (P, S);
  if (S < 0.0) vdir.Reverse();
}

inline gp_Ax1 gp_Ax1::Scaled (const gp_Pnt& P,
         const Standard_Real S) const
{
  gp_Ax1 A1 = *this;
  A1.Scale (P, S);
  return A1;
}

inline void gp_Ax1::Transform (const gp_Trsf& T)
{
   loc.Transform(T);
   vdir.Transform(T);
}

inline gp_Ax1 gp_Ax1::Transformed (const gp_Trsf& T) const
{
  gp_Ax1 A1 = *this;
  A1.Transform (T);
  return A1;
}

inline void gp_Ax1::Translate (const gp_Vec& V)
{ loc.Translate (V); }

inline gp_Ax1 gp_Ax1::Translated (const gp_Vec& V) const
{
  gp_Ax1 A1 = *this;
  (A1.loc).Translate (V);
  return A1;
}

inline void gp_Ax1::Translate (const gp_Pnt& P1,
          const gp_Pnt& P2)
{
  loc.Translate (P1, P2);
}

inline gp_Ax1 gp_Ax1::Translated (const gp_Pnt& P1,
      const gp_Pnt& P2) const
{
  gp_Ax1 A1 = *this;
  (A1.loc).Translate (P1, P2);
  return A1;
}
# 232 "/usr/include/opencascade/gp_Ax1.hxx" 2
# 23 "/usr/include/opencascade/gp_Ax2.hxx" 2



class Standard_ConstructionError;
class gp_Pnt;
class gp_Dir;
class gp_Ax1;
class gp_Trsf;
class gp_Vec;
# 63 "/usr/include/opencascade/gp_Ax2.hxx"
class gp_Ax2
{
public:

  void* operator new (size_t theSize) { return Standard::Allocate (theSize); } void operator delete (void* theAddress) { Standard::Free (theAddress); } void* operator new[] (size_t theSize) { return Standard::Allocate (theSize); } void operator delete[] (void* theAddress) { Standard::Free (theAddress); } void* operator new (size_t, void* theAddress) { return theAddress; } void operator delete (void*, void*) { }




    gp_Ax2();
# 81 "/usr/include/opencascade/gp_Ax2.hxx"
    gp_Ax2(const gp_Pnt& P, const gp_Dir& N, const gp_Dir& Vx);





  gp_Ax2(const gp_Pnt& P, const gp_Dir& V);
# 97 "/usr/include/opencascade/gp_Ax2.hxx"
  void SetAxis (const gp_Ax1& A1);
# 107 "/usr/include/opencascade/gp_Ax2.hxx"
  void SetDirection (const gp_Dir& V);



  void SetLocation (const gp_Pnt& P);
# 121 "/usr/include/opencascade/gp_Ax2.hxx"
  void SetXDirection (const gp_Dir& Vx);
# 132 "/usr/include/opencascade/gp_Ax2.hxx"
  void SetYDirection (const gp_Dir& Vy);





  Standard_Real Angle (const gp_Ax2& Other) const;




    const gp_Ax1& Axis() const;



    const gp_Dir& Direction() const;



    const gp_Pnt& Location() const;



    const gp_Dir& XDirection() const;



    const gp_Dir& YDirection() const;

  Standard_Boolean IsCoplanar (const gp_Ax2& Other, const Standard_Real LinearTolerance, const Standard_Real AngularTolerance) const;







    Standard_Boolean IsCoplanar (const gp_Ax1& A1, const Standard_Real LinearTolerance, const Standard_Real AngularTolerance) const;
# 187 "/usr/include/opencascade/gp_Ax2.hxx"
  void Mirror (const gp_Pnt& P);
# 205 "/usr/include/opencascade/gp_Ax2.hxx"
  [[nodiscard]] gp_Ax2 Mirrored (const gp_Pnt& P) const;
# 223 "/usr/include/opencascade/gp_Ax2.hxx"
  void Mirror (const gp_Ax1& A1);
# 241 "/usr/include/opencascade/gp_Ax2.hxx"
  [[nodiscard]] gp_Ax2 Mirrored (const gp_Ax1& A1) const;
# 260 "/usr/include/opencascade/gp_Ax2.hxx"
  void Mirror (const gp_Ax2& A2);
# 279 "/usr/include/opencascade/gp_Ax2.hxx"
  [[nodiscard]] gp_Ax2 Mirrored (const gp_Ax2& A2) const;

    void Rotate (const gp_Ax1& A1, const Standard_Real Ang);





    [[nodiscard]] gp_Ax2 Rotated (const gp_Ax1& A1, const Standard_Real Ang) const;

    void Scale (const gp_Pnt& P, const Standard_Real S);
# 299 "/usr/include/opencascade/gp_Ax2.hxx"
    [[nodiscard]] gp_Ax2 Scaled (const gp_Pnt& P, const Standard_Real S) const;

    void Transform (const gp_Trsf& T);







    [[nodiscard]] gp_Ax2 Transformed (const gp_Trsf& T) const;

    void Translate (const gp_Vec& V);




    [[nodiscard]] gp_Ax2 Translated (const gp_Vec& V) const;

    void Translate (const gp_Pnt& P1, const gp_Pnt& P2);




    [[nodiscard]] gp_Ax2 Translated (const gp_Pnt& P1, const gp_Pnt& P2) const;



  void DumpJson (Standard_OStream& theOStream, Standard_Integer theDepth = -1) const;


  Standard_Boolean InitFromJson (const Standard_SStream& theSStream, Standard_Integer& theStreamPos);



protected:





private:



  gp_Ax1 axis;
  gp_Dir vydir;
  gp_Dir vxdir;


};


# 1 "/usr/include/opencascade/gp_Ax2.lxx" 1
# 15 "/usr/include/opencascade/gp_Ax2.lxx"
# 1 "/usr/include/opencascade/Precision.hxx" 1
# 98 "/usr/include/opencascade/Precision.hxx"
class Precision
{
public:

  void* operator new (size_t theSize) { return Standard::Allocate (theSize); } void operator delete (void* theAddress) { Standard::Free (theAddress); } void* operator new[] (size_t theSize) { return Standard::Allocate (theSize); } void operator delete[] (void* theAddress) { Standard::Free (theAddress); } void* operator new (size_t, void* theAddress) { return theAddress; } void operator delete (void*, void*) { }
# 123 "/usr/include/opencascade/Precision.hxx"
  static Standard_Real Angular() { return 1.e-12; }
# 165 "/usr/include/opencascade/Precision.hxx"
  static Standard_Real Confusion() { return 1.e-7; }



  static Standard_Real SquareConfusion() { return Confusion() * Confusion(); }
# 193 "/usr/include/opencascade/Precision.hxx"
  static Standard_Real Intersection() { return Confusion() * 0.01; }
# 208 "/usr/include/opencascade/Precision.hxx"
  static Standard_Real Approximation() { return Confusion() * 10.0; }






  static Standard_Real Parametric (const Standard_Real P, const Standard_Real T) { return P / T; }
# 261 "/usr/include/opencascade/Precision.hxx"
  static Standard_Real PConfusion (const Standard_Real T) { return Parametric (Confusion(), T); }



  static Standard_Real SquarePConfusion() { return PConfusion() * PConfusion(); }
# 280 "/usr/include/opencascade/Precision.hxx"
  static Standard_Real PIntersection (const Standard_Real T) { return Parametric(Intersection(),T); }
# 295 "/usr/include/opencascade/Precision.hxx"
  static Standard_Real PApproximation (const Standard_Real T) { return Parametric(Approximation(),T); }





  static Standard_Real Parametric (const Standard_Real P) { return Parametric (P, 100.0); }





  static Standard_Real PConfusion() { return Parametric (Confusion()); }





  static Standard_Real PIntersection() { return Parametric (Intersection()); }





  static Standard_Real PApproximation() { return Parametric (Approximation()); }



  static Standard_Boolean IsInfinite (const Standard_Real R) { return Abs (R) >= (0.5 * Precision::Infinite()); }



  static Standard_Boolean IsPositiveInfinite (const Standard_Real R) { return R >= (0.5 * Precision::Infinite()); }



  static Standard_Boolean IsNegativeInfinite (const Standard_Real R) { return R <= -(0.5 * Precision::Infinite()); }



  static Standard_Real Infinite() { return 2.e+100; }

};
# 16 "/usr/include/opencascade/gp_Ax2.lxx" 2

inline gp_Ax2::gp_Ax2()
  :
  vydir(0.,1.,0.)

{ }

inline gp_Ax2::gp_Ax2(const gp_Pnt& P,
        const gp_Dir& N,
        const gp_Dir& Vx) : axis(P, N), vydir(N), vxdir(N)
{
  vxdir.CrossCross(Vx, N);
  vydir.Cross(vxdir);
}

inline void gp_Ax2::SetAxis (const gp_Ax1& A1)
{
  Standard_Real a = A1.Direction() * vxdir;
  if(Abs(Abs(a) - 1.) <= Precision::Angular()) {
    if(a > 0.) {
      vxdir = vydir;
      vydir = axis.Direction();
      axis = A1;
    }
    else {
      vxdir = axis.Direction();
      axis = A1;
    }
  }
  else {
    axis = A1;
    vxdir = axis.Direction().CrossCrossed (vxdir, axis.Direction());
    vydir = axis.Direction().Crossed (vxdir);
  }
}

inline void gp_Ax2::SetDirection (const gp_Dir& V)
{
  Standard_Real a = V * vxdir;
  if(Abs(Abs(a) - 1.) <= Precision::Angular()) {
    if(a > 0.) {
      vxdir = vydir;
      vydir = axis.Direction();
      axis.SetDirection (V);
    }
    else {
      vxdir = axis.Direction();
      axis.SetDirection (V);
    }
  }
  else {
    axis.SetDirection (V);
    vxdir = V.CrossCrossed (vxdir, V);
    vydir = V.Crossed (vxdir);
  }
}

inline void gp_Ax2::SetLocation (const gp_Pnt& P)
{ axis.SetLocation(P); }

inline void gp_Ax2::SetXDirection (const gp_Dir& Vx)
{
  vxdir = axis.Direction().CrossCrossed (Vx, axis.Direction());
  vydir = axis.Direction().Crossed (vxdir);
}

inline void gp_Ax2::SetYDirection (const gp_Dir& Vy)
{
  vxdir = Vy.Crossed (axis.Direction());
  vydir = (axis.Direction()).Crossed (vxdir);
}

inline Standard_Real gp_Ax2::Angle (const gp_Ax2& Other) const
{ return axis.Angle (Other.axis); }

inline const gp_Ax1& gp_Ax2::Axis () const
{ return axis; }

inline const gp_Dir& gp_Ax2::Direction () const
{ return axis.Direction(); }

inline const gp_Pnt& gp_Ax2::Location () const
{ return axis.Location(); }

inline const gp_Dir& gp_Ax2::XDirection () const
{ return vxdir; }

inline const gp_Dir& gp_Ax2::YDirection () const
{ return vydir; }

inline Standard_Boolean gp_Ax2::IsCoplanar
(const gp_Ax2& Other,
 const Standard_Real LinearTolerance,
 const Standard_Real AngularTolerance) const
{
  const gp_Dir& DD = axis.Direction();
  const gp_Pnt& PP = axis.Location ();
  const gp_Pnt& OP = Other.axis.Location ();
  Standard_Real D1 = (DD.X() * (OP.X() - PP.X()) +
        DD.Y() * (OP.Y() - PP.Y()) +
        DD.Z() * (OP.Z() - PP.Z()));
  if (D1 < 0 ) D1 = - D1;
  return (D1 <= LinearTolerance &&
   axis.IsParallel (Other.axis, AngularTolerance));
}

inline Standard_Boolean gp_Ax2::IsCoplanar
(const gp_Ax1& A,
 const Standard_Real LinearTolerance,
 const Standard_Real AngularTolerance) const
{
  const gp_Dir& DD = axis.Direction();
  const gp_Pnt& PP = axis.Location ();
  const gp_Pnt& AP = A .Location ();
  Standard_Real D1 = (DD.X() * (AP.X() - PP.X()) +
        DD.Y() * (AP.Y() - PP.Y()) +
        DD.Z() * (AP.Z() - PP.Z()));
  if (D1 < 0) D1 = - D1;
  return (D1 <= LinearTolerance &&
   axis.IsNormal (A, AngularTolerance));
}

inline void gp_Ax2::Rotate(const gp_Ax1& A1, const Standard_Real Ang)
{
  gp_Pnt Temp = axis.Location();
  Temp.Rotate (A1, Ang);
  axis.SetLocation (Temp);
  vxdir.Rotate (A1, Ang);
  vydir.Rotate (A1, Ang);
  axis.SetDirection (vxdir.Crossed (vydir));
}

inline gp_Ax2 gp_Ax2::Rotated(const gp_Ax1& A1,
         const Standard_Real Ang) const
{
  gp_Ax2 Temp = *this;
  Temp.Rotate (A1, Ang);
  return Temp;
}

inline void gp_Ax2::Scale (const gp_Pnt& P, const Standard_Real S)
{
  gp_Pnt Temp = axis.Location();
  Temp.Scale (P, S);
  axis.SetLocation (Temp);
  if (S < 0.0) {
    vxdir.Reverse ();
    vydir.Reverse ();
  }
}

inline gp_Ax2 gp_Ax2::Scaled(const gp_Pnt& P,
        const Standard_Real S) const
{
  gp_Ax2 Temp = *this;
  Temp.Scale (P, S);
  return Temp;
}

inline void gp_Ax2::Transform (const gp_Trsf& T)
{
  gp_Pnt Temp = axis.Location();
  Temp.Transform (T);
  axis.SetLocation (Temp);
  vxdir.Transform (T);
  vydir.Transform (T);
  axis.SetDirection (vxdir.Crossed (vydir));
}

inline gp_Ax2 gp_Ax2::Transformed(const gp_Trsf& T) const
{
  gp_Ax2 Temp = *this;
  Temp.Transform (T);
  return Temp;
}

inline void gp_Ax2::Translate (const gp_Vec& V)
{ axis.Translate (V); }

inline gp_Ax2 gp_Ax2::Translated(const gp_Vec& V) const
{
  gp_Ax2 Temp = *this;
  Temp.Translate (V);
  return Temp;
}

inline void gp_Ax2::Translate (const gp_Pnt& P1, const gp_Pnt& P2)
{ axis.Translate (P1, P2); }

inline gp_Ax2 gp_Ax2::Translated (const gp_Pnt& P1,
      const gp_Pnt& P2) const
{
  gp_Ax2 Temp = *this;
  Temp.Translate (P1, P2);
  return Temp;
}
# 353 "/usr/include/opencascade/gp_Ax2.hxx" 2
# 36 "/usr/include/opencascade/Graphic3d_Group.hxx" 2
# 1 "/usr/include/opencascade/TCollection_ExtendedString.hxx" 1
# 24 "/usr/include/opencascade/TCollection_ExtendedString.hxx"
# 1 "/usr/include/opencascade/Standard_PExtCharacter.hxx" 1
# 19 "/usr/include/opencascade/Standard_PExtCharacter.hxx"
typedef Standard_ExtCharacter* Standard_PExtCharacter;
# 25 "/usr/include/opencascade/TCollection_ExtendedString.hxx" 2
# 34 "/usr/include/opencascade/TCollection_ExtendedString.hxx"
class Standard_NullObject;
class Standard_OutOfRange;
class Standard_NumericError;
class Standard_NegativeValue;
class TCollection_AsciiString;
# 56 "/usr/include/opencascade/TCollection_ExtendedString.hxx"
class TCollection_ExtendedString
{
public:

  void* operator new (size_t theSize) { return Standard::Allocate (theSize); } void operator delete (void* theAddress) { Standard::Free (theAddress); } void* operator new[] (size_t theSize) { return Standard::Allocate (theSize); } void operator delete[] (void* theAddress) { Standard::Free (theAddress); } void* operator new (size_t, void* theAddress) { return theAddress; } void operator delete (void*, void*) { }



  TCollection_ExtendedString();






  TCollection_ExtendedString(const Standard_CString astring, const Standard_Boolean isMultiByte = false);


  TCollection_ExtendedString(const Standard_ExtString astring);







  TCollection_ExtendedString (const Standard_WideChar* theStringUtf);



  TCollection_ExtendedString(const Standard_Character aChar);


  TCollection_ExtendedString(const Standard_ExtCharacter aChar);



  TCollection_ExtendedString(const Standard_Integer length, const Standard_ExtCharacter filler);


  TCollection_ExtendedString(const Standard_Integer value);


  TCollection_ExtendedString(const Standard_Real value);


  TCollection_ExtendedString(const TCollection_ExtendedString& astring);



  TCollection_ExtendedString (TCollection_ExtendedString&& theOther)
  : mystring (theOther.mystring),
    mylength (theOther.mylength)
  {
    theOther.mystring = 
# 110 "/usr/include/opencascade/TCollection_ExtendedString.hxx" 3 4
                       __null
# 110 "/usr/include/opencascade/TCollection_ExtendedString.hxx"
                           ;
    theOther.mylength = 0;
  }






  TCollection_ExtendedString(const TCollection_AsciiString& astring, const Standard_Boolean isMultiByte = true);




  void AssignCat (const TCollection_ExtendedString& other);
void operator += (const TCollection_ExtendedString& other)
{
  AssignCat(other);
}


  void AssignCat (const Standard_Utf16Char theChar);


  TCollection_ExtendedString Cat (const TCollection_ExtendedString& other) const;
TCollection_ExtendedString operator + (const TCollection_ExtendedString& other) const
{
  return Cat(other);
}






  void ChangeAll (const Standard_ExtCharacter aChar, const Standard_ExtCharacter NewChar);



  void Clear();



  void Copy (const TCollection_ExtendedString& fromwhere);
void operator = (const TCollection_ExtendedString& fromwhere)
{
  Copy(fromwhere);
}


  void Swap (TCollection_ExtendedString& theOther);



  TCollection_ExtendedString& operator= (TCollection_ExtendedString&& theOther) { Swap (theOther); return *this; }



  ~TCollection_ExtendedString();


  void Insert (const Standard_Integer where, const Standard_ExtCharacter what);


  void Insert (const Standard_Integer where, const TCollection_ExtendedString& what);


  Standard_Boolean IsEmpty() const { return mylength == 0; }




  Standard_Boolean IsEqual (const Standard_ExtString other) const;
Standard_Boolean operator == (const Standard_ExtString other) const
{
  return IsEqual(other);
}




  Standard_Boolean IsEqual (const TCollection_ExtendedString& other) const;
Standard_Boolean operator == (const TCollection_ExtendedString& other) const
{
  return IsEqual(other);
}




  Standard_Boolean IsDifferent (const Standard_ExtString other) const;
Standard_Boolean operator != (const Standard_ExtString other) const
{
  return IsDifferent(other);
}




  Standard_Boolean IsDifferent (const TCollection_ExtendedString& other) const;
Standard_Boolean operator != (const TCollection_ExtendedString& other) const
{
  return IsDifferent(other);
}


  Standard_Boolean IsLess (const Standard_ExtString other) const;
Standard_Boolean operator < (const Standard_ExtString other) const
{
  return IsLess(other);
}


  Standard_Boolean IsLess (const TCollection_ExtendedString& other) const;
Standard_Boolean operator < (const TCollection_ExtendedString& other) const
{
  return IsLess(other);
}


  Standard_Boolean IsGreater (const Standard_ExtString other) const;
Standard_Boolean operator > (const Standard_ExtString other) const
{
  return IsGreater(other);
}


  Standard_Boolean IsGreater (const TCollection_ExtendedString& other) const;
Standard_Boolean operator > (const TCollection_ExtendedString& other) const
{
  return IsGreater(other);
}


  Standard_Boolean StartsWith (const TCollection_ExtendedString& theStartString) const;


  Standard_Boolean EndsWith (const TCollection_ExtendedString& theEndString) const;



  Standard_Boolean IsAscii() const;



  Standard_Integer Length() const;


  void Print (Standard_OStream& astream) const;
friend Standard_OStream& operator << (Standard_OStream& astream,const TCollection_ExtendedString& astring);


  void RemoveAll (const Standard_ExtCharacter what);


  void Remove (const Standard_Integer where, const Standard_Integer ahowmany = 1);




  Standard_Integer Search (const TCollection_ExtendedString& what) const;




  Standard_Integer SearchFromEnd (const TCollection_ExtendedString& what) const;




  void SetValue (const Standard_Integer where, const Standard_ExtCharacter what);


  void SetValue (const Standard_Integer where, const TCollection_ExtendedString& what);
# 295 "/usr/include/opencascade/TCollection_ExtendedString.hxx"
  TCollection_ExtendedString Split (const Standard_Integer where);
# 312 "/usr/include/opencascade/TCollection_ExtendedString.hxx"
  TCollection_ExtendedString Token (const Standard_ExtString separators, const Standard_Integer whichone = 1) const;


  Standard_ExtString ToExtString() const;
# 329 "/usr/include/opencascade/TCollection_ExtendedString.hxx"
  void Trunc (const Standard_Integer ahowmany);
# 340 "/usr/include/opencascade/TCollection_ExtendedString.hxx"
  Standard_ExtCharacter Value (const Standard_Integer where) const;







  static Standard_Integer HashCode (const TCollection_ExtendedString& theString,
                                    const Standard_Integer theUpperBound)
  {
    return ::HashCode (theString.ToExtString(), theUpperBound);
  }




  static Standard_Boolean IsEqual (const TCollection_ExtendedString& theString1,
                                   const TCollection_ExtendedString& theString2)
  {
    return theString1.IsEqual (theString2);
  }




  Standard_Integer ToUTF8CString (Standard_PCharacter& theCString) const;




  Standard_Integer LengthOfCString() const;

private:



  Standard_Boolean ConvertToUnicode (const Standard_CString astring);

private:

  Standard_PExtCharacter mystring;
  Standard_Integer mylength;

};





inline Standard_Integer HashCode (const TCollection_ExtendedString& theExtendedString,
                                  const Standard_Integer theUpperBound)
{
  return TCollection_ExtendedString::HashCode (theExtendedString, theUpperBound);
}
# 37 "/usr/include/opencascade/Graphic3d_Group.hxx" 2

class Graphic3d_Structure;
class Graphic3d_ArrayOfPrimitives;
class Graphic3d_Text;
# 72 "/usr/include/opencascade/Graphic3d_Group.hxx"
class Graphic3d_Group : public Standard_Transient
{
  friend class Graphic3d_Structure;
  public: typedef Standard_Transient base_type; static const char* get_type_name () { return "Graphic3d_Group"; using direct_base_classes = opencascade::direct_base_class_as_tuple<std::tr2::direct_bases<Graphic3d_Group>::type>::type; static_assert(opencascade::has_type<Standard_Transient, direct_base_classes>::type::value, "OCCT RTTI definition is incorrect: " "Standard_Transient" " is not direct base class of " "Graphic3d_Group"); static_assert(&get_type_name == &Graphic3d_Group::get_type_name, "OCCT RTTI definition is misplaced: current class is not " "Graphic3d_Group"); } static const opencascade::handle<Standard_Type>& get_type_descriptor (); virtual const opencascade::handle<Standard_Type>& DynamicType() const override;

public:
# 86 "/usr/include/opencascade/Graphic3d_Group.hxx"
  virtual void Clear (const Standard_Boolean theUpdateStructureMgr = true);


  virtual ~Graphic3d_Group();





  void Remove();

public:


  virtual opencascade::handle<Graphic3d_Aspects> Aspects() const = 0;


  virtual void SetGroupPrimitivesAspect (const opencascade::handle<Graphic3d_Aspects>& theAspect) = 0;


  virtual void SetPrimitivesAspect (const opencascade::handle<Graphic3d_Aspects>& theAspect) = 0;


  virtual void SynchronizeAspects() = 0;


  virtual void ReplaceAspects (const Graphic3d_MapOfAspectsToAspects& theMap) = 0;


  virtual void AddText (const opencascade::handle<Graphic3d_Text>& theTextParams,
                                        const Standard_Boolean theToEvalMinMax = true);


  virtual void AddPrimitiveArray (const Graphic3d_TypeOfPrimitiveArray theType,
                                                  const opencascade::handle<Graphic3d_IndexBuffer>& theIndices,
                                                  const opencascade::handle<Graphic3d_Buffer>& theAttribs,
                                                  const opencascade::handle<Graphic3d_BoundBuffer>& theBounds,
                                                  const Standard_Boolean theToEvalMinMax = true);


  void AddPrimitiveArray (const opencascade::handle<Graphic3d_ArrayOfPrimitives>& thePrim, const Standard_Boolean theToEvalMinMax = true);


  void Marker (const Graphic3d_Vertex& thePoint, const Standard_Boolean theToEvalMinMax = true);

public:


  virtual void SetStencilTestOptions (const Standard_Boolean theIsEnabled) = 0;


  virtual void SetFlippingOptions (const Standard_Boolean theIsEnabled, const gp_Ax2& theRefPlane) = 0;


  bool ContainsFacet() const { return myContainsFacet; }




  Standard_Boolean IsDeleted() const;


  Standard_Boolean IsEmpty() const;


  void MinMaxValues (Standard_Real& theXMin, Standard_Real& theYMin, Standard_Real& theZMin,
                                     Standard_Real& theXMax, Standard_Real& theYMax, Standard_Real& theZMax) const;


  void SetMinMaxValues (const Standard_Real theXMin, const Standard_Real theYMin, const Standard_Real theZMin,
                                        const Standard_Real theXMax, const Standard_Real theYMax, const Standard_Real theZMax);


  const Graphic3d_BndBox4f& BoundingBox() const { return myBounds; }


  Graphic3d_BndBox4f& ChangeBoundingBox() { return myBounds; }


  opencascade::handle<Graphic3d_Structure> Structure() const;


  void SetClosed (const bool theIsClosed) { myIsClosed = theIsClosed; }


  bool IsClosed() const { return myIsClosed; }


public:
# 186 "/usr/include/opencascade/Graphic3d_Group.hxx"
  __attribute__((deprecated("Deprecated method Text() with obsolete arguments, use AddText() instead of it")))
  virtual void Text (const Standard_CString AText,
                                     const Graphic3d_Vertex& APoint,
                                     const Standard_Real AHeight,
                                     const Standard_Real AAngle,
                                     const Graphic3d_TextPath ATp,
                                     const Graphic3d_HorizontalTextAlignment AHta,
                                     const Graphic3d_VerticalTextAlignment AVta,
                                     const Standard_Boolean EvalMinMax = true);
# 209 "/usr/include/opencascade/Graphic3d_Group.hxx"
  __attribute__((deprecated("Deprecated method Text() with obsolete arguments, use AddText() instead of it")))
  void Text (const Standard_CString AText,
                             const Graphic3d_Vertex& APoint,
                             const Standard_Real AHeight,
                             const Standard_Boolean EvalMinMax = true);
# 225 "/usr/include/opencascade/Graphic3d_Group.hxx"
  __attribute__((deprecated("Deprecated method Text() with obsolete arguments, use AddText() instead of it")))
  void Text (const TCollection_ExtendedString& AText,
                             const Graphic3d_Vertex& APoint,
                             const Standard_Real AHeight,
                             const Standard_Real AAngle,
                             const Graphic3d_TextPath ATp,
                             const Graphic3d_HorizontalTextAlignment AHta,
                             const Graphic3d_VerticalTextAlignment AVta,
                             const Standard_Boolean EvalMinMax = true);
# 248 "/usr/include/opencascade/Graphic3d_Group.hxx"
  __attribute__((deprecated("Deprecated method Text() with obsolete arguments, use AddText() instead of it")))
  void Text (const TCollection_ExtendedString& AText,
                             const Graphic3d_Vertex& APoint,
                             const Standard_Real AHeight,
                             const Standard_Boolean EvalMinMax = true);


  __attribute__((deprecated("Deprecated method Text() with obsolete arguments, use AddText() instead of it")))
  virtual void Text (const Standard_CString theTextUtf,
                                     const gp_Ax2& theOrientation,
                                     const Standard_Real theHeight,
                                     const Standard_Real theAngle,
                                     const Graphic3d_TextPath theTp,
                                     const Graphic3d_HorizontalTextAlignment theHTA,
                                     const Graphic3d_VerticalTextAlignment theVTA,
                                     const Standard_Boolean theToEvalMinMax = true,
                                     const Standard_Boolean theHasOwnAnchor = true);


  __attribute__((deprecated("Deprecated method Text() with obsolete arguments, use AddText() instead of it")))
  virtual void Text (const TCollection_ExtendedString& theText,
                                     const gp_Ax2& theOrientation,
                                     const Standard_Real theHeight,
                                     const Standard_Real theAngle,
                                     const Graphic3d_TextPath theTp,
                                     const Graphic3d_HorizontalTextAlignment theHTA,
                                     const Graphic3d_VerticalTextAlignment theVTA,
                                     const Standard_Boolean theToEvalMinMax = true,
                                     const Standard_Boolean theHasOwnAnchor = true);



  virtual void DumpJson (Standard_OStream& theOStream, Standard_Integer theDepth = -1) const;

protected:


  Graphic3d_Group(const opencascade::handle<Graphic3d_Structure>& theStructure);



  void Update() const;

protected:

  Graphic3d_Structure* myStructure;
  Graphic3d_BndBox4f myBounds;
  bool myIsClosed;
  bool myContainsFacet;

};

class Graphic3d_Group; typedef opencascade::handle<Graphic3d_Group> Handle_Graphic3d_Group;
# 20 "/usr/include/opencascade/Graphic3d_CStructure.hxx" 2

# 1 "/usr/include/opencascade/Graphic3d_SequenceOfGroup.hxx" 1
# 22 "/usr/include/opencascade/Graphic3d_SequenceOfGroup.hxx"
typedef NCollection_Sequence<opencascade::handle<Graphic3d_Group> > Graphic3d_SequenceOfGroup;
# 22 "/usr/include/opencascade/Graphic3d_CStructure.hxx" 2
# 1 "/usr/include/opencascade/Graphic3d_SequenceOfHClipPlane.hxx" 1
# 20 "/usr/include/opencascade/Graphic3d_SequenceOfHClipPlane.hxx"
# 1 "/usr/include/opencascade/Graphic3d_ClipPlane.hxx" 1
# 20 "/usr/include/opencascade/Graphic3d_ClipPlane.hxx"
# 1 "/usr/include/opencascade/gp_Pln.hxx" 1
# 22 "/usr/include/opencascade/gp_Pln.hxx"
# 1 "/usr/include/opencascade/gp_Ax3.hxx" 1
# 28 "/usr/include/opencascade/gp_Ax3.hxx"
class Standard_ConstructionError;
class gp_Ax2;
class gp_Pnt;
class gp_Dir;
class gp_Ax1;
class gp_Trsf;
class gp_Vec;
# 71 "/usr/include/opencascade/gp_Ax3.hxx"
class gp_Ax3
{
public:

  void* operator new (size_t theSize) { return Standard::Allocate (theSize); } void operator delete (void* theAddress) { Standard::Free (theAddress); } void* operator new[] (size_t theSize) { return Standard::Allocate (theSize); } void operator delete[] (void* theAddress) { Standard::Free (theAddress); } void* operator new (size_t, void* theAddress) { return theAddress; } void operator delete (void*, void*) { }




  gp_Ax3();



  gp_Ax3(const gp_Ax2& A);





  gp_Ax3(const gp_Pnt& P, const gp_Dir& N, const gp_Dir& Vx);




  gp_Ax3(const gp_Pnt& P, const gp_Dir& V);


  void XReverse();


  void YReverse();


  void ZReverse();
# 118 "/usr/include/opencascade/gp_Ax3.hxx"
  void SetAxis (const gp_Ax1& A1);
# 130 "/usr/include/opencascade/gp_Ax3.hxx"
  void SetDirection (const gp_Dir& V);



  void SetLocation (const gp_Pnt& P);
# 143 "/usr/include/opencascade/gp_Ax3.hxx"
  void SetXDirection (const gp_Dir& Vx);
# 152 "/usr/include/opencascade/gp_Ax3.hxx"
    void SetYDirection (const gp_Dir& Vy);





    Standard_Real Angle (const gp_Ax3& Other) const;




    const gp_Ax1& Axis() const;







  gp_Ax2 Ax2() const;



    const gp_Dir& Direction() const;



    const gp_Pnt& Location() const;



    const gp_Dir& XDirection() const;



    const gp_Dir& YDirection() const;



    Standard_Boolean Direct() const;
# 201 "/usr/include/opencascade/gp_Ax3.hxx"
    Standard_Boolean IsCoplanar (const gp_Ax3& Other, const Standard_Real LinearTolerance, const Standard_Real AngularTolerance) const;







    Standard_Boolean IsCoplanar (const gp_Ax1& A1, const Standard_Real LinearTolerance, const Standard_Real AngularTolerance) const;

  void Mirror (const gp_Pnt& P);
# 221 "/usr/include/opencascade/gp_Ax3.hxx"
  [[nodiscard]] gp_Ax3 Mirrored (const gp_Pnt& P) const;

  void Mirror (const gp_Ax1& A1);
# 233 "/usr/include/opencascade/gp_Ax3.hxx"
  [[nodiscard]] gp_Ax3 Mirrored (const gp_Ax1& A1) const;

  void Mirror (const gp_Ax2& A2);
# 246 "/usr/include/opencascade/gp_Ax3.hxx"
  [[nodiscard]] gp_Ax3 Mirrored (const gp_Ax2& A2) const;

  void Rotate (const gp_Ax1& A1, const Standard_Real Ang);





  [[nodiscard]] gp_Ax3 Rotated (const gp_Ax1& A1, const Standard_Real Ang) const;

  void Scale (const gp_Pnt& P, const Standard_Real S);
# 266 "/usr/include/opencascade/gp_Ax3.hxx"
  [[nodiscard]] gp_Ax3 Scaled (const gp_Pnt& P, const Standard_Real S) const;

  void Transform (const gp_Trsf& T);







  [[nodiscard]] gp_Ax3 Transformed (const gp_Trsf& T) const;

  void Translate (const gp_Vec& V);




  [[nodiscard]] gp_Ax3 Translated (const gp_Vec& V) const;

  void Translate (const gp_Pnt& P1, const gp_Pnt& P2);




  [[nodiscard]] gp_Ax3 Translated (const gp_Pnt& P1, const gp_Pnt& P2) const;



  void DumpJson (Standard_OStream& theOStream, Standard_Integer theDepth = -1) const;


  Standard_Boolean InitFromJson (const Standard_SStream& theSStream, Standard_Integer& theStreamPos);

protected:





private:



  gp_Ax1 axis;
  gp_Dir vydir;
  gp_Dir vxdir;


};


# 1 "/usr/include/opencascade/gp_Ax3.lxx" 1
# 17 "/usr/include/opencascade/gp_Ax3.lxx"
inline gp_Ax3::gp_Ax3()
  :
  vydir(0.,1.,0.)

{ }

inline gp_Ax3::gp_Ax3(const gp_Ax2& A) :
axis(A.Axis()),
vydir(A.YDirection()),
vxdir(A.XDirection())
{ }

inline gp_Ax3::gp_Ax3(const gp_Pnt& P, const gp_Dir& N, const gp_Dir& Vx) :
axis(P, N), vydir(N), vxdir(N)
{
  vxdir.CrossCross(Vx, N);
  vydir.Cross(vxdir);
}

inline void gp_Ax3::XReverse()
{ vxdir.Reverse(); }

inline void gp_Ax3::YReverse()
{ vydir.Reverse(); }

inline void gp_Ax3::ZReverse()
{ axis.Reverse(); }

inline void gp_Ax3::SetAxis(const gp_Ax1& A1)
{
  Standard_Boolean direct = Direct();
  axis = A1;
  vxdir = axis.Direction().CrossCrossed (vxdir, axis.Direction());
  if(direct) { vydir = axis.Direction().Crossed(vxdir); }
  else { vydir = vxdir.Crossed(axis.Direction()); }
}

inline void gp_Ax3::SetDirection(const gp_Dir& V)
{
  Standard_Boolean direct = Direct();
  axis.SetDirection (V);
  vxdir = V.CrossCrossed (vxdir, V);
  if (direct) { vydir = V.Crossed (vxdir); }
  else { vydir = vxdir.Crossed (V); }
}

inline void gp_Ax3::SetLocation(const gp_Pnt& P)
{ axis.SetLocation(P); }

inline void gp_Ax3::SetXDirection(const gp_Dir& Vx)
{
  Standard_Boolean direct = Direct();
  vxdir = axis.Direction().CrossCrossed (Vx, axis.Direction());
  if (direct) { vydir = axis.Direction().Crossed(vxdir); }
  else { vydir = vxdir.Crossed(axis.Direction()); }
}

inline void gp_Ax3::SetYDirection(const gp_Dir& Vy)
{
  Standard_Boolean direct = Direct();
  vxdir = Vy.Crossed (axis.Direction());
  vydir = (axis.Direction()).Crossed (vxdir);
  if (!direct) { vxdir.Reverse(); }
}

inline Standard_Real gp_Ax3::Angle(const gp_Ax3& Other) const
{ return axis.Angle (Other.axis); }

inline const gp_Ax1& gp_Ax3::Axis()const
{ return axis; }

inline gp_Ax2 gp_Ax3::Ax2()const
{
  gp_Dir zz = axis.Direction();
  if (!Direct()) { zz.Reverse(); }
  return gp_Ax2 (axis.Location(),zz,vxdir);
}

inline const gp_Dir& gp_Ax3::Direction()const
{ return axis.Direction(); }

inline const gp_Pnt& gp_Ax3::Location()const
{ return axis.Location(); }

inline const gp_Dir& gp_Ax3::XDirection()const
{ return vxdir; }

inline const gp_Dir& gp_Ax3::YDirection()const
{ return vydir; }

inline Standard_Boolean gp_Ax3::Direct()const
{ return (vxdir.Crossed(vydir).Dot(axis.Direction()) > 0.); }

inline Standard_Boolean gp_Ax3::IsCoplanar
(const gp_Ax3& Other,
 const Standard_Real LinearTolerance,
 const Standard_Real AngularTolerance)const
{
  gp_Vec vec(axis.Location(),Other.axis.Location());
  Standard_Real D1 = gp_Vec(axis.Direction() ).Dot(vec);
  if (D1 < 0) D1 = - D1;
  Standard_Real D2 = gp_Vec(Other.axis.Direction()).Dot(vec);
  if (D2 < 0) D2 = - D2;
  return (D1 <= LinearTolerance && D2 <= LinearTolerance &&
          axis.IsParallel (Other.axis, AngularTolerance));
}

inline Standard_Boolean gp_Ax3::IsCoplanar
(const gp_Ax1& A1,
 const Standard_Real LinearTolerance,
 const Standard_Real AngularTolerance)const
{
  gp_Vec vec(axis.Location(),A1.Location());
  Standard_Real D1 = gp_Vec(axis.Direction()).Dot(vec);
  if (D1 < 0) D1 = - D1;
  Standard_Real D2 = (gp_Vec(A1.Direction()).Crossed(vec)).Magnitude();
  if (D2 < 0) D2 = - D2;
  return (D1 <= LinearTolerance && D2 <= LinearTolerance &&
          axis.IsNormal (A1, AngularTolerance));
}

inline void gp_Ax3::Rotate(const gp_Ax1& A1,
       const Standard_Real Ang)
{
  axis.Rotate (A1,Ang);
  vxdir.Rotate (A1,Ang);
  vydir.Rotate (A1,Ang);
}

inline gp_Ax3 gp_Ax3::Rotated(const gp_Ax1& A1,
          const Standard_Real Ang)const
{
  gp_Ax3 Temp = *this;
  Temp.Rotate (A1,Ang);
  return Temp;
}

inline void gp_Ax3::Scale(const gp_Pnt& P, const Standard_Real S)
{
  axis.Scale (P,S);
  if (S < 0.) {
    vxdir.Reverse ();
    vydir.Reverse ();
  }
}

inline gp_Ax3 gp_Ax3::Scaled(const gp_Pnt& P,
         const Standard_Real S)const
{
  gp_Ax3 Temp = *this;
  Temp.Scale (P,S);
  return Temp;
}

inline void gp_Ax3::Transform(const gp_Trsf& T)
{
  axis.Transform (T);
  vxdir.Transform (T);
  vydir.Transform (T);
}

inline gp_Ax3 gp_Ax3::Transformed(const gp_Trsf& T)const
{
  gp_Ax3 Temp = *this;
  Temp.Transform (T);
  return Temp;
}

inline void gp_Ax3::Translate(const gp_Vec& V)
{ axis.Translate (V); }

inline gp_Ax3 gp_Ax3::Translated(const gp_Vec& V)const
{
  gp_Ax3 Temp = *this;
  Temp.Translate (V);
  return Temp;
}

inline void gp_Ax3::Translate(const gp_Pnt& P1, const gp_Pnt& P2)
{ Translate(gp_Vec(P1,P2)); }

inline gp_Ax3 gp_Ax3::Translated(const gp_Pnt& P1, const gp_Pnt& P2)const
{ return Translated(gp_Vec(P1,P2)); }
# 318 "/usr/include/opencascade/gp_Ax3.hxx" 2
# 23 "/usr/include/opencascade/gp_Pln.hxx" 2



class Standard_ConstructionError;
class gp_Ax3;
class gp_Pnt;
class gp_Dir;
class gp_Ax1;
class gp_Lin;
class gp_Ax2;
class gp_Trsf;
class gp_Vec;
# 58 "/usr/include/opencascade/gp_Pln.hxx"
class gp_Pln
{
public:

  void* operator new (size_t theSize) { return Standard::Allocate (theSize); } void operator delete (void* theAddress) { Standard::Free (theAddress); } void* operator new[] (size_t theSize) { return Standard::Allocate (theSize); } void operator delete[] (void* theAddress) { Standard::Free (theAddress); } void* operator new (size_t, void* theAddress) { return theAddress; } void operator delete (void*, void*) { }




    gp_Pln();
# 76 "/usr/include/opencascade/gp_Pln.hxx"
    gp_Pln(const gp_Ax3& A3);




  gp_Pln(const gp_Pnt& P, const gp_Dir& V);





  gp_Pln(const Standard_Real A, const Standard_Real B, const Standard_Real C, const Standard_Real D);




    void Coefficients (Standard_Real& A, Standard_Real& B, Standard_Real& C, Standard_Real& D) const;





    void SetAxis (const gp_Ax1& A1);


    void SetLocation (const gp_Pnt& Loc);


    void SetPosition (const gp_Ax3& A3);



    void UReverse();



    void VReverse();


    Standard_Boolean Direct() const;


    const gp_Ax1& Axis() const;


    const gp_Pnt& Location() const;


    const gp_Ax3& Position() const;


    Standard_Real Distance (const gp_Pnt& P) const;


    Standard_Real Distance (const gp_Lin& L) const;


    Standard_Real Distance (const gp_Pln& Other) const;



    Standard_Real SquareDistance (const gp_Pnt& P) const;



    Standard_Real SquareDistance (const gp_Lin& L) const;



    Standard_Real SquareDistance (const gp_Pln& Other) const;


    gp_Ax1 XAxis() const;


    gp_Ax1 YAxis() const;
# 161 "/usr/include/opencascade/gp_Pln.hxx"
    Standard_Boolean Contains (const gp_Pnt& P, const Standard_Real LinearTolerance) const;
# 171 "/usr/include/opencascade/gp_Pln.hxx"
    Standard_Boolean Contains (const gp_Lin& L, const Standard_Real LinearTolerance, const Standard_Real AngularTolerance) const;

  void Mirror (const gp_Pnt& P);







  [[nodiscard]] gp_Pln Mirrored (const gp_Pnt& P) const;

  void Mirror (const gp_Ax1& A1);
# 193 "/usr/include/opencascade/gp_Pln.hxx"
  [[nodiscard]] gp_Pln Mirrored (const gp_Ax1& A1) const;

  void Mirror (const gp_Ax2& A2);
# 205 "/usr/include/opencascade/gp_Pln.hxx"
  [[nodiscard]] gp_Pln Mirrored (const gp_Ax2& A2) const;

    void Rotate (const gp_Ax1& A1, const Standard_Real Ang);




    [[nodiscard]] gp_Pln Rotated (const gp_Ax1& A1, const Standard_Real Ang) const;

    void Scale (const gp_Pnt& P, const Standard_Real S);



    [[nodiscard]] gp_Pln Scaled (const gp_Pnt& P, const Standard_Real S) const;

    void Transform (const gp_Trsf& T);







    [[nodiscard]] gp_Pln Transformed (const gp_Trsf& T) const;

    void Translate (const gp_Vec& V);




    [[nodiscard]] gp_Pln Translated (const gp_Vec& V) const;

    void Translate (const gp_Pnt& P1, const gp_Pnt& P2);



    [[nodiscard]] gp_Pln Translated (const gp_Pnt& P1, const gp_Pnt& P2) const;



  void DumpJson (Standard_OStream& theOStream, Standard_Integer theDepth = -1) const;



protected:





private:



  gp_Ax3 pos;


};


# 1 "/usr/include/opencascade/gp_Pln.lxx" 1
# 17 "/usr/include/opencascade/gp_Pln.lxx"
# 1 "/usr/include/opencascade/gp_Lin.hxx" 1
# 25 "/usr/include/opencascade/gp_Lin.hxx"
class Standard_ConstructionError;
class gp_Ax1;
class gp_Pnt;
class gp_Dir;
class gp_Ax2;
class gp_Trsf;
class gp_Vec;
# 49 "/usr/include/opencascade/gp_Lin.hxx"
class gp_Lin
{
public:

  void* operator new (size_t theSize) { return Standard::Allocate (theSize); } void operator delete (void* theAddress) { Standard::Free (theAddress); } void* operator new[] (size_t theSize) { return Standard::Allocate (theSize); } void operator delete[] (void* theAddress) { Standard::Free (theAddress); } void* operator new (size_t, void* theAddress) { return theAddress; } void operator delete (void*, void*) { }




    gp_Lin();


    gp_Lin(const gp_Ax1& A1);




  gp_Lin(const gp_Pnt& P, const gp_Dir& V);

    void Reverse();





    [[nodiscard]] gp_Lin Reversed() const;


    void SetDirection (const gp_Dir& V);


    void SetLocation (const gp_Pnt& P);





    void SetPosition (const gp_Ax1& A1);


    const gp_Dir& Direction() const;



    const gp_Pnt& Location() const;




    const gp_Ax1& Position() const;


    Standard_Real Angle (const gp_Lin& Other) const;




    Standard_Boolean Contains (const gp_Pnt& P, const Standard_Real LinearTolerance) const;


    Standard_Real Distance (const gp_Pnt& P) const;


  Standard_Real Distance (const gp_Lin& Other) const;



    Standard_Real SquareDistance (const gp_Pnt& P) const;


    Standard_Real SquareDistance (const gp_Lin& Other) const;







    gp_Lin Normal (const gp_Pnt& P) const;

  void Mirror (const gp_Pnt& P);





  [[nodiscard]] gp_Lin Mirrored (const gp_Pnt& P) const;

  void Mirror (const gp_Ax1& A1);





  [[nodiscard]] gp_Lin Mirrored (const gp_Ax1& A1) const;

  void Mirror (const gp_Ax2& A2);






  [[nodiscard]] gp_Lin Mirrored (const gp_Ax2& A2) const;

    void Rotate (const gp_Ax1& A1, const Standard_Real Ang);




    [[nodiscard]] gp_Lin Rotated (const gp_Ax1& A1, const Standard_Real Ang) const;

    void Scale (const gp_Pnt& P, const Standard_Real S);





    [[nodiscard]] gp_Lin Scaled (const gp_Pnt& P, const Standard_Real S) const;

    void Transform (const gp_Trsf& T);



    [[nodiscard]] gp_Lin Transformed (const gp_Trsf& T) const;

    void Translate (const gp_Vec& V);




    [[nodiscard]] gp_Lin Translated (const gp_Vec& V) const;

    void Translate (const gp_Pnt& P1, const gp_Pnt& P2);



    [[nodiscard]] gp_Lin Translated (const gp_Pnt& P1, const gp_Pnt& P2) const;




protected:





private:



  gp_Ax1 pos;


};


# 1 "/usr/include/opencascade/gp_Lin.lxx" 1
# 17 "/usr/include/opencascade/gp_Lin.lxx"
inline gp_Lin::gp_Lin ()
{ }

inline gp_Lin::gp_Lin (const gp_Ax1& A1) : pos (A1)
{ }

inline gp_Lin::gp_Lin (const gp_Pnt& P,
         const gp_Dir& V) : pos (P, V)
{ }

inline void gp_Lin::Reverse()
{ pos.Reverse(); }

inline gp_Lin gp_Lin::Reversed() const {
  gp_Lin L = *this;
  L.pos.Reverse();
  return L;
}

inline void gp_Lin::SetDirection (const gp_Dir& V)
{ pos.SetDirection(V); }

inline void gp_Lin::SetLocation (const gp_Pnt& P)
{ pos.SetLocation(P); }

inline void gp_Lin::SetPosition (const gp_Ax1& A1)
{ pos = A1; }

inline const gp_Dir& gp_Lin::Direction() const
{ return pos.Direction(); }

inline const gp_Pnt& gp_Lin::Location() const
{ return pos.Location(); }

inline const gp_Ax1& gp_Lin::Position() const
{ return pos; }

inline Standard_Real gp_Lin::Angle (const gp_Lin& Other) const
{ return pos.Direction().Angle (Other.pos.Direction()); }

inline Standard_Boolean gp_Lin::Contains
(const gp_Pnt& P,
 const Standard_Real LinearTolerance) const
{ return Distance(P) <= LinearTolerance; }

inline Standard_Real gp_Lin::Distance (const gp_Pnt& P) const {
  gp_XYZ Coord = P.XYZ();
  Coord.Subtract ((pos.Location()).XYZ());
  Coord.Cross ((pos.Direction()).XYZ());
  return Coord.Modulus();
}

inline Standard_Real gp_Lin::SquareDistance (const gp_Pnt& P) const
{
  const gp_Pnt& Loc = pos.Location();
  gp_Vec V (P.X() - Loc.X(),
     P.Y() - Loc.Y(),
     P.Z() - Loc.Z());
  V.Cross (pos.Direction());
  return V.SquareMagnitude ();
}

inline Standard_Real gp_Lin::SquareDistance (const gp_Lin& Other) const
{
  Standard_Real D = Distance (Other);
  return D * D;
}

inline gp_Lin gp_Lin::Normal (const gp_Pnt& P) const
{
  const gp_Pnt& Loc = pos.Location();
  gp_Dir V (P.X() - Loc.X(),
     P.Y() - Loc.Y(),
     P.Z() - Loc.Z());
  V = pos.Direction().CrossCrossed(V, pos.Direction());
  return gp_Lin (P, V);
}

inline void gp_Lin::Rotate (const gp_Ax1& A1,
       const Standard_Real Ang)
{ pos.Rotate(A1, Ang); }

inline gp_Lin gp_Lin::Rotated (const gp_Ax1& A1,
          const Standard_Real Ang) const
{
  gp_Lin L = *this;
  L.pos.Rotate (A1, Ang);
  return L;
}

inline void gp_Lin::Scale (const gp_Pnt& P,
      const Standard_Real S)
{ pos.Scale(P, S); }

inline gp_Lin gp_Lin::Scaled (const gp_Pnt& P,
         const Standard_Real S) const
{
  gp_Lin L = *this;
  L.pos.Scale (P, S);
  return L;
}

inline void gp_Lin::Transform (const gp_Trsf& T)
{ pos.Transform(T); }

inline gp_Lin gp_Lin::Transformed (const gp_Trsf& T) const
{
  gp_Lin L = *this;
  L.pos.Transform (T);
  return L;
}

inline void gp_Lin::Translate (const gp_Vec& V)
{ pos.Translate(V); }

inline gp_Lin gp_Lin::Translated (const gp_Vec& V) const
{
  gp_Lin L = *this;
  L.pos.Translate (V);
  return L;
}

inline void gp_Lin::Translate (const gp_Pnt& P1,
          const gp_Pnt& P2)
{pos.Translate (P1, P2);}

inline gp_Lin gp_Lin::Translated (const gp_Pnt& P1,
      const gp_Pnt& P2) const
{
  gp_Lin L = *this;
  L.pos.Translate (gp_Vec(P1, P2));
  return L;
}
# 208 "/usr/include/opencascade/gp_Lin.hxx" 2
# 18 "/usr/include/opencascade/gp_Pln.lxx" 2

inline gp_Pln::gp_Pln()
{ }

inline gp_Pln::gp_Pln(const gp_Ax3& A3) : pos(A3)
{ }

inline void gp_Pln::Coefficients (Standard_Real& A,
      Standard_Real& B,
      Standard_Real& C,
      Standard_Real& D) const
{
  const gp_Dir& dir = pos.Direction();
  if (pos.Direct()) {
    A = dir.X();
    B = dir.Y();
    C = dir.Z();
  }
  else {
    A = -dir.X();
    B = -dir.Y();
    C = -dir.Z();
  }
  const gp_Pnt& P = pos.Location();
  D = -(A * P.X() + B * P.Y() + C * P.Z());
}

inline void gp_Pln::SetAxis (const gp_Ax1& A1)
{ pos.SetAxis (A1); }

inline void gp_Pln::SetLocation (const gp_Pnt& Loc)
{ pos.SetLocation (Loc); }

inline void gp_Pln::SetPosition (const gp_Ax3& A3)
{ pos = A3; }

inline void gp_Pln::UReverse ()
{ pos.XReverse(); }

inline void gp_Pln::VReverse ()
{ pos.YReverse(); }

inline Standard_Boolean gp_Pln::Direct()const
{ return pos.Direct(); }

inline const gp_Ax1& gp_Pln::Axis() const
{ return pos.Axis(); }

inline const gp_Pnt& gp_Pln::Location() const
{ return pos.Location(); }

inline const gp_Ax3& gp_Pln::Position() const
{ return pos; }

inline Standard_Real gp_Pln::Distance(const gp_Pnt& P) const
{
  const gp_Pnt& loc = pos.Location ();
  const gp_Dir& dir = pos.Direction();
  Standard_Real D = (dir.X() * (P.X() - loc.X()) +
       dir.Y() * (P.Y() - loc.Y()) +
       dir.Z() * (P.Z() - loc.Z()));
  if (D < 0) D = - D;
  return D;
}

inline Standard_Real gp_Pln::Distance (const gp_Lin& L) const
{
  Standard_Real D = 0.0;
  if ((pos.Direction()).IsNormal (L.Direction(), gp::Resolution())) {
    const gp_Pnt& P = L .Location ();
    const gp_Pnt& loc = pos.Location ();
    const gp_Dir& dir = pos.Direction();
    D = (dir.X() * (P.X() - loc.X()) +
  dir.Y() * (P.Y() - loc.Y()) +
  dir.Z() * (P.Z() - loc.Z()));
    if (D < 0) D = - D;
  }
  return D;
}

inline Standard_Real gp_Pln::Distance(const gp_Pln& Other) const
{
  Standard_Real D = 0.0;
  if ((pos.Direction()).IsParallel(Other.pos.Direction(), gp::Resolution())){
    const gp_Pnt& P = Other.pos.Location();
    const gp_Pnt& loc = pos.Location ();
    const gp_Dir& dir = pos.Direction();
    D = (dir.X() * (P.X() - loc.X()) +
  dir.Y() * (P.Y() - loc.Y()) +
  dir.Z() * (P.Z() - loc.Z()));
    if (D < 0) D = - D;
  }
  return D;
}

inline Standard_Real gp_Pln::SquareDistance (const gp_Pnt& P) const
{ Standard_Real D = Distance(P); return D * D; }

inline Standard_Real gp_Pln::SquareDistance (const gp_Lin& L) const
{ Standard_Real D = Distance(L); return D * D; }

inline Standard_Real gp_Pln::SquareDistance (const gp_Pln& Other) const
{ Standard_Real D = Distance(Other); return D * D; }

inline gp_Ax1 gp_Pln::XAxis () const
{ return gp_Ax1 (pos.Location(), pos.XDirection()); }

inline gp_Ax1 gp_Pln::YAxis () const
{ return gp_Ax1 (pos.Location(), pos.YDirection()); }

inline Standard_Boolean gp_Pln::Contains
(const gp_Pnt& P,
 const Standard_Real LinearTolerance) const
{ return Distance(P) <= LinearTolerance; }

inline Standard_Boolean gp_Pln::Contains
(const gp_Lin& L,
 const Standard_Real LinearTolerance,
 const Standard_Real AngularTolerance) const
{ return Contains(L.Location(), LinearTolerance) &&
    pos.Direction().IsNormal(L.Direction(), AngularTolerance);
}

inline void gp_Pln::Rotate (const gp_Ax1& A1, const Standard_Real Ang)
{ pos.Rotate(A1, Ang); }

inline gp_Pln gp_Pln::Rotated (const gp_Ax1& A1,
          const Standard_Real Ang) const
{
  gp_Pln Pl = *this;
  Pl.pos.Rotate(A1, Ang);
  return Pl;
}

inline void gp_Pln::Scale (const gp_Pnt& P, const Standard_Real S)
{ pos.Scale(P, S); }

inline gp_Pln gp_Pln::Scaled (const gp_Pnt& P,
         const Standard_Real S) const
{
  gp_Pln Pl = *this;
  Pl.pos.Scale(P, S);
  return Pl;
}

inline void gp_Pln::Transform (const gp_Trsf& T)
{ pos.Transform(T); }

inline gp_Pln gp_Pln::Transformed (const gp_Trsf& T) const
{
  gp_Pln Pl = *this;
  Pl.pos.Transform(T);
  return Pl;
}

inline void gp_Pln::Translate (const gp_Vec& V)
{ pos.Translate(V); }

inline gp_Pln gp_Pln::Translated (const gp_Vec& V) const
{
  gp_Pln Pl = *this;
  Pl.pos.Translate(V);
  return Pl;
}

inline void gp_Pln::Translate (const gp_Pnt& P1, const gp_Pnt& P2)
{ pos.Translate(P1,P2); }

inline gp_Pln gp_Pln::Translated (const gp_Pnt& P1,
      const gp_Pnt& P2) const
{
  gp_Pln Pl = *this;
  Pl.pos.Translate(P1, P2);
  return Pl;
}
# 266 "/usr/include/opencascade/gp_Pln.hxx" 2
# 21 "/usr/include/opencascade/Graphic3d_ClipPlane.hxx" 2


# 1 "/usr/include/opencascade/Graphic3d_CappingFlags.hxx" 1
# 19 "/usr/include/opencascade/Graphic3d_CappingFlags.hxx"
enum Graphic3d_CappingFlags
{
  Graphic3d_CappingFlags_None = 0x0000,
  Graphic3d_CappingFlags_ObjectMaterial = 0x0001,
  Graphic3d_CappingFlags_ObjectTexture = 0x0002,
  Graphic3d_CappingFlags_ObjectShader = 0x0008,
  Graphic3d_CappingFlags_ObjectAspect =
    Graphic3d_CappingFlags_ObjectMaterial | Graphic3d_CappingFlags_ObjectTexture | Graphic3d_CappingFlags_ObjectShader
};
# 24 "/usr/include/opencascade/Graphic3d_ClipPlane.hxx" 2







enum Graphic3d_ClipState
{
  Graphic3d_ClipState_Out,
  Graphic3d_ClipState_In,
  Graphic3d_ClipState_On,
};




class Graphic3d_ClipPlane : public Standard_Transient
{
  public: typedef Standard_Transient base_type; static const char* get_type_name () { return "Graphic3d_ClipPlane"; using direct_base_classes = opencascade::direct_base_class_as_tuple<std::tr2::direct_bases<Graphic3d_ClipPlane>::type>::type; static_assert(opencascade::has_type<Standard_Transient, direct_base_classes>::type::value, "OCCT RTTI definition is incorrect: " "Standard_Transient" " is not direct base class of " "Graphic3d_ClipPlane"); static_assert(&get_type_name == &Graphic3d_ClipPlane::get_type_name, "OCCT RTTI definition is misplaced: current class is not " "Graphic3d_ClipPlane"); } static const opencascade::handle<Standard_Type>& get_type_descriptor (); virtual const opencascade::handle<Standard_Type>& DynamicType() const override;
public:


  typedef Graphic3d_Vec4d Equation;

public:
# 60 "/usr/include/opencascade/Graphic3d_ClipPlane.hxx"
  Graphic3d_ClipPlane();



  Graphic3d_ClipPlane(const Graphic3d_ClipPlane& theOther);




  Graphic3d_ClipPlane (const Graphic3d_Vec4d& theEquation);




  Graphic3d_ClipPlane (const gp_Pln& thePlane);




  void SetEquation (const gp_Pln& thePlane);




  void SetEquation (const Graphic3d_Vec4d& theEquation);



  const Graphic3d_Vec4d& GetEquation() const { return myEquation; }



  const Graphic3d_Vec4d& ReversedEquation() const { return myEquationRev; }



  Standard_Boolean IsOn() const
  {
    return myIsOn;
  }




  void SetOn(const Standard_Boolean theIsOn);






  void SetCapping(const Standard_Boolean theIsOn);



  Standard_Boolean IsCapping() const
  {
    return myIsCapping;
  }



  const gp_Pln& ToPlane() const { return myPlane; }





  virtual opencascade::handle<Graphic3d_ClipPlane> Clone() const;

public:
# 145 "/usr/include/opencascade/Graphic3d_ClipPlane.hxx"
  Standard_Boolean IsChain() const { return !myNextInChain.IsNull(); }





  opencascade::handle<Graphic3d_ClipPlane> ChainPreviousPlane() const { return myPrevInChain; }




  const opencascade::handle<Graphic3d_ClipPlane>& ChainNextPlane() const { return myNextInChain; }



  Standard_Integer NbChainNextPlanes() const { return myChainLenFwd; }




  void SetChainNextPlane (const opencascade::handle<Graphic3d_ClipPlane>& thePlane);

public:


  Quantity_Color CappingColor() const { return myAspect->FrontMaterial().MaterialType() == Graphic3d_MATERIAL_ASPECT ? myAspect->FrontMaterial().Color() : myAspect->InteriorColor(); }


  void SetCappingColor (const Quantity_Color& theColor);



  void SetCappingMaterial (const Graphic3d_MaterialAspect& theMat);


  const Graphic3d_MaterialAspect& CappingMaterial() const { return myAspect->FrontMaterial(); }



  void SetCappingTexture (const opencascade::handle<Graphic3d_TextureMap>& theTexture);


  opencascade::handle<Graphic3d_TextureMap> CappingTexture() const { return !myAspect->TextureSet().IsNull() && !myAspect->TextureSet()->IsEmpty()
                                                              ? myAspect->TextureSet()->First()
                                                              : opencascade::handle<Graphic3d_TextureMap>(); }



  void SetCappingHatch (const Aspect_HatchStyle theStyle);


  Aspect_HatchStyle CappingHatch() const { return (Aspect_HatchStyle)myAspect->HatchStyle()->HatchType(); }



  void SetCappingCustomHatch (const opencascade::handle<Graphic3d_HatchStyle>& theStyle);


  const opencascade::handle<Graphic3d_HatchStyle>& CappingCustomHatch() const { return myAspect->HatchStyle(); }


  void SetCappingHatchOn();


  void SetCappingHatchOff();


  Standard_Boolean IsHatchOn() const { return myAspect->InteriorStyle() == Aspect_IS_HATCH; }
# 221 "/usr/include/opencascade/Graphic3d_ClipPlane.hxx"
  const TCollection_AsciiString& GetId() const
  {
    return myId;
  }

public:



  const opencascade::handle<Graphic3d_AspectFillArea3d>& CappingAspect() const { return myAspect; }


  void SetCappingAspect (const opencascade::handle<Graphic3d_AspectFillArea3d>& theAspect);



  bool ToUseObjectMaterial() const { return (myFlags & Graphic3d_CappingFlags_ObjectMaterial) != 0; }


  void SetUseObjectMaterial (bool theToUse) { setCappingFlag (theToUse, Graphic3d_CappingFlags_ObjectMaterial); }



  bool ToUseObjectTexture() const { return (myFlags & Graphic3d_CappingFlags_ObjectTexture) != 0; }


  void SetUseObjectTexture (bool theToUse) { setCappingFlag (theToUse, Graphic3d_CappingFlags_ObjectTexture); }



  bool ToUseObjectShader() const { return (myFlags & Graphic3d_CappingFlags_ObjectShader) != 0; }


  void SetUseObjectShader(bool theToUse) { setCappingFlag (theToUse, Graphic3d_CappingFlags_ObjectShader); }


  bool ToUseObjectProperties() const { return myFlags != Graphic3d_CappingFlags_None; }

public:


  Graphic3d_ClipState ProbePoint (const Graphic3d_Vec4d& thePoint) const
  {
    Graphic3d_ClipState aState = Graphic3d_ClipState_Out;
    for (const Graphic3d_ClipPlane* aPlaneIter = this; aPlaneIter != 
# 265 "/usr/include/opencascade/Graphic3d_ClipPlane.hxx" 3 4
                                                                    __null
# 265 "/usr/include/opencascade/Graphic3d_ClipPlane.hxx"
                                                                        ; aPlaneIter = aPlaneIter->myNextInChain.get())
    {
      Graphic3d_ClipState aPlnState = aPlaneIter->ProbePointHalfspace (thePoint);
      if (aPlnState == Graphic3d_ClipState_In)
      {
        return Graphic3d_ClipState_In;
      }
      else if (aPlnState != Graphic3d_ClipState_Out)
      {
        aState = Graphic3d_ClipState_On;
      }
    }
    return aState;
  }


  Graphic3d_ClipState ProbeBox (const Graphic3d_BndBox3d& theBox) const
  {
    Graphic3d_ClipState aState = Graphic3d_ClipState_Out;
    for (const Graphic3d_ClipPlane* aPlaneIter = this; aPlaneIter != 
# 284 "/usr/include/opencascade/Graphic3d_ClipPlane.hxx" 3 4
                                                                    __null
# 284 "/usr/include/opencascade/Graphic3d_ClipPlane.hxx"
                                                                        ; aPlaneIter = aPlaneIter->myNextInChain.get())
    {
      if (aPlaneIter->IsBoxFullInHalfspace (theBox))
      {

        return Graphic3d_ClipState_In;
      }
      else if (!aPlaneIter->IsBoxFullOutHalfspace (theBox))
      {

        aState = Graphic3d_ClipState_On;
      }
    }
    return aState;
  }


  Standard_Boolean ProbeBoxTouch (const Graphic3d_BndBox3d& theBox) const
  {
    for (const Graphic3d_ClipPlane* aPlaneIter = this; aPlaneIter != 
# 303 "/usr/include/opencascade/Graphic3d_ClipPlane.hxx" 3 4
                                                                    __null
# 303 "/usr/include/opencascade/Graphic3d_ClipPlane.hxx"
                                                                        ; aPlaneIter = aPlaneIter->myNextInChain.get())
    {
      if (aPlaneIter->IsBoxFullInHalfspace (theBox))
      {

        return false;
      }
      else if (!aPlaneIter->IsBoxFullOutHalfspace (theBox))
      {

        if (ProbeBoxMaxPointHalfspace (theBox) != Graphic3d_ClipState_Out)
        {
          return true;
        }
      }
    }
    return false;
  }

public:


  Graphic3d_ClipState ProbePointHalfspace (const Graphic3d_Vec4d& thePoint) const
  {
    const Standard_Real aVal = myEquation.Dot (thePoint);
    return aVal < 0.0
         ? Graphic3d_ClipState_Out
         : (aVal == 0.0
          ? Graphic3d_ClipState_On
          : Graphic3d_ClipState_In);
  }


  Graphic3d_ClipState ProbeBoxHalfspace (const Graphic3d_BndBox3d& theBox) const
  {
    if (IsBoxFullOutHalfspace (theBox))
    {
      return Graphic3d_ClipState_Out;
    }
    return IsBoxFullInHalfspace (theBox)
         ? Graphic3d_ClipState_In
         : Graphic3d_ClipState_On;
  }


  bool IsPointOutHalfspace (const Graphic3d_Vec4d& thePoint) const { return ProbePointHalfspace (thePoint) == Graphic3d_ClipState_Out; }


  bool IsBoxFullOutHalfspace (const Graphic3d_BndBox3d& theBox) const
  {
    const Graphic3d_Vec4d aMaxPnt (myEquation.x() > 0.0 ? theBox.CornerMax().x() : theBox.CornerMin().x(),
                                   myEquation.y() > 0.0 ? theBox.CornerMax().y() : theBox.CornerMin().y(),
                                   myEquation.z() > 0.0 ? theBox.CornerMax().z() : theBox.CornerMin().z(),
                                   1.0);
    return IsPointOutHalfspace (aMaxPnt);
  }


  Graphic3d_ClipState ProbeBoxMaxPointHalfspace (const Graphic3d_BndBox3d& theBox) const
  {
    const Graphic3d_Vec4d aMaxPnt (myEquation.x() > 0.0 ? theBox.CornerMax().x() : theBox.CornerMin().x(),
                                   myEquation.y() > 0.0 ? theBox.CornerMax().y() : theBox.CornerMin().y(),
                                   myEquation.z() > 0.0 ? theBox.CornerMax().z() : theBox.CornerMin().z(),
                                   1.0);
    return ProbePointHalfspace (aMaxPnt);
  }


  bool IsBoxFullInHalfspace (const Graphic3d_BndBox3d& theBox) const
  {
    const Graphic3d_Vec4d aMinPnt (myEquation.x() > 0.0 ? theBox.CornerMin().x() : theBox.CornerMax().x(),
                                   myEquation.y() > 0.0 ? theBox.CornerMin().y() : theBox.CornerMax().y(),
                                   myEquation.z() > 0.0 ? theBox.CornerMin().z() : theBox.CornerMax().z(),
                                   1.0);
    return !IsPointOutHalfspace (aMinPnt);
  }


  virtual void DumpJson (Standard_OStream& theOStream, Standard_Integer theDepth = -1) const;

public:


  unsigned int MCountEquation() const
  {
    return myEquationMod;
  }


  unsigned int MCountAspect() const
  {
    return myAspectMod;
  }

private:


  void makeId();


  void setCappingFlag (bool theToUse, int theFlag);


  void updateChainLen();


  void updateInversedPlane()
  {
    gp_Pln aPlane = myPlane;
    aPlane.SetAxis (aPlane.Axis().Reversed());
    aPlane.Coefficients (myEquationRev[0], myEquationRev[1], myEquationRev[2], myEquationRev[3]);
  }

private:

  opencascade::handle<Graphic3d_AspectFillArea3d> myAspect;
  opencascade::handle<Graphic3d_ClipPlane> myNextInChain;
  Graphic3d_ClipPlane* myPrevInChain;
  TCollection_AsciiString myId;
  gp_Pln myPlane;
  Graphic3d_Vec4d myEquation;
  Graphic3d_Vec4d myEquationRev;
  Standard_Integer myChainLenFwd;
  unsigned int myFlags;
  unsigned int myEquationMod;
  unsigned int myAspectMod;
  Standard_Boolean myIsOn;
  Standard_Boolean myIsCapping;

};

class Graphic3d_ClipPlane; typedef opencascade::handle<Graphic3d_ClipPlane> Handle_Graphic3d_ClipPlane;
# 21 "/usr/include/opencascade/Graphic3d_SequenceOfHClipPlane.hxx" 2
# 33 "/usr/include/opencascade/Graphic3d_SequenceOfHClipPlane.hxx"
class Graphic3d_SequenceOfHClipPlane : public Standard_Transient
{
  public: typedef Standard_Transient base_type; static const char* get_type_name () { return "Graphic3d_SequenceOfHClipPlane"; using direct_base_classes = opencascade::direct_base_class_as_tuple<std::tr2::direct_bases<Graphic3d_SequenceOfHClipPlane>::type>::type; static_assert(opencascade::has_type<Standard_Transient, direct_base_classes>::type::value, "OCCT RTTI definition is incorrect: " "Standard_Transient" " is not direct base class of " "Graphic3d_SequenceOfHClipPlane"); static_assert(&get_type_name == &Graphic3d_SequenceOfHClipPlane::get_type_name, "OCCT RTTI definition is misplaced: current class is not " "Graphic3d_SequenceOfHClipPlane"); } static const opencascade::handle<Standard_Type>& get_type_descriptor (); virtual const opencascade::handle<Standard_Type>& DynamicType() const override;
public:


  class Iterator : public NCollection_Sequence<opencascade::handle<Graphic3d_ClipPlane> >::Iterator
  {
  public:
    Iterator() {}
    Iterator (const Graphic3d_SequenceOfHClipPlane& thePlanes) : NCollection_Sequence<opencascade::handle<Graphic3d_ClipPlane> >::Iterator (thePlanes.myItems) {}
    Iterator (const opencascade::handle<Graphic3d_SequenceOfHClipPlane>& thePlanes) { Init (thePlanes); }

    void Init (const Graphic3d_SequenceOfHClipPlane& thePlanes) { NCollection_Sequence<opencascade::handle<Graphic3d_ClipPlane> >::Iterator::Init (thePlanes.myItems); }
    void Init (const opencascade::handle<Graphic3d_SequenceOfHClipPlane>& thePlanes)
    {
      if (!thePlanes.IsNull())
      {
        NCollection_Sequence<opencascade::handle<Graphic3d_ClipPlane> >::Iterator::Init (thePlanes->myItems);
      }
      else
      {
        *this = Iterator();
      }
    }
  };

public:


  Graphic3d_SequenceOfHClipPlane();


  Standard_Boolean ToOverrideGlobal() const { return myToOverrideGlobal; }


  void SetOverrideGlobal (const Standard_Boolean theToOverride) { myToOverrideGlobal = theToOverride; }


  bool IsEmpty() const { return myItems.IsEmpty(); }


  Standard_Integer Size() const { return myItems.Size(); }



  bool Append (const opencascade::handle<Graphic3d_ClipPlane>& theItem);



  bool Remove (const opencascade::handle<Graphic3d_ClipPlane>& theItem);


  void Remove (Iterator& theItem) { myItems.Remove (theItem); }


  void Clear()
  {
    myItems.Clear();
  }


  const opencascade::handle<Graphic3d_ClipPlane>& First() const { return myItems.First(); }


  virtual void DumpJson (Standard_OStream& theOStream, Standard_Integer theDepth = -1) const;

protected:

  NCollection_Sequence<opencascade::handle<Graphic3d_ClipPlane> > myItems;
  Standard_Boolean myToOverrideGlobal;

};

class Graphic3d_SequenceOfHClipPlane; typedef opencascade::handle<Graphic3d_SequenceOfHClipPlane> Handle_Graphic3d_SequenceOfHClipPlane;
# 23 "/usr/include/opencascade/Graphic3d_CStructure.hxx" 2
# 1 "/usr/include/opencascade/Graphic3d_TypeOfComposition.hxx" 1
# 21 "/usr/include/opencascade/Graphic3d_TypeOfComposition.hxx"
enum Graphic3d_TypeOfComposition
{
Graphic3d_TOC_REPLACE,
Graphic3d_TOC_POSTCONCATENATE
};
# 24 "/usr/include/opencascade/Graphic3d_CStructure.hxx" 2
# 1 "/usr/include/opencascade/Graphic3d_ViewAffinity.hxx" 1
# 24 "/usr/include/opencascade/Graphic3d_ViewAffinity.hxx"
class Graphic3d_ViewAffinity : public Standard_Transient
{
public:


  Graphic3d_ViewAffinity()
  {
    SetVisible (true);
  }


  bool IsVisible (const Standard_Integer theViewId) const
  {
    const unsigned int aBit = 1 << theViewId;
    return (myMask & aBit) != 0;
  }


  void SetVisible (const Standard_Boolean theIsVisible)
  {
    ::memset (&myMask, theIsVisible ? 0xFF : 0x00, sizeof(myMask));
  }


  void SetVisible (const Standard_Integer theViewId,
                   const bool theIsVisible)
  {
    const unsigned int aBit = 1 << theViewId;
    if (theIsVisible)
    {
      myMask |= aBit;
    }
    else
    {
      myMask &= ~aBit;
    }
  }


  void DumpJson (Standard_OStream& theOStream, Standard_Integer theDepth = -1) const;

private:

  unsigned int myMask;

public:

  public: typedef Standard_Transient base_type; static const char* get_type_name () { return "Graphic3d_ViewAffinity"; using direct_base_classes = opencascade::direct_base_class_as_tuple<std::tr2::direct_bases<Graphic3d_ViewAffinity>::type>::type; static_assert(opencascade::has_type<Standard_Transient, direct_base_classes>::type::value, "OCCT RTTI definition is incorrect: " "Standard_Transient" " is not direct base class of " "Graphic3d_ViewAffinity"); static_assert(&get_type_name == &Graphic3d_ViewAffinity::get_type_name, "OCCT RTTI definition is misplaced: current class is not " "Graphic3d_ViewAffinity"); } static const opencascade::handle<Standard_Type>& get_type_descriptor (); virtual const opencascade::handle<Standard_Type>& DynamicType() const override;

};

class Graphic3d_ViewAffinity; typedef opencascade::handle<Graphic3d_ViewAffinity> Handle_Graphic3d_ViewAffinity;
# 25 "/usr/include/opencascade/Graphic3d_CStructure.hxx" 2
# 1 "/usr/include/opencascade/Graphic3d_TransformPers.hxx" 1
# 19 "/usr/include/opencascade/Graphic3d_TransformPers.hxx"
# 1 "/usr/include/opencascade/Aspect_TypeOfTriedronPosition.hxx" 1
# 21 "/usr/include/opencascade/Aspect_TypeOfTriedronPosition.hxx"
enum Aspect_TypeOfTriedronPosition
{
  Aspect_TOTP_CENTER = 0x0000,
  Aspect_TOTP_TOP = 0x0001,
  Aspect_TOTP_BOTTOM = 0x0002,
  Aspect_TOTP_LEFT = 0x0004,
  Aspect_TOTP_RIGHT = 0x0008,
  Aspect_TOTP_LEFT_LOWER = Aspect_TOTP_BOTTOM
                          | Aspect_TOTP_LEFT,
  Aspect_TOTP_LEFT_UPPER = Aspect_TOTP_TOP
                          | Aspect_TOTP_LEFT,
  Aspect_TOTP_RIGHT_LOWER = Aspect_TOTP_BOTTOM
                          | Aspect_TOTP_RIGHT,
  Aspect_TOTP_RIGHT_UPPER = Aspect_TOTP_TOP
                          | Aspect_TOTP_RIGHT,

};
# 20 "/usr/include/opencascade/Graphic3d_TransformPers.hxx" 2


# 1 "/usr/include/opencascade/Graphic3d_Camera.hxx" 1
# 19 "/usr/include/opencascade/Graphic3d_Camera.hxx"
# 1 "/usr/include/opencascade/Aspect_Eye.hxx" 1
# 18 "/usr/include/opencascade/Aspect_Eye.hxx"
enum Aspect_Eye
{
  Aspect_Eye_Left,
  Aspect_Eye_Right
};
# 20 "/usr/include/opencascade/Graphic3d_Camera.hxx" 2
# 1 "/usr/include/opencascade/Aspect_FrustumLRBT.hxx" 1
# 18 "/usr/include/opencascade/Aspect_FrustumLRBT.hxx"
template<typename Elem_t>
struct Aspect_FrustumLRBT
{
  Elem_t Left;
  Elem_t Right;
  Elem_t Bottom;
  Elem_t Top;


  Aspect_FrustumLRBT() : Left (0), Right (0), Bottom (0), Top (0) {}


  template<typename Other_t>
  explicit Aspect_FrustumLRBT (const Aspect_FrustumLRBT<Other_t>& theOther)
  : Left (static_cast<Elem_t> (theOther.Left)),
    Right (static_cast<Elem_t> (theOther.Right)),
    Bottom(static_cast<Elem_t> (theOther.Bottom)),
    Top (static_cast<Elem_t> (theOther.Top)) {}


  void Multiply (Elem_t theScale)
  {
    Left *= theScale;
    Right *= theScale;
    Bottom *= theScale;
    Top *= theScale;
  }


  Aspect_FrustumLRBT<Elem_t> Multiplied (Elem_t theScale)
  {
    Aspect_FrustumLRBT<Elem_t> aCopy (*this);
    aCopy.Multiply (theScale);
    return aCopy;
  }
};
# 21 "/usr/include/opencascade/Graphic3d_Camera.hxx" 2
# 1 "/usr/include/opencascade/Graphic3d_CameraTile.hxx" 1
# 23 "/usr/include/opencascade/Graphic3d_CameraTile.hxx"
class Graphic3d_CameraTile
{
public:

  Graphic3d_Vec2i TotalSize;
  Graphic3d_Vec2i TileSize;
  Graphic3d_Vec2i Offset;
  bool IsTopDown;

public:




  Graphic3d_CameraTile() : IsTopDown (false) {}


  bool IsValid() const
  {
    return TotalSize.x() > 0 && TotalSize.y() > 0
        && TileSize.x() > 0 && TileSize.y() > 0;
  }


  Graphic3d_Vec2i OffsetLowerLeft() const
  {
    return Graphic3d_Vec2i (Offset.x(),
                           !IsTopDown
                           ? Offset.y()
                           : TotalSize.y() - Offset.y() - 1);
  }


  Graphic3d_CameraTile Cropped() const
  {
    Graphic3d_CameraTile aTile = *this;
    if (!IsValid())
    {
      return aTile;
    }

    aTile.Offset.x() = Max (Offset.x(), 0);
    aTile.Offset.y() = Max (Offset.y(), 0);

    const Standard_Integer anX = Min (Offset.x() + TileSize.x(), TotalSize.x());
    const Standard_Integer anY = Min (Offset.y() + TileSize.y(), TotalSize.y());
    aTile.TileSize.x() = anX - Offset.x();
    aTile.TileSize.y() = anY - Offset.y();
    return aTile;
  }


  bool operator== (const Graphic3d_CameraTile& theOther) const
  {
    const Graphic3d_Vec2i anOffset1 = OffsetLowerLeft();
    const Graphic3d_Vec2i anOffset2 = theOther.OffsetLowerLeft();
    return TotalSize.x() == theOther.TotalSize.x()
        && TotalSize.y() == theOther.TotalSize.y()
        && TileSize.x() == theOther.TileSize.x()
        && TileSize.y() == theOther.TileSize.y()
        && anOffset1.x() == anOffset2.x()
        && anOffset1.y() == anOffset2.y();
  }


  void DumpJson (Standard_OStream& theOStream, Standard_Integer theDepth = -1) const;

};
# 22 "/usr/include/opencascade/Graphic3d_Camera.hxx" 2



# 1 "/usr/include/opencascade/Graphic3d_WorldViewProjState.hxx" 1
# 24 "/usr/include/opencascade/Graphic3d_WorldViewProjState.hxx"
class Graphic3d_WorldViewProjState
{
public:


  Graphic3d_WorldViewProjState()
  {
    Reset();
  }






  Graphic3d_WorldViewProjState (const Standard_Size theProjectionState,
                                const Standard_Size theWorldViewState,
                                const Standard_Transient* theCamera = 
# 41 "/usr/include/opencascade/Graphic3d_WorldViewProjState.hxx" 3 4
                                                                     __null
# 41 "/usr/include/opencascade/Graphic3d_WorldViewProjState.hxx"
                                                                         )
  {
    Initialize (theProjectionState, theWorldViewState, theCamera);
  }

public:



  Standard_Boolean IsValid()
  {
    return myIsValid;
  }


  void Reset()
  {
    myIsValid = false;
    myCamera = 
# 59 "/usr/include/opencascade/Graphic3d_WorldViewProjState.hxx" 3 4
                       __null
# 59 "/usr/include/opencascade/Graphic3d_WorldViewProjState.hxx"
                           ;
    myProjectionState = 0;
    myWorldViewState = 0;
  }


  void Initialize (const Standard_Size theProjectionState,
                   const Standard_Size theWorldViewState,
                   const Standard_Transient* theCamera = 
# 67 "/usr/include/opencascade/Graphic3d_WorldViewProjState.hxx" 3 4
                                                        __null
# 67 "/usr/include/opencascade/Graphic3d_WorldViewProjState.hxx"
                                                            )
  {
    myIsValid = true;
    myCamera = const_cast<Standard_Transient*> (theCamera);
    myProjectionState = theProjectionState;
    myWorldViewState = theWorldViewState;
  }


  void Initialize (const Standard_Transient* theCamera = 
# 76 "/usr/include/opencascade/Graphic3d_WorldViewProjState.hxx" 3 4
                                                        __null
# 76 "/usr/include/opencascade/Graphic3d_WorldViewProjState.hxx"
                                                            )
  {
    myIsValid = true;
    myCamera = const_cast<Standard_Transient*> (theCamera);
    myProjectionState = 0;
    myWorldViewState = 0;
  }

public:


  Standard_Size& ProjectionState()
  {
    return myProjectionState;
  }


  Standard_Size& WorldViewState()
  {
    return myWorldViewState;
  }

public:



  Standard_Boolean IsProjectionChanged (const Graphic3d_WorldViewProjState& theState)
  {
    return myIsValid != theState.myIsValid
        || myCamera != theState.myCamera
        || myProjectionState != theState.myProjectionState;
  }



  Standard_Boolean IsWorldViewChanged (const Graphic3d_WorldViewProjState& theState)
  {
    return myIsValid != theState.myIsValid
        || myCamera != theState.myCamera
        || myWorldViewState != theState.myWorldViewState;
  }



  Standard_Boolean IsChanged (const Graphic3d_WorldViewProjState& theState)
  {
    return *this != theState;
  }

public:



  bool operator != (const Graphic3d_WorldViewProjState& theOther) const
  {
    return !(*this == theOther);
  }



  bool operator == (const Graphic3d_WorldViewProjState& theOther) const
  {
    return myIsValid == theOther.myIsValid
        && myCamera == theOther.myCamera
        && myProjectionState == theOther.myProjectionState
        && myWorldViewState == theOther.myWorldViewState;
  }


  void DumpJson (Standard_OStream& theOStream, Standard_Integer) const
  {
    { TCollection_AsciiString aName = Standard_Dump::DumpFieldToName ("myIsValid"); Standard_Dump::AddValuesSeparator (theOStream); theOStream << "\"" << aName << "\": " << myIsValid; }
    { TCollection_AsciiString aName = Standard_Dump::DumpFieldToName ("myCamera"); Standard_Dump::AddValuesSeparator (theOStream); theOStream << "\"" << aName << "\": \"" << Standard_Dump::GetPointerInfo (myCamera) << "\""; }
    { TCollection_AsciiString aName = Standard_Dump::DumpFieldToName ("myProjectionState"); Standard_Dump::AddValuesSeparator (theOStream); theOStream << "\"" << aName << "\": " << myProjectionState; }
    { TCollection_AsciiString aName = Standard_Dump::DumpFieldToName ("myWorldViewState"); Standard_Dump::AddValuesSeparator (theOStream); theOStream << "\"" << aName << "\": " << myWorldViewState; }
  }

private:

  Standard_Boolean myIsValid;
  Standard_Transient* myCamera;
  Standard_Size myProjectionState;
  Standard_Size myWorldViewState;
};
# 26 "/usr/include/opencascade/Graphic3d_Camera.hxx" 2
# 1 "/usr/include/opencascade/NCollection_Lerp.hxx" 1
# 20 "/usr/include/opencascade/NCollection_Lerp.hxx"
template<class T>
class NCollection_Lerp
{
public:





  static T Interpolate (const T& theStart,
                        const T& theEnd,
                        double theT)
  {
    T aResult;
    NCollection_Lerp aLerp (theStart, theEnd);
    aLerp.Interpolate (theT, aResult);
    return aResult;
  }

public:


  NCollection_Lerp() : myStart(), myEnd() {}


  NCollection_Lerp (const T& theStart, const T& theEnd)
  {
    Init (theStart, theEnd);
  }


  void Init (const T& theStart, const T& theEnd)
  {
    myStart = theStart;
    myEnd = theEnd;
  }





  void Interpolate (double theT, T& theResult) const
  {
    theResult = (1.0 - theT) * myStart + theT * myEnd;
  }

private:
  T myStart;
  T myEnd;
};
# 27 "/usr/include/opencascade/Graphic3d_Camera.hxx" 2
# 38 "/usr/include/opencascade/Graphic3d_Camera.hxx"
class Graphic3d_WorldViewProjState;



class Graphic3d_Camera : public Standard_Transient
{
private:


  template<typename Elem_t>
  struct TransformMatrices
  {


    TransformMatrices() : myIsOrientationValid (false), myIsProjectionValid (false) {}


    void InitOrientation()
    {
      myIsOrientationValid = true;
      Orientation.InitIdentity();
    }


    void InitProjection()
    {
      myIsProjectionValid = true;
      MProjection.InitIdentity();
      LProjection.InitIdentity();
      RProjection.InitIdentity();
    }


    void ResetOrientation() { myIsOrientationValid = false; }


    void ResetProjection() { myIsProjectionValid = false; }


    Standard_Boolean IsOrientationValid() const { return myIsOrientationValid; }


    Standard_Boolean IsProjectionValid() const { return myIsProjectionValid; }


    void DumpJson (Standard_OStream& theOStream, Standard_Integer theDepth = -1) const
    {
      if (IsOrientationValid())
      {
        { if (theDepth != 0 && (void*)(&Orientation) != 
# 87 "/usr/include/opencascade/Graphic3d_Camera.hxx" 3 4
       __null
# 87 "/usr/include/opencascade/Graphic3d_Camera.hxx"
       ) { Standard_SStream aFieldStream; (&Orientation)->DumpJson (aFieldStream, theDepth - 1); TCollection_AsciiString aName = Standard_Dump::DumpFieldToName ("&Orientation"); Standard_Dump::DumpKeyToClass (theOStream, aName, Standard_Dump::Text (aFieldStream)); } }
      }
      if (IsProjectionValid())
      {
        { if (theDepth != 0 && (void*)(&MProjection) != 
# 91 "/usr/include/opencascade/Graphic3d_Camera.hxx" 3 4
       __null
# 91 "/usr/include/opencascade/Graphic3d_Camera.hxx"
       ) { Standard_SStream aFieldStream; (&MProjection)->DumpJson (aFieldStream, theDepth - 1); TCollection_AsciiString aName = Standard_Dump::DumpFieldToName ("&MProjection"); Standard_Dump::DumpKeyToClass (theOStream, aName, Standard_Dump::Text (aFieldStream)); } }
        { if (theDepth != 0 && (void*)(&LProjection) != 
# 92 "/usr/include/opencascade/Graphic3d_Camera.hxx" 3 4
       __null
# 92 "/usr/include/opencascade/Graphic3d_Camera.hxx"
       ) { Standard_SStream aFieldStream; (&LProjection)->DumpJson (aFieldStream, theDepth - 1); TCollection_AsciiString aName = Standard_Dump::DumpFieldToName ("&LProjection"); Standard_Dump::DumpKeyToClass (theOStream, aName, Standard_Dump::Text (aFieldStream)); } }
        { if (theDepth != 0 && (void*)(&RProjection) != 
# 93 "/usr/include/opencascade/Graphic3d_Camera.hxx" 3 4
       __null
# 93 "/usr/include/opencascade/Graphic3d_Camera.hxx"
       ) { Standard_SStream aFieldStream; (&RProjection)->DumpJson (aFieldStream, theDepth - 1); TCollection_AsciiString aName = Standard_Dump::DumpFieldToName ("&RProjection"); Standard_Dump::DumpKeyToClass (theOStream, aName, Standard_Dump::Text (aFieldStream)); } }
      }
      { TCollection_AsciiString aName = Standard_Dump::DumpFieldToName ("myIsOrientationValid"); Standard_Dump::AddValuesSeparator (theOStream); theOStream << "\"" << aName << "\": " << myIsOrientationValid; }
      { TCollection_AsciiString aName = Standard_Dump::DumpFieldToName ("myIsProjectionValid"); Standard_Dump::AddValuesSeparator (theOStream); theOStream << "\"" << aName << "\": " << myIsProjectionValid; }
    }

  public:

    NCollection_Mat4<Elem_t> Orientation;
    NCollection_Mat4<Elem_t> MProjection;
    NCollection_Mat4<Elem_t> LProjection;
    NCollection_Mat4<Elem_t> RProjection;

  private:

    Standard_Boolean myIsOrientationValid;
    Standard_Boolean myIsProjectionValid;

  };

public:







  enum Projection
  {
    Projection_Orthographic,
    Projection_Perspective,
    Projection_Stereo,
    Projection_MonoLeftEye,
    Projection_MonoRightEye
  };





  enum FocusType
  {
    FocusType_Absolute,
    FocusType_Relative
  };





  enum IODType
  {
    IODType_Absolute,
    IODType_Relative
  };

public:







  Graphic3d_Camera();



  Graphic3d_Camera (const opencascade::handle<Graphic3d_Camera>& theOther);


  void CopyMappingData (const opencascade::handle<Graphic3d_Camera>& theOtherCamera);


  void CopyOrientationData (const opencascade::handle<Graphic3d_Camera>& theOtherCamera);



  void Copy (const opencascade::handle<Graphic3d_Camera>& theOther);


public:



  const gp_Dir& Direction() const { return myDirection; }




  void SetDirectionFromEye (const gp_Dir& theDir);




  void SetDirection (const gp_Dir& theDir);



  const gp_Dir& Up() const { return myUp; }





  void SetUp (const gp_Dir& theUp);


  void OrthogonalizeUp();


  gp_Dir OrthogonalizedUp() const;


  gp_Dir SideRight() const
  {
    return -(gp_Vec (Direction()) ^ gp_Vec (OrthogonalizedUp()));
  }



  const gp_Pnt& Eye() const { return myEye; }





  void MoveEyeTo (const gp_Pnt& theEye);




  void SetEyeAndCenter (const gp_Pnt& theEye,
                                        const gp_Pnt& theCenter);






  void SetEye (const gp_Pnt& theEye);




  gp_Pnt Center() const
  {
    return myEye.XYZ() + myDirection.XYZ() * myDistance;
  }





  void SetCenter (const gp_Pnt& theCenter);



  Standard_Real Distance() const { return myDistance; }



  void SetDistance (const Standard_Real theDistance);



  Standard_Real Scale() const;
# 270 "/usr/include/opencascade/Graphic3d_Camera.hxx"
  void SetScale (const Standard_Real theScale);



  const gp_XYZ& AxialScale() const { return myAxialScale; }



  void SetAxialScale (const gp_XYZ& theAxialScale);






  void SetProjectionType (const Projection theProjection);


  Projection ProjectionType() const
  {
    return myProjType;
  }




  Standard_Boolean IsOrthographic() const
  {
    return (myProjType == Projection_Orthographic);
  }






  Standard_Boolean IsStereo() const
  {
    return (myProjType == Projection_Stereo);
  }




  void SetFOVy (const Standard_Real theFOVy);



  Standard_Real FOVy() const { return myFOVy; }



  Standard_Real FOVx() const { return myFOVx; }





  Standard_Real FOV2d() const { return myFOV2d; }


  void SetFOV2d (Standard_Real theFOV);
# 345 "/usr/include/opencascade/Graphic3d_Camera.hxx"
  bool ZFitAll (const Standard_Real theScaleFactor,
                                const Bnd_Box& theMinMax,
                                const Bnd_Box& theGraphicBB,
                                Standard_Real& theZNear,
                                Standard_Real& theZFar) const;


  void ZFitAll (const Standard_Real theScaleFactor, const Bnd_Box& theMinMax, const Bnd_Box& theGraphicBB)
  {
    Standard_Real aZNear = 0.0, aZFar = 1.0;
    ZFitAll (theScaleFactor, theMinMax, theGraphicBB, aZNear, aZFar);
    SetZRange (aZNear, aZFar);
  }
# 366 "/usr/include/opencascade/Graphic3d_Camera.hxx"
  void SetZRange (const Standard_Real theZNear, const Standard_Real theZFar);



  Standard_Real ZNear() const
  {
    return myZNear;
  }



  Standard_Real ZFar() const
  {
    return myZFar;
  }



  void SetAspect (const Standard_Real theAspect);



  Standard_Real Aspect() const
  {
    return myAspect;
  }







  void SetZFocus (const FocusType theType, const Standard_Real theZFocus);




  Standard_Real ZFocus() const
  {
    return myZFocus;
  }



  FocusType ZFocusType() const
  {
    return myZFocusType;
  }





  void SetIOD (const IODType theType, const Standard_Real theIOD);



  Standard_Real IOD() const
  {
    return myIOD;
  }



  IODType GetIODType() const
  {
    return myIODType;
  }


  const Graphic3d_CameraTile& Tile() const { return myTile; }




  void SetTile (const Graphic3d_CameraTile& theTile);


public:




  void Transform (const gp_Trsf& theTrsf);




  gp_XYZ ViewDimensions() const
  {
    return ViewDimensions (Distance());
  }





  gp_XYZ ViewDimensions (const Standard_Real theZValue) const;



  Standard_Real NDC2dOffsetX() const
  {
    return myFOV2d >= myFOVx
         ? 0.5
         : 0.5 * myFOV2d / myFOVx;
  }



  Standard_Real NDC2dOffsetY() const
  {
    return myFOV2d >= myFOVy
         ? 0.5
         : 0.5 * myFOV2d / myFOVy;
  }
# 496 "/usr/include/opencascade/Graphic3d_Camera.hxx"
  void Frustum (gp_Pln& theLeft,
                                gp_Pln& theRight,
                                gp_Pln& theBottom,
                                gp_Pln& theTop,
                                gp_Pln& theNear,
                                gp_Pln& theFar) const;


public:





  gp_Pnt Project (const gp_Pnt& thePnt) const;





  gp_Pnt UnProject (const gp_Pnt& thePnt) const;





  gp_Pnt ConvertView2Proj (const gp_Pnt& thePnt) const;





  gp_Pnt ConvertProj2View (const gp_Pnt& thePnt) const;





  gp_Pnt ConvertWorld2View (const gp_Pnt& thePnt) const;





  gp_Pnt ConvertView2World (const gp_Pnt& thePnt) const;


public:


  const Graphic3d_WorldViewProjState& WorldViewProjState() const
  {
    return myWorldViewProjState;
  }



  Standard_Size ProjectionState() const
  {
    return myWorldViewProjState.ProjectionState();
  }


  Standard_Size WorldViewState() const
  {
    return myWorldViewProjState.WorldViewState();
  }


public:



  const Graphic3d_Mat4d& OrientationMatrix() const;



  const Graphic3d_Mat4& OrientationMatrixF() const;




  const Graphic3d_Mat4d& ProjectionMatrix() const;




  const Graphic3d_Mat4& ProjectionMatrixF() const;



  const Graphic3d_Mat4d& ProjectionStereoLeft() const;



  const Graphic3d_Mat4& ProjectionStereoLeftF() const;



  const Graphic3d_Mat4d& ProjectionStereoRight() const;



  const Graphic3d_Mat4& ProjectionStereoRightF() const;



  void InvalidateProjection();



  void InvalidateOrientation();

public:






  void StereoProjection (Graphic3d_Mat4d& theProjL,
                                         Graphic3d_Mat4d& theHeadToEyeL,
                                         Graphic3d_Mat4d& theProjR,
                                         Graphic3d_Mat4d& theHeadToEyeR) const;






  void StereoProjectionF (Graphic3d_Mat4& theProjL,
                                          Graphic3d_Mat4& theHeadToEyeL,
                                          Graphic3d_Mat4& theProjR,
                                          Graphic3d_Mat4& theHeadToEyeR) const;


  void ResetCustomProjection();


  bool IsCustomStereoFrustum() const { return myIsCustomFrustomLR; }



  void SetCustomStereoFrustums (const Aspect_FrustumLRBT<Standard_Real>& theFrustumL,
                                                const Aspect_FrustumLRBT<Standard_Real>& theFrustumR);


  bool IsCustomStereoProjection() const { return myIsCustomProjMatLR; }






  void SetCustomStereoProjection (const Graphic3d_Mat4d& theProjL,
                                                  const Graphic3d_Mat4d& theHeadToEyeL,
                                                  const Graphic3d_Mat4d& theProjR,
                                                  const Graphic3d_Mat4d& theHeadToEyeR);


  bool IsCustomMonoProjection() const { return myIsCustomProjMatM; }


  void SetCustomMonoProjection (const Graphic3d_Mat4d& theProj);


  void DumpJson (Standard_OStream& theOStream, Standard_Integer theDepth = -1) const;


private:






  template <typename Elem_t>
  void stereoProjection (NCollection_Mat4<Elem_t>& theProjL,
                                         NCollection_Mat4<Elem_t>& theHeadToEyeL,
                                         NCollection_Mat4<Elem_t>& theProjR,
                                         NCollection_Mat4<Elem_t>& theHeadToEyeR) const;






  template <typename Elem_t>
  void computeProjection (NCollection_Mat4<Elem_t>& theProjM,
                                          NCollection_Mat4<Elem_t>& theProjL,
                                          NCollection_Mat4<Elem_t>& theProjR,
                                          bool theToAddHeadToEye) const;



  template <typename Elem_t>
  TransformMatrices<Elem_t>& UpdateProjection (TransformMatrices<Elem_t>& theMatrices) const
  {
    if (!theMatrices.IsProjectionValid())
    {
      theMatrices.InitProjection();
      computeProjection (theMatrices.MProjection, theMatrices.LProjection, theMatrices.RProjection, true);
    }
    return theMatrices;
  }



  template <typename Elem_t>
 
    TransformMatrices<Elem_t>& UpdateOrientation (TransformMatrices<Elem_t>& theMatrices) const;

private:






  template <typename Elem_t>
  static void orthoProj (NCollection_Mat4<Elem_t>& theOutMx,
                         const Aspect_FrustumLRBT<Elem_t>& theLRBT,
                         const Elem_t theNear,
                         const Elem_t theFar);






  template <typename Elem_t>
  static void perspectiveProj (NCollection_Mat4<Elem_t>& theOutMx,
                               const Aspect_FrustumLRBT<Elem_t>& theLRBT,
                               const Elem_t theNear,
                               const Elem_t theFar);
# 740 "/usr/include/opencascade/Graphic3d_Camera.hxx"
  template <typename Elem_t>
  static void stereoEyeProj (NCollection_Mat4<Elem_t>& theOutMx,
                             const Aspect_FrustumLRBT<Elem_t>& theLRBT,
                             const Elem_t theNear,
                             const Elem_t theFar,
                             const Elem_t theIOD,
                             const Elem_t theZFocus,
                             const Aspect_Eye theEyeIndex);
# 757 "/usr/include/opencascade/Graphic3d_Camera.hxx"
  template <typename Elem_t>
  static void
    LookOrientation (const NCollection_Vec3<Elem_t>& theEye,
                     const NCollection_Vec3<Elem_t>& theFwdDir,
                     const NCollection_Vec3<Elem_t>& theUpDir,
                     const NCollection_Vec3<Elem_t>& theAxialScale,
                     NCollection_Mat4<Elem_t>& theOutMx);

public:


  enum
  {
    FrustumVert_LeftBottomNear,
    FrustumVert_LeftBottomFar,
    FrustumVert_LeftTopNear,
    FrustumVert_LeftTopFar,
    FrustumVert_RightBottomNear,
    FrustumVert_RightBottomFar,
    FrustumVert_RightTopNear,
    FrustumVert_RightTopFar,
    FrustumVerticesNB
  };




  void FrustumPoints (NCollection_Array1<Graphic3d_Vec3d>& thePoints,
                                      const Graphic3d_Mat4d& theModelWorld = Graphic3d_Mat4d()) const;

private:

  gp_Dir myUp;
  gp_Dir myDirection;
  gp_Pnt myEye;
  Standard_Real myDistance;

  gp_XYZ myAxialScale;

  Projection myProjType;
  Standard_Real myFOVy;
  Standard_Real myFOVx;
  Standard_Real myFOV2d;
  Standard_Real myFOVyTan;
  Standard_Real myZNear;
  Standard_Real myZFar;
  Standard_Real myAspect;

  Standard_Real myScale;
  Standard_Real myZFocus;
  FocusType myZFocusType;

  Standard_Real myIOD;
  IODType myIODType;

  Graphic3d_CameraTile myTile;

  Graphic3d_Mat4d myCustomProjMatM;
  Graphic3d_Mat4d myCustomProjMatL;
  Graphic3d_Mat4d myCustomProjMatR;
  Graphic3d_Mat4d myCustomHeadToEyeMatL;
  Graphic3d_Mat4d myCustomHeadToEyeMatR;
  Aspect_FrustumLRBT<Standard_Real> myCustomFrustumL;
  Aspect_FrustumLRBT<Standard_Real> myCustomFrustumR;
  Standard_Boolean myIsCustomProjMatM;
  Standard_Boolean myIsCustomProjMatLR;
  Standard_Boolean myIsCustomFrustomLR;

  mutable TransformMatrices<Standard_Real> myMatricesD;
  mutable TransformMatrices<Standard_ShortReal> myMatricesF;

  mutable Graphic3d_WorldViewProjState myWorldViewProjState;

public:

  public: typedef Standard_Transient base_type; static const char* get_type_name () { return "Graphic3d_Camera"; using direct_base_classes = opencascade::direct_base_class_as_tuple<std::tr2::direct_bases<Graphic3d_Camera>::type>::type; static_assert(opencascade::has_type<Standard_Transient, direct_base_classes>::type::value, "OCCT RTTI definition is incorrect: " "Standard_Transient" " is not direct base class of " "Graphic3d_Camera"); static_assert(&get_type_name == &Graphic3d_Camera::get_type_name, "OCCT RTTI definition is misplaced: current class is not " "Graphic3d_Camera"); } static const opencascade::handle<Standard_Type>& get_type_descriptor (); virtual const opencascade::handle<Standard_Type>& DynamicType() const override;
};

class Graphic3d_Camera; typedef opencascade::handle<Graphic3d_Camera> Handle_Graphic3d_Camera;
# 854 "/usr/include/opencascade/Graphic3d_Camera.hxx"
template<>
 void NCollection_Lerp<opencascade::handle<Graphic3d_Camera> >::Interpolate (const double theT,
                                                                              opencascade::handle<Graphic3d_Camera>& theResult) const;
typedef NCollection_Lerp<opencascade::handle<Graphic3d_Camera> > Graphic3d_CameraLerp;
# 23 "/usr/include/opencascade/Graphic3d_TransformPers.hxx" 2
# 1 "/usr/include/opencascade/Graphic3d_TransformUtils.hxx" 1
# 20 "/usr/include/opencascade/Graphic3d_TransformUtils.hxx"
# 1 "/usr/include/opencascade/Standard_math.hxx" 1
# 21 "/usr/include/opencascade/Graphic3d_TransformUtils.hxx" 2


namespace Graphic3d_TransformUtils
{
  template<class T> struct MatrixType {};

  template<> struct MatrixType<Standard_Real> { typedef Graphic3d_Mat4d Mat4; };

  template<> struct MatrixType<Standard_ShortReal> { typedef Graphic3d_Mat4 Mat4; };

  template<class T> struct VectorType {};

  template<> struct VectorType<Standard_Real> {
    typedef Graphic3d_Vec2d Vec2;
    typedef Graphic3d_Vec3d Vec3;
    typedef Graphic3d_Vec4d Vec4;
  };

  template<> struct VectorType<Standard_ShortReal> {
    typedef Graphic3d_Vec2 Vec2;
    typedef Graphic3d_Vec3 Vec3;
    typedef Graphic3d_Vec4 Vec4;
  };


  template<class T>
  static void Convert (const gp_Trsf& theTransformation,
                       typename MatrixType<T>::Mat4& theOut);


  template<class T>
  static void Ortho (typename MatrixType<T>::Mat4& theOut,
                     const T theLeft,
                     const T theRight,
                     const T theBottom,
                     const T theTop,
                     const T theZNear,
                     const T theZFar);


  template<class T>
  static void Ortho2D (typename MatrixType<T>::Mat4& theOut,
                       const T theLeft,
                       const T theRight,
                       const T theBottom,
                       const T theTop);


  template<class T>
  static Standard_Boolean Project (const T theObjX,
                                   const T theObjY,
                                   const T theObjZ,
                                   const typename MatrixType<T>::Mat4& theModViewMat,
                                   const typename MatrixType<T>::Mat4& theProjectMat,
                                   const Standard_Integer theViewport[4],
                                   T& theWinX,
                                   T& theWinY,
                                   T& theWinZ);


  template<class T>
  static Standard_Boolean UnProject (const T theWinX,
                                     const T theWinY,
                                     const T theWinZ,
                                     const typename MatrixType<T>::Mat4& theModViewMat,
                                     const typename MatrixType<T>::Mat4& theProjectMat,
                                     const Standard_Integer theViewport[4],
                                     T& theObjX,
                                     T& theObjY,
                                     T& theObjZ);


  template<class T>
  static void ConstructRotate (typename MatrixType<T>::Mat4& theOut,
                               T theA,
                               T theX,
                               T theY,
                               T theZ);


  template<class T>
  static void Rotate (typename MatrixType<T>::Mat4& theOut,
                      T theA,
                      T theX,
                      T theY,
                      T theZ);


  template<class T>
  static void Scale (typename MatrixType<T>::Mat4& theOut,
                     T theX,
                     T theY,
                     T theZ);


  template<class T>
  static void Translate (typename MatrixType<T>::Mat4& theOut,
                         T theX,
                         T theY,
                         T theZ);


  template<class T>
  static Standard_Real ScaleFactor (const typename MatrixType<T>::Mat4& theMatrix);
}





template<class T>
void Graphic3d_TransformUtils::Convert (const gp_Trsf& theTransformation,
                                        typename MatrixType<T>::Mat4& theOut)
{
  theOut.InitIdentity();


  theOut.ChangeValue (0, 0) = theTransformation.Value (1, 1);
  theOut.ChangeValue (0, 1) = theTransformation.Value (1, 2);
  theOut.ChangeValue (0, 2) = theTransformation.Value (1, 3);
  theOut.ChangeValue (1, 0) = theTransformation.Value (2, 1);
  theOut.ChangeValue (1, 1) = theTransformation.Value (2, 2);
  theOut.ChangeValue (1, 2) = theTransformation.Value (2, 3);
  theOut.ChangeValue (2, 0) = theTransformation.Value (3, 1);
  theOut.ChangeValue (2, 1) = theTransformation.Value (3, 2);
  theOut.ChangeValue (2, 2) = theTransformation.Value (3, 3);


  theOut.ChangeValue (0, 3) = theTransformation.TranslationPart().X();
  theOut.ChangeValue (1, 3) = theTransformation.TranslationPart().Y();
  theOut.ChangeValue (2, 3) = theTransformation.TranslationPart().Z();
}





template<class T>
void Graphic3d_TransformUtils::Rotate (typename MatrixType<T>::Mat4& theOut,
                                       T theA,
                                       T theX,
                                       T theY,
                                       T theZ)
{
  typename MatrixType<T>::Mat4 aMat;
  ConstructRotate (aMat, theA, theX, theY, theZ);
  theOut = theOut * aMat;
}





template<class T>
void Graphic3d_TransformUtils::Translate (typename MatrixType<T>::Mat4& theOut,
                                          T theX,
                                          T theY,
                                          T theZ)
{
  theOut.ChangeValue (0, 3) = theOut.GetValue (0, 0) * theX +
                              theOut.GetValue (0, 1) * theY +
                              theOut.GetValue (0, 2) * theZ +
                              theOut.GetValue (0, 3);

  theOut.ChangeValue (1, 3) = theOut.GetValue (1, 0) * theX +
                              theOut.GetValue (1, 1) * theY +
                              theOut.GetValue (1, 2) * theZ +
                              theOut.GetValue (1, 3);

  theOut.ChangeValue (2, 3) = theOut.GetValue (2, 0) * theX +
                              theOut.GetValue (2, 1) * theY +
                              theOut.GetValue (2, 2) * theZ +
                              theOut.GetValue (2, 3);

  theOut.ChangeValue (3, 3) = theOut.GetValue (3, 0) * theX +
                              theOut.GetValue (3, 1) * theY +
                              theOut.GetValue (3, 2) * theZ +
                              theOut.GetValue (3, 3);
}





template<class T>
void Graphic3d_TransformUtils::Scale (typename MatrixType<T>::Mat4& theOut,
                                      T theX,
                                      T theY,
                                      T theZ)
{
  theOut.ChangeValue (0, 0) *= theX;
  theOut.ChangeValue (1, 0) *= theX;
  theOut.ChangeValue (2, 0) *= theX;
  theOut.ChangeValue (3, 0) *= theX;

  theOut.ChangeValue (0, 1) *= theY;
  theOut.ChangeValue (1, 1) *= theY;
  theOut.ChangeValue (2, 1) *= theY;
  theOut.ChangeValue (3, 1) *= theY;

  theOut.ChangeValue (0, 2) *= theZ;
  theOut.ChangeValue (1, 2) *= theZ;
  theOut.ChangeValue (2, 2) *= theZ;
  theOut.ChangeValue (3, 2) *= theZ;
}





template<class T>
void Graphic3d_TransformUtils::ConstructRotate (typename MatrixType<T>::Mat4& theOut,
                                                T theA,
                                                T theX,
                                                T theY,
                                                T theZ)
{
  const T aSin = std::sin (theA * static_cast<T> (
# 238 "/usr/include/opencascade/Graphic3d_TransformUtils.hxx" 3 4
                                                 3.14159265358979323846 
# 238 "/usr/include/opencascade/Graphic3d_TransformUtils.hxx"
                                                      / 180.0));
  const T aCos = std::cos (theA * static_cast<T> (
# 239 "/usr/include/opencascade/Graphic3d_TransformUtils.hxx" 3 4
                                                 3.14159265358979323846 
# 239 "/usr/include/opencascade/Graphic3d_TransformUtils.hxx"
                                                      / 180.0));

  const Standard_Boolean isOnlyX = (theX != static_cast<T> (0.0))
                                && (theY == static_cast<T> (0.0))
                                && (theZ == static_cast<T> (0.0));

  const Standard_Boolean isOnlyY = (theX == static_cast<T> (0.0))
                                && (theY != static_cast<T> (0.0))
                                && (theZ == static_cast<T> (0.0));

  const Standard_Boolean isOnlyZ = (theX == static_cast<T> (0.0))
                                && (theY == static_cast<T> (0.0))
                                && (theZ != static_cast<T> (0.0));

  if (isOnlyX)
  {
    theOut.SetValue (1, 1, aCos);
    theOut.SetValue (2, 2, aCos);

    if (theX < static_cast<T> (0.0))
    {
      theOut.SetValue (1, 2, aSin);
      theOut.SetValue (2, 1, -aSin);
    }
    else
    {
      theOut.SetValue (1, 2, -aSin);
      theOut.SetValue (2, 1, aSin);
    }

    return;
  }
  else if (isOnlyY)
  {
    theOut.SetValue (0, 0, aCos);
    theOut.SetValue (2, 2, aCos);

    if (theY < static_cast<T> (0.0))
    {
      theOut.SetValue (0, 2, -aSin);
      theOut.SetValue (2, 0, aSin);
    }
    else
    {
      theOut.SetValue (0, 2, aSin);
      theOut.SetValue (2, 0, -aSin);
    }

    return;
  }
  else if (isOnlyZ)
  {
    theOut.SetValue (0, 0, aCos);
    theOut.SetValue (1, 1, aCos);

    if (theZ < static_cast<T> (0.0))
    {
      theOut.SetValue (0, 1, aSin);
      theOut.SetValue (1, 0, -aSin);
    }
    else
    {
      theOut.SetValue (0, 1, -aSin);
      theOut.SetValue (1, 0, aSin);
    }

    return;
  }

  T aNorm = std::sqrt (theX * theX + theY * theY + theZ * theZ);

  if (aNorm <= static_cast<T> (1.0e-4))
  {
    return;
  }

  aNorm = static_cast<T> (1.0) / aNorm;

  theX *= aNorm;
  theY *= aNorm;
  theZ *= aNorm;

  const T aXX = theX * theX;
  const T aYY = theY * theY;
  const T aZZ = theZ * theZ;
  const T aXY = theX * theY;
  const T aYZ = theY * theZ;
  const T aZX = theZ * theX;
  const T aSinX = theX * aSin;
  const T aSinY = theY * aSin;
  const T aSinZ = theZ * aSin;

  const T aOneMinusCos = static_cast<T> (1.0) - aCos;

  theOut.SetValue (0, 0, aOneMinusCos * aXX + aCos);
  theOut.SetValue (0, 1, aOneMinusCos * aXY - aSinZ);
  theOut.SetValue (0, 2, aOneMinusCos * aZX + aSinY);

  theOut.SetValue (1, 0, aOneMinusCos * aXY + aSinZ);
  theOut.SetValue (1, 1, aOneMinusCos * aYY + aCos);
  theOut.SetValue (1, 2, aOneMinusCos * aYZ - aSinX);

  theOut.SetValue (2, 0, aOneMinusCos * aZX - aSinY);
  theOut.SetValue (2, 1, aOneMinusCos * aYZ + aSinX);
  theOut.SetValue (2, 2, aOneMinusCos * aZZ + aCos);
}





template<class T>
void Graphic3d_TransformUtils::Ortho (typename MatrixType<T>::Mat4& theOut,
                                      const T theLeft,
                                      const T theRight,
                                      const T theBottom,
                                      const T theTop,
                                      const T theZNear,
                                      const T theZFar)
{
  theOut.InitIdentity();

  T* aData = theOut.ChangeData();

  const T anInvDx = static_cast<T> (1.0) / (theRight - theLeft);
  const T anInvDy = static_cast<T> (1.0) / (theTop - theBottom);
  const T anInvDz = static_cast<T> (1.0) / (theZFar - theZNear);

  aData[0] = static_cast<T> ( 2.0) * anInvDx;
  aData[5] = static_cast<T> ( 2.0) * anInvDy;
  aData[10] = static_cast<T> (-2.0) * anInvDz;

  aData[12] = -(theRight + theLeft) * anInvDx;
  aData[13] = -(theTop + theBottom) * anInvDy;
  aData[14] = -(theZFar + theZNear) * anInvDz;
}





template<class T>
void Graphic3d_TransformUtils::Ortho2D (typename MatrixType<T>::Mat4& theOut,
                                        const T theLeft,
                                        const T theRight,
                                        const T theBottom,
                                        const T theTop)
{
  Ortho (theOut, theLeft, theRight, theBottom, theTop, static_cast<T> (-1.0), static_cast<T> (1.0));
}





template<class T>
static Standard_Boolean Graphic3d_TransformUtils::Project (const T theObjX,
                                                           const T theObjY,
                                                           const T theObjZ,
                                                           const typename MatrixType<T>::Mat4& theModViewMat,
                                                           const typename MatrixType<T>::Mat4& theProjectMat,
                                                           const Standard_Integer theViewport[4],
                                                           T& theWinX,
                                                           T& theWinY,
                                                           T& theWinZ)
{
  typename VectorType<T>::Vec4 anIn (theObjX, theObjY, theObjZ, static_cast<T> (1.0));

  typename VectorType<T>::Vec4 anOut = theProjectMat * (theModViewMat * anIn);

  if (anOut.w() == static_cast<T> (0.0))
  {
    return false;
  }

  anOut.w() = static_cast<T> (1.0) / anOut.w();

  anOut.x() *= anOut.w();
  anOut.y() *= anOut.w();
  anOut.z() *= anOut.w();


  anOut.x() = anOut.x() * static_cast<T> (0.5) + static_cast<T> (0.5);
  anOut.y() = anOut.y() * static_cast<T> (0.5) + static_cast<T> (0.5);
  anOut.z() = anOut.z() * static_cast<T> (0.5) + static_cast<T> (0.5);


  anOut.x() = anOut.x() * theViewport[2] + theViewport[0];
  anOut.y() = anOut.y() * theViewport[3] + theViewport[1];

  theWinX = anOut.x();
  theWinY = anOut.y();
  theWinZ = anOut.z();

  return true;
}





template<class T>
static Standard_Boolean Graphic3d_TransformUtils::UnProject (const T theWinX,
                                                             const T theWinY,
                                                             const T theWinZ,
                                                             const typename MatrixType<T>::Mat4& theModViewMat,
                                                             const typename MatrixType<T>::Mat4& theProjectMat,
                                                             const Standard_Integer theViewport[4],
                                                             T& theObjX,
                                                             T& theObjY,
                                                             T& theObjZ)
{
  typename MatrixType<T>::Mat4 anUnviewMat;

  if (!(theProjectMat * theModViewMat).Inverted (anUnviewMat))
  {
    return false;
  }

  typename VectorType<T>::Vec4 anIn (theWinX, theWinY, theWinZ, static_cast<T> (1.0));


  anIn.x() = (anIn.x() - theViewport[0]) / theViewport[2];
  anIn.y() = (anIn.y() - theViewport[1]) / theViewport[3];


  anIn.x() = anIn.x() * static_cast<T> (2.0) - static_cast<T> (1.0);
  anIn.y() = anIn.y() * static_cast<T> (2.0) - static_cast<T> (1.0);
  anIn.z() = anIn.z() * static_cast<T> (2.0) - static_cast<T> (1.0);

  typename VectorType<T>::Vec4 anOut = anUnviewMat * anIn;

  if (anOut.w() == static_cast<T> (0.0))
  {
    return false;
  }

  anOut.w() = static_cast<T> (1.0) / anOut.w();

  anOut.x() *= anOut.w();
  anOut.y() *= anOut.w();
  anOut.z() *= anOut.w();

  theObjX = anOut.x();
  theObjY = anOut.y();
  theObjZ = anOut.z();

  return true;
}





template<class T>
static Standard_Real Graphic3d_TransformUtils::ScaleFactor (const typename MatrixType<T>::Mat4& theMatrix)
{

  const T aDeterminant = (theMatrix.GetValue (0, 0) * theMatrix.GetValue (1, 1) * theMatrix.GetValue (2, 2) +
                          theMatrix.GetValue (0, 1) * theMatrix.GetValue (1, 2) * theMatrix.GetValue (2, 0) +
                          theMatrix.GetValue (0, 2) * theMatrix.GetValue (1, 0) * theMatrix.GetValue (2, 1))
                       - (theMatrix.GetValue (0, 2) * theMatrix.GetValue (1, 1) * theMatrix.GetValue (2, 0) +
                          theMatrix.GetValue (0, 0) * theMatrix.GetValue (1, 2) * theMatrix.GetValue (2, 1) +
                          theMatrix.GetValue (0, 1) * theMatrix.GetValue (1, 0) * theMatrix.GetValue (2, 2));

  return Pow (static_cast<Standard_Real> (aDeterminant), 1.0 / 3.0);
}
# 24 "/usr/include/opencascade/Graphic3d_TransformPers.hxx" 2
# 1 "/usr/include/opencascade/Graphic3d_TransModeFlags.hxx" 1
# 20 "/usr/include/opencascade/Graphic3d_TransModeFlags.hxx"
enum Graphic3d_TransModeFlags
{
  Graphic3d_TMF_None = 0x0000,
  Graphic3d_TMF_ZoomPers = 0x0002,
  Graphic3d_TMF_RotatePers = 0x0008,
  Graphic3d_TMF_TriedronPers = 0x0020,
  Graphic3d_TMF_2d = 0x0040,
  Graphic3d_TMF_ZoomRotatePers = Graphic3d_TMF_ZoomPers
                               | Graphic3d_TMF_RotatePers
};
# 25 "/usr/include/opencascade/Graphic3d_TransformPers.hxx" 2



class Graphic3d_TransformPers; typedef opencascade::handle<Graphic3d_TransformPers> Handle_Graphic3d_TransformPers;
# 45 "/usr/include/opencascade/Graphic3d_TransformPers.hxx"
class Graphic3d_TransformPers : public Standard_Transient
{
  public: typedef Standard_Transient base_type; static const char* get_type_name () { return "Graphic3d_TransformPers"; using direct_base_classes = opencascade::direct_base_class_as_tuple<std::tr2::direct_bases<Graphic3d_TransformPers>::type>::type; static_assert(opencascade::has_type<Standard_Transient, direct_base_classes>::type::value, "OCCT RTTI definition is incorrect: " "Standard_Transient" " is not direct base class of " "Graphic3d_TransformPers"); static_assert(&get_type_name == &Graphic3d_TransformPers::get_type_name, "OCCT RTTI definition is misplaced: current class is not " "Graphic3d_TransformPers"); } static const opencascade::handle<Standard_Type>& get_type_descriptor (); virtual const opencascade::handle<Standard_Type>& DynamicType() const override;
public:


  static Standard_Boolean IsZoomOrRotate (Graphic3d_TransModeFlags theMode)
  {
    return (theMode & (Graphic3d_TMF_ZoomPers | Graphic3d_TMF_RotatePers)) != 0;
  }


  static Standard_Boolean IsTrihedronOr2d (Graphic3d_TransModeFlags theMode)
  {
    return (theMode & (Graphic3d_TMF_TriedronPers | Graphic3d_TMF_2d)) != 0;
  }



  static opencascade::handle<Graphic3d_TransformPers> FromDeprecatedParams (Graphic3d_TransModeFlags theFlag,
                                                                               const gp_Pnt& thePoint);

public:


  Graphic3d_TransformPers (const Graphic3d_TransModeFlags theMode)
  : myMode (theMode)
  {
    if (IsZoomOrRotate (theMode))
    {
      SetPersistence (theMode, gp_Pnt(0.0, 0.0, 0.0));
    }
    else if (IsTrihedronOr2d (theMode))
    {
      SetPersistence (theMode, Aspect_TOTP_LEFT_LOWER, Graphic3d_Vec2i (0, 0));
    }
    else
    {
      throw Standard_ProgramError("Graphic3d_TransformPers::SetPersistence(), wrong persistence mode.");
    }
  }




  Graphic3d_TransformPers (const Graphic3d_TransModeFlags theMode,
                           const gp_Pnt& thePnt)
  : myMode (Graphic3d_TMF_None)
  {
    SetPersistence (theMode, thePnt);
  }





  Graphic3d_TransformPers (const Graphic3d_TransModeFlags theMode,
                           const Aspect_TypeOfTriedronPosition theCorner,
                           const Graphic3d_Vec2i& theOffset = Graphic3d_Vec2i (0, 0))
  : myMode (Graphic3d_TMF_None)
  {
    SetPersistence (theMode, theCorner, theOffset);
  }


  Standard_Boolean IsZoomOrRotate() const { return IsZoomOrRotate (myMode); }


  Standard_Boolean IsTrihedronOr2d() const { return IsTrihedronOr2d (myMode); }


  Graphic3d_TransModeFlags Mode() const { return myMode; }


  Graphic3d_TransModeFlags Flags() const { return myMode; }



  void SetPersistence (const Graphic3d_TransModeFlags theMode,
                       const gp_Pnt& thePnt)
  {
    if (!IsZoomOrRotate (theMode))
    {
      throw Standard_ProgramError("Graphic3d_TransformPers::SetPersistence(), wrong persistence mode.");
    }

    myMode = theMode;
    myParams.Params3d.PntX = thePnt.X();
    myParams.Params3d.PntY = thePnt.Y();
    myParams.Params3d.PntZ = thePnt.Z();
  }



  void SetPersistence (const Graphic3d_TransModeFlags theMode,
                       const Aspect_TypeOfTriedronPosition theCorner,
                       const Graphic3d_Vec2i& theOffset)
  {
    if (!IsTrihedronOr2d (theMode))
    {
      throw Standard_ProgramError("Graphic3d_TransformPers::SetPersistence(), wrong persistence mode.");
    }

    myMode = theMode;
    myParams.Params2d.Corner = theCorner;
    myParams.Params2d.OffsetX = theOffset.x();
    myParams.Params2d.OffsetY = theOffset.y();
  }

public:


  gp_Pnt AnchorPoint() const
  {
    if (!IsZoomOrRotate())
    {
      throw Standard_ProgramError("Graphic3d_TransformPers::AnchorPoint(), wrong persistence mode.");
    }

    return gp_Pnt (myParams.Params3d.PntX, myParams.Params3d.PntY, myParams.Params3d.PntZ);
  }


  void SetAnchorPoint (const gp_Pnt& thePnt)
  {
    if (!IsZoomOrRotate())
    {
      throw Standard_ProgramError("Graphic3d_TransformPers::SetAnchorPoint(), wrong persistence mode.");
    }

    myParams.Params3d.PntX = thePnt.X();
    myParams.Params3d.PntY = thePnt.Y();
    myParams.Params3d.PntZ = thePnt.Z();
  }


  Aspect_TypeOfTriedronPosition Corner2d() const
  {
    if (!IsTrihedronOr2d())
    {
      throw Standard_ProgramError("Graphic3d_TransformPers::Corner2d(), wrong persistence mode.");
    }

    return myParams.Params2d.Corner;
  }


  void SetCorner2d (const Aspect_TypeOfTriedronPosition thePos)
  {
    if (!IsTrihedronOr2d())
    {
      throw Standard_ProgramError("Graphic3d_TransformPers::SetCorner2d(), wrong persistence mode.");
    }

    myParams.Params2d.Corner = thePos;
  }


  Graphic3d_Vec2i Offset2d() const
  {
    if (!IsTrihedronOr2d())
    {
      throw Standard_ProgramError("Graphic3d_TransformPers::Offset2d(), wrong persistence mode.");
    }

    return Graphic3d_Vec2i (myParams.Params2d.OffsetX, myParams.Params2d.OffsetY);
  }


  void SetOffset2d (const Graphic3d_Vec2i& theOffset)
  {
    if (!IsTrihedronOr2d())
    {
      throw Standard_ProgramError("Graphic3d_TransformPers::SetOffset2d(), wrong persistence mode.");
    }

    myParams.Params2d.OffsetX = theOffset.x();
    myParams.Params2d.OffsetY = theOffset.y();
  }

public:
# 234 "/usr/include/opencascade/Graphic3d_TransformPers.hxx"
  template<class T>
  void Apply (const opencascade::handle<Graphic3d_Camera>& theCamera,
              const NCollection_Mat4<T>& theProjection,
              const NCollection_Mat4<T>& theWorldView,
              const Standard_Integer theViewportWidth,
              const Standard_Integer theViewportHeight,
              Bnd_Box& theBoundingBox) const;
# 249 "/usr/include/opencascade/Graphic3d_TransformPers.hxx"
  template<class T>
  void Apply (const opencascade::handle<Graphic3d_Camera>& theCamera,
              const NCollection_Mat4<T>& theProjection,
              const NCollection_Mat4<T>& theWorldView,
              const Standard_Integer theViewportWidth,
              const Standard_Integer theViewportHeight,
              BVH_Box<T, 3>& theBoundingBox) const;
# 266 "/usr/include/opencascade/Graphic3d_TransformPers.hxx"
  template<class T>
  NCollection_Mat4<T> Compute (const opencascade::handle<Graphic3d_Camera>& theCamera,
                               const NCollection_Mat4<T>& theProjection,
                               const NCollection_Mat4<T>& theWorldView,
                               const Standard_Integer theViewportWidth,
                               const Standard_Integer theViewportHeight) const;







  template<class T>
  void Apply (const opencascade::handle<Graphic3d_Camera>& theCamera,
              const NCollection_Mat4<T>& theProjection,
              NCollection_Mat4<T>& theWorldView,
              const Standard_Integer theViewportWidth,
              const Standard_Integer theViewportHeight) const;


  virtual void DumpJson (Standard_OStream& theOStream, Standard_Integer theDepth = -1) const;

private:


  struct PersParams3d
  {
    Standard_Real PntX;
    Standard_Real PntY;
    Standard_Real PntZ;


    void DumpJson (Standard_OStream& theOStream, Standard_Integer theDepth = -1) const;
  };


  struct PersParams2d
  {
    Standard_Integer OffsetX;
    Standard_Integer OffsetY;
    Aspect_TypeOfTriedronPosition Corner;


    void DumpJson (Standard_OStream& theOStream, Standard_Integer theDepth = -1) const;
  };

private:

  Graphic3d_TransModeFlags myMode;
  union
  {
    PersParams3d Params3d;
    PersParams2d Params2d;
  } myParams;

};





template<class T>
void Graphic3d_TransformPers::Apply (const opencascade::handle<Graphic3d_Camera>& theCamera,
                                     const NCollection_Mat4<T>& theProjection,
                                     NCollection_Mat4<T>& theWorldView,
                                     const Standard_Integer theViewportWidth,
                                     const Standard_Integer theViewportHeight) const
{
  (void )theViewportWidth;
  (void )theProjection;
  if (myMode == Graphic3d_TMF_None
   || theViewportHeight == 0)
  {
    return;
  }


  const Standard_Integer aVPSizeY = theCamera->Tile().IsValid() ? theCamera->Tile().TotalSize.y() : theViewportHeight;



  const Standard_Real aJitterComp = 0.001;
  if (myMode == Graphic3d_TMF_TriedronPers)
  {

    const Standard_Real aFocus = theCamera->IsOrthographic()
                               ? theCamera->Distance()
                               : (theCamera->ZFocusType() == Graphic3d_Camera::FocusType_Relative
                                ? Standard_Real(theCamera->ZFocus() * theCamera->Distance())
                                : Standard_Real(theCamera->ZFocus()));


    const gp_XYZ aViewDim = theCamera->ViewDimensions (aFocus);
    const Standard_Real aScale = Abs(aViewDim.Y()) / Standard_Real(aVPSizeY);
    const gp_Dir aForward = theCamera->Direction();
    gp_XYZ aCenter = theCamera->Center().XYZ() + aForward.XYZ() * (aFocus - theCamera->Distance());
    if ((myParams.Params2d.Corner & (Aspect_TOTP_LEFT | Aspect_TOTP_RIGHT)) != 0)
    {
      const Standard_Real anOffsetX = (Standard_Real(myParams.Params2d.OffsetX) + aJitterComp) * aScale;
      const gp_Dir aSide = aForward.Crossed (theCamera->Up());
      const gp_XYZ aDeltaX = aSide.XYZ() * (Abs(aViewDim.X()) * theCamera->NDC2dOffsetX() - anOffsetX);
      if ((myParams.Params2d.Corner & Aspect_TOTP_RIGHT) != 0)
      {
        aCenter += aDeltaX;
      }
      else
      {
        aCenter -= aDeltaX;
      }
    }
    if ((myParams.Params2d.Corner & (Aspect_TOTP_TOP | Aspect_TOTP_BOTTOM)) != 0)
    {
      const Standard_Real anOffsetY = (Standard_Real(myParams.Params2d.OffsetY) + aJitterComp) * aScale;
      const gp_XYZ aDeltaY = theCamera->Up().XYZ() * (Abs(aViewDim.Y()) * theCamera->NDC2dOffsetY() - anOffsetY);
      if ((myParams.Params2d.Corner & Aspect_TOTP_TOP) != 0)
      {
        aCenter += aDeltaY;
      }
      else
      {
        aCenter -= aDeltaY;
      }
    }

    NCollection_Mat4<Standard_Real> aWorldView = theCamera->OrientationMatrix();
    Graphic3d_TransformUtils::Translate (aWorldView, aCenter.X(), aCenter.Y(), aCenter.Z());
    Graphic3d_TransformUtils::Scale (aWorldView, aScale, aScale, aScale);
    theWorldView.ConvertFrom (aWorldView);
    return;
  }
  else if (myMode == Graphic3d_TMF_2d)
  {
    const Standard_Real aFocus = theCamera->IsOrthographic()
                               ? theCamera->Distance()
                               : (theCamera->ZFocusType() == Graphic3d_Camera::FocusType_Relative
                                ? Standard_Real(theCamera->ZFocus() * theCamera->Distance())
                                : Standard_Real(theCamera->ZFocus()));


    const gp_XYZ aViewDim = theCamera->ViewDimensions (aFocus);
    const Standard_Real aScale = Abs(aViewDim.Y()) / Standard_Real(aVPSizeY);
    gp_XYZ aCenter (0.0, 0.0, -aFocus);
    if ((myParams.Params2d.Corner & (Aspect_TOTP_LEFT | Aspect_TOTP_RIGHT)) != 0)
    {
      aCenter.SetX (-aViewDim.X() * theCamera->NDC2dOffsetX() + (Standard_Real(myParams.Params2d.OffsetX) + aJitterComp) * aScale);
      if ((myParams.Params2d.Corner & Aspect_TOTP_RIGHT) != 0)
      {
        aCenter.SetX (-aCenter.X());
      }
    }
    if ((myParams.Params2d.Corner & (Aspect_TOTP_TOP | Aspect_TOTP_BOTTOM)) != 0)
    {
      aCenter.SetY (-aViewDim.Y() * theCamera->NDC2dOffsetY() + (Standard_Real(myParams.Params2d.OffsetY) + aJitterComp) * aScale);
      if ((myParams.Params2d.Corner & Aspect_TOTP_TOP) != 0)
      {
        aCenter.SetY (-aCenter.Y());
      }
    }

    theWorldView.InitIdentity();
    Graphic3d_TransformUtils::Translate (theWorldView, T(aCenter.X()), T(aCenter.Y()), T(aCenter.Z()));
    Graphic3d_TransformUtils::Scale (theWorldView, T(aScale), T(aScale), T(aScale));
    return;
  }
  else
  {

    NCollection_Mat4<Standard_Real> aWorldView = theCamera->OrientationMatrix();
    Graphic3d_TransformUtils::Translate (aWorldView, myParams.Params3d.PntX, myParams.Params3d.PntY, myParams.Params3d.PntZ);
    if ((myMode & Graphic3d_TMF_RotatePers) != 0)
    {

      aWorldView.SetValue (0, 0, 1.0);
      aWorldView.SetValue (1, 0, 0.0);
      aWorldView.SetValue (2, 0, 0.0);

      aWorldView.SetValue (0, 1, 0.0);
      aWorldView.SetValue (1, 1, 1.0);
      aWorldView.SetValue (2, 1, 0.0);

      aWorldView.SetValue (0, 2, 0.0);
      aWorldView.SetValue (1, 2, 0.0);
      aWorldView.SetValue (2, 2, 1.0);
    }

    if ((myMode & Graphic3d_TMF_ZoomPers) != 0)
    {

      gp_Vec aVecToEye (theCamera->Direction());
      gp_Vec aVecToObj (theCamera->Eye(), gp_Pnt (myParams.Params3d.PntX, myParams.Params3d.PntY, myParams.Params3d.PntZ));
      const Standard_Real aFocus = aVecToObj.Dot (aVecToEye);
      const gp_XYZ aViewDim = theCamera->ViewDimensions (aFocus);
      const Standard_Real aScale = Abs(aViewDim.Y()) / Standard_Real(aVPSizeY);
      Graphic3d_TransformUtils::Scale (aWorldView, aScale, aScale, aScale);
    }
    theWorldView.ConvertFrom (aWorldView);
    return;
  }
}





template<class T>
void Graphic3d_TransformPers::Apply (const opencascade::handle<Graphic3d_Camera>& theCamera,
                                     const NCollection_Mat4<T>& theProjection,
                                     const NCollection_Mat4<T>& theWorldView,
                                     const Standard_Integer theViewportWidth,
                                     const Standard_Integer theViewportHeight,
                                     Bnd_Box& theBoundingBox) const
{
  if (theBoundingBox.IsVoid())
  {
    return;
  }

  T aXmin, aYmin, aZmin, aXmax, aYmax, aZmax;

  theBoundingBox.Get (aXmin, aYmin, aZmin, aXmax, aYmax, aZmax);

  typename BVH_Box<T, 3>::BVH_VecNt aMin (aXmin, aYmin, aZmin);
  typename BVH_Box<T, 3>::BVH_VecNt aMax (aXmax, aYmax, aZmax);
  BVH_Box<T, 3> aBBox (aMin, aMax);

  Apply (theCamera, theProjection, theWorldView, theViewportWidth, theViewportHeight, aBBox);

  theBoundingBox = Bnd_Box();
  theBoundingBox.Update (aBBox.CornerMin().x(), aBBox.CornerMin().y(), aBBox.CornerMin().z(),
                         aBBox.CornerMax().x(), aBBox.CornerMax().y(), aBBox.CornerMax().z());
}





template<class T>
void Graphic3d_TransformPers::Apply (const opencascade::handle<Graphic3d_Camera>& theCamera,
                                     const NCollection_Mat4<T>& theProjection,
                                     const NCollection_Mat4<T>& theWorldView,
                                     const Standard_Integer theViewportWidth,
                                     const Standard_Integer theViewportHeight,
                                     BVH_Box<T, 3>& theBoundingBox) const
{
  NCollection_Mat4<T> aTPers = Compute (theCamera, theProjection, theWorldView, theViewportWidth, theViewportHeight);
  if (aTPers.IsIdentity()
  || !theBoundingBox.IsValid())
  {
    return;
  }

  const typename BVH_Box<T, 3>::BVH_VecNt& aMin = theBoundingBox.CornerMin();
  const typename BVH_Box<T, 3>::BVH_VecNt& aMax = theBoundingBox.CornerMax();

  typename BVH_Box<T, 4>::BVH_VecNt anArrayOfCorners[8];
  anArrayOfCorners[0] = typename BVH_Box<T, 4>::BVH_VecNt (aMin.x(), aMin.y(), aMin.z(), static_cast<T> (1.0));
  anArrayOfCorners[1] = typename BVH_Box<T, 4>::BVH_VecNt (aMin.x(), aMin.y(), aMax.z(), static_cast<T> (1.0));
  anArrayOfCorners[2] = typename BVH_Box<T, 4>::BVH_VecNt (aMin.x(), aMax.y(), aMin.z(), static_cast<T> (1.0));
  anArrayOfCorners[3] = typename BVH_Box<T, 4>::BVH_VecNt (aMin.x(), aMax.y(), aMax.z(), static_cast<T> (1.0));
  anArrayOfCorners[4] = typename BVH_Box<T, 4>::BVH_VecNt (aMax.x(), aMin.y(), aMin.z(), static_cast<T> (1.0));
  anArrayOfCorners[5] = typename BVH_Box<T, 4>::BVH_VecNt (aMax.x(), aMin.y(), aMax.z(), static_cast<T> (1.0));
  anArrayOfCorners[6] = typename BVH_Box<T, 4>::BVH_VecNt (aMax.x(), aMax.y(), aMin.z(), static_cast<T> (1.0));
  anArrayOfCorners[7] = typename BVH_Box<T, 4>::BVH_VecNt (aMax.x(), aMax.y(), aMax.z(), static_cast<T> (1.0));

  theBoundingBox.Clear();
  for (Standard_Integer anIt = 0; anIt < 8; ++anIt)
  {
    typename BVH_Box<T, 4>::BVH_VecNt& aCorner = anArrayOfCorners[anIt];
    aCorner = aTPers * aCorner;
    aCorner = aCorner / aCorner.w();
    theBoundingBox.Add (typename BVH_Box<T, 3>::BVH_VecNt (aCorner.x(), aCorner.y(), aCorner.z()));
  }
}





template<class T>
NCollection_Mat4<T> Graphic3d_TransformPers::Compute (const opencascade::handle<Graphic3d_Camera>& theCamera,
                                                      const NCollection_Mat4<T>& theProjection,
                                                      const NCollection_Mat4<T>& theWorldView,
                                                      const Standard_Integer theViewportWidth,
                                                      const Standard_Integer theViewportHeight) const
{
  if (myMode == Graphic3d_TMF_None)
  {
    return NCollection_Mat4<T>();
  }

  NCollection_Mat4<T> aWorldView (theWorldView);
  NCollection_Mat4<T> anUnviewMat;
  if (!theWorldView.Inverted (anUnviewMat))
  {
    return NCollection_Mat4<T>();
  }



  Apply (theCamera, theProjection, aWorldView, theViewportWidth, theViewportHeight);
  return anUnviewMat * aWorldView;
}
# 26 "/usr/include/opencascade/Graphic3d_CStructure.hxx" 2


# 1 "/usr/include/opencascade/TopLoc_Datum3D.hxx" 1
# 27 "/usr/include/opencascade/TopLoc_Datum3D.hxx"
class TopLoc_Datum3D;
class TopLoc_Datum3D; typedef opencascade::handle<TopLoc_Datum3D> Handle_TopLoc_Datum3D;






class TopLoc_Datum3D : public Standard_Transient
{

public:


  TopLoc_Datum3D();



  TopLoc_Datum3D(const gp_Trsf& T);


  const gp_Trsf& Transformation() const { return myTrsf; }


  const gp_Trsf& Trsf() const { return myTrsf; }


  gp_TrsfForm Form() const { return myTrsf.Form(); }


  void DumpJson (Standard_OStream& theOStream, Standard_Integer theDepth = -1) const;


  void ShallowDump (Standard_OStream& S) const;

  public: typedef Standard_Transient base_type; static const char* get_type_name () { return "TopLoc_Datum3D"; using direct_base_classes = opencascade::direct_base_class_as_tuple<std::tr2::direct_bases<TopLoc_Datum3D>::type>::type; static_assert(opencascade::has_type<Standard_Transient, direct_base_classes>::type::value, "OCCT RTTI definition is incorrect: " "Standard_Transient" " is not direct base class of " "TopLoc_Datum3D"); static_assert(&get_type_name == &TopLoc_Datum3D::get_type_name, "OCCT RTTI definition is misplaced: current class is not " "TopLoc_Datum3D"); } static const opencascade::handle<Standard_Type>& get_type_descriptor (); virtual const opencascade::handle<Standard_Type>& DynamicType() const override;

private:

  gp_Trsf myTrsf;

};

inline void ShallowDump(const opencascade::handle<TopLoc_Datum3D>& me,Standard_OStream& S) {
 me->ShallowDump(S);
}
# 29 "/usr/include/opencascade/Graphic3d_CStructure.hxx" 2
# 1 "/usr/include/opencascade/NCollection_IndexedMap.hxx" 1
# 39 "/usr/include/opencascade/NCollection_IndexedMap.hxx"
template < class TheKeyType,
           class Hasher = NCollection_DefaultHasher<TheKeyType> >
class NCollection_IndexedMap : public NCollection_BaseMap
{
public:

  typedef TheKeyType key_type;

protected:

  class IndexedMapNode : public NCollection_TListNode<TheKeyType>
  {
  public:

    IndexedMapNode (const TheKeyType& theKey1,
                    const Standard_Integer theIndex,
                    NCollection_ListNode* theNext1)
    : NCollection_TListNode<TheKeyType> (theKey1, theNext1),
      myIndex (theIndex)
    {
    }

    TheKeyType& Key1() { return this->ChangeValue(); }


    Standard_Integer& Index() { return myIndex; }


    static void delNode (NCollection_ListNode * theNode,
                         opencascade::handle<NCollection_BaseAllocator>& theAl)
    {
      ((IndexedMapNode *) theNode)->~IndexedMapNode();
      theAl->Free(theNode);
    }

  private:
    Standard_Integer myIndex;
  };

 public:

  class Iterator
  {
  public:

    Iterator (void) :
      myMap(
# 85 "/usr/include/opencascade/NCollection_IndexedMap.hxx" 3 4
           __null
# 85 "/usr/include/opencascade/NCollection_IndexedMap.hxx"
               ),
      myIndex(0) {}

    Iterator (const NCollection_IndexedMap& theMap) :
      myMap((NCollection_IndexedMap *) &theMap),
      myIndex(1) {}

    Standard_Boolean More(void) const
    { return (myMap != 
# 93 "/usr/include/opencascade/NCollection_IndexedMap.hxx" 3 4
                      __null
# 93 "/usr/include/opencascade/NCollection_IndexedMap.hxx"
                          ) && (myIndex <= myMap->Extent()); }

    void Next(void)
    { myIndex++; }

    const TheKeyType& Value(void) const
    {
      if (!More()) throw Standard_NoSuchObject("NCollection_IndexedMap::Iterator::Value");;
      return myMap->FindKey(myIndex);
    }


    Standard_Boolean IsEqual (const Iterator& theOther) const
    {
      return myMap == theOther.myMap && myIndex == theOther.myIndex;
    }

  private:
    NCollection_IndexedMap * myMap;
    Standard_Integer myIndex;
  };


  typedef NCollection_StlIterator<std::forward_iterator_tag, Iterator, TheKeyType, true> const_iterator;


  const_iterator cbegin() const { return Iterator (*this); }


  const_iterator cend() const { return Iterator(); }

 public:



  NCollection_IndexedMap() : NCollection_BaseMap (1, false, opencascade::handle<NCollection_BaseAllocator>()) {}


  explicit NCollection_IndexedMap (const Standard_Integer theNbBuckets,
                                   const opencascade::handle<NCollection_BaseAllocator>& theAllocator=0L)
  : NCollection_BaseMap (theNbBuckets, false, theAllocator) {}


  NCollection_IndexedMap (const NCollection_IndexedMap& theOther)
  : NCollection_BaseMap (theOther.NbBuckets(), false, theOther.myAllocator)
  { *this = theOther; }



  void Exchange (NCollection_IndexedMap& theOther)
  {
    this->exchangeMapsData (theOther);
  }



  NCollection_IndexedMap& Assign (const NCollection_IndexedMap& theOther)
  {
    if (this == &theOther)
      return *this;

    Clear();
    Standard_Integer anExt = theOther.Extent();
    if (anExt)
    {
      ReSize (anExt-1);
      for (Standard_Integer anIndexIter = 1; anIndexIter <= anExt; ++anIndexIter)
      {
        const TheKeyType& aKey1 = theOther.FindKey (anIndexIter);
        const Standard_Integer iK1 = Hasher::HashCode (aKey1, NbBuckets());
        IndexedMapNode* pNode = new (this->myAllocator) IndexedMapNode (aKey1, anIndexIter, myData1[iK1]);
        myData1[iK1] = pNode;
        myData2[anIndexIter - 1] = pNode;
        Increment();
      }
    }
    return *this;
  }


  NCollection_IndexedMap& operator= (const NCollection_IndexedMap& theOther)
  {
    return Assign (theOther);
  }


  void ReSize (const Standard_Integer theExtent)
  {
    NCollection_ListNode** ppNewData1 = 
# 181 "/usr/include/opencascade/NCollection_IndexedMap.hxx" 3 4
                                       __null
# 181 "/usr/include/opencascade/NCollection_IndexedMap.hxx"
                                           ;
    NCollection_ListNode** ppNewData2 = 
# 182 "/usr/include/opencascade/NCollection_IndexedMap.hxx" 3 4
                                       __null
# 182 "/usr/include/opencascade/NCollection_IndexedMap.hxx"
                                           ;
    Standard_Integer newBuck;
    if (BeginResize (theExtent, newBuck, ppNewData1, ppNewData2))
    {
      if (myData1)
      {
        memcpy (ppNewData2, myData2, sizeof(IndexedMapNode*) * Extent());
        for (Standard_Integer aBucketIter = 0; aBucketIter <= NbBuckets(); ++aBucketIter)
        {
          if (myData1[aBucketIter])
          {
            IndexedMapNode* p = (IndexedMapNode* )myData1[aBucketIter];
            while (p)
            {
              const Standard_Integer iK1 = Hasher::HashCode (p->Key1(), newBuck);
              IndexedMapNode* q = (IndexedMapNode* )p->Next();
              p->Next() = ppNewData1[iK1];
              ppNewData1[iK1] = p;
              p = q;
            }
          }
        }
      }
      EndResize (theExtent, newBuck, ppNewData1, ppNewData2);
    }
  }


  Standard_Integer Add (const TheKeyType& theKey1)
  {
    if (Resizable())
    {
      ReSize (Extent());
    }

    Standard_Integer iK1 = Hasher::HashCode (theKey1, NbBuckets());
    IndexedMapNode* pNode = (IndexedMapNode* )myData1[iK1];
    while (pNode)
    {
      if (Hasher::IsEqual (pNode->Key1(), theKey1))
      {
        return pNode->Index();
      }
      pNode = (IndexedMapNode *) pNode->Next();
    }

    const Standard_Integer aNewIndex = Increment();
    pNode = new (this->myAllocator) IndexedMapNode (theKey1, aNewIndex, myData1[iK1]);
    myData1[iK1] = pNode;
    myData2[aNewIndex - 1] = pNode;
    return aNewIndex;
  }


  Standard_Boolean Contains (const TheKeyType& theKey1) const
  {
    if (IsEmpty())
      return false;
    Standard_Integer iK1 = Hasher::HashCode (theKey1, NbBuckets());
    IndexedMapNode * pNode1;
    pNode1 = (IndexedMapNode *) myData1[iK1];
    while (pNode1)
    {
      if (Hasher::IsEqual(pNode1->Key1(), theKey1))
        return true;
      pNode1 = (IndexedMapNode *) pNode1->Next();
    }
    return false;
  }


  void Substitute (const Standard_Integer theIndex,
                   const TheKeyType& theKey1)
  {
   

#pragma GCC diagnostic push
# 256 "/usr/include/opencascade/NCollection_IndexedMap.hxx"
   

#pragma GCC diagnostic ignored "-Wstrict-overflow"
# 256 "/usr/include/opencascade/NCollection_IndexedMap.hxx"
    if (theIndex < 1 || theIndex > Extent()) throw Standard_OutOfRange("NCollection_IndexedMap::Substitute : " "Index is out of range");

#pragma GCC diagnostic pop
# 256 "/usr/include/opencascade/NCollection_IndexedMap.hxx"
   

                                                          ;


    Standard_Integer iK1 = Hasher::HashCode (theKey1, NbBuckets());
    IndexedMapNode* p = (IndexedMapNode *) myData1[iK1];
    while (p)
    {
      if (Hasher::IsEqual (p->Key1(), theKey1))
      {
        if (p->Index() != theIndex)
        {
          throw Standard_DomainError ("NCollection_IndexedMap::Substitute : "
                                      "Attempt to substitute existing key");
        }
        p->Key1() = theKey1;
        return;
      }
      p = (IndexedMapNode *) p->Next();
    }


    p = (IndexedMapNode* )myData2[theIndex - 1];


    Standard_Integer iK = Hasher::HashCode (p->Key1(), NbBuckets());
    IndexedMapNode * q = (IndexedMapNode *) myData1[iK];
    if (q == p)
      myData1[iK] = (IndexedMapNode *) p->Next();
    else
    {
      while (q->Next() != p)
        q = (IndexedMapNode *) q->Next();
      q->Next() = p->Next();
    }


    p->Key1() = theKey1;
    p->Next() = myData1[iK1];
    myData1[iK1] = p;
  }


  void Swap (const Standard_Integer theIndex1,
             const Standard_Integer theIndex2)
  {
   
#pragma GCC diagnostic push
# 303 "/usr/include/opencascade/NCollection_IndexedMap.hxx"
   
#pragma GCC diagnostic ignored "-Wstrict-overflow"
# 303 "/usr/include/opencascade/NCollection_IndexedMap.hxx"
    if (theIndex1 < 1 || theIndex1 > Extent() || theIndex2 < 1 || theIndex2 > Extent()) throw Standard_OutOfRange("NCollection_IndexedMap::Swap");
#pragma GCC diagnostic pop
# 303 "/usr/include/opencascade/NCollection_IndexedMap.hxx"
   
                                                                                                        ;

    if (theIndex1 == theIndex2)
    {
      return;
    }

    IndexedMapNode* aP1 = (IndexedMapNode* )myData2[theIndex1 - 1];
    IndexedMapNode* aP2 = (IndexedMapNode* )myData2[theIndex2 - 1];
    std::swap (aP1->Index(), aP2->Index());
    myData2[theIndex2 - 1] = aP1;
    myData2[theIndex1 - 1] = aP2;
  }


  void RemoveLast (void)
  {
    const Standard_Integer aLastIndex = Extent();
   
# 322 "/usr/include/opencascade/NCollection_IndexedMap.hxx"
#pragma GCC diagnostic push
# 322 "/usr/include/opencascade/NCollection_IndexedMap.hxx"
   
# 322 "/usr/include/opencascade/NCollection_IndexedMap.hxx"
#pragma GCC diagnostic ignored "-Wstrict-overflow"
# 322 "/usr/include/opencascade/NCollection_IndexedMap.hxx"
    if (aLastIndex == 0) throw Standard_OutOfRange("NCollection_IndexedMap::RemoveLast");
# 322 "/usr/include/opencascade/NCollection_IndexedMap.hxx"
#pragma GCC diagnostic pop
# 322 "/usr/include/opencascade/NCollection_IndexedMap.hxx"
    ;


    IndexedMapNode* p = (IndexedMapNode* )myData2[aLastIndex - 1];
    myData2[aLastIndex - 1] = 
# 326 "/usr/include/opencascade/NCollection_IndexedMap.hxx" 3 4
                             __null
# 326 "/usr/include/opencascade/NCollection_IndexedMap.hxx"
                                 ;


    Standard_Integer iK1 = Hasher::HashCode (p->Key1(), NbBuckets());
    IndexedMapNode* q = (IndexedMapNode *) myData1[iK1];
    if (q == p)
      myData1[iK1] = (IndexedMapNode *) p->Next();
    else
    {
      while (q->Next() != p)
        q = (IndexedMapNode *) q->Next();
      q->Next() = p->Next();
    }
    p->~IndexedMapNode();
    this->myAllocator->Free(p);
    Decrement();
  }



  void RemoveFromIndex(const Standard_Integer theIndex)
  {
   
# 348 "/usr/include/opencascade/NCollection_IndexedMap.hxx"
#pragma GCC diagnostic push
# 348 "/usr/include/opencascade/NCollection_IndexedMap.hxx"
   
# 348 "/usr/include/opencascade/NCollection_IndexedMap.hxx"
#pragma GCC diagnostic ignored "-Wstrict-overflow"
# 348 "/usr/include/opencascade/NCollection_IndexedMap.hxx"
    if (theIndex < 1 || theIndex > Extent()) throw Standard_OutOfRange("NCollection_IndexedMap::RemoveFromIndex");
# 348 "/usr/include/opencascade/NCollection_IndexedMap.hxx"
#pragma GCC diagnostic pop
# 348 "/usr/include/opencascade/NCollection_IndexedMap.hxx"
    ;
    const Standard_Integer aLastInd = Extent();
    if (theIndex != aLastInd)
    {
      Swap(theIndex, aLastInd);
    }
    RemoveLast();
  }



  Standard_Boolean RemoveKey (const TheKeyType& theKey1)
  {
    Standard_Integer anIndToRemove = FindIndex(theKey1);
    if (anIndToRemove < 1)
    {
      return false;
    }

    RemoveFromIndex (anIndToRemove);
    return true;
  }


  const TheKeyType& FindKey (const Standard_Integer theIndex) const
  {
   
# 374 "/usr/include/opencascade/NCollection_IndexedMap.hxx"
#pragma GCC diagnostic push
# 374 "/usr/include/opencascade/NCollection_IndexedMap.hxx"
   
# 374 "/usr/include/opencascade/NCollection_IndexedMap.hxx"
#pragma GCC diagnostic ignored "-Wstrict-overflow"
# 374 "/usr/include/opencascade/NCollection_IndexedMap.hxx"
    if (theIndex < 1 || theIndex > Extent()) throw Standard_OutOfRange("NCollection_IndexedMap::FindKey");
# 374 "/usr/include/opencascade/NCollection_IndexedMap.hxx"
#pragma GCC diagnostic pop
# 374 "/usr/include/opencascade/NCollection_IndexedMap.hxx"
    ;
    IndexedMapNode* pNode2 = (IndexedMapNode* )myData2[theIndex - 1];
    return pNode2->Key1();
  }


  const TheKeyType& operator() (const Standard_Integer theIndex) const
  { return FindKey (theIndex); }


  Standard_Integer FindIndex(const TheKeyType& theKey1) const
  {
    if (IsEmpty()) return 0;
    IndexedMapNode* pNode1 = (IndexedMapNode* )myData1[Hasher::HashCode(theKey1,NbBuckets())];
    while (pNode1)
    {
      if (Hasher::IsEqual (pNode1->Key1(), theKey1))
      {
        return pNode1->Index();
      }
      pNode1 = (IndexedMapNode*) pNode1->Next();
    }
    return 0;
  }



  void Clear(const Standard_Boolean doReleaseMemory = true)
  { Destroy (IndexedMapNode::delNode, doReleaseMemory); }


  void Clear (const opencascade::handle<NCollection_BaseAllocator>& theAllocator)
  {
    Clear();
    this->myAllocator = ( ! theAllocator.IsNull() ? theAllocator :
                    NCollection_BaseAllocator::CommonBaseAllocator() );
  }


  virtual ~NCollection_IndexedMap (void)
  { Clear(); }


  Standard_Integer Size(void) const
  { return Extent(); }
};
# 30 "/usr/include/opencascade/Graphic3d_CStructure.hxx" 2

class Graphic3d_GraphicDriver;
class Graphic3d_StructureManager;


class Graphic3d_CStructure : public Standard_Transient
{
protected:


  template<class Struct_t>
  class SubclassStructIterator
  {
  public:
    SubclassStructIterator (const NCollection_IndexedMap<const Graphic3d_CStructure*>& theStructs) : myIter (theStructs) {}
    Standard_Boolean More() const { return myIter.More(); }
    void Next() { myIter.Next(); }
    const Struct_t* Value() const { return (const Struct_t* )(myIter.Value()); }
    Struct_t* ChangeValue() { return (Struct_t* )(myIter.Value()); }
  private:
    NCollection_IndexedMap<const Graphic3d_CStructure*>::Iterator myIter;
  };


  template<class Group_t>
  class SubclassGroupIterator
  {
  public:
    SubclassGroupIterator (const Graphic3d_SequenceOfGroup& theGroups) : myIter (theGroups) {}
    Standard_Boolean More() const { return myIter.More(); }
    void Next() { myIter.Next(); }
    const Group_t* Value() const { return (const Group_t* )(myIter.Value().get()); }
    Group_t* ChangeValue() { return (Group_t* )(myIter.ChangeValue().get()); }
  private:
    Graphic3d_SequenceOfGroup::Iterator myIter;
  };

public:


  const opencascade::handle<Graphic3d_GraphicDriver>& GraphicDriver() const
  {
    return myGraphicDriver;
  }


  const Graphic3d_SequenceOfGroup& Groups() const
  {
    return myGroups;
  }


  const opencascade::handle<TopLoc_Datum3D>& Transformation() const { return myTrsf; }


  virtual void SetTransformation (const opencascade::handle<TopLoc_Datum3D>& theTrsf) { myTrsf = theTrsf; }


  const opencascade::handle<Graphic3d_TransformPers>& TransformPersistence() const { return myTrsfPers; }


  virtual void SetTransformPersistence (const opencascade::handle<Graphic3d_TransformPers>& theTrsfPers) { myTrsfPers = theTrsfPers; }


  const opencascade::handle<Graphic3d_SequenceOfHClipPlane>& ClipPlanes() const
  {
    return myClipPlanes;
  }


  void SetClipPlanes (const opencascade::handle<Graphic3d_SequenceOfHClipPlane>& thePlanes) { myClipPlanes = thePlanes; }


  const Graphic3d_BndBox3d& BoundingBox() const
  {
    return myBndBox;
  }



  Graphic3d_BndBox3d& ChangeBoundingBox()
  {
    return myBndBox;
  }


  bool IsVisible() const { return visible != 0; }


  bool IsVisible (const Standard_Integer theViewId) const
  {
    return visible != 0
        && (ViewAffinity.IsNull()
         || ViewAffinity->IsVisible (theViewId));
  }


  virtual void SetZLayer (const Graphic3d_ZLayerId theLayerIndex) { myZLayer = theLayerIndex; }


  Graphic3d_ZLayerId ZLayer() const { return myZLayer; }



  const opencascade::handle<Graphic3d_PresentationAttributes>& HighlightStyle() const { return myHighlightStyle; }

public:


  Standard_Boolean IsCulled() const { return myIsCulled; }


  void SetCulled (Standard_Boolean theIsCulled) const { myIsCulled = theIsCulled; }



  void MarkAsNotCulled() const { myIsCulled = false; }


  Standard_Boolean BndBoxClipCheck() const { return myBndBoxClipCheck; }


  void SetBndBoxClipCheck(Standard_Boolean theBndBoxClipCheck) { myBndBoxClipCheck = theBndBoxClipCheck; }


  Standard_Boolean IsAlwaysRendered() const
  {
    return IsInfinite
        || IsForHighlight
        || IsMutable
        || Is2dText
        || (!myTrsfPers.IsNull() && myTrsfPers->IsTrihedronOr2d());
  }

public:


  virtual void OnVisibilityChanged() = 0;


  virtual void Clear() = 0;


  virtual void Connect (Graphic3d_CStructure& theStructure) = 0;


  virtual void Disconnect (Graphic3d_CStructure& theStructure) = 0;


  virtual void GraphicHighlight (const opencascade::handle<Graphic3d_PresentationAttributes>& theStyle) = 0;



  virtual void GraphicUnhighlight() = 0;


  virtual opencascade::handle<Graphic3d_CStructure> ShadowLink (const opencascade::handle<Graphic3d_StructureManager>& theManager) const = 0;


  virtual opencascade::handle<Graphic3d_Group> NewGroup (const opencascade::handle<Graphic3d_Structure>& theStruct) = 0;


  virtual void RemoveGroup (const opencascade::handle<Graphic3d_Group>& theGroup) = 0;


  virtual void updateLayerTransformation() {}


  virtual void DumpJson (Standard_OStream& theOStream, Standard_Integer theDepth = -1) const;

public:

  int Id;
  Graphic3d_ZLayerId myZLayer;
  int Priority;
  int PreviousPriority;

  int ContainsFacet;

  opencascade::handle<Graphic3d_ViewAffinity> ViewAffinity;

  unsigned IsInfinite : 1;
  unsigned stick : 1;
  unsigned highlight : 1;
  unsigned visible : 1;
  unsigned HLRValidation : 1;
  unsigned IsForHighlight : 1;
  unsigned IsMutable : 1;
  unsigned Is2dText : 1;

protected:


  Graphic3d_CStructure (const opencascade::handle<Graphic3d_StructureManager>& theManager);

protected:

  opencascade::handle<Graphic3d_GraphicDriver> myGraphicDriver;
  Graphic3d_SequenceOfGroup myGroups;
  Graphic3d_BndBox3d myBndBox;
  opencascade::handle<TopLoc_Datum3D> myTrsf;
  opencascade::handle<Graphic3d_TransformPers> myTrsfPers;
  opencascade::handle<Graphic3d_SequenceOfHClipPlane> myClipPlanes;
  opencascade::handle<Graphic3d_PresentationAttributes> myHighlightStyle;

  mutable Standard_Boolean myIsCulled;
  Standard_Boolean myBndBoxClipCheck;

public:

  public: typedef Standard_Transient base_type; static const char* get_type_name () { return "Graphic3d_CStructure"; using direct_base_classes = opencascade::direct_base_class_as_tuple<std::tr2::direct_bases<Graphic3d_CStructure>::type>::type; static_assert(opencascade::has_type<Standard_Transient, direct_base_classes>::type::value, "OCCT RTTI definition is incorrect: " "Standard_Transient" " is not direct base class of " "Graphic3d_CStructure"); static_assert(&get_type_name == &Graphic3d_CStructure::get_type_name, "OCCT RTTI definition is misplaced: current class is not " "Graphic3d_CStructure"); } static const opencascade::handle<Standard_Type>& get_type_descriptor (); virtual const opencascade::handle<Standard_Type>& DynamicType() const override;

};

class Graphic3d_CStructure; typedef opencascade::handle<Graphic3d_CStructure> Handle_Graphic3d_CStructure;
# 23 "/usr/include/opencascade/Graphic3d_Structure.hxx" 2
# 1 "/usr/include/opencascade/Graphic3d_MapOfStructure.hxx" 1
# 19 "/usr/include/opencascade/Graphic3d_MapOfStructure.hxx"
# 1 "/usr/include/opencascade/NCollection_Map.hxx" 1
# 55 "/usr/include/opencascade/NCollection_Map.hxx"
template < class TheKeyType,
           class Hasher = NCollection_DefaultHasher<TheKeyType> >
class NCollection_Map : public NCollection_BaseMap
{
public:

  typedef TheKeyType key_type;

public:

  class MapNode : public NCollection_TListNode<TheKeyType>
  {
  public:

    MapNode (const TheKeyType& theKey,
             NCollection_ListNode* theNext) :
      NCollection_TListNode<TheKeyType> (theKey, theNext) {}

    const TheKeyType& Key (void)
    { return this->Value(); }

  };

 public:

  class Iterator : public NCollection_BaseMap::Iterator
  {
  public:

    Iterator (void) :
      NCollection_BaseMap::Iterator() {}

    Iterator (const NCollection_Map& theMap) :
      NCollection_BaseMap::Iterator(theMap) {}

    Standard_Boolean More(void) const
    { return PMore(); }

    void Next(void)
    { PNext(); }

    const TheKeyType& Value(void) const
    {
      if (!More()) throw Standard_NoSuchObject("NCollection_Map::Iterator::Value");;
      return ((MapNode *) myNode)->Value();
    }


    const TheKeyType& Key (void) const
    {
      if (!More()) throw Standard_NoSuchObject("NCollection_Map::Iterator::Key");;
      return ((MapNode *) myNode)->Value();
    }
  };


  typedef NCollection_StlIterator<std::forward_iterator_tag, Iterator, TheKeyType, true> const_iterator;


  const_iterator cbegin() const { return Iterator (*this); }


  const_iterator cend() const { return Iterator(); }

 public:



  NCollection_Map() : NCollection_BaseMap (1, true, opencascade::handle<NCollection_BaseAllocator>()) {}


  explicit NCollection_Map (const Standard_Integer theNbBuckets,
                            const opencascade::handle<NCollection_BaseAllocator>& theAllocator = 0L)
  : NCollection_BaseMap (theNbBuckets, true, theAllocator) {}


  NCollection_Map (const NCollection_Map& theOther) :
    NCollection_BaseMap (theOther.NbBuckets(), true, theOther.myAllocator)
  { *this = theOther; }



  void Exchange (NCollection_Map& theOther)
  {
    this->exchangeMapsData (theOther);
  }



  NCollection_Map& Assign (const NCollection_Map& theOther)
  {
    if (this == &theOther)
      return *this;

    Clear();
    int anExt = theOther.Extent();
    if (anExt)
    {
      ReSize (anExt-1);
      Iterator anIter(theOther);
      for (; anIter.More(); anIter.Next())
        Add (anIter.Key());
    }
    return *this;
  }


  NCollection_Map& operator= (const NCollection_Map& theOther)
  {
    return Assign(theOther);
  }


  void ReSize (const Standard_Integer N)
  {
    NCollection_ListNode** newdata = 0L;
    NCollection_ListNode** dummy = 0L;
    Standard_Integer newBuck;
    if (BeginResize (N, newBuck, newdata, dummy))
    {
      if (myData1)
      {
        MapNode** olddata = (MapNode**) myData1;
        MapNode *p, *q;
        Standard_Integer i,k;
        for (i = 0; i <= NbBuckets(); i++)
        {
          if (olddata[i])
          {
            p = olddata[i];
            while (p)
            {
              k = Hasher::HashCode(p->Key(),newBuck);
              q = (MapNode*) p->Next();
              p->Next() = newdata[k];
              newdata[k] = p;
              p = q;
            }
          }
        }
      }
      EndResize (N, newBuck, newdata, dummy);
    }
  }


  Standard_Boolean Add(const TheKeyType& K)
  {
    if (Resizable())
      ReSize(Extent());
    MapNode** data = (MapNode**)myData1;
    Standard_Integer k = Hasher::HashCode(K,NbBuckets());
    MapNode* p = data[k];
    while (p)
    {
      if (Hasher::IsEqual(p->Key(),K))
        return false;
      p = (MapNode *) p->Next();
    }
    data[k] = new (this->myAllocator) MapNode(K,data[k]);
    Increment();
    return true;
  }



  const TheKeyType& Added(const TheKeyType& K)
  {
    if (Resizable())
      ReSize(Extent());
    MapNode** data = (MapNode**)myData1;
    Standard_Integer k = Hasher::HashCode(K,NbBuckets());
    MapNode* p = data[k];
    while (p)
    {
      if (Hasher::IsEqual(p->Key(),K))
        return p->Key();
      p = (MapNode *) p->Next();
    }
    data[k] = new (this->myAllocator) MapNode(K,data[k]);
    Increment();
    return data[k]->Key();
  }


  Standard_Boolean Contains(const TheKeyType& K) const
  {
    if (IsEmpty())
      return false;
    MapNode** data = (MapNode**) myData1;
    MapNode* p = data[Hasher::HashCode(K,NbBuckets())];
    while (p)
    {
      if (Hasher::IsEqual(p->Key(),K))
        return true;
      p = (MapNode *) p->Next();
    }
    return false;
  }


  Standard_Boolean Remove(const TheKeyType& K)
  {
    if (IsEmpty())
      return false;
    MapNode** data = (MapNode**) myData1;
    Standard_Integer k = Hasher::HashCode(K,NbBuckets());
    MapNode* p = data[k];
    MapNode* q = 
# 263 "/usr/include/opencascade/NCollection_Map.hxx" 3 4
                __null
# 263 "/usr/include/opencascade/NCollection_Map.hxx"
                    ;
    while (p)
    {
      if (Hasher::IsEqual(p->Key(),K))
      {
        Decrement();
        if (q)
          q->Next() = p->Next();
        else
          data[k] = (MapNode*) p->Next();
        p->~MapNode();
        this->myAllocator->Free(p);
        return true;
      }
      q = p;
      p = (MapNode*) p->Next();
    }
    return false;
  }



  void Clear(const Standard_Boolean doReleaseMemory = true)
  { Destroy (MapNode::delNode, doReleaseMemory); }


  void Clear (const opencascade::handle<NCollection_BaseAllocator>& theAllocator)
  {
    Clear();
    this->myAllocator = ( ! theAllocator.IsNull() ? theAllocator :
                    NCollection_BaseAllocator::CommonBaseAllocator() );
  }


  virtual ~NCollection_Map (void)
  { Clear(); }


  Standard_Integer Size(void) const
  { return Extent(); }

 public:




  Standard_Boolean IsEqual (const NCollection_Map& theOther) const
  {
    return Extent() == theOther.Extent()
        && Contains (theOther);
  }


  Standard_Boolean Contains (const NCollection_Map& theOther) const
  {
    if (this == &theOther
     || theOther.IsEmpty())
    {
      return true;
    }
    else if (Extent() < theOther.Extent())
    {
      return false;
    }

    for (Iterator anIter (theOther); anIter.More(); anIter.Next())
    {
      if (!Contains (anIter.Key()))
      {
        return false;
      }
    }

    return true;
  }





  void Union (const NCollection_Map& theLeft,
              const NCollection_Map& theRight)
  {
    if (&theLeft == &theRight)
    {
      Assign (theLeft);
      return;
    }

    if (this != &theLeft
     && this != &theRight)
    {
      Clear();
    }

    if (this != &theLeft)
    {
      for (Iterator anIter (theLeft); anIter.More(); anIter.Next())
      {
        Add (anIter.Key());
      }
    }
    if (this != &theRight)
    {
      for (Iterator anIter (theRight); anIter.More(); anIter.Next())
      {
        Add (anIter.Key());
      }
    }
  }





  Standard_Boolean Unite (const NCollection_Map& theOther)
  {
    if (this == &theOther)
    {
      return false;
    }

    const Standard_Integer anOldExtent = Extent();
    Union (*this, theOther);
    return anOldExtent != Extent();
  }


  Standard_Boolean HasIntersection (const NCollection_Map& theMap) const
  {
    const NCollection_Map* aMap1 = this;
    const NCollection_Map* aMap2 = &theMap;
    if (theMap.Size() < Size())
    {
      aMap1 = &theMap;
      aMap2 = this;
    }

    for (NCollection_Map::Iterator aIt(*aMap1); aIt.More(); aIt.Next())
    {
      if (aMap2->Contains(aIt.Value()))
      {
        return true;
      }
    }

    return false;
  }





  void Intersection (const NCollection_Map& theLeft,
                     const NCollection_Map& theRight)
  {
    if (&theLeft == &theRight)
    {
      Assign (theLeft);
      return;
    }

    if (this == &theLeft)
    {
      NCollection_Map aCopy (1, this->myAllocator);
      Exchange (aCopy);
      Intersection (aCopy, theRight);
      return;
    }
    else if (this == &theRight)
    {
      NCollection_Map aCopy (1, this->myAllocator);
      Exchange (aCopy);
      Intersection (theLeft, aCopy);
      return;
    }

    Clear();
    if (theLeft.Extent() < theRight.Extent())
    {
      for (Iterator anIter (theLeft); anIter.More(); anIter.Next())
      {
        if (theRight.Contains (anIter.Key()))
        {
          Add (anIter.Key());
        }
      }
    }
    else
    {
      for (Iterator anIter (theRight); anIter.More(); anIter.Next())
      {
        if (theLeft.Contains (anIter.Key()))
        {
          Add (anIter.Key());
        }
      }
    }
  }





  Standard_Boolean Intersect (const NCollection_Map& theOther)
  {
    if (this == &theOther
     || IsEmpty())
    {
      return false;
    }

    const Standard_Integer anOldExtent = Extent();
    Intersection (*this, theOther);
    return anOldExtent != Extent();
  }





  void Subtraction (const NCollection_Map& theLeft,
                    const NCollection_Map& theRight)
  {
    if (this == &theLeft)
    {
      Subtract (theRight);
      return;
    }
    else if (this == &theRight)
    {
      NCollection_Map aCopy (1, this->myAllocator);
      Exchange (aCopy);
      Subtraction (theLeft, aCopy);
      return;
    }

    Assign (theLeft);
    Subtract (theRight);
  }






  Standard_Boolean Subtract (const NCollection_Map& theOther)
  {
    if (this == &theOther)
    {
      if (IsEmpty())
      {
        return false;
      }

      Clear();
      return true;
    }

    const Standard_Integer anOldExtent = Extent();
    for (Iterator anIter (theOther); anIter.More(); anIter.Next())
    {
      Remove (anIter.Key());
    }
    return anOldExtent != Extent();
  }




  void Difference (const NCollection_Map& theLeft,
                   const NCollection_Map& theRight)
  {
    if (&theLeft == &theRight)
    {
      Clear();
      return;
    }
    else if (this == &theLeft)
    {
      NCollection_Map aCopy (1, this->myAllocator);
      Exchange (aCopy);
      Difference (aCopy, theRight);
      return;
    }
    else if (this == &theRight)
    {
      NCollection_Map aCopy (1, this->myAllocator);
      Exchange (aCopy);
      Difference (theLeft, aCopy);
      return;
    }

    Clear();
    for (Iterator anIter (theLeft); anIter.More(); anIter.Next())
    {
      if (!theRight.Contains (anIter.Key()))
      {
        Add (anIter.Key());
      }
    }
    for (Iterator anIter (theRight); anIter.More(); anIter.Next())
    {
      if (!theLeft.Contains (anIter.Key()))
      {
        Add (anIter.Key());
      }
    }
  }





  Standard_Boolean Differ (const NCollection_Map& theOther)
  {
    if (this == &theOther)
    {
      if (IsEmpty())
      {
        return false;
      }
      Clear();
      return true;
    }

    const Standard_Integer anOldExtent = Extent();
    Difference (*this, theOther);
    return anOldExtent != Extent();
  }


};
# 20 "/usr/include/opencascade/Graphic3d_MapOfStructure.hxx" 2

class Graphic3d_Structure;
typedef NCollection_Map<opencascade::handle<Graphic3d_Structure> > Graphic3d_MapOfStructure;
# 24 "/usr/include/opencascade/Graphic3d_Structure.hxx" 2



# 1 "/usr/include/opencascade/Graphic3d_TypeOfConnection.hxx" 1
# 21 "/usr/include/opencascade/Graphic3d_TypeOfConnection.hxx"
enum Graphic3d_TypeOfConnection
{
Graphic3d_TOC_ANCESTOR,
Graphic3d_TOC_DESCENDANT
};
# 28 "/usr/include/opencascade/Graphic3d_Structure.hxx" 2
# 1 "/usr/include/opencascade/Graphic3d_TypeOfStructure.hxx" 1
# 22 "/usr/include/opencascade/Graphic3d_TypeOfStructure.hxx"
enum Graphic3d_TypeOfStructure
{
Graphic3d_TOS_WIREFRAME,
Graphic3d_TOS_SHADING,
Graphic3d_TOS_COMPUTED,
Graphic3d_TOS_ALL
};
# 29 "/usr/include/opencascade/Graphic3d_Structure.hxx" 2






class Graphic3d_StructureManager;
class Graphic3d_DataStructureManager;
class Bnd_Box;
class gp_Pnt;

class Graphic3d_Structure; typedef opencascade::handle<Graphic3d_Structure> Handle_Graphic3d_Structure;




class Graphic3d_Structure : public Standard_Transient
{
  public: typedef Standard_Transient base_type; static const char* get_type_name () { return "Graphic3d_Structure"; using direct_base_classes = opencascade::direct_base_class_as_tuple<std::tr2::direct_bases<Graphic3d_Structure>::type>::type; static_assert(opencascade::has_type<Standard_Transient, direct_base_classes>::type::value, "OCCT RTTI definition is incorrect: " "Standard_Transient" " is not direct base class of " "Graphic3d_Structure"); static_assert(&get_type_name == &Graphic3d_Structure::get_type_name, "OCCT RTTI definition is misplaced: current class is not " "Graphic3d_Structure"); } static const opencascade::handle<Standard_Type>& get_type_descriptor (); virtual const opencascade::handle<Standard_Type>& DynamicType() const override;
  friend class Graphic3d_Group;
public:






  Graphic3d_Structure (const opencascade::handle<Graphic3d_StructureManager>& theManager,
                                       const opencascade::handle<Graphic3d_Structure>& theLinkPrs = opencascade::handle<Graphic3d_Structure>());
# 69 "/usr/include/opencascade/Graphic3d_Structure.hxx"
  virtual void Clear (const Standard_Boolean WithDestruction = true)
  {
    clear (WithDestruction);
  }



  virtual ~Graphic3d_Structure();


  virtual void Display();


  Standard_Integer DisplayPriority() const { return myCStructure->Priority; }


  virtual void Erase() { erase(); }





  void Highlight (const opencascade::handle<Graphic3d_PresentationAttributes>& theStyle, const Standard_Boolean theToUpdateMgr = true);





  void Remove();


  virtual void CalculateBoundBox();






  void SetInfiniteState (const Standard_Boolean theToSet)
  {
    if (!myCStructure.IsNull()) { myCStructure->IsInfinite = theToSet ? 1 : 0; }
  }
# 124 "/usr/include/opencascade/Graphic3d_Structure.hxx"
  void SetDisplayPriority (const Standard_Integer Priority);







  void ResetDisplayPriority();





  void SetZLayer (const Graphic3d_ZLayerId theLayerId);



  Graphic3d_ZLayerId GetZLayer() const { return myCStructure->ZLayer(); }



  void SetClipPlanes (const opencascade::handle<Graphic3d_SequenceOfHClipPlane>& thePlanes)
  {
    if (!myCStructure.IsNull()) { myCStructure->SetClipPlanes (thePlanes); }
  }



  const opencascade::handle<Graphic3d_SequenceOfHClipPlane>& ClipPlanes() const { return myCStructure->ClipPlanes(); }





  void SetVisible (const Standard_Boolean AValue);


  virtual void SetVisual (const Graphic3d_TypeOfStructure AVisual);
# 171 "/usr/include/opencascade/Graphic3d_Structure.hxx"
  void SetZoomLimit (const Standard_Real LimitInf, const Standard_Real LimitSup);


  void SetIsForHighlight (const Standard_Boolean isForHighlight)
  {
    if (!myCStructure.IsNull()) { myCStructure->IsForHighlight = isForHighlight; }
  }



  void UnHighlight();

  virtual void Compute()
  {

  }


  virtual void computeHLR (const opencascade::handle<Graphic3d_Camera>& theProjector,
                           opencascade::handle<Graphic3d_Structure>& theStructure)
  {
    (void )theProjector;
    (void )theStructure;
  }



  void ReCompute();



  void ReCompute (const opencascade::handle<Graphic3d_DataStructureManager>& aProjector);



  Standard_Boolean ContainsFacet() const;


  const Graphic3d_SequenceOfGroup& Groups() const { return myCStructure->Groups(); }


  Standard_Integer NumberOfGroups() const { return myCStructure->Groups().Length(); }


  opencascade::handle<Graphic3d_Group> NewGroup();


  opencascade::handle<Graphic3d_Group> CurrentGroup()
  {
    if (Groups().IsEmpty())
    {
      return NewGroup();
    }
    return Groups().Last();
  }


  const opencascade::handle<Graphic3d_PresentationAttributes>& HighlightStyle() const { return myCStructure->HighlightStyle(); }


  Standard_Boolean IsDeleted() const { return myCStructure.IsNull(); }


  virtual Standard_Boolean IsDisplayed() const
  {
    return !myCStructure.IsNull()
        && myCStructure->stick != 0;
  }






  Standard_Boolean IsEmpty() const;


  Standard_Boolean IsInfinite() const
  {
    return IsDeleted()
        || myCStructure->IsInfinite;
  }


  virtual Standard_Boolean IsHighlighted() const
  {
    return !myCStructure.IsNull()
        && myCStructure->highlight != 0;
  }


  Standard_Boolean IsTransformed() const
  {
    return !myCStructure.IsNull()
        && !myCStructure->Transformation().IsNull()
        && myCStructure->Transformation()->Form() != gp_Identity;
  }


  Standard_Boolean IsVisible() const
  {
    return !myCStructure.IsNull()
        && myCStructure->visible != 0;
  }
# 285 "/usr/include/opencascade/Graphic3d_Structure.hxx"
  Bnd_Box MinMaxValues (const Standard_Boolean theToIgnoreInfiniteFlag = false) const;


  Graphic3d_TypeOfStructure Visual() const { return myVisual; }
# 303 "/usr/include/opencascade/Graphic3d_Structure.hxx"
  static Standard_Boolean AcceptConnection (Graphic3d_Structure* theStructure1,
                                                            Graphic3d_Structure* theStructure2,
                                                            Graphic3d_TypeOfConnection theType);


  void Ancestors (Graphic3d_MapOfStructure& SG) const;
# 318 "/usr/include/opencascade/Graphic3d_Structure.hxx"
  void Connect (Graphic3d_Structure* theStructure,
                                Graphic3d_TypeOfConnection theType,
                                Standard_Boolean theWithCheck = false);

  __attribute__((deprecated("Deprecated short-cut")))
  void Connect (const opencascade::handle<Graphic3d_Structure>& thePrs)
  {
    Connect (thePrs.get(), Graphic3d_TOC_DESCENDANT);
  }


  void Descendants (Graphic3d_MapOfStructure& SG) const;


  void Disconnect (Graphic3d_Structure* theStructure);

  __attribute__((deprecated("Deprecated alias for Disconnect()")))
  void Remove (const opencascade::handle<Graphic3d_Structure>& thePrs) { Disconnect (thePrs.get()); }





  void DisconnectAll (const Graphic3d_TypeOfConnection AType);

  __attribute__((deprecated("Deprecated alias for DisconnectAll()")))
  void RemoveAll() { DisconnectAll (Graphic3d_TOC_DESCENDANT); }






  static void Network (Graphic3d_Structure* theStructure,
                                       const Graphic3d_TypeOfConnection theType,
                                       NCollection_Map<Graphic3d_Structure*>& theSet);

  void SetOwner (const Standard_Address theOwner) { myOwner = theOwner; }

  Standard_Address Owner() const { return myOwner; }

  void SetHLRValidation (const Standard_Boolean theFlag)
  {
    if (!myCStructure.IsNull()) { myCStructure->HLRValidation = theFlag ? 1 : 0; }
  }




  Standard_Boolean HLRValidation() const
  {
    return myOwner != 
# 369 "/usr/include/opencascade/Graphic3d_Structure.hxx" 3 4
                     __null
        
# 370 "/usr/include/opencascade/Graphic3d_Structure.hxx"
       && myCStructure->HLRValidation != 0;
  }


  const opencascade::handle<TopLoc_Datum3D>& Transformation() const { return myCStructure->Transformation(); }


  void SetTransformation (const opencascade::handle<TopLoc_Datum3D>& theTrsf);

  __attribute__((deprecated("This method is deprecated - SetTransformation() should be called instead")))
  void Transform (const opencascade::handle<TopLoc_Datum3D>& theTrsf) { SetTransformation (theTrsf); }


  void SetTransformPersistence (const opencascade::handle<Graphic3d_TransformPers>& theTrsfPers);


  const opencascade::handle<Graphic3d_TransformPers>& TransformPersistence() const { return myCStructure->TransformPersistence(); }


  void SetMutable (const Standard_Boolean theIsMutable)
  {
    if (!myCStructure.IsNull()) { myCStructure->IsMutable = theIsMutable; }
  }



  Standard_Boolean IsMutable() const
  {
    return !myCStructure.IsNull()
        && myCStructure->IsMutable;
  }

  Graphic3d_TypeOfStructure ComputeVisual() const { return myComputeVisual; }


  void GraphicClear (const Standard_Boolean WithDestruction);

  void GraphicConnect (const opencascade::handle<Graphic3d_Structure>& theDaughter)
  {
    if (!myCStructure.IsNull()) { myCStructure->Connect (*theDaughter->myCStructure); }
  }

  void GraphicDisconnect (const opencascade::handle<Graphic3d_Structure>& theDaughter)
  {
    if (!myCStructure.IsNull()) { myCStructure->Disconnect (*theDaughter->myCStructure); }
  }


  void GraphicTransform (const opencascade::handle<TopLoc_Datum3D>& theTrsf)
  {
    if (!myCStructure.IsNull()) { myCStructure->SetTransformation (theTrsf); }
  }


  Standard_Integer Identification() const { return myCStructure->Id; }



  static void PrintNetwork (const opencascade::handle<Graphic3d_Structure>& AStructure, const Graphic3d_TypeOfConnection AType);


  void Remove (Graphic3d_Structure* thePtr,
                               const Graphic3d_TypeOfConnection theType);

  void SetComputeVisual (const Graphic3d_TypeOfStructure theVisual)
  {


    if (theVisual != Graphic3d_TOS_COMPUTED)
    {
      myComputeVisual = theVisual;
    }
  }


  static void Transforms (const gp_Trsf& theTrsf,
                                          const Standard_Real theX, const Standard_Real theY, const Standard_Real theZ,
                                          Standard_Real& theNewX, Standard_Real& theNewY, Standard_Real& theNewZ);


  const opencascade::handle<Graphic3d_CStructure>& CStructure() const { return myCStructure; }


  virtual void DumpJson (Standard_OStream& theOStream, Standard_Integer theDepth = -1) const;

protected:


  static void TransformBoundaries (const gp_Trsf& theTrsf,
                                                   Standard_Real& theXMin, Standard_Real& theYMin, Standard_Real& theZMin,
                                                   Standard_Real& theXMax, Standard_Real& theYMax, Standard_Real& theZMax);


  Standard_Boolean AppendDescendant (Graphic3d_Structure* theDescendant);


  Standard_Boolean RemoveDescendant (Graphic3d_Structure* theDescendant);


  Standard_Boolean AppendAncestor (Graphic3d_Structure* theAncestor);


  Standard_Boolean RemoveAncestor (Graphic3d_Structure* theAncestor);


  void clear (const Standard_Boolean WithDestruction);


  void erase();

private:



  void Remove (const opencascade::handle<Graphic3d_Group>& theGroup);





  void GroupsWithFacet (const Standard_Integer ADelta);


  Graphic3d_BndBox4f minMaxCoord() const;


  void getBox (Graphic3d_BndBox3d& theBox, const Standard_Boolean theToIgnoreInfiniteFlag = false) const;


  void addTransformed (Graphic3d_BndBox3d& theBox, const Standard_Boolean theToIgnoreInfiniteFlag = false) const;


  opencascade::handle<Graphic3d_StructureManager> StructureManager() const;



  void Update (const bool theUpdateLayer = false) const;

protected:

  Graphic3d_StructureManager* myStructureManager;
  opencascade::handle<Graphic3d_CStructure> myCStructure;
  NCollection_IndexedMap<Graphic3d_Structure*> myAncestors;
  NCollection_IndexedMap<Graphic3d_Structure*> myDescendants;
  Standard_Address myOwner;
  Graphic3d_TypeOfStructure myVisual;
  Graphic3d_TypeOfStructure myComputeVisual;

};
# 21 "/usr/include/opencascade/Prs3d_Presentation.hxx" 2


typedef Graphic3d_Structure Prs3d_Presentation;
# 26 "/usr/include/opencascade/DsgPrs_FixPresentation.hxx" 2

class gp_Pnt;
class gp_Dir;


class DsgPrs_FixPresentation
{
public:

  void* operator new (size_t theSize) { return Standard::Allocate (theSize); } void operator delete (void* theAddress) { Standard::Free (theAddress); } void* operator new[] (size_t theSize) { return Standard::Allocate (theSize); } void operator delete[] (void* theAddress) { Standard::Free (theAddress); } void* operator new (size_t, void* theAddress) { return theAddress; } void operator delete (void*, void*) { }







  static void Add (const opencascade::handle<Prs3d_Presentation>& aPresentation, const opencascade::handle<Prs3d_Drawer>& aDrawer, const gp_Pnt& aPntAttach, const gp_Pnt& aPntEnd, const gp_Dir& aNormPln, const Standard_Real aSymbSize);




protected:





private:





};
