# /usr/include/opencascade/Standard_Handle.hxx --> occt/standard/Standard_Handle.nim
import os, strutils
# import std/time_t  # To use C "time_t" uncomment this line and use time_t.Time

const sourcePath = currentSourcePath().splitPath.head
{.passC: "-I\"/usr/include/opencascade/\"".}
const headerStandardhandle = "/usr/include/opencascade/Standard_Handle.hxx"
discard "forward decl of Standard_Transient"
## !!!Ignored construct:  template < class T > [end of template] class handle { public : typedef T element_type ; public : handle ( ) : entity ( 0 ) { } handle ( const T * thePtr ) : entity ( const_cast < T * > [end of template] ( thePtr ) ) { BeginScope ( ) ; } handle ( const handle & theHandle ) : entity ( theHandle . entity ) { BeginScope ( ) ; } handle ( handle && theHandle ) : entity ( theHandle . entity ) { theHandle . entity = 0 ; } ~ handle ( ) { EndScope ( ) ; } void Nullify ( ) { EndScope ( ) ; } bool IsNull ( ) const { return entity == 0 ; } void reset ( T * thePtr ) { Assign ( thePtr ) ; } handle & operator = ( const handle & theHandle ) { Assign ( theHandle . entity ) ; return * this ; } handle & operator = ( const T * thePtr ) { Assign ( const_cast < T * > [end of template] ( thePtr ) ) ; return * this ; } handle & operator = ( handle && theHandle ) { std :: swap ( this -> entity , theHandle . entity ) ; return * this ; } T * get ( ) const { return static_cast < T * > [end of template] ( this -> entity ) ; } T * operator -> ( ) const { return static_cast < T * > [end of template] ( this -> entity ) ; } T & operator * ( ) const { return * get ( ) ; } template < class T2 > [end of template] bool operator == ( const handle < T2 > [end of template] & theHandle ) const { return get ( ) == theHandle . get ( ) ; } template < class T2 > [end of template] bool operator == ( const T2 * thePtr ) const { return get ( ) == thePtr ; } template < class T2 > [end of template] friend bool operator == ( const T2 * left , const handle & right ) { return left == right . get ( ) ; } template < class T2 > bool operator != ( const handle < T2 > & theHandle ) const { return get ( ) != theHandle . get ( ) ; } template < class T2 > bool operator != ( const T2 * thePtr ) const { return get ( ) != thePtr ; } template < class T2 > friend bool operator != ( const T2 * left , const handle & right ) { return left != right . get ( ) ; } template < class T2 > bool operator < ( const handle < T2 > & theHandle ) const { return get ( ) < theHandle . get ( ) ; } template < class T2 > static typename opencascade :: std :: enable_if < is_base_but_not_same < T2 , T > :: value , handle > :: type DownCast ( const handle < T2 > & theObject ) { return handle ( dynamic_cast < T * > ( const_cast < T2 * > ( theObject . get ( ) ) ) ) ; } template < class T2 > static typename opencascade :: std :: enable_if < is_base_but_not_same < T2 , T > :: value , handle > :: type DownCast ( const T2 * thePtr ) { return handle ( dynamic_cast < T * > ( const_cast < T2 * > ( thePtr ) ) ) ; } template < class T2 > ( ( deprecated ( down-casting from object of the same or unrelated type is meaningless ) ) ) static handle DownCast ( const handle < T2 > & theObject , typename opencascade :: std :: enable_if < ! is_base_but_not_same < T2 , T > :: value , void * > :: type = 0 ) { return handle ( dynamic_cast < T * > ( const_cast < T2 * > ( theObject . get ( ) ) ) ) ; } template < class T2 > ( ( deprecated ( down-casting from object of the same or unrelated type is meaningless ) ) ) static handle DownCast ( const T2 * thePtr , typename opencascade :: std :: enable_if < ! is_base_but_not_same < T2 , T > :: value , void * > :: type = 0 ) { return handle ( dynamic_cast < T * > ( const_cast < T2 * > ( thePtr ) ) ) ; } explicit operator bool ( ) const { return entity != nullptr ; } template < class T2 , typename = typename std :: enable_if < is_base_but_not_same < T2 , T > :: value > :: type > operator const handle < T2 > & ( ) const { return reinterpret_cast < const handle < T2 > & > ( * this ) ; } template < class T2 , typename = typename std :: enable_if < is_base_but_not_same < T2 , T > :: value > :: type > operator handle < T2 > & ( ) { return reinterpret_cast < handle < T2 > & > ( * this ) ; } private : void Assign ( Standard_Transient * thePtr ) { if ( thePtr == entity ) return ; EndScope ( ) ; entity = thePtr ; BeginScope ( ) ; } void BeginScope ( ) { if ( entity != 0 ) entity -> IncrementRefCounter ( ) ; } void EndScope ( ) { if ( entity != 0 && entity -> DecrementRefCounter ( ) == 0 ) entity -> Delete ( ) ; entity = 0 ; } template < class T2 > friend class handle ; private : Standard_Transient * entity ; } ;
## Error: token expected: ; but got: <!!!

proc hashCode*[TheTransientType](theHandle: Handle[TheTransientType];
                                theUpperBound: StandardInteger): StandardInteger =
  discard
