#ifdef C2NIM
#def DEFINE_STANDARD_ALLOC
#def DEFINE_NCOLLECTION_ALLOC
#def Standard_EXPORT
#def Standard_OVERRIDE
#def STANDARD_TYPE(theType) theType::get_type_descriptor()
#def OCCT_CHECK_BASE_CLASS
#def TRUE_ (1)
#def FALSE_ (0)
#def DEFINE_STANDARD_HANDLE(C1,C2) DEFINE_STANDARD_HANDLECLASS(C1,C2,Standard_Transient)
#def DEFINE_HARRAY1(HClassName, _Array1Type_)                               \
  class HClassName : public _Array1Type_, public MMgt_TShared {                  \
  public:                                                                       \
    DEFINE_STANDARD_ALLOC                                                       \
    DEFINE_NCOLLECTION_ALLOC                                                    \
    HClassName (const Standard_Integer theLower,                                \
                const Standard_Integer theUpper) :                              \
      _Array1Type_ (theLower,theUpper)  {}                                      \
    HClassName (const Standard_Integer theLower,                                \
                const Standard_Integer theUpper,                                \
                const _Array1Type_::value_type& theValue) :                     \
      _Array1Type_ (theLower,theUpper)  { Init (theValue); }                    \
    HClassName  (const _Array1Type_& theOther) : _Array1Type_(theOther) {}      \
    const _Array1Type_& Array1 () const { return *this; }                       \
    _Array1Type_& ChangeArray1 ()       { return *this; }                       \
    DEFINE_STANDARD_RTTI_INLINE(HClassName,MMgt_TShared)                              \
  }; 
#def DEFINE_STANDARD_HANDLECLASS(C1,C2,BC) class C1; typedef Handle(C1) Handle_##C1;
#def Handle(Class) opencascade::handle<Class>
#def DEFINE_STANDARD_RTTIEXT(Class,Base) \
      public: \
        typedef Base base_type; \
        static const char* get_type_name () { return #Class; } \
        Standard_EXPORT static const Handle(Standard_Type)& get_type_descriptor (); \
        Standard_EXPORT virtual const Handle(Standard_Type)& DynamicType() const Standard_OVERRIDE;

#def DEFINE_STANDARD_RTTI_INLINE(Class,Base) \
public: \
  typedef Base base_type; \
  static const char* get_type_name () { return #Class; OCCT_CHECK_BASE_CLASS(Class,Base) } \
  static const Handle(Standard_Type)& get_type_descriptor () { return Standard_Type::Instance<Class>(); } \
  virtual const Handle(Standard_Type)& DynamicType() const Standard_OVERRIDE { return get_type_descriptor (); }

#def DEFINE_NCOLLECTION_ALLOC                                               \
   void* operator new (size_t theSize,                                           \
                       const Handle(NCollection_BaseAllocator)& theAllocator)    \
   {                                                                             \
     return theAllocator->Allocate(theSize);                                     \
   }                                                                             \
   void  operator delete (void* theAddress,                                      \
                          const Handle(NCollection_BaseAllocator)& theAllocator) \
   {                                                                             \
     theAllocator->Free(theAddress);                                             \
   }

#endif